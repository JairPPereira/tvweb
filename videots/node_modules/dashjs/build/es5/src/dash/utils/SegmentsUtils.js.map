{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":["unescapeDollarsInTemplate","replaceIDForTemplate","replaceTokenForTemplate","getIndexBasedSegment","getTimeBasedSegment","zeroPadToLength","numStr","minStrLength","length","getNumberForSegment","segment","segmentIndex","representation","startNumber","url","split","join","value","indexOf","v","toString","token","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","formatTagLen","charAt","parseInt","substring","toUpperCase","getSegment","duration","presentationStartTime","mediaStartTime","availabilityStartTime","timelineConverter","presentationEndTime","isDynamic","index","seg","Segment","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","adaptation","period","mpd","wallStartTime","calcWallTimeForSegment","replacementNumber","availabilityIdx","isSegmentAvailable","periodEnd","getPeriodEnd","periodRelativeEnd","calcPeriodRelativeTimeFromMpdRelativeTime","segmentTime","segmentAvailabilityRange","end","segmentDuration","isNaN","parseFloat","start","toFixed","calcMediaTimeFromPresentationTime","calcAvailabilityStartTimeFromPresentationTime","time","fTimescale","range","tManifest","scaledTime","scaledDuration","Math","min","maxSegmentDuration","calcPresentationTimeFromMediaTime","manifest","loadedTime","replacementTime","media","mediaRange"],"mappings":"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","file":"SegmentsUtils.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function unescapeDollarsInTemplate(url) {\n    return url ? url.split('$$').join('$') : url;\n}\n\nexport function replaceIDForTemplate(url, value) {\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) { return url; }\n    let v = value.toString();\n    return url.split('$RepresentationID$').join(v);\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nfunction getSegment(representation, duration, presentationStartTime, mediaStartTime, availabilityStartTime,\n    timelineConverter, presentationEndTime, isDynamic, index) {\n    let seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n    seg.mediaStartTime = mediaStartTime;\n    seg.availabilityStartTime = availabilityStartTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nfunction isSegmentAvailable(timelineConverter, representation, segment, isDynamic) {\n    const periodEnd = timelineConverter.getPeriodEnd(representation, isDynamic);\n    const periodRelativeEnd = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, periodEnd);\n\n    const segmentTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, segment.presentationStartTime);\n    if (segmentTime >= periodRelativeEnd) {\n        if (isDynamic) {\n            // segment is not available in current period, but it may be segment available in another period that current one (in DVR window)\n            // if not (time > segmentAvailabilityRange.end), then return false\n            if ( representation.segmentAvailabilityRange && segment.presentationStartTime >= representation.segmentAvailabilityRange.end) {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n\n    const segment = getSegment(representation, duration, presentationStartTime,\n                      timelineConverter.calcMediaTimeFromPresentationTime(presentationStartTime, representation),\n                      timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic),\n                      timelineConverter, presentationEndTime, isDynamic, index);\n\n    if (!isSegmentAvailable(timelineConverter, representation, segment, isDynamic)) {\n        return null;\n    }\n\n    return segment;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = getSegment(representation, scaledDuration, presentationStartTime,\n                     scaledTime,\n                     representation.adaptation.period.mpd.manifest.loadedTime,\n                     timelineConverter, presentationEndTime, isDynamic, index);\n\n    if (!isSegmentAvailable(timelineConverter, representation, seg, isDynamic)) {\n        return null;\n    }\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n\n    return seg;\n}\n"]}