{"version":3,"sources":["../../../../../src/dash/utils/TimelineSegmentsGetter.js"],"names":["TimelineSegmentsGetter","config","isDynamic","timelineConverter","instance","checkConfig","hasOwnProperty","Error","Constants","MISSING_CONFIG_ERROR","iterateSegments","representation","iterFunc","base","adaptation","period","mpd","manifest","Period_asArray","index","AdaptationSet_asArray","Representation_asArray","SegmentTemplate","SegmentList","timeline","SegmentTimeline","list","SegmentURL_asArray","time","scaledTime","availabilityIdx","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","fTimescale","timescale","S_asArray","breakIterator","length","r","t","availabilityEnd","segmentAvailabilityRange","end","calcSegmentAvailabilityRange","calcMediaTimeFromPresentationTime","segmentDuration","d","Math","ceil","availableSegmentsNumber","getSegmentByIndex","lastSegmentTime","segment","found","media","mediaRange","tManifest","getSegmentByTime","requestedTime","undefined","requiredMediaTime","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"mappings":"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","file":"TimelineSegmentsGetter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Constants from '../../streaming/constants/Constants';\n\nimport { getTimeBasedSegment } from './SegmentsUtils';\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n\n    config = config || {};\n    const timelineConverter = config.timelineConverter;\n\n    let instance;\n\n    function checkConfig() {\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function iterateSegments(representation, iterFunc) {\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n                AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n        const timeline = base.SegmentTimeline;\n        const list = base.SegmentURL_asArray;\n\n        let time = 0;\n        let scaledTime = 0;\n        let availabilityIdx = -1;\n\n        let fragments,\n            frag,\n            i,\n            len,\n            j,\n            repeat,\n            repeatEndTime,\n            nextFrag,\n            fTimescale;\n\n        fTimescale = representation.timescale;\n        fragments = timeline.S_asArray;\n\n        let breakIterator = false;\n\n        for (i = 0, len = fragments.length; i < len && !breakIterator; i++) {\n            frag = fragments[i];\n            repeat = 0;\n            if (frag.hasOwnProperty('r')) {\n                repeat = frag.r;\n            }\n\n            // For a repeated S element, t belongs only to the first segment\n            if (frag.hasOwnProperty('t')) {\n                time = frag.t;\n                scaledTime = time / fTimescale;\n            }\n\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n            // next MPD update.\"\n            if (repeat < 0) {\n                nextFrag = fragments[i + 1];\n\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\n                    repeatEndTime = nextFrag.t / fTimescale;\n                } else {\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n                    representation.segmentDuration = frag.d / fTimescale;\n                }\n\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n            }\n\n            for (j = 0; j <= repeat && !breakIterator; j++) {\n                availabilityIdx++;\n\n                breakIterator = iterFunc(time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i);\n\n                if (breakIterator) {\n                    representation.segmentDuration = frag.d / fTimescale;\n\n                    // check if there is at least one more segment\n                    if (j < repeat - 1 || i < len - 1) {\n                        availabilityIdx++;\n                    }\n                }\n\n                time += frag.d;\n                scaledTime = time / fTimescale;\n            }\n        }\n\n        representation.availableSegmentsNumber = availabilityIdx;\n    }\n\n    function getSegmentByIndex(representation, index, lastSegmentTime) {\n        checkConfig();\n\n        if (!representation) {\n            return null;\n        }\n\n        let segment = null;\n        let found = false;\n\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n            if (found || lastSegmentTime < 0) {\n                let media = base.media;\n                let mediaRange = frag.mediaRange;\n\n                if (list) {\n                    media = list[i].media || '';\n                    mediaRange = list[i].mediaRange;\n                }\n\n                segment = getTimeBasedSegment(\n                    timelineConverter,\n                    isDynamic,\n                    representation,\n                    time,\n                    frag.d,\n                    fTimescale,\n                    media,\n                    mediaRange,\n                    availabilityIdx,\n                    frag.tManifest);\n\n                return true;\n            } else if (scaledTime >= lastSegmentTime - frag.d * 0.5 / fTimescale) { // same logic, if deviation is\n                // 50% of segment duration, segment is found if scaledTime is greater than or equal to (startTime of previous segment - half of the previous segment duration)\n                found = true;\n            }\n\n            return false;\n        });\n\n        return segment;\n    }\n\n    function getSegmentByTime(representation, requestedTime) {\n        checkConfig();\n\n        if (!representation) {\n            return null;\n        }\n\n        if (requestedTime === undefined) {\n            requestedTime = null;\n        }\n\n        let segment = null;\n        const requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\n            // In some cases when requiredMediaTime = actual end time of the last segment\n            // it is possible that this time a bit exceeds the declared end time of the last segment.\n            // in this case we still need to include the last segment in the segment list.\n            if (requiredMediaTime < (scaledTime + (frag.d / fTimescale))) {\n                let media = base.media;\n                let mediaRange = frag.mediaRange;\n\n                if (list) {\n                    media = list[i].media || '';\n                    mediaRange = list[i].mediaRange;\n                }\n\n                segment = getTimeBasedSegment(\n                    timelineConverter,\n                    isDynamic,\n                    representation,\n                    time,\n                    frag.d,\n                    fTimescale,\n                    media,\n                    mediaRange,\n                    availabilityIdx,\n                    frag.tManifest);\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return segment;\n    }\n\n\n    instance = {\n        getSegmentByIndex: getSegmentByIndex,\n        getSegmentByTime: getSegmentByTime\n    };\n\n    return instance;\n}\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\nexport default factory;\n"]}