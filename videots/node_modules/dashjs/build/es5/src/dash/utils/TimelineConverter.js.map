{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["TimelineConverter","context","eventBus","getInstance","instance","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","initialize","resetInitialSettings","on","Events","TIME_SYNCHRONIZATION_COMPLETED","onTimeSyncComplete","isTimeSyncCompleted","setTimeSyncCompleted","value","getClientTimeOffset","setClientTimeOffset","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","getPeriodEnd","min","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","reset","off","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction TimelineConverter() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = { start: voPeriod.start, end: voPeriod.start + voPeriod.duration };\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n            voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n\n        return range;\n    }\n\n    function getPeriodEnd(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        if (!isDynamic) {\n            return voPeriod.start + voPeriod.duration;\n        }\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n            voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n\n        return Math.min(now - endOffset, periodEnd);\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function onTimeSyncComplete(e) {\n\n        if (isClientServerTimeSyncCompleted) return;\n\n        if (e.offset !== undefined) {\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n        }\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        getPeriodEnd: getPeriodEnd,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}