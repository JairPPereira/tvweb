{"version":3,"sources":["../../../../../src/dash/controllers/RepresentationController.js"],"names":["RepresentationController","context","eventBus","getInstance","instance","realAdaptation","updating","voAvailableRepresentations","currentVoRepresentation","abrController","playbackController","timelineConverter","dashMetrics","type","streamId","manifestModel","setup","resetInitialSettings","on","Events","QUALITY_CHANGE_REQUESTED","onQualityChanged","REPRESENTATION_UPDATE_COMPLETED","onRepresentationUpdated","WALLCLOCK_TIME_UPDATED","onWallclockTimeUpdated","MANIFEST_VALIDITY_CHANGED","onManifestValidityChanged","setConfig","config","checkConfig","Error","Constants","MISSING_CONFIG_ERROR","getData","isUpdating","getCurrentRepresentation","reset","off","getType","getStreamId","updateData","newRealAdaptation","availableRepresentations","quality","startDataUpdate","getRepresentationForQuality","VIDEO","AUDIO","FRAGMENTED_TEXT","endDataUpdate","updateAvailabilityWindow","getIsDynamic","addRepresentationSwitch","now","Date","currentRepresentation","currentVideoTimeMs","getTime","adaptation","id","undefined","length","getQualityForRepresentation","voRepresentation","indexOf","isAllRepresentationsUpdated","i","ln","segmentInfoType","segmentAvailabilityRange","hasInitialization","DashConstants","SEGMENT_BASE","BASE_URL","segments","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","presentationStartTime","updateRepresentation","representation","isDynamic","calcSegmentAvailabilityRange","end","start","useCalculatedLiveEdgeTime","error","DashJSError","Errors","SEGMENTS_UNAVAILABLE_ERROR_CODE","SEGMENTS_UNAVAILABLE_ERROR_MESSAGE","availabilityDelay","notifyUpdate","trigger","REPRESENTATION_UPDATE_STARTED","sender","resetAvailabilityWindow","forEach","rep","DATA_UPDATE_STARTED","eventArg","data","DATA_UPDATE_COMPLETED","postponeUpdate","postponeTimePeriod","delay","update","AST_IN_FUTURE","setTimeout","e","getStreamInfo","streamInfo","r","manifestUpdateInfo","getCurrentManifestUpdate","alreadyAdded","repInfo","err","repSwitch","period","mpd","manifest","DYNAMIC","ignorePostponeTimePeriod","segmentAvailabilityTimePeriod","liveDelay","computeLiveDelay","segmentDuration","manifestInfo","DVRWindowSize","SEGMENTS_UPDATE_FAILED_ERROR_CODE","SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE","representationInfo","index","mediaType","addManifestUpdateRepresentationInfo","setPlaybackQuality","latency","getCurrentRepresentationSwitch","newQuality","newDuration","duration","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"RepresentationController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../../streaming/constants/Constants';\nimport Errors from '../../core/errors/Errors';\nimport DashConstants from '../constants/DashConstants';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction RepresentationController() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        realAdaptation,\n        updating,\n        voAvailableRepresentations,\n        currentVoRepresentation,\n        abrController,\n        playbackController,\n        timelineConverter,\n        dashMetrics,\n        type,\n        streamId,\n        manifestModel;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.on(Events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.on(Events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n    }\n\n    function setConfig(config) {\n        if (config.abrController) {\n            abrController = config.abrController;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.playbackController) {\n            playbackController = config.playbackController;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.type) {\n            type = config.type;\n        }\n        if (config.streamId) {\n            streamId = config.streamId;\n        }\n    }\n\n    function checkConfig() {\n        if (!abrController || !dashMetrics || !playbackController ||\n            !timelineConverter || !manifestModel) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getData() {\n        return realAdaptation;\n    }\n\n    function isUpdating() {\n        return updating;\n    }\n\n    function getCurrentRepresentation() {\n        return currentVoRepresentation;\n    }\n\n    function resetInitialSettings() {\n        realAdaptation = null;\n        updating = true;\n        voAvailableRepresentations = [];\n        abrController = null;\n        playbackController = null;\n        timelineConverter = null;\n        dashMetrics = null;\n    }\n\n    function reset() {\n\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\n        eventBus.off(Events.REPRESENTATION_UPDATE_COMPLETED, onRepresentationUpdated, instance);\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\n        eventBus.off(Events.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged, instance);\n\n        resetInitialSettings();\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamId() {\n        return streamId;\n    }\n\n    function updateData(newRealAdaptation, availableRepresentations, type, quality) {\n        checkConfig();\n\n        startDataUpdate();\n\n        voAvailableRepresentations = availableRepresentations;\n\n        currentVoRepresentation = getRepresentationForQuality(quality);\n        realAdaptation = newRealAdaptation;\n\n        if (type !== Constants.VIDEO && type !== Constants.AUDIO && type !== Constants.FRAGMENTED_TEXT) {\n            endDataUpdate();\n            return;\n        }\n\n        updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n    }\n\n    function addRepresentationSwitch() {\n        checkConfig();\n        const now = new Date();\n        const currentRepresentation = getCurrentRepresentation();\n        const currentVideoTimeMs = playbackController.getTime() * 1000;\n        if (currentRepresentation) {\n            dashMetrics.addRepresentationSwitch(currentRepresentation.adaptation.type, now, currentVideoTimeMs, currentRepresentation.id);\n        }\n    }\n\n    function getRepresentationForQuality(quality) {\n        return quality === null || quality === undefined || quality >= voAvailableRepresentations.length ? null : voAvailableRepresentations[quality];\n    }\n\n    function getQualityForRepresentation(voRepresentation) {\n        return voAvailableRepresentations.indexOf(voRepresentation);\n    }\n\n    function isAllRepresentationsUpdated() {\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            let segmentInfoType = voAvailableRepresentations[i].segmentInfoType;\n            if (voAvailableRepresentations[i].segmentAvailabilityRange === null || !voAvailableRepresentations[i].hasInitialization() ||\n                ((segmentInfoType === DashConstants.SEGMENT_BASE || segmentInfoType === DashConstants.BASE_URL) && !voAvailableRepresentations[i].segments)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function updateRepresentation(representation, isDynamic) {\n        representation.segmentAvailabilityRange = timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n        if ((representation.segmentAvailabilityRange.end < representation.segmentAvailabilityRange.start) && !representation.useCalculatedLiveEdgeTime) {\n            let error = new DashJSError(Errors.SEGMENTS_UNAVAILABLE_ERROR_CODE, Errors.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE, {availabilityDelay: representation.segmentAvailabilityRange.start - representation.segmentAvailabilityRange.end});\n            endDataUpdate(error);\n            return;\n        }\n\n        if (isDynamic) {\n            setExpectedLiveEdge(representation.segmentAvailabilityRange.end);\n        }\n    }\n\n    function updateAvailabilityWindow(isDynamic, notifyUpdate) {\n        checkConfig();\n\n        for (let i = 0, ln = voAvailableRepresentations.length; i < ln; i++) {\n            updateRepresentation(voAvailableRepresentations[i], isDynamic);\n            if (notifyUpdate) {\n                eventBus.trigger(Events.REPRESENTATION_UPDATE_STARTED, { sender: instance, representation:  voAvailableRepresentations[i]});\n            }\n        }\n    }\n\n    function resetAvailabilityWindow() {\n        voAvailableRepresentations.forEach(rep => {\n            rep.segmentAvailabilityRange = null;\n        });\n    }\n\n    function startDataUpdate() {\n        updating = true;\n        eventBus.trigger(Events.DATA_UPDATE_STARTED, { sender: instance });\n    }\n\n    function endDataUpdate(error) {\n        updating = false;\n        let eventArg = {sender: instance, data: realAdaptation, currentRepresentation: currentVoRepresentation};\n        if (error) {\n            eventArg.error = error;\n        }\n        eventBus.trigger(Events.DATA_UPDATE_COMPLETED, eventArg);\n    }\n\n    function postponeUpdate(postponeTimePeriod) {\n        let delay = postponeTimePeriod;\n        let update = function () {\n            if (isUpdating()) return;\n\n            startDataUpdate();\n\n            // clear the segmentAvailabilityRange for all reps.\n            // this ensures all are updated before the live edge search starts\n            resetAvailabilityWindow();\n\n            updateAvailabilityWindow(playbackController.getIsDynamic(), true);\n        };\n        eventBus.trigger(Events.AST_IN_FUTURE, { delay: delay });\n        setTimeout(update, delay);\n    }\n\n    function onRepresentationUpdated(e) {\n        if (e.sender.getType() !== getType() || e.sender.getStreamInfo().id !== streamId || !isUpdating()) return;\n\n        if (e.error) {\n            endDataUpdate(e.error);\n            return;\n        }\n\n        let streamInfo = e.sender.getStreamInfo();\n        let r = e.representation;\n        let manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate();\n        let alreadyAdded = false;\n        let postponeTimePeriod = 0;\n        let repInfo,\n            err,\n            repSwitch;\n\n        if (r.adaptation.period.mpd.manifest.type === DashConstants.DYNAMIC && !r.adaptation.period.mpd.manifest.ignorePostponeTimePeriod)\n        {\n            let segmentAvailabilityTimePeriod = r.segmentAvailabilityRange.end - r.segmentAvailabilityRange.start;\n            // We must put things to sleep unless till e.g. the startTime calculation in ScheduleController.onLiveEdgeSearchCompleted fall after the segmentAvailabilityRange.start\n            let liveDelay = playbackController.computeLiveDelay(currentVoRepresentation.segmentDuration, streamInfo.manifestInfo.DVRWindowSize);\n            postponeTimePeriod = (liveDelay - segmentAvailabilityTimePeriod) * 1000;\n        }\n\n        if (postponeTimePeriod > 0) {\n            postponeUpdate(postponeTimePeriod);\n            err = new DashJSError(Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE, Errors.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE);\n            endDataUpdate(err);\n            return;\n        }\n\n        if (manifestUpdateInfo) {\n            for (let i = 0; i < manifestUpdateInfo.representationInfo.length; i++) {\n                repInfo = manifestUpdateInfo.representationInfo[i];\n                if (repInfo.index === r.index && repInfo.mediaType === getType()) {\n                    alreadyAdded = true;\n                    break;\n                }\n            }\n\n            if (!alreadyAdded) {\n                dashMetrics.addManifestUpdateRepresentationInfo(r, getType());\n            }\n        }\n\n        if (isAllRepresentationsUpdated()) {\n            abrController.setPlaybackQuality(getType(), streamInfo, getQualityForRepresentation(currentVoRepresentation));\n            dashMetrics.updateManifestUpdateInfo({latency: currentVoRepresentation.segmentAvailabilityRange.end - playbackController.getTime()});\n\n            repSwitch = dashMetrics.getCurrentRepresentationSwitch(getCurrentRepresentation().adaptation.type);\n\n            if (!repSwitch) {\n                addRepresentationSwitch();\n            }\n            endDataUpdate();\n        }\n    }\n\n    function onWallclockTimeUpdated(e) {\n        if (e.isDynamic) {\n            updateAvailabilityWindow(e.isDynamic);\n        }\n    }\n\n    function onQualityChanged(e) {\n        if (e.mediaType !== getType() || streamId !== e.streamInfo.id) return;\n\n        currentVoRepresentation = getRepresentationForQuality(e.newQuality);\n        addRepresentationSwitch();\n    }\n\n    function onManifestValidityChanged(e) {\n        if (e.newDuration) {\n            const representation = getCurrentRepresentation();\n            if (representation && representation.adaptation.period) {\n                const period = representation.adaptation.period;\n                period.duration = e.newDuration;\n            }\n        }\n    }\n\n    instance = {\n        setConfig: setConfig,\n        getData: getData,\n        isUpdating: isUpdating,\n        updateData: updateData,\n        updateRepresentation: updateRepresentation,\n        getCurrentRepresentation: getCurrentRepresentation,\n        getRepresentationForQuality: getRepresentationForQuality,\n        getType: getType,\n        getStreamId: getStreamId,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nRepresentationController.__dashjs_factory_name = 'RepresentationController';\nexport default FactoryMaker.getClassFactory(RepresentationController);\n"]}