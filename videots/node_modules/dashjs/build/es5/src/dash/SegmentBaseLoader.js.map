{"version":3,"sources":["../../../../src/dash/SegmentBaseLoader.js"],"names":["SegmentBaseLoader","context","eventBus","getInstance","instance","logger","errHandler","boxParser","requestModifier","dashMetrics","mediaPlayerModel","httpLoader","baseURLController","setup","getLogger","initialize","create","setConfig","config","checkConfig","hasOwnProperty","Error","loadInitialization","representation","loadingInfo","initRange","baseUrl","resolve","path","info","init","url","undefined","range","start","end","searching","bytesLoaded","bytesToLoad","mediaType","adaptation","type","debug","request","getFragmentRequest","onload","response","findInitRange","trigger","Events","INITIALIZATION_LOADED","onerror","load","success","error","loadSegments","callback","parts","toString","split","parseFloat","onLoaded","isoFile","sidx","hasRange","extraBytes","loadedLength","byteLength","parse","getBox","isComplete","offset","size","lastBox","getLastBox","ref","references","loadMultiSidx","segments","length","reference_type","j","len","ss","se","r","segs","count","tmpCallback","result","concat","sort","a","b","startTime","referenced_size","id","getSegmentsForSidx","reset","abort","refs","timescale","time","earliest_presentation_time","first_offset","segment","duration","i","subsegment_duration","Segment","mediaRange","push","FragmentRequest","setInfo","SEGMENTS_LOADED","DashJSError","Errors","SEGMENT_BASE_LOADER_ERROR_CODE","SEGMENT_BASE_LOADER_ERROR_MESSAGE","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"SegmentBaseLoader.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport RequestModifier from '../streaming/utils/RequestModifier';\nimport Segment from './vo/Segment';\nimport DashJSError from '../streaming/vo/DashJSError';\nimport Events from '../core/events/Events';\nimport EventBus from '../core/EventBus';\nimport BoxParser from '../streaming/utils/BoxParser';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Debug from '../core/Debug';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport HTTPLoader from '../streaming/net/HTTPLoader';\nimport Errors from '../core/errors/Errors';\n\nfunction SegmentBaseLoader() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        errHandler,\n        boxParser,\n        requestModifier,\n        dashMetrics,\n        mediaPlayerModel,\n        httpLoader,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize() {\n        boxParser = BoxParser(context).getInstance();\n        requestModifier = RequestModifier(context).getInstance();\n        httpLoader = HTTPLoader(context).create({\n            errHandler: errHandler,\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            requestModifier: requestModifier\n        });\n    }\n\n    function setConfig(config) {\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n    }\n\n    function checkConfig() {\n        if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function loadInitialization(representation, loadingInfo) {\n        checkConfig();\n        let initRange = null;\n        const baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        const info = loadingInfo || {\n            init: true,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: {\n                start: 0,\n                end: 1500\n            },\n            searching: false,\n            bytesLoaded: 0,\n            bytesToLoad: 1500,\n            mediaType: representation && representation.adaptation ? representation.adaptation.type : null\n        };\n\n        logger.debug('Start searching for initialization.');\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            info.bytesLoaded = info.range.end;\n            initRange = boxParser.findInitRange(response);\n\n            if (initRange) {\n                representation.range = initRange;\n                // note that we don't explicitly set rep.initialization as this\n                // will be computed when all BaseURLs are resolved later\n                eventBus.trigger(Events.INITIALIZATION_LOADED, {representation: representation});\n            } else {\n                info.range.end = info.bytesLoaded + info.bytesToLoad;\n                loadInitialization(representation, info);\n            }\n        };\n\n        const onerror = function () {\n            eventBus.trigger(Events.INITIALIZATION_LOADED, {representation: representation});\n        };\n\n        httpLoader.load({request: request, success: onload, error: onerror});\n\n        logger.debug('Perform init search: ' + info.url);\n    }\n\n    function loadSegments(representation, type, range, loadingInfo, callback) {\n        checkConfig();\n        if (range && (range.start === undefined || range.end === undefined)) {\n            const parts = range ? range.toString().split('-') : null;\n            range = parts ? {start: parseFloat(parts[0]), end: parseFloat(parts[1])} : null;\n        }\n\n        callback = !callback ? onLoaded : callback;\n        let isoFile = null;\n        let sidx = null;\n        const hasRange = !!range;\n        const baseUrl = representation ? baseURLController.resolve(representation.path) : null;\n        const info = {\n            init: false,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: hasRange ? range : { start: 0, end: 1500 },\n            searching: !hasRange,\n            bytesLoaded: loadingInfo ? loadingInfo.bytesLoaded : 0,\n            bytesToLoad: 1500,\n            mediaType: representation && representation.adaptation ? representation.adaptation.type : null\n        };\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            const extraBytes = info.bytesToLoad;\n            const loadedLength = response.byteLength;\n\n            info.bytesLoaded = info.range.end - info.range.start;\n            isoFile = boxParser.parse(response);\n            sidx = isoFile.getBox('sidx');\n\n            if (!sidx || !sidx.isComplete) {\n                if (sidx) {\n                    info.range.start = sidx.offset || info.range.start;\n                    info.range.end = info.range.start + (sidx.size || extraBytes);\n                } else if (loadedLength < info.bytesLoaded) {\n                    // if we have reached a search limit or if we have reached the end of the file we have to stop trying to find sidx\n                    callback(null, representation, type);\n                    return;\n                } else {\n                    const lastBox = isoFile.getLastBox();\n\n                    if (lastBox && lastBox.size) {\n                        info.range.start = lastBox.offset + lastBox.size;\n                        info.range.end = info.range.start + extraBytes;\n                    } else {\n                        info.range.end += extraBytes;\n                    }\n                }\n                loadSegments(representation, type, info.range, info, callback);\n            } else {\n                const ref = sidx.references;\n                let loadMultiSidx,\n                    segments;\n\n                if (ref !== null && ref !== undefined && ref.length > 0) {\n                    loadMultiSidx = (ref[0].reference_type === 1);\n                }\n\n                if (loadMultiSidx) {\n                    logger.debug('Initiate multiple SIDX load.');\n                    info.range.end = info.range.start + sidx.size;\n\n                    let j, len, ss, se, r;\n                    let segs = [];\n                    let count = 0;\n                    let offset = (sidx.offset || info.range.start) + sidx.size;\n                    const tmpCallback = function (result) {\n                        if (result) {\n                            segs = segs.concat(result);\n                            count++;\n\n                            if (count >= len) {\n                                // http requests can be processed in a wrong order, so, we have to reorder segments with an ascending start Time order\n                                segs.sort(function (a, b) {\n                                    return a.startTime - b.startTime < 0 ? -1 : 0;\n                                });\n                                callback(segs, representation, type);\n                            }\n                        } else {\n                            callback(null, representation, type);\n                        }\n                    };\n\n                    for (j = 0, len = ref.length; j < len; j++) {\n                        ss = offset;\n                        se = offset + ref[j].referenced_size - 1;\n                        offset = offset + ref[j].referenced_size;\n                        r = {start: ss, end: se};\n                        loadSegments(representation, null, r, info, tmpCallback);\n                    }\n\n                } else {\n                    logger.debug('Parsing segments from SIDX. representation ' + representation.adaptation.type + ' - id: ' + representation.id + ' for range : ' + info.range.start + ' - ' + info.range.end);\n                    segments = getSegmentsForSidx(sidx, info);\n                    callback(segments, representation, type);\n                }\n            }\n        };\n\n        const onerror = function () {\n            callback(null, representation, type);\n        };\n\n        httpLoader.load({request: request, success: onload, error: onerror});\n        logger.debug('Perform SIDX load: ' + info.url + ' with range : ' + info.range.start + ' - ' + info.range.end);\n    }\n\n    function reset() {\n        httpLoader.abort();\n        httpLoader = null;\n        errHandler = null;\n        boxParser = null;\n        requestModifier = null;\n    }\n\n    function getSegmentsForSidx(sidx, info) {\n        const refs = sidx.references;\n        const len = refs.length;\n        const timescale = sidx.timescale;\n        let time = sidx.earliest_presentation_time;\n        let start = info.range.start + sidx.offset + sidx.first_offset + sidx.size;\n        const segments = [];\n        let segment,\n            end,\n            duration,\n            size;\n\n        for (let i = 0; i < len; i++) {\n            duration = refs[i].subsegment_duration;\n            size = refs[i].referenced_size;\n\n            segment = new Segment();\n            // note that we don't explicitly set segment.media as this will be\n            // computed when all BaseURLs are resolved later\n            segment.duration = duration;\n            segment.startTime = time;\n            segment.timescale = timescale;\n            end = start + size - 1;\n            segment.mediaRange = start + '-' + end;\n            segments.push(segment);\n            time += duration;\n            start += size;\n        }\n\n        return segments;\n    }\n\n    function getFragmentRequest(info) {\n        if (!info.url) {\n            return;\n        }\n        const request = new FragmentRequest();\n        request.setInfo(info);\n        return request;\n    }\n\n    function onLoaded(segments, representation, type) {\n        if (segments) {\n            eventBus.trigger(Events.SEGMENTS_LOADED, {segments: segments, representation: representation, mediaType: type});\n        } else {\n            eventBus.trigger(Events.SEGMENTS_LOADED, {segments: null, representation: representation, mediaType: type, error: new DashJSError(Errors.SEGMENT_BASE_LOADER_ERROR_CODE, Errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)});\n        }\n    }\n\n    instance = {\n        setConfig: setConfig,\n        initialize: initialize,\n        loadInitialization: loadInitialization,\n        loadSegments: loadSegments,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nSegmentBaseLoader.__dashjs_factory_name = 'SegmentBaseLoader';\nexport default FactoryMaker.getSingletonFactory(SegmentBaseLoader);\n"]}