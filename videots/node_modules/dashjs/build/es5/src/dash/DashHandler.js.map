{"version":3,"sources":["../../../../src/dash/DashHandler.js"],"names":["DashHandler","config","context","eventBus","getInstance","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","currentTime","isDynamicManifest","segmentsController","setup","getLogger","resetInitialSettings","create","on","Events","INITIALIZATION_LOADED","onInitializationLoaded","SEGMENTS_LOADED","onSegmentsLoaded","REPRESENTATION_UPDATE_STARTED","onRepresentationUpdateStarted","initialize","isDynamic","getType","getStreamInfo","setCurrentTime","value","getCurrentTime","resetIndex","reset","off","setRequestUrl","request","destination","representation","baseURL","resolve","path","url","serviceLocation","isRelative","generateInitRequest","mediaInfo","mediaType","FragmentRequest","period","adaptation","presentationStartTime","start","HTTPRequest","INIT_SEGMENT_TYPE","range","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","duration","quality","index","representationId","id","initialization","bandwidth","getInitRequest","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","eventObj","sender","processRepresentation","voRepresentation","hasInitialization","hasSegments","trigger","REPRESENTATION_UPDATE_COMPLETED","update","getRequestForSegment","segment","undefined","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","media","replacementNumber","replacementTime","MEDIA_SEGMENT_TYPE","mediaRange","startTime","timescale","wallStartTime","availabilityIdx","adaptationIndex","isMediaFinished","isFinished","availableSegmentsNumber","time","parseFloat","toFixed","endTime","getSegmentRequestForTime","options","segmentInfoType","idx","keepIdx","ignoreIsFinished","debug","getSegmentByTime","finished","action","ACTION_COMPLETE","DashConstants","SEGMENT_TIMELINE","getNextSegmentRequest","indexToRequest","getSegmentByIndex","mediaStartTime","isEndlessMedia","isFinite","e","segments","error","fragments","count","i","len","s","seg","length","push","segmentAvailabilityRange","end","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"DashHandler.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashConstants from './constants/DashConstants';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport { HTTPRequest } from '../streaming/vo/metrics/HTTPRequest';\nimport Events from '../core/events/Events';\nimport EventBus from '../core/EventBus';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Debug from '../core/Debug';\nimport URLUtils from '../streaming/utils/URLUtils';\nimport {\n    replaceIDForTemplate,\n    unescapeDollarsInTemplate,\n    replaceTokenForTemplate,\n    getTimeBasedSegment\n} from './utils/SegmentsUtils';\n\nimport SegmentsController from './controllers/SegmentsController';\n\nfunction DashHandler(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n\n    let instance,\n        logger,\n        segmentIndex,\n        lastSegment,\n        requestedTime,\n        currentTime,\n        isDynamicManifest,\n        segmentsController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        segmentsController = SegmentsController(context).create(config);\n\n        eventBus.on(Events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.on(Events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.on(Events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n    }\n\n    function initialize(isDynamic) {\n        isDynamicManifest = isDynamic;\n        segmentsController.initialize(isDynamic);\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function setCurrentTime(value) {\n        currentTime = value;\n    }\n\n    function getCurrentTime() {\n        return currentTime;\n    }\n\n    function resetIndex() {\n        segmentIndex = -1;\n        lastSegment = null;\n    }\n\n    function resetInitialSettings() {\n        resetIndex();\n        currentTime = 0;\n        requestedTime = null;\n        segmentsController = null;\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.off(Events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.off(Events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n    }\n\n    function setRequestUrl(request, destination, representation) {\n        const baseURL = baseURLController.resolve(representation.path);\n        let url,\n            serviceLocation;\n\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\n            url = destination;\n        } else {\n            url = baseURL.url;\n            serviceLocation = baseURL.serviceLocation;\n\n            if (destination) {\n                url = urlUtils.resolve(destination, url);\n            }\n        }\n\n        if (urlUtils.isRelative(url)) {\n            return false;\n        }\n\n        request.url = url;\n        request.serviceLocation = serviceLocation;\n\n        return true;\n    }\n\n    function generateInitRequest(mediaInfo, representation, mediaType) {\n        const request = new FragmentRequest();\n        const period = representation.adaptation.period;\n        const presentationStartTime = period.start;\n\n        request.mediaType = mediaType;\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\n        request.range = representation.range;\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n        request.quality = representation.index;\n        request.mediaInfo = mediaInfo;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, representation.initialization, representation)) {\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\n            return request;\n        }\n    }\n\n    function getInitRequest(mediaInfo, representation) {\n        if (!representation) return null;\n        const request = generateInitRequest(mediaInfo, representation, getType());\n        return request;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function onRepresentationUpdateStarted(eventObj) {\n        if (eventObj.sender.getType() !== getType()) return;\n\n        processRepresentation(eventObj.representation);\n    }\n\n    function processRepresentation(voRepresentation) {\n        const hasInitialization = voRepresentation.hasInitialization();\n        const hasSegments = voRepresentation.hasSegments();\n\n        //if representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n        //otherwise, it means that a request has to be made to get initialization and/or segments informations\n        if (hasInitialization && hasSegments) {\n            eventBus.trigger(Events.REPRESENTATION_UPDATE_COMPLETED, {sender: instance, representation: voRepresentation});\n        } else {\n            segmentsController.update(voRepresentation, getType(), hasInitialization, hasSegments);\n        }\n    }\n\n    function getRequestForSegment(mediaInfo, segment) {\n        if (segment === null || segment === undefined) {\n            return null;\n        }\n\n        const request = new FragmentRequest();\n        const representation = segment.representation;\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n        let url = segment.media;\n\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\n        url = replaceIDForTemplate(url, representation.id);\n        url = unescapeDollarsInTemplate(url);\n\n        request.mediaType = getType();\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\n        request.range = segment.mediaRange;\n        request.startTime = segment.presentationStartTime;\n        request.duration = segment.duration;\n        request.timescale = representation.timescale;\n        request.availabilityStartTime = segment.availabilityStartTime;\n        request.availabilityEndTime = segment.availabilityEndTime;\n        request.wallStartTime = segment.wallStartTime;\n        request.quality = representation.index;\n        request.index = segment.availabilityIdx;\n        request.mediaInfo = mediaInfo;\n        request.adaptationIndex = representation.adaptation.index;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, url, representation)) {\n            return request;\n        }\n    }\n\n    function isMediaFinished(representation) {\n        let isFinished = false;\n\n        if (!representation) return isFinished;\n\n        if (!isDynamicManifest) {\n            if (segmentIndex >= representation.availableSegmentsNumber) {\n                isFinished = true;\n            }\n        } else {\n            if (lastSegment) {\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n                const duration = representation.adaptation.period.duration;\n\n                isFinished = endTime >= duration;\n            }\n        }\n\n        return isFinished;\n    }\n\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return request;\n        }\n\n        const idx = segmentIndex;\n        const keepIdx = options ? options.keepIdx : false;\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\n\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n            requestedTime = time;\n            logger.debug('Getting the request for time : ' + time);\n        }\n\n        const segment = segmentsController.getSegmentByTime(representation, time);\n        if (segment) {\n            segmentIndex = segment.availabilityIdx;\n            lastSegment = segment;\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n            request = getRequestForSegment(mediaInfo, segment);\n        } else {\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = type;\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete in getSegmentRequestForTime');\n            }\n        }\n\n        if (keepIdx && idx >= 0) {\n            segmentIndex = representation.segmentInfoType === DashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n        }\n\n        return request;\n    }\n\n    function getNextSegmentRequest(mediaInfo, representation) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return null;\n        }\n\n        requestedTime = null;\n\n        const indexToRequest = segmentIndex + 1;\n        logger.debug('Getting the next request at index: ' + indexToRequest);\n\n        // check that there is a segment in this index\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n        if (!segment && isEndlessMedia(representation)) {\n            logger.debug('No segment found at index: ' + indexToRequest + '. Wait for next loop');\n            return null;\n        } else {\n            if (segment) {\n                request = getRequestForSegment(mediaInfo, segment);\n                segmentIndex = segment.availabilityIdx;\n            } else {\n                if (isDynamicManifest) {\n                    segmentIndex = indexToRequest - 1;\n                } else {\n                    segmentIndex = indexToRequest;\n                }\n            }\n        }\n\n        if (segment) {\n            lastSegment = segment;\n        } else {\n            const finished = isMediaFinished(representation, segment);\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = getType();\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete');\n            }\n        }\n\n        return request;\n    }\n\n    function isEndlessMedia(representation) {\n        return !isFinite(representation.adaptation.period.duration);\n    }\n\n    function onInitializationLoaded(e) {\n        const representation = e.representation;\n        if (!representation.segments) return;\n\n        eventBus.trigger(Events.REPRESENTATION_UPDATE_COMPLETED, {sender: this, representation: representation});\n    }\n\n    function onSegmentsLoaded(e) {\n        if (e.error || (getType() !== e.mediaType)) return;\n\n        const fragments = e.segments;\n        const representation = e.representation;\n        const segments = [];\n        let count = 0;\n\n        let i,\n            len,\n            s,\n            seg;\n\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n            s = fragments[i];\n\n            seg = getTimeBasedSegment(\n                timelineConverter,\n                isDynamicManifest,\n                representation,\n                s.startTime,\n                s.duration,\n                s.timescale,\n                s.media,\n                s.mediaRange,\n                count);\n\n            if (seg) {\n                segments.push(seg);\n                seg = null;\n                count++;\n            }\n        }\n\n        if (segments.length > 0) {\n            representation.segmentAvailabilityRange = {start: segments[0].presentationStartTime, end: segments[segments.length - 1].presentationStartTime};\n            representation.availableSegmentsNumber = segments.length;\n            representation.segments = segments;\n\n            if (isDynamicManifest) {\n                const lastSegment = segments[segments.length - 1];\n                const liveEdge = lastSegment.presentationStartTime - 8;\n                // the last segment is the Expected, not calculated, live edge.\n                setExpectedLiveEdge(liveEdge);\n            }\n        }\n\n        if (!representation.hasInitialization()) {\n            return;\n        }\n\n        eventBus.trigger(Events.REPRESENTATION_UPDATE_COMPLETED, {sender: this, representation: representation});\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType, //need to be public in order to be used by logger\n        getStreamInfo: getStreamInfo,\n        getInitRequest: getInitRequest,\n        getSegmentRequestForTime: getSegmentRequestForTime,\n        getNextSegmentRequest: getNextSegmentRequest,\n        setCurrentTime: setCurrentTime,\n        getCurrentTime: getCurrentTime,\n        reset: reset,\n        resetIndex: resetIndex\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexport default FactoryMaker.getClassFactory(DashHandler);\n"]}