{"version":3,"sources":["../../../../src/mss/MssFragmentMoofProcessor.js"],"names":["MssFragmentMoofProcessor","config","instance","type","logger","dashMetrics","playbackController","errorHandler","errHandler","eventBus","ISOBoxer","debug","setup","getLogger","processTfrf","request","tfrf","tfdt","streamProcessor","representationController","getRepresentationController","representation","getCurrentRepresentation","manifest","adaptation","period","mpd","Period_asArray","index","AdaptationSet_asArray","timescale","SegmentTemplate","getType","timeShiftBufferDepth","error","DashJSError","MssErrors","MSS_NO_TFRF_CODE","MSS_NO_TFRF_MESSAGE","segments","SegmentTimeline","S","entries","entry","segmentTime","range","segment","t","availabilityStartTime","length","tManifest","parseFloat","fragment_absolute_time","start","end","baseMediaDecodeTime","duration","updateDVR","mediaType","getStreamInfo","manifestInfo","d","fragment_duration","push","trigger","Events","MANIFEST_VALIDITY_CHANGED","sender","newDuration","Math","round","splice","updateRepresentation","dvrInfos","getCurrentDVRInfo","addDVRInfo","getTime","getBoxOffset","parent","offset","i","boxes","size","convertFragment","e","sp","isoFile","parseBuffer","response","tfhd","fetch","track_ID","mediaInfo","traf","createFullBox","version","flags","floor","startTime","trun","tfxd","_parent","indexOf","sepiff","usertype","undefined","saio","entry_count","saiz","sample_count","default_sample_info_size","sample_info_size","NumberOfEntries","moof","getLength","data_offset","trafPosInMoof","sencPosInTraf","write","updateSegmentList","Error","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"MssFragmentMoofProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from '../streaming/vo/DashJSError';\nimport MssErrors from './errors/MssErrors';\n\nimport Events from '../streaming/MediaPlayerEvents';\n\n/**\n * @module MssFragmentMoofProcessor\n * @ignore\n * @param {Object} config object\n */\nfunction MssFragmentMoofProcessor(config) {\n\n    config = config || {};\n    let instance,\n        type,\n        logger;\n    const dashMetrics = config.dashMetrics;\n    const playbackController = config.playbackController;\n    const errorHandler = config.errHandler;\n    const eventBus = config.eventBus;\n    const ISOBoxer = config.ISOBoxer;\n    const debug = config.debug;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        type = '';\n    }\n\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\n        const representationController = streamProcessor.getRepresentationController();\n        const representation = representationController.getCurrentRepresentation();\n\n        const manifest = representation.adaptation.period.mpd.manifest;\n        const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n        const timescale = adaptation.SegmentTemplate.timescale;\n\n        type = streamProcessor.getType();\n\n        if (manifest.type !== 'dynamic' && !manifest.timeShiftBufferDepth) {\n            return;\n        }\n\n        if (!tfrf) {\n            errorHandler.error(new DashJSError(MssErrors.MSS_NO_TFRF_CODE, MssErrors.MSS_NO_TFRF_MESSAGE));\n            return;\n        }\n\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\n        const segments = adaptation.SegmentTemplate.SegmentTimeline.S;\n        const entries = tfrf.entry;\n        let entry,\n            segmentTime,\n            range;\n        let segment = null;\n        let t = 0;\n        let availabilityStartTime = null;\n\n        if (entries.length === 0) {\n            return;\n        }\n\n        // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)\n        entry = entries[0];\n\n        // In case of start-over streams, check if we have reached end of original manifest duration (set in timeShiftBufferDepth)\n        // => then do not update anymore timeline\n        if (manifest.type === 'static') {\n            // Get first segment time\n            segmentTime = segments[0].tManifest ? parseFloat(segments[0].tManifest) : segments[0].t;\n            if (entry.fragment_absolute_time > (segmentTime + (manifest.timeShiftBufferDepth * timescale))) {\n                return;\n            }\n        }\n\n        logger.debug('entry - t = ', (entry.fragment_absolute_time / timescale));\n\n        // Get last segment time\n        segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;\n        logger.debug('Last segment - t = ', (segmentTime / timescale));\n\n        // Check if we have to append new segment to timeline\n        if (entry.fragment_absolute_time <= segmentTime) {\n            // Update DVR window range\n            // => set range end to end time of current segment\n            range = {\n                start: segments[0].t / timescale,\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\n            };\n\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\n            return;\n        }\n\n        logger.debug('Add new segment - t = ', (entry.fragment_absolute_time / timescale));\n        segment = {};\n        segment.t = entry.fragment_absolute_time;\n        segment.d = entry.fragment_duration;\n        // If timestamps starts at 0 relative to 1st segment (dynamic to static) then update segment time\n        if (segments[0].tManifest) {\n            segment.t -= parseFloat(segments[0].tManifest) - segments[0].t;\n            segment.tManifest = entry.fragment_absolute_time;\n        }\n        segments.push(segment);\n\n        // In case of static start-over streams, update content duration\n        if (manifest.type === 'static') {\n            if (type === 'video') {\n                segment = segments[segments.length - 1];\n                var end = (segment.t + segment.d) / timescale;\n                if (end > representation.adaptation.period.duration) {\n                    eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { sender: this, newDuration: end });\n                }\n            }\n            return;\n        }\n        // In case of live streams, update segment timeline according to DVR window\n        else if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\n            // Get timestamp of the last segment\n            segment = segments[segments.length - 1];\n            t = segment.t;\n\n            // Determine the segments' availability start time\n            availabilityStartTime = Math.round((t - (manifest.timeShiftBufferDepth * timescale)) / timescale);\n\n            // Remove segments prior to availability start time\n            segment = segments[0];\n            while (Math.round(segment.t / timescale) < availabilityStartTime) {\n                logger.debug('Remove segment  - t = ' + (segment.t / timescale));\n                segments.splice(0, 1);\n                segment = segments[0];\n            }\n\n            // Update DVR window range => set range end to end time of current segment\n            range = {\n                start: segments[0].t / timescale,\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\n            };\n\n            updateDVR(type, range, streamProcessor.getStreamInfo().manifestInfo);\n        }\n\n        representationController.updateRepresentation(representation, true);\n    }\n\n    function updateDVR(type, range, manifestInfo) {\n        const dvrInfos = dashMetrics.getCurrentDVRInfo(type);\n        if (!dvrInfos || (range.end > dvrInfos.range.end)) {\n            logger.debug('Update DVR Infos [' + range.start + ' - ' + range.end + ']');\n            dashMetrics.addDVRInfo(type, playbackController.getTime(), manifestInfo, range);\n        }\n    }\n\n    // This function returns the offset of the 1st byte of a child box within a container box\n    function getBoxOffset(parent, type) {\n        let offset = 8;\n        let i = 0;\n\n        for (i = 0; i < parent.boxes.length; i++) {\n            if (parent.boxes[i].type === type) {\n                return offset;\n            }\n            offset += parent.boxes[i].size;\n        }\n        return offset;\n    }\n\n    function convertFragment(e, sp) {\n        let i;\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        const isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        const tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        const traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        const trun = isoFile.fetch('trun');\n\n        // Process tfxd boxes\n        // This box provide absolute timestamp but we take the segment start time for tfdt\n        let tfxd = isoFile.fetch('tfxd');\n        if (tfxd) {\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\n            tfxd = null;\n        }\n        let tfrf = isoFile.fetch('tfrf');\n        processTfrf(e.request, tfrf, tfdt, sp);\n        if (tfrf) {\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\n        // => convert sepiff box it into a senc box\n        // => create saio and saiz boxes (if not already present)\n        const sepiff = isoFile.fetch('sepiff');\n        if (sepiff !== null) {\n            sepiff.type = 'senc';\n            sepiff.usertype = undefined;\n\n            let saio = isoFile.fetch('saio');\n            if (saio === null) {\n                // Create Sample Auxiliary Information Offsets Box box (saio)\n                saio = ISOBoxer.createFullBox('saio', traf);\n                saio.version = 0;\n                saio.flags = 0;\n                saio.entry_count = 1;\n                saio.offset = [0];\n\n                const saiz = ISOBoxer.createFullBox('saiz', traf);\n                saiz.version = 0;\n                saiz.flags = 0;\n                saiz.sample_count = sepiff.sample_count;\n                saiz.default_sample_info_size = 0;\n                saiz.sample_info_size = [];\n\n                if (sepiff.flags & 0x02) {\n                    // Sub-sample encryption => set sample_info_size for each sample\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\n                    }\n                } else {\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\n                    saiz.default_sample_info_size = 8;\n                }\n            }\n        }\n\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\n\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\n        const moof = isoFile.fetch('moof');\n        let length = moof.getLength();\n        trun.data_offset = length + 8;\n\n        // Update saio box offset field according to new senc box offset\n        let saio = isoFile.fetch('saio');\n        if (saio !== null) {\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\n            // Set offset from begin fragment to the first IV field in senc box\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\n        }\n\n        // Write transformed/processed fragment into request reponse data\n        e.response = isoFile.write();\n    }\n\n    function updateSegmentList(e, sp) {\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            throw new Error('e.response parameter is missing');\n        }\n\n        const isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        const tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let tfrf = isoFile.fetch('tfrf');\n        processTfrf(e.request, tfrf, tfdt, sp);\n        if (tfrf) {\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    instance = {\n        convertFragment: convertFragment,\n        updateSegmentList: updateSegmentList,\n        getType: getType\n    };\n\n    setup();\n    return instance;\n}\n\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\n"]}