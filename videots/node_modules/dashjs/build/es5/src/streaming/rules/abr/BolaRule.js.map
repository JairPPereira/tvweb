{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":["BOLA_STATE_ONE_BITRATE","BOLA_STATE_STARTUP","BOLA_STATE_STEADY","MINIMUM_BUFFER_S","MINIMUM_BUFFER_PER_BITRATE_LEVEL_S","PLACEHOLDER_BUFFER_DECAY","BolaRule","config","context","dashMetrics","mediaPlayerModel","eventBus","getInstance","instance","logger","bolaStateDict","setup","getLogger","resetInitialSettings","on","Events","BUFFER_EMPTY","onBufferEmpty","PLAYBACK_SEEKING","onPlaybackSeeking","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","METRIC_ADDED","onMetricAdded","QUALITY_CHANGE_REQUESTED","onQualityChangeRequested","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","utilitiesFromBitrates","bitrates","map","Math","log","b","calculateBolaParameters","stableBufferTime","utilities","highestUtilityIndex","reduce","highestIndex","u","uIndex","bufferTime","max","length","gp","Vp","getInitialBolaState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrateList","bandwidth","getStableBufferTime","params","state","lastQuality","clearBolaStateOnSeek","bolaState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","checkBolaStateStableBufferTime","mediaType","bufferLevel","getCurrentBufferLevel","effectiveBufferLevel","getBolaState","getMediaType","getQualityFromBufferLevel","bitrateCount","quality","score","i","s","isNaN","maxBufferLevelForQuality","minBufferLevelForQuality","qBitrate","qUtility","min","iBitrate","iUtility","level","updatePlaceholderBuffer","nowMs","Date","now","delay","lastCallTimeMs","hasOwnProperty","e","chunk","type","start","duration","checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","trequest","getTime","_tfinish","bufferAtLastSegmentRequest","maxEffectiveBufferForLastSegment","maxPlaceholderBuffer","abrQuality","newQuality","wantEffectiveBufferLevel","getMaxIndex","switchRequest","create","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","streamId","id","isDynamic","manifestInfo","useBufferOccupancyABR","reason","setTimeToLoadDelay","throughput","getAverageThroughput","safeThroughput","getSafeAverageThroughput","latency","getAverageLatency","getQualityForBitrate","qualityForThroughput","delayS","getTopQualityIndexFor","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport { HTTPRequest } from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        bolaStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n        // giving:\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n        const Vp = MINIMUM_BUFFER_S / gp;\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n        return {gp: gp, Vp: Vp};\n    }\n\n    function getInitialBolaState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        let utilities = utilitiesFromBitrates(bitrates);\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n        if (!params) {\n            // only happens when there is only one bitrate level\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n        } else {\n            initialState.state = BOLA_STATE_STARTUP;\n\n            initialState.bitrates = bitrates;\n            initialState.utilities = utilities;\n            initialState.stableBufferTime = stableBufferTime;\n            initialState.Vp = params.Vp;\n            initialState.gp = params.gp;\n\n            initialState.lastQuality = 0;\n            clearBolaStateOnSeek(initialState);\n        }\n\n        return initialState;\n    }\n\n    function clearBolaStateOnSeek(bolaState) {\n        bolaState.placeholderBuffer = 0;\n        bolaState.mostAdvancedSegmentStart = NaN;\n        bolaState.lastSegmentWasReplacement = false;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentDurationS = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n    }\n\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        if (bolaState.stableBufferTime !== stableBufferTime) {\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n                // correct placeholder buffer using two criteria:\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\n\n                bolaState.stableBufferTime = stableBufferTime;\n                bolaState.Vp = params.Vp;\n                bolaState.gp = params.gp;\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getBolaState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let bolaState = bolaStateDict[mediaType];\n        if (!bolaState) {\n            bolaState = getInitialBolaState(rulesContext);\n            bolaStateDict[mediaType] = bolaState;\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n            checkBolaStateStableBufferTime(bolaState, mediaType);\n        }\n        return bolaState;\n    }\n\n    // The core idea of BOLA.\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    // maximum buffer level which prefers to download at quality rather than wait\n    function maxBufferLevelForQuality(bolaState, quality) {\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n    }\n\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n    function minBufferLevelForQuality(bolaState, quality) {\n        const qBitrate = bolaState.bitrates[quality];\n        const qUtility = bolaState.utilities[quality];\n\n        let min = 0;\n        for (let i = quality - 1; i >= 0; --i) {\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n                const iBitrate = bolaState.bitrates[i];\n                const iUtility = bolaState.utilities[i];\n\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n            }\n        }\n        return min;\n    }\n\n    /*\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n     * There are two main reasons we might want to increase the placeholder buffer:\n     *\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n     *\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n     */\n    function updatePlaceholderBuffer(bolaState, mediaType) {\n        const nowMs = Date.now();\n\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\n            // no download after last call, compensate for delay between calls\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        }\n\n        bolaState.lastCallTimeMs = nowMs;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n\n        checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    function onBufferEmpty() {\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n                bolaStateDict[mediaType].placeholderBuffer = 0;\n            }\n        }\n    }\n\n    function onPlaybackSeeking() {\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\n                const bolaState = bolaStateDict[mediaType];\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n                    clearBolaStateOnSeek(bolaState);\n                }\n            }\n        }\n    }\n\n    function onPeriodSwitchStarted() {\n        // TODO: does this have to be handled here?\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n                    bolaState.mostAdvancedSegmentStart = start;\n                    bolaState.lastSegmentWasReplacement = false;\n                } else {\n                    bolaState.lastSegmentWasReplacement = true;\n                }\n\n                bolaState.lastSegmentStart = start;\n                bolaState.lastSegmentDurationS = e.chunk.duration;\n                bolaState.lastQuality = e.chunk.quality;\n\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n            }\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n                checkNewSegment(bolaState, e.mediaType);\n            }\n        }\n    }\n\n    /*\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n     * decides not to increase the quality to avoid oscillations.\n     *\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n     * We avoid this by growing the placeholder buffer.\n     */\n    function checkNewSegment(bolaState, mediaType) {\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\n\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n            }\n\n            // then see if we should grow placeholder buffer\n\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n                // compensate for segments that were downloaded but did not grow the buffer\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n            }\n\n            bolaState.lastSegmentStart = NaN;\n            bolaState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    function onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(e.mediaType, true);\n                let wantEffectiveBufferLevel;\n                if (bolaState.abrQuality > 0) {\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n                } else {\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n                }\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useBufferOccupancyABR')) {\n            return switchRequest;\n        }\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const streamId = streamInfo ? streamInfo.id : null;\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useBufferOccupancyABR) {\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const bolaState = getBolaState(rulesContext);\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (bolaState.state) {\n            case BOLA_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n                bolaState.lastQuality = quality;\n\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n                    bolaState.state = BOLA_STATE_STEADY;\n                }\n\n                break; // BOLA_STATE_STARTUP\n\n            case BOLA_STATE_STEADY:\n\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n                //     However, the InsufficientBufferRule takes care of this scenario.\n\n                updatePlaceholderBuffer(bolaState, mediaType);\n\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\n\n                // we want to avoid oscillations\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\n                    // we are only avoid oscillations - do not drop below last quality\n\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n                }\n\n                // We do not want to overfill buffer with low quality chunks.\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\n\n                // First reduce placeholder buffer, then tell schedule controller to pause.\n                if (delayS <= bolaState.placeholderBuffer) {\n                    bolaState.placeholderBuffer -= delayS;\n                    delayS = 0;\n                } else {\n                    delayS -= bolaState.placeholderBuffer;\n                    bolaState.placeholderBuffer = 0;\n\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\n                        scheduleController.setTimeToLoadDelay(1000 * delayS);\n                    } else {\n                        delayS = 0;\n                    }\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n                switchRequest.reason.delay = delayS;\n\n                bolaState.lastQuality = quality;\n                // keep bolaState.state === BOLA_STATE_STEADY\n\n                break; // BOLA_STATE_STEADY\n\n            default:\n                logger.debug('BOLA ABR rule invoked in bad state.');\n                // should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = bolaState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                bolaState.state = BOLA_STATE_STARTUP;\n                clearBolaStateOnSeek(bolaState);\n        }\n\n        return switchRequest;\n    }\n\n    function resetInitialSettings() {\n        bolaStateDict = {};\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexport default FactoryMaker.getClassFactory(BolaRule);\n"]}