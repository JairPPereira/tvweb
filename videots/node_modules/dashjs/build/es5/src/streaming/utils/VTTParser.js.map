{"version":3,"sources":["../../../../../src/streaming/utils/VTTParser.js"],"names":["WEBVTT","VTTParser","context","instance","logger","regExNewLine","regExToken","regExWhiteSpace","regExWhiteSpaceWordBoundary","setup","getInstance","getLogger","parse","data","captionArray","len","lastStartTime","split","length","i","item","match","attributes","parseItemAttributes","cuePoints","styles","text","getSublines","startTime","convertCuePointTimes","replace","endTime","isNaN","push","start","end","error","time","timeArray","parseInt","parseFloat","vttCuePoints","arr","shift","getCaptionStyles","styleObject","forEach","element","val","search","align","line","position","size","idx","subline","lineData","lineCount","j","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"VTTParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst WEBVTT = 'WEBVTT';\n\nfunction VTTParser() {\n    const context = this.context;\n\n    let instance,\n        logger,\n        regExNewLine,\n        regExToken,\n        regExWhiteSpace,\n        regExWhiteSpaceWordBoundary;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        regExNewLine = /(?:\\r\\n|\\r|\\n)/gm;\n        regExToken = /-->/;\n        regExWhiteSpace = /(^[\\s]+|[\\s]+$)/g;\n        regExWhiteSpaceWordBoundary = /\\s\\b/g;\n    }\n\n    function parse(data) {\n        const captionArray = [];\n        let len,\n            lastStartTime;\n\n        if (!data) {\n            return captionArray;\n        }\n\n        data = data.split( regExNewLine );\n        len = data.length;\n        lastStartTime = -1;\n\n        for (let i = 0 ; i < len; i++) {\n            let item = data[i];\n\n            if (item.length > 0 && item !== WEBVTT) {\n                if (item.match(regExToken)) {\n                    const attributes = parseItemAttributes(item);\n                    const cuePoints = attributes.cuePoints;\n                    const styles = attributes.styles;\n                    const text = getSublines(data, i + 1);\n                    const startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));\n                    const endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));\n\n                    if ((!isNaN(startTime) && !isNaN(endTime)) && startTime >= lastStartTime && endTime > startTime) {\n                        if (text !== '') {\n                            lastStartTime = startTime;\n                            //TODO Make VO external so other parsers can use.\n                            captionArray.push({\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: styles\n                            });\n                        }\n                        else {\n                            logger.error('Skipping cue due to empty/malformed cue text');\n                        }\n                    }\n                    else {\n                        logger.error('Skipping cue due to incorrect cue timing');\n                    }\n                }\n            }\n        }\n\n        return captionArray;\n    }\n\n    function convertCuePointTimes(time) {\n        const timeArray = time.split(':');\n        const len = timeArray.length - 1;\n\n        time = parseInt( timeArray[len - 1], 10 ) * 60 + parseFloat( timeArray[len]);\n\n        if ( len === 2 ) {\n            time += parseInt( timeArray[0], 10 ) * 3600;\n        }\n\n        return time;\n    }\n\n    function parseItemAttributes(data) {\n        const vttCuePoints = data.split(regExToken);\n        const arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);\n        arr.shift(); //remove first array index it is empty...\n        vttCuePoints[1] = arr[0];\n        arr.shift();\n        return {cuePoints: vttCuePoints, styles: getCaptionStyles(arr)};\n    }\n\n    function getCaptionStyles(arr) {\n        const styleObject = {};\n        arr.forEach(function (element) {\n            if (element.split(/:/).length > 1) {\n                let val = element.split(/:/)[1];\n                if (val && val.search(/%/) != -1) {\n                    val = parseInt(val.replace(/%/, ''), 10);\n                }\n                if (element.match(/align/) || element.match(/A/)) {\n                    styleObject.align = val;\n                }\n                if (element.match(/line/) || element.match(/L/) ) {\n                    styleObject.line = val;\n                }\n                if (element.match(/position/) || element.match(/P/) ) {\n                    styleObject.position = val;\n                }\n                if (element.match(/size/) || element.match(/S/)) {\n                    styleObject.size = val;\n                }\n            }\n        });\n\n        return styleObject;\n    }\n\n    /*\n    * VTT can have multiple lines to display per cuepoint.\n    */\n    function getSublines(data, idx) {\n        let i = idx;\n\n        let subline = '';\n        let lineData = '';\n        let lineCount;\n\n        while (data[i] !== '' && i < data.length) {\n            i++;\n        }\n\n        lineCount = i - idx;\n        if (lineCount > 1) {\n            for (let j = 0; j < lineCount; j++) {\n                lineData = data[(idx + j)];\n                if (!lineData.match(regExToken)) {\n                    subline += lineData;\n                    if (j !== lineCount - 1) {\n                        subline += '\\n';\n                    }\n                }\n                else {\n                    // caption text should not have '-->' in it\n                    subline = '';\n                    break;\n                }\n            }\n        } else {\n            lineData = data[idx];\n            if (!lineData.match(regExToken))\n                subline = lineData;\n        }\n        return subline;\n    }\n\n    instance = {\n        parse: parse\n    };\n\n    setup();\n    return instance;\n}\nVTTParser.__dashjs_factory_name = 'VTTParser';\nexport default FactoryMaker.getSingletonFactory(VTTParser);\n"]}