{"version":3,"sources":["../../../../../src/streaming/text/TextSourceBuffer.js"],"names":["TextSourceBuffer","context","eventBus","getInstance","embeddedInitialized","instance","logger","boxParser","errHandler","adapter","manifestModel","mediaController","parser","vttParser","ttmlParser","mediaInfos","textTracks","fragmentedFragmentModel","initializationSegmentReceived","timescale","fragmentedTracks","videoModel","streamController","firstFragmentedSubtitleStart","currFragmentedTrackIdx","embeddedTracks","embeddedTimescale","embeddedLastSequenceNumber","embeddedCea608FieldParsers","embeddedTextHtmlRender","mseTimeOffset","setup","getLogger","resetInitialSettings","resetFragmented","NaN","initialize","mimeType","streamProcessor","initEmbedded","setConfig","addMediaInfos","isFragmented","getIsTextTrack","concat","getMediaInfoArr","getFragmentModel","buffered","create","getTracksFor","Constants","FRAGMENTED_TEXT","getStreamInfo","currFragTrack","getCurrentTrackFor","i","length","setCurrentFragmentedTrackIdx","createTextTrackFromMediaInfo","abort","deleteAllTextTracks","reset","onVideoChunkReceived","e","chunk","mediaInfo","embeddedCaptions","append","bytes","streamProcessors","getActiveStreamProcessors","getType","getRepresentationInfo","MSETimeOffset","on","Events","VIDEO_CHUNK_RECEIVED","BUFFER_CLEARED","onVideoBufferCleared","resetEmbedded","off","addEmbeddedTrack","id","CC1","CC3","push","warn","config","getConfig","fragmentModel","idx","captionData","textTrackInfo","TextTrackInfo","trackKindMap","subtitle","caption","getKind","kind","roles","checkTTML","ttml","codec","search","STPP","TTML","lang","labels","index","isTTML","defaultTrack","getIsDefault","isEmbedded","accessibility","totalNrTracks","addTextTrack","result","sampleList","j","k","samplesInfo","ccContent","mediaType","type","codecType","error","segmentType","getMediaTimescaleFromMoov","getSamplesInfo","cts","start","getParser","sample","sampleStart","sampleRelStart","add","duration","dataView","DataView","offset","subSizes","ISOBoxer","Utils","dataViewToString","UTF8","images","subOffset","inData","Uint8Array","raw","String","fromCharCode","apply","manifest","getValue","offsetTime","ttmlTimeIsRelative","parse","addCaptions","removeExecutedRequestsBeforeTime","remove","message","captionArray","sampleData","slice","size","sampleBoxes","parseBuffer","boxes","box1","debug","box2","cue_text","start_time","end_time","end","data","styles","TEXT","byteLength","getCurrentTrackIdx","DashJSError","Errors","TIMED_TEXT_ERROR_ID_PARSE_CODE","TIMED_TEXT_ERROR_MESSAGE_PARSE","VIDEO","HTTPRequest","INIT_SEGMENT_TYPE","makeCueAdderForIndex","self","trackIndex","newCue","startTime","endTime","captionScreen","captionsArray","getTTMLRenderingDiv","createHTMLCaptionsFromScreen","getElement","text","getDisplayText","sequenceNumber","lastSequenceNumber","field","handler","trackIdx","getTrackIdxForId","cea608parser","Cea608Parser","numSequences","allCcData","extractCea608Data","fieldNr","ccData","fields","fieldParser","addData","samples","splits","cea608Ranges","findCea608Nalus","lastSampleTime","extractCea608DataFromRange","forEach","sortField","sort","a","b","isDefault","substring","VTT","undefined","track","deleteCuesFromTrackIdx","from","to","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"TextSourceBuffer.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport TextTrackInfo from '../vo/TextTrackInfo';\nimport BoxParser from '../utils/BoxParser';\nimport CustomTimeRanges from '../utils/CustomTimeRanges';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport TextTracks from './TextTracks';\nimport EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender';\nimport ISOBoxer from 'codem-isoboxer';\nimport cea608parser from '../../../externals/cea608-parser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport DashJSError from '../vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nfunction TextSourceBuffer() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    let embeddedInitialized = false;\n\n    let instance,\n        logger,\n        boxParser,\n        errHandler,\n        adapter,\n        manifestModel,\n        mediaController,\n        parser,\n        vttParser,\n        ttmlParser,\n        mediaInfos,\n        textTracks,\n        fragmentedFragmentModel,\n        initializationSegmentReceived,\n        timescale,\n        fragmentedTracks,\n        videoModel,\n        streamController,\n        firstFragmentedSubtitleStart,\n        currFragmentedTrackIdx,\n        embeddedTracks,\n        embeddedTimescale,\n        embeddedLastSequenceNumber,\n        embeddedCea608FieldParsers,\n        embeddedTextHtmlRender,\n        mseTimeOffset;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        resetInitialSettings();\n    }\n\n    function resetFragmented () {\n        fragmentedFragmentModel = null;\n        timescale = NaN;\n        fragmentedTracks = [];\n        firstFragmentedSubtitleStart = null;\n        initializationSegmentReceived = false;\n    }\n\n    function resetInitialSettings() {\n        resetFragmented();\n\n        mediaInfos = [];\n        parser = null;\n    }\n\n    function initialize(mimeType, streamProcessor) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n\n        if (!boxParser) {\n            boxParser = BoxParser(context).getInstance();\n        }\n\n        addMediaInfos(mimeType, streamProcessor);\n    }\n\n    function addMediaInfos(mimeType, streamProcessor) {\n        const isFragmented = !adapter.getIsTextTrack(mimeType);\n        if (streamProcessor) {\n            mediaInfos = mediaInfos.concat(streamProcessor.getMediaInfoArr());\n\n            if (isFragmented) {\n                fragmentedFragmentModel = streamProcessor.getFragmentModel();\n                instance.buffered = CustomTimeRanges(context).create();\n                fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamProcessor.getStreamInfo());\n                const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamProcessor.getStreamInfo());\n                for (let i = 0; i < fragmentedTracks.length; i++) {\n                    if (fragmentedTracks[i] === currFragTrack) {\n                        setCurrentFragmentedTrackIdx(i);\n                        break;\n                    }\n                }\n            }\n\n            for (let i = 0; i < mediaInfos.length; i++) {\n                createTextTrackFromMediaInfo(null, mediaInfos[i]);\n            }\n        }\n    }\n\n    function abort() {\n        textTracks.deleteAllTextTracks();\n        resetFragmented();\n        boxParser = null;\n        mediaInfos = [];\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        streamController = null;\n        videoModel = null;\n        textTracks = null;\n    }\n\n    function onVideoChunkReceived(e) {\n        const chunk = e.chunk;\n\n        if (chunk.mediaInfo.embeddedCaptions) {\n            append(chunk.bytes, chunk);\n        }\n    }\n\n    function initEmbedded() {\n        embeddedTracks = [];\n        textTracks = TextTracks(context).getInstance();\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n        boxParser = BoxParser(context).getInstance();\n        currFragmentedTrackIdx = null;\n        embeddedTimescale = 0;\n        embeddedCea608FieldParsers = [];\n        embeddedLastSequenceNumber = null;\n        embeddedInitialized = true;\n        embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance();\n\n        const streamProcessors = streamController.getActiveStreamProcessors();\n        for (const i in streamProcessors) {\n            if (streamProcessors[i].getType() === 'video') {\n                mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n                break;\n            }\n        }\n\n        eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        eventBus.on(Events.BUFFER_CLEARED, onVideoBufferCleared, this);\n    }\n\n    function resetEmbedded() {\n        eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        eventBus.off(Events.BUFFER_CLEARED, onVideoBufferCleared, this);\n        if (textTracks) {\n            textTracks.deleteAllTextTracks();\n        }\n        embeddedInitialized = false;\n        embeddedTracks = [];\n        embeddedCea608FieldParsers = [null, null];\n        embeddedLastSequenceNumber = null;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n        if (mediaInfo) {\n            if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) {\n                for (let i = 0; i < embeddedTracks.length; i++) {\n                    if (embeddedTracks[i].id === mediaInfo.id) {\n                        return;\n                    }\n                }\n                embeddedTracks.push(mediaInfo);\n            } else {\n                logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n            }\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n    }\n\n    function getConfig() {\n        const config = {\n            fragmentModel: fragmentedFragmentModel,\n            fragmentedTracks: fragmentedTracks,\n            videoModel: videoModel\n        };\n\n        return config;\n    }\n\n    function setCurrentFragmentedTrackIdx(idx) {\n        currFragmentedTrackIdx = idx;\n    }\n\n    function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n        const textTrackInfo = new TextTrackInfo();\n        const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n        const getKind = function () {\n            let kind = (mediaInfo.roles.length > 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n            kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption;\n            return kind;\n        };\n\n        const checkTTML = function () {\n            let ttml = false;\n            if (mediaInfo.codec && mediaInfo.codec.search(Constants.STPP) >= 0) {\n                ttml = true;\n            }\n            if (mediaInfo.mimeType && mediaInfo.mimeType.search(Constants.TTML) >= 0) {\n                ttml = true;\n            }\n            return ttml;\n        };\n\n        textTrackInfo.captionData = captionData;\n        textTrackInfo.lang = mediaInfo.lang;\n        textTrackInfo.labels = mediaInfo.labels;\n        textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n        textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n        textTrackInfo.isTTML = checkTTML();\n        textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n        textTrackInfo.isFragmented = !adapter.getIsTextTrack(mediaInfo.mimeType);\n        textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n        textTrackInfo.kind = getKind();\n        textTrackInfo.roles = mediaInfo.roles;\n        textTrackInfo.accessibility = mediaInfo.accessibility;\n        const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n        textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n    }\n\n    function append(bytes, chunk) {\n        let result,\n            sampleList,\n            i, j, k,\n            samplesInfo,\n            ccContent;\n        const mediaInfo = chunk.mediaInfo;\n        const mediaType = mediaInfo.type;\n        const mimeType = mediaInfo.mimeType;\n        const codecType = mediaInfo.codec || mimeType;\n        if (!codecType) {\n            logger.error('No text type defined');\n            return;\n        }\n\n        if (mediaType === Constants.FRAGMENTED_TEXT) {\n            if (!initializationSegmentReceived && chunk.segmentType === 'InitializationSegment') {\n                initializationSegmentReceived = true;\n                timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n            } else {\n                if (!initializationSegmentReceived) {\n                    return;\n                }\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n                sampleList = samplesInfo.sampleList;\n                if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n                    firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n                }\n                if (codecType.search(Constants.STPP) >= 0) {\n                    parser = parser !== null ? parser : getParser(codecType);\n                    for (i = 0; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        const sampleStart = sample.cts;\n                        const sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n                        this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n                        const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n                        ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n                        const images = [];\n                        let subOffset = sample.offset + sample.subSizes[0];\n                        for (j = 1; j < sample.subSizes.length; j++) {\n                            const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n                            const raw = String.fromCharCode.apply(null, inData);\n                            images.push(raw);\n                            subOffset += sample.subSizes[j];\n                        }\n                        try {\n                            // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n                            const manifest = manifestModel.getValue();\n                            const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n                            result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n                            textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n                        } catch (e) {\n                            fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n                            this.remove();\n                            logger.error('TTML parser error: ' + e.message);\n                        }\n                    }\n                } else {\n                    // WebVTT case\n                    const captionArray = [];\n                    for (i = 0 ; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        sample.cts -= firstFragmentedSubtitleStart;\n                        this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale);\n                        const sampleData = bytes.slice(sample.offset, sample.offset + sample.size);\n                        // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n                        const sampleBoxes = ISOBoxer.parseBuffer(sampleData);\n\n                        for (j = 0 ; j < sampleBoxes.boxes.length; j++) {\n                            const box1 = sampleBoxes.boxes[j];\n                            logger.debug('VTT box1: ' + box1.type);\n                            if (box1.type === 'vtte') {\n                                continue; //Empty box\n                            }\n                            if (box1.type === 'vttc') {\n                                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n                                for (k = 0 ; k < box1.boxes.length; k++) {\n                                    const box2 = box1.boxes[k];\n                                    logger.debug('VTT box2: ' + box2.type);\n                                    if (box2.type === 'payl') {\n                                        const cue_text = box2.cue_text;\n                                        logger.debug('VTT cue_text = ' + cue_text);\n                                        const start_time = sample.cts / timescale;\n                                        const end_time = (sample.cts + sample.duration) / timescale;\n                                        captionArray.push({\n                                            start: start_time,\n                                            end: end_time,\n                                            data: cue_text,\n                                            styles: {}\n                                        });\n                                        logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (captionArray.length > 0) {\n                        textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n                    }\n                }\n            }\n        } else if (mediaType === Constants.TEXT) {\n            const dataView = new DataView(bytes, 0, bytes.byteLength);\n            ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n\n            try {\n                result = getParser(codecType).parse(ccContent, 0);\n                textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n            } catch (e) {\n                errHandler.error(new DashJSError(Errors.TIMED_TEXT_ERROR_ID_PARSE_CODE, Errors.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n            }\n        } else if (mediaType === Constants.VIDEO) { //embedded text\n            if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) {\n                if (embeddedTimescale === 0) {\n                    embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n                    }\n                }\n            } else { // MediaSegment\n                if (embeddedTimescale === 0) {\n                    logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n                    return;\n                }\n                const makeCueAdderForIndex = function (self, trackIndex) {\n                    function newCue(startTime, endTime, captionScreen) {\n                        let captionsArray = null;\n                        if (videoModel.getTTMLRenderingDiv()) {\n                            captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n                        } else {\n                            const text = captionScreen.getDisplayText();\n                            captionsArray = [{\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: {}\n                            }];\n                        }\n                        if (captionsArray) {\n                            textTracks.addCaptions(trackIndex, 0, captionsArray);\n                        }\n                    }\n                    return newCue;\n                };\n\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n\n                const sequenceNumber = samplesInfo.lastSequenceNumber;\n\n                if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n                    // Time to setup the CEA-608 parsing\n                    let field, handler, trackIdx;\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        if (embeddedTracks[i].id === Constants.CC1) {\n                            field = 0;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC1);\n                        } else if (embeddedTracks[i].id === Constants.CC3) {\n                            field = 1;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC3);\n                        }\n                        if (trackIdx === -1) {\n                            logger.warn('CEA-608: data before track is ready.');\n                            return;\n                        }\n                        handler = makeCueAdderForIndex(this, trackIdx);\n                        embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i + 1, {\n                            'newCue': handler\n                        }, null);\n                    }\n                }\n\n                if (embeddedTimescale) {\n                    if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n                        for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n                            if (embeddedCea608FieldParsers[i]) {\n                                embeddedCea608FieldParsers[i].reset();\n                            }\n                        }\n                    }\n\n                    const allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n                    for (let fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n                        const ccData = allCcData.fields[fieldNr];\n                        const fieldParser = embeddedCea608FieldParsers[fieldNr];\n                        if (fieldParser) {\n                            for (i = 0; i < ccData.length; i++) {\n                                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n                            }\n                        }\n                    }\n                    embeddedLastSequenceNumber = sequenceNumber;\n                }\n            }\n        }\n    }\n    /**\n     * Extract CEA-608 data from a buffer of data.\n     * @param {ArrayBuffer} data\n     * @param {Array} samples cue information\n     * @returns {Object|null} ccData corresponding to one segment.\n     */\n    function extractCea608Data(data, samples) {\n        if (samples.length === 0) {\n            return null;\n        }\n\n        const allCcData = {\n            splits: [],\n            fields: [[], []]\n        };\n        const raw = new DataView(data);\n        for (let i = 0; i < samples.length; i++) {\n            const sample = samples[i];\n            const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size);\n            let lastSampleTime = null;\n            let idx = 0;\n            for (let j = 0; j < cea608Ranges.length; j++) {\n                const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]);\n                for (let k = 0; k < 2; k++) {\n                    if (ccData[k].length > 0) {\n                        if (sample.cts !== lastSampleTime) {\n                            idx = 0;\n                        } else {\n                            idx += 1;\n                        }\n                        allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]);\n                        lastSampleTime = sample.cts;\n                    }\n                }\n            }\n        }\n\n        // Sort by sampleTime ascending order\n        // If two packets have the same sampleTime, use them in the order\n        // they were received\n        allCcData.fields.forEach(function sortField(field) {\n            field.sort(function (a, b) {\n                if (a[0] === b[0]) {\n                    return a[2] - b[2];\n                }\n                return a[0] - b[0];\n            });\n        });\n\n        return allCcData;\n    }\n\n    function getIsDefault(mediaInfo) {\n        //TODO How to tag default. currently same order as listed in manifest.\n        // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n        // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n        let isDefault = false;\n        if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n            isDefault = (mediaInfo.id && mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist\n        } else if (embeddedTracks.length === 1) {\n            if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3\n                isDefault = true;\n            }\n        } else if (embeddedTracks.length === 0) {\n            isDefault = (mediaInfo.index === mediaInfos[0].index);\n        }\n        return isDefault;\n    }\n\n    function getParser(codecType) {\n        let parser;\n        if (codecType.search(Constants.VTT) >= 0) {\n            parser = vttParser;\n        } else if (codecType.search(Constants.TTML) >= 0 || codecType.search(Constants.STPP) >= 0) {\n            parser = ttmlParser;\n        }\n        return parser;\n    }\n\n    function remove(start, end) {\n        //if start and end are not defined, remove all\n        if ((start === undefined) && (start === end)) {\n            start = this.buffered.start(0);\n            end = this.buffered.end(this.buffered.length - 1);\n        }\n        this.buffered.remove(start, end);\n    }\n\n    function onVideoBufferCleared(e) {\n        embeddedTracks.forEach(function (track) {\n            const trackIdx = textTracks.getTrackIdxForId(track.id);\n            if (trackIdx >= 0) {\n                textTracks.deleteCuesFromTrackIdx(trackIdx, e.from, e.to);\n            }\n        });\n    }\n\n    instance = {\n        initialize: initialize,\n        append: append,\n        abort: abort,\n        addEmbeddedTrack: addEmbeddedTrack,\n        resetEmbedded: resetEmbedded,\n        setConfig: setConfig,\n        getConfig: getConfig,\n        setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n        remove: remove,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexport default FactoryMaker.getSingletonFactory(TextSourceBuffer);\n"]}