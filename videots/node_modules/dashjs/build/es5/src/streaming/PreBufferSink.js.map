{"version":3,"sources":["../../../../src/streaming/PreBufferSink.js"],"names":["PreBufferSink","onAppendedCallback","context","instance","logger","outstandingInit","chunks","onAppended","setup","getInstance","getLogger","reset","append","chunk","segmentType","push","sort","a","b","start","debug","end","remove","filter","isNaN","abort","getAllBufferRanges","ranges","i","length","timeranges","n","Object","defineProperty","get","hasDiscontinuitiesAfter","updateTimestampOffset","getBuffer","discharge","result","getChunksAt","waitForUpdateEnd","callback","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"mappings":"sEA8BA,oC,2CACA,kD,4IAEA;;;;;;;GAjCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyCA,QAASA,cAAT,CAAuBC,kBAAvB,CAA2C,CACvC,GAAMC,SAAU,KAAKA,OAArB,CAEA,GAAIC,gBAAJ,CACIC,aADJ,CAEIC,sBAFJ,CAGA,GAAIC,QAAS,EAAb,CACA,GAAIC,YAAaN,kBAAjB,CAEA,QAASO,MAAT,EAAiB,CACbJ,OAAS,oBAAMF,OAAN,EAAeO,WAAf,GAA6BC,SAA7B,CAAuCP,QAAvC,CAAT,CACH,CAED,QAASQ,MAAT,EAAiB,CACbL,OAAS,EAAT,CACAD,gBAAkB,IAAlB,CACAE,WAAa,IAAb,CACH,CAED,QAASK,OAAT,CAAgBC,KAAhB,CAAuB,CACnB,GAAIA,MAAMC,WAAN,GAAsB,uBAA1B,CAAmD,CAAE;AACjDR,OAAOS,IAAP,CAAYF,KAAZ,EACAP,OAAOU,IAAP,CAAY,SAAUC,CAAV,CAAaC,CAAb,CAAgB,CAAE,MAAOD,GAAEE,KAAF,CAAUD,EAAEC,KAAnB,CAA2B,CAAzD,EACAd,gBAAkB,IAAlB,CACH,CAJD,IAIO,CAAC;AACJA,gBAAkBQ,KAAlB,CACH,CAEDT,OAAOgB,KAAP,CAAa,mCAAqCP,MAAMM,KAA3C,CAAmD,OAAnD,CAA6DN,MAAMQ,GAAhF,EACA,GAAId,UAAJ,CAAgB,CACZA,WAAW,CACPM,MAAOA,KADA,CAAX,EAGH,CACJ,CAED,QAASS,OAAT,CAAgBH,KAAhB,CAAuBE,GAAvB,CAA4B,CACxBf,OAASA,OAAOiB,MAAP,CAAe,kBAAK,EAAE,CAACC,MAAMH,GAAN,GAAcJ,EAAEE,KAAF,CAAUE,GAAzB,IAAkCG,MAAML,KAAN,GAAgBF,EAAEI,GAAF,CAAQF,KAA1D,CAAF,CAAL,EAAf,CAAT,CAAmG;AACtG,CAED;AACA,QAASM,MAAT,EAAiB,CAChB,CAED,QAASC,mBAAT,EAA8B,CAC1B,GAAIC,QAAS,EAAb,CAEA,IAAK,GAAIC,GAAI,CAAb,CAAgBA,EAAItB,OAAOuB,MAA3B,CAAmCD,GAAnC,CAAwC,CACpC,GAAIf,OAAQP,OAAOsB,CAAP,CAAZ,CACA,GAAID,OAAOE,MAAP,GAAkB,CAAlB,EAAuBhB,MAAMM,KAAN,CAAcQ,OAAOA,OAAOE,MAAP,CAAgB,CAAvB,EAA0BR,GAAnE,CAAwE,CACpEM,OAAOZ,IAAP,CAAY,CAAEI,MAAON,MAAMM,KAAf,CAAsBE,IAAKR,MAAMQ,GAAjC,CAAZ,EACH,CAFD,IAEO,CACHM,OAAOA,OAAOE,MAAP,CAAgB,CAAvB,EAA0BR,GAA1B,CAAgCR,MAAMQ,GAAtC,CACH,CACJ,CAED;AACA,GAAMS,YAAa,CACfX,MAAO,eAAUY,CAAV,CAAa,CAChB,MAAOJ,QAAOI,CAAP,EAAUZ,KAAjB,CACH,CAHc,CAIfE,IAAK,aAAUU,CAAV,CAAa,CACd,MAAOJ,QAAOI,CAAP,EAAUV,GAAjB,CACH,CANc,CAAnB,CASAW,OAAOC,cAAP,CAAsBH,UAAtB,CAAkC,QAAlC,CAA4C,CACxCI,IAAK,cAAY,CACb,MAAOP,QAAOE,MAAd,CACH,CAHuC,CAA5C,EAMA,MAAOC,WAAP,CACH,CAED,QAASK,wBAAT,EAAmC,CAC/B,MAAO,MAAP,CACH,CAED,QAASC,sBAAT,EAAiC,CAC7B;AACH,CAED,QAASC,UAAT,EAAqB,CACjB,MAAO,KAAP,CACH,CAED;;;;;;;;OASA,QAASC,UAAT,CAAmBnB,KAAnB,CAA0BE,GAA1B,CAA+B,CAC3B,GAAMkB,QAASC,YAAYrB,KAAZ,CAAmBE,GAAnB,CAAf,CACA,GAAIhB,eAAJ,CAAqB,CACjBkC,OAAOxB,IAAP,CAAYV,eAAZ,EACAA,gBAAkB,IAAlB,CACH,CAEDiB,OAAOH,KAAP,CAAcE,GAAd,EAEA,MAAOkB,OAAP,CACH,CAED,QAASC,YAAT,CAAqBrB,KAArB,CAA4BE,GAA5B,CAAiC,CAC7B,MAAOf,QAAOiB,MAAP,CAAe,kBAAM,CAACC,MAAMH,GAAN,GAAcJ,EAAEE,KAAF,CAAUE,GAAzB,IAAkCG,MAAML,KAAN,GAAgBF,EAAEI,GAAF,CAAQF,KAA1D,CAAN,EAAf,CAAP,CACH,CAED,QAASsB,iBAAT,CAA0BC,QAA1B,CAAoC,CAChCA,WACH,CAEDvC,SAAW,CACPuB,mBAAoBA,kBADb,CAEPd,OAAQA,MAFD,CAGPU,OAAQA,MAHD,CAIPG,MAAOA,KAJA,CAKPa,UAAWA,SALJ,CAMP3B,MAAOA,KANA,CAOPyB,sBAAuBA,qBAPhB,CAQPD,wBAAyBA,uBARlB,CASPM,iBAAkBA,gBATX,CAUPJ,UAAWA,SAVJ,CAAX,CAaA7B,QAEA,MAAOL,SAAP,CACH,CAEDH,cAAc2C,qBAAd,CAAsC,eAAtC,CACA,GAAMC,SAAUC,uBAAaC,eAAb,CAA6B9C,aAA7B,CAAhB,C,gBACe4C,O","file":"PreBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport FactoryMaker from '../core/FactoryMaker';\n\n/**\n * This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n *\n * @class PreBufferSink\n * @ignore\n * @implements FragmentSink\n */\nfunction PreBufferSink(onAppendedCallback) {\n    const context = this.context;\n\n    let instance,\n        logger,\n        outstandingInit;\n    let chunks = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function reset() {\n        chunks = [];\n        outstandingInit = null;\n        onAppended = null;\n    }\n\n    function append(chunk) {\n        if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache.\n            chunks.push(chunk);\n            chunks.sort(function (a, b) { return a.start - b.start; });\n            outstandingInit = null;\n        } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n            outstandingInit = chunk;\n        }\n\n        logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n        if (onAppended) {\n            onAppended({\n                chunk: chunk\n            });\n        }\n    }\n\n    function remove(start, end) {\n        chunks = chunks.filter( a => !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start))); //The opposite of the getChunks predicate.\n    }\n\n    //Nothing async, nothing to abort.\n    function abort() {\n    }\n\n    function getAllBufferRanges() {\n        let ranges = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            let chunk = chunks[i];\n            if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n                ranges.push({ start: chunk.start, end: chunk.end });\n            } else {\n                ranges[ranges.length - 1].end = chunk.end;\n            }\n        }\n\n        //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n        const timeranges = {\n            start: function (n) {\n                return ranges[n].start;\n            },\n            end: function (n) {\n                return ranges[n].end;\n            }\n        };\n\n        Object.defineProperty(timeranges, 'length', {\n            get: function () {\n                return ranges.length;\n            }\n        });\n\n        return timeranges;\n    }\n\n    function hasDiscontinuitiesAfter() {\n        return false;\n    }\n\n    function updateTimestampOffset() {\n        // Nothing to do\n    }\n\n    function getBuffer() {\n        return this;\n    }\n\n    /**\n     * Return the all chunks in the buffer the lie between times start and end.\n     * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n     * Chunks are removed from the buffer when they are discharged.\n     * @function PreBufferSink#discharge\n     * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @returns {Array} The set of chunks from the buffer within the time ranges.\n     */\n    function discharge(start, end) {\n        const result = getChunksAt(start, end);\n        if (outstandingInit) {\n            result.push(outstandingInit);\n            outstandingInit = null;\n        }\n\n        remove(start, end);\n\n        return result;\n    }\n\n    function getChunksAt(start, end) {\n        return chunks.filter( a => ((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start)) );\n    }\n\n    function waitForUpdateEnd(callback) {\n        callback();\n    }\n\n    instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        append: append,\n        remove: remove,\n        abort: abort,\n        discharge: discharge,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n        waitForUpdateEnd: waitForUpdateEnd,\n        getBuffer: getBuffer\n    };\n\n    setup();\n\n    return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\nconst factory = FactoryMaker.getClassFactory(PreBufferSink);\nexport default factory;\n"]}