{"version":3,"sources":["../../../../src/streaming/MediaPlayerEvents.js"],"names":["MediaPlayerEvents","AST_IN_FUTURE","BUFFER_EMPTY","BUFFER_LOADED","BUFFER_LEVEL_STATE_CHANGED","ERROR","FRAGMENT_LOADING_COMPLETED","FRAGMENT_LOADING_PROGRESS","FRAGMENT_LOADING_STARTED","FRAGMENT_LOADING_ABANDONED","LOG","MANIFEST_LOADED","METRICS_CHANGED","METRIC_CHANGED","METRIC_ADDED","METRIC_UPDATED","PERIOD_SWITCH_COMPLETED","PERIOD_SWITCH_STARTED","QUALITY_CHANGE_REQUESTED","QUALITY_CHANGE_RENDERED","TRACK_CHANGE_RENDERED","SOURCE_INITIALIZED","STREAM_INITIALIZING","STREAM_INITIALIZED","STREAM_TEARDOWN_COMPLETE","TEXT_TRACKS_ADDED","TEXT_TRACK_ADDED","TTML_PARSED","TTML_TO_PARSE","CAPTION_RENDERED","CAPTION_CONTAINER_RESIZE","CAN_PLAY","PLAYBACK_ENDED","PLAYBACK_ERROR","PLAYBACK_NOT_ALLOWED","PLAYBACK_METADATA_LOADED","PLAYBACK_PAUSED","PLAYBACK_PLAYING","PLAYBACK_PROGRESS","PLAYBACK_RATE_CHANGED","PLAYBACK_SEEKED","PLAYBACK_SEEKING","PLAYBACK_SEEK_ASKED","PLAYBACK_STALLED","PLAYBACK_STARTED","PLAYBACK_TIME_UPDATED","PLAYBACK_WAITING","MANIFEST_VALIDITY_CHANGED","EventsBase","mediaPlayerEvents"],"mappings":"sEA8BA,sD,u7BA9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BA;;;MAIMA,kB,gEAEF;;OAGA,4BAAc,yCAEV;;;;;WAFU,8HAQV,MAAKC,aAAL,CAAqB,aAArB,CAEA;;;;WAKA,MAAKC,YAAL,CAAoB,eAApB,CAEA;;;;WAKA,MAAKC,aAAL,CAAqB,cAArB,CAEA;;;WAIA,MAAKC,0BAAL,CAAkC,oBAAlC,CAEA;;;WAIA,MAAKC,KAAL,CAAa,OAAb,CAEA;;;WAIA,MAAKC,0BAAL,CAAkC,0BAAlC,CAEA;;;WAIA,MAAKC,yBAAL,CAAiC,yBAAjC,CACA;;;WAIA,MAAKC,wBAAL,CAAgC,wBAAhC,CAEA;;;WAIA,MAAKC,0BAAL,CAAkC,0BAAlC,CAEA;;;WAIA,MAAKC,GAAL,CAAW,KAAX,CAEA;AACA;;;WAIA,MAAKC,eAAL,CAAuB,gBAAvB,CAEA;;;WAIA,MAAKC,eAAL,CAAuB,gBAAvB,CAEA;;;WAIA,MAAKC,cAAL,CAAsB,eAAtB,CAEA;;;WAIA,MAAKC,YAAL,CAAoB,aAApB,CAEA;;;WAIA,MAAKC,cAAL,CAAsB,eAAtB,CAEA;;;WAIA,MAAKC,uBAAL,CAA+B,uBAA/B,CAEA;;;WAIA,MAAKC,qBAAL,CAA6B,qBAA7B,CAEA;;;WAIA,MAAKC,wBAAL,CAAgC,wBAAhC,CAEA;;;WAIA,MAAKC,uBAAL,CAA+B,uBAA/B,CAEA;;;WAIA,MAAKC,qBAAL,CAA6B,qBAA7B,CAEA;;;WAIA,MAAKC,kBAAL,CAA0B,mBAA1B,CAEA;;;WAIA,MAAKC,mBAAL,CAA2B,oBAA3B,CAEA;;;WAIA,MAAKC,kBAAL,CAA0B,mBAA1B,CAEA;;;WAIA,MAAKC,wBAAL,CAAgC,wBAAhC,CAEA;;;WAIA,MAAKC,iBAAL,CAAyB,oBAAzB,CAEA;;;WAIA,MAAKC,gBAAL,CAAwB,gBAAxB,CAEA;;;WAIA,MAAKC,WAAL,CAAmB,YAAnB,CAEA;;;WAIA,MAAKC,aAAL,CAAqB,aAArB,CAEA;;;WAIA,MAAKC,gBAAL,CAAwB,iBAAxB,CAEA;;;WAIA,MAAKC,wBAAL,CAAgC,wBAAhC,CAEA;;;;;WAMA,MAAKC,QAAL,CAAgB,SAAhB,CAEA;;;WAIA,MAAKC,cAAL,CAAsB,eAAtB,CAEA;;;;WAKA,MAAKC,cAAL,CAAsB,eAAtB,CAEA;;;WAIA,MAAKC,oBAAL,CAA4B,oBAA5B,CAEA;;;;WAKA,MAAKC,wBAAL,CAAgC,wBAAhC,CAEA;;;WAIA,MAAKC,eAAL,CAAuB,gBAAvB,CAEA;;;;;WAMA,MAAKC,gBAAL,CAAwB,iBAAxB,CAEA;;;;;WAMA,MAAKC,iBAAL,CAAyB,kBAAzB,CAEA;;;WAIA,MAAKC,qBAAL,CAA6B,qBAA7B,CAEA;;;WAIA,MAAKC,eAAL,CAAuB,gBAAvB,CAEA;;;WAIA,MAAKC,gBAAL,CAAwB,iBAAxB,CAEA;;;WAIA,MAAKC,mBAAL,CAA2B,mBAA3B,CAEA;;;WAIA,MAAKC,gBAAL,CAAwB,iBAAxB,CAEA;;;;;WAMA,MAAKC,gBAAL,CAAwB,iBAAxB,CAEA;;;WAIA,MAAKC,qBAAL,CAA6B,qBAA7B,CAEA;;;;WAKA,MAAKC,gBAAL,CAAwB,iBAAxB,CAEA;;;WAIA,MAAKC,yBAAL,CAAiC,yBAAjC,CAzSU,aA0Sb,C,2BA/S2BC,oB,EAkThC,GAAIC,mBAAoB,GAAIjD,kBAAJ,EAAxB,C,gBACeiD,iB","file":"MediaPlayerEvents.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventsBase from '../core/events/EventsBase';\n/**\n * @class\n * @implements EventsBase\n */\nclass MediaPlayerEvents extends EventsBase {\n\n    /**\n     * @description Public facing external events to be used when developing a player that implements dash.js.\n     */\n    constructor() {\n        super();\n        /**\n         * Triggered when playback will not start yet\n         * as the MPD's availabilityStartTime is in the future.\n         * Check delay property in payload to determine time before playback will start.\n         * @event MediaPlayerEvents#AST_IN_FUTURE\n         */\n        this.AST_IN_FUTURE = 'astInFuture';\n\n        /**\n         * Triggered when the video element's buffer state changes to stalled.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_EMPTY\n         */\n        this.BUFFER_EMPTY = 'bufferStalled';\n\n        /**\n         * Triggered when the video element's buffer state changes to loaded.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_LOADED\n         */\n        this.BUFFER_LOADED = 'bufferLoaded';\n\n        /**\n         * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state.\n         * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED\n         */\n        this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged';\n\n        /**\n         * Triggered when there is an error from the element or MSE source buffer.\n         * @event MediaPlayerEvents#ERROR\n         */\n        this.ERROR = 'error';\n\n        /**\n         * Triggered when a fragment download has completed.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED\n         */\n        this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted';\n\n        /**\n         * Triggered when a partial fragment download has completed.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_PROGRESS\n         */\n        this.FRAGMENT_LOADING_PROGRESS = 'fragmentLoadingProgress';\n        /**\n         * Triggered when a fragment download has started.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED\n         */\n        this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted';\n\n        /**\n         * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule..\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED\n         */\n        this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned';\n\n        /**\n         * Triggered when {@link module:Debug} logger methods are called.\n         * @event MediaPlayerEvents#LOG\n         */\n        this.LOG = 'log';\n\n        //TODO refactor with internal event\n        /**\n         * Triggered when the manifest load is complete\n         * @event MediaPlayerEvents#MANIFEST_LOADED\n         */\n        this.MANIFEST_LOADED = 'manifestLoaded';\n\n        /**\n         * Triggered anytime there is a change to the overall metrics.\n         * @event MediaPlayerEvents#METRICS_CHANGED\n         */\n        this.METRICS_CHANGED = 'metricsChanged';\n\n        /**\n         * Triggered when an individual metric is added, updated or cleared.\n         * @event MediaPlayerEvents#METRIC_CHANGED\n         */\n        this.METRIC_CHANGED = 'metricChanged';\n\n        /**\n         * Triggered every time a new metric is added.\n         * @event MediaPlayerEvents#METRIC_ADDED\n         */\n        this.METRIC_ADDED = 'metricAdded';\n\n        /**\n         * Triggered every time a metric is updated.\n         * @event MediaPlayerEvents#METRIC_UPDATED\n         */\n        this.METRIC_UPDATED = 'metricUpdated';\n\n        /**\n         * Triggered at the stream end of a period.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED\n         */\n        this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted';\n\n        /**\n         * Triggered when a new period starts.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED\n         */\n        this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted';\n\n        /**\n         * Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED\n         */\n        this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested';\n\n        /**\n         * Triggered when the new ABR quality is being rendered on-screen.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED\n         */\n        this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered';\n\n        /**\n         * Triggered when the new track is being rendered.\n         * @event MediaPlayerEvents#TRACK_CHANGE_RENDERED\n         */\n        this.TRACK_CHANGE_RENDERED = 'trackChangeRendered';\n\n        /**\n         * Triggered when the source is setup and ready.\n         * @event MediaPlayerEvents#SOURCE_INITIALIZED\n         */\n        this.SOURCE_INITIALIZED = 'sourceInitialized';\n\n        /**\n         * Triggered when a stream (period) is being loaded\n         * @event MediaPlayerEvents#STREAM_INITIALIZING\n         */\n        this.STREAM_INITIALIZING = 'streamInitializing';\n\n        /**\n         * Triggered when a stream (period) is loaded\n         * @event MediaPlayerEvents#STREAM_INITIALIZED\n         */\n        this.STREAM_INITIALIZED = 'streamInitialized';\n\n        /**\n         * Triggered when the player has been reset.\n         * @event MediaPlayerEvents#STREAM_TEARDOWN_COMPLETE\n         */\n        this.STREAM_TEARDOWN_COMPLETE = 'streamTeardownComplete';\n\n        /**\n         * Triggered once all text tracks detected in the MPD are added to the video element.\n         * @event MediaPlayerEvents#TEXT_TRACKS_ADDED\n         */\n        this.TEXT_TRACKS_ADDED = 'allTextTracksAdded';\n\n        /**\n         * Triggered when a text track is added to the video element's TextTrackList\n         * @event MediaPlayerEvents#TEXT_TRACK_ADDED\n         */\n        this.TEXT_TRACK_ADDED = 'textTrackAdded';\n\n        /**\n         * Triggered when a ttml chunk is parsed.\n         * @event MediaPlayerEvents#TTML_PARSED\n         */\n        this.TTML_PARSED = 'ttmlParsed';\n\n        /**\n         * Triggered when a ttml chunk has to be parsed.\n         * @event MediaPlayerEvents#TTML_TO_PARSE\n         */\n        this.TTML_TO_PARSE = 'ttmlToParse';\n\n        /**\n         * Triggered when a caption is rendered.\n         * @event MediaPlayerEvents#CAPTION_RENDERED\n         */\n        this.CAPTION_RENDERED = 'captionRendered';\n\n        /**\n         * Triggered when the caption container is resized.\n         * @event MediaPlayerEvents#CAPTION_CONTAINER_RESIZE\n         */\n        this.CAPTION_CONTAINER_RESIZE = 'captionContainerResize';\n\n        /**\n         * Sent when enough data is available that the media can be played,\n         * at least for a couple of frames.  This corresponds to the\n         * HAVE_ENOUGH_DATA readyState.\n         * @event MediaPlayerEvents#CAN_PLAY\n         */\n        this.CAN_PLAY = 'canPlay';\n\n        /**\n         * Sent when playback completes.\n         * @event MediaPlayerEvents#PLAYBACK_ENDED\n         */\n        this.PLAYBACK_ENDED = 'playbackEnded';\n\n        /**\n         * Sent when an error occurs.  The element's error\n         * attribute contains more information.\n         * @event MediaPlayerEvents#PLAYBACK_ERROR\n         */\n        this.PLAYBACK_ERROR = 'playbackError';\n\n        /**\n         * Sent when playback is not allowed (for example if user gesture is needed).\n         * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED\n         */\n        this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed';\n\n        /**\n         * The media's metadata has finished loading; all attributes now\n         * contain as much useful information as they're going to.\n         * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED\n         */\n        this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded';\n\n        /**\n         * Sent when playback is paused.\n         * @event MediaPlayerEvents#PLAYBACK_PAUSED\n         */\n        this.PLAYBACK_PAUSED = 'playbackPaused';\n\n        /**\n         * Sent when the media begins to play (either for the first time, after having been paused,\n         * or after ending and then restarting).\n         *\n         * @event MediaPlayerEvents#PLAYBACK_PLAYING\n         */\n        this.PLAYBACK_PLAYING = 'playbackPlaying';\n\n        /**\n         * Sent periodically to inform interested parties of progress downloading\n         * the media. Information about the current amount of the media that has\n         * been downloaded is available in the media element's buffered attribute.\n         * @event MediaPlayerEvents#PLAYBACK_PROGRESS\n         */\n        this.PLAYBACK_PROGRESS = 'playbackProgress';\n\n        /**\n         * Sent when the playback speed changes.\n         * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED\n         */\n        this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged';\n\n        /**\n         * Sent when a seek operation completes.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKED\n         */\n        this.PLAYBACK_SEEKED = 'playbackSeeked';\n\n        /**\n         * Sent when a seek operation begins.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKING\n         */\n        this.PLAYBACK_SEEKING = 'playbackSeeking';\n\n        /**\n         * Sent when a seek operation has been asked.\n         * @event MediaPlayerEvents#PLAYBACK_SEEK_ASKED\n         */\n        this.PLAYBACK_SEEK_ASKED = 'playbackSeekAsked';\n\n        /**\n         * Sent when the video element reports stalled\n         * @event MediaPlayerEvents#PLAYBACK_STALLED\n         */\n        this.PLAYBACK_STALLED = 'playbackStalled';\n\n        /**\n         * Sent when playback of the media starts after having been paused;\n         * that is, when playback is resumed after a prior pause event.\n         *\n         * @event MediaPlayerEvents#PLAYBACK_STARTED\n         */\n        this.PLAYBACK_STARTED = 'playbackStarted';\n\n        /**\n         * The time indicated by the element's currentTime attribute has changed.\n         * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED\n         */\n        this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated';\n\n        /**\n         * Sent when the media playback has stopped because of a temporary lack of data.\n         *\n         * @event MediaPlayerEvents#PLAYBACK_WAITING\n         */\n        this.PLAYBACK_WAITING = 'playbackWaiting';\n\n        /**\n         * Manifest validity changed - As a result of an MPD validity expiration event.\n         * @event MediaPlayerEvents#MANIFEST_VALIDITY_CHANGED\n         */\n        this.MANIFEST_VALIDITY_CHANGED = 'manifestValidityChanged';\n    }\n}\n\nlet mediaPlayerEvents = new MediaPlayerEvents();\nexport default mediaPlayerEvents;\n"]}