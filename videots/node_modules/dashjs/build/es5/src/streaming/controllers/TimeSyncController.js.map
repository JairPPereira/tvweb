{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":["HTTP_TIMEOUT_MS","TimeSyncController","context","eventBus","getInstance","urlUtils","instance","logger","offsetToDeviceTimeMs","isSynchronizing","useManifestDateHeaderTimeSource","handlers","dashMetrics","baseURLController","setup","getLogger","initialize","timingSources","useManifestDateHeader","httpHeadHandler","httpHandler","bind","xsdatetimeDecoder","iso8601Decoder","directHandler","notSupportedHandler","getIsSynchronizing","attemptSync","setConfig","config","getOffsetToDeviceTimeMs","getOffsetMs","setIsSynchronizing","value","setOffsetMs","alternateXsdatetimeDecoder","xsdatetimeStr","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","exec","Date","UTC","parseInt","parseFloat","getTime","parsedDate","parse","isNaN","isoStr","rfc1123Decoder","dateStr","url","onSuccessCB","onFailureCB","time","decoder","isHeadRequest","oncomplete","onload","complete","req","XMLHttpRequest","verb","HTTPRequest","HEAD","GET","urls","shift","length","join","result","status","getResponseHeader","response","isRelative","baseUrl","resolve","open","timeout","onloadend","send","checkForDateHeader","dateHeaderValue","getLatestMPDRequestHeaderValueByID","dateHeaderTime","Number","NaN","completeTimeSyncSequence","failed","offset","trigger","Events","TIME_SYNCHRONIZATION_COMPLETED","error","DashJSError","Errors","TIME_SYNC_FAILED_ERROR_CODE","TIME_SYNC_FAILED_ERROR_MESSAGE","calculateTimeOffset","serverTime","deviceTime","sources","sourceIndex","index","source","onComplete","hasOwnProperty","schemeIdUri","info","reset","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"TimeSyncController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from './../vo/DashJSError';\nimport { HTTPRequest } from './../vo/metrics/HTTPRequest';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport Errors from './../../core/errors/Errors';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport URLUtils from '../utils/URLUtils';\n\nconst HTTP_TIMEOUT_MS = 5000;\n\nfunction TimeSyncController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        offsetToDeviceTimeMs,\n        isSynchronizing,\n        useManifestDateHeaderTimeSource,\n        handlers,\n        dashMetrics,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize(timingSources, useManifestDateHeader) {\n        useManifestDateHeaderTimeSource = useManifestDateHeader;\n        offsetToDeviceTimeMs = 0;\n        isSynchronizing = false;\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014':        directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012':        directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014':      notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014':           notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014':          notSupportedHandler\n        };\n\n        if (!getIsSynchronizing()) {\n            attemptSync(timingSources);\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n    }\n\n    function getOffsetToDeviceTimeMs() {\n        return getOffsetMs();\n    }\n\n    function setIsSynchronizing(value) {\n        isSynchronizing = value;\n    }\n\n    function getIsSynchronizing() {\n        return isSynchronizing;\n    }\n\n    function setOffsetMs(value) {\n        offsetToDeviceTimeMs = value;\n    }\n\n    function getOffsetMs() {\n        return offsetToDeviceTimeMs;\n    }\n\n    // takes xsdatetime and returns milliseconds since UNIX epoch\n    // may not be necessary as xsdatetime is very similar to ISO 8601\n    // which is natively understood by javascript Date parser\n    function alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        const SECONDS_IN_MIN = 60;\n        const MINUTES_IN_HOUR = 60;\n        const MILLISECONDS_IN_SECONDS = 1000;\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        let utcDate,\n            timezoneOffset;\n\n        let match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n    // try to use the built in parser, since xsdate is a constrained ISO8601\n    // which is supported natively by Date.parse. if that fails, try a\n    // regex-based version used elsewhere in this application.\n    function xsdatetimeDecoder(xsdatetimeStr) {\n        let parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    // takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n    function iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    // takes RFC 1123 timestamp (which is same as ISO8601) and returns\n    // milliseconds since UNIX epoch\n    function rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    function notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    function directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        let time = xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    function httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        let oncomplete,\n            onload;\n        let complete = false;\n        let req = new XMLHttpRequest();\n\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\n        let urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            let time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                        req.getResponseHeader('Date') :\n                        req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        if (urlUtils.isRelative(url)) {\n            // passing no path to resolve will return just MPD BaseURL/baseUri\n            const baseUrl = baseURLController.resolve();\n            if (baseUrl) {\n                url = urlUtils.resolve(url, baseUrl.url);\n            }\n        }\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    function httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        httpHandler(rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    function checkForDateHeader() {\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID('Date');\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            setOffsetMs(dateHeaderTime - new Date().getTime());\n            completeTimeSyncSequence(false, dateHeaderTime / 1000, offsetToDeviceTimeMs);\n        } else {\n            completeTimeSyncSequence(true);\n        }\n    }\n\n    function completeTimeSyncSequence(failed, time, offset) {\n        setIsSynchronizing(false);\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED, { time: time, offset: offset, error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null });\n    }\n\n    function calculateTimeOffset(serverTime, deviceTime) {\n        return serverTime - deviceTime;\n    }\n\n    function attemptSync(sources, sourceIndex) {\n\n        // if called with no sourceIndex, use zero (highest priority)\n        let  index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        let source = sources[index];\n\n        // callback to emit event to listeners\n        const onComplete = function (time, offset) {\n            let failed = !time || !offset;\n            if (failed && useManifestDateHeaderTimeSource) {\n                //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n                checkForDateHeader();\n            } else {\n                completeTimeSyncSequence(failed, time, offset);\n            }\n        };\n\n        setIsSynchronizing(true);\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        const deviceTime = new Date().getTime();\n                        const offset = calculateTimeOffset(serverTime, deviceTime);\n\n                        setOffsetMs(offset);\n\n                        logger.info('Local time: ' + new Date(deviceTime));\n                        logger.info('Server time: ' + new Date(serverTime));\n                        logger.info('Server Time - Local Time (ms): ' + offset);\n\n                        onComplete(serverTime, offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        attemptSync(sources, index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                attemptSync(sources, index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            setOffsetMs(0);\n            onComplete();\n        }\n    }\n\n    function reset() {\n        setIsSynchronizing(false);\n    }\n\n    instance = {\n        initialize: initialize,\n        getOffsetToDeviceTimeMs: getOffsetToDeviceTimeMs,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\nexport default factory;\n"]}