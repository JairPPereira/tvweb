{"version":3,"sources":["../../../../../src/streaming/controllers/AbrController.js"],"names":["DEFAULT_VIDEO_BITRATE","DEFAULT_AUDIO_BITRATE","QUALITY_DEFAULT","AbrController","context","debug","getInstance","eventBus","instance","logger","abrRulesCollection","streamController","topQualities","qualityDict","streamProcessorDict","abandonmentStateDict","abandonmentTimeout","windowResizeEventCalled","elementWidth","elementHeight","adapter","videoModel","mediaPlayerModel","domStorage","playbackIndex","switchHistoryDict","droppedFramesHistory","throughputHistory","isUsingBufferOccupancyABRDict","dashMetrics","settings","setup","getLogger","resetInitialSettings","registerStreamType","type","streamProcessor","create","state","MetricsConstants","ALLOW_LOAD","on","Events","LOADING_PROGRESS","onFragmentLoadProgress","Constants","VIDEO","QUALITY_CHANGE_RENDERED","onQualityChangeRendered","setElementSize","METRIC_ADDED","onMetricAdded","PERIOD_SWITCH_COMPLETED","createAbrRulesCollection","unRegisterStreamType","initialize","undefined","clearTimeout","reset","off","setConfig","config","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","e","mediaType","oldQuality","push","getPlaybackQuality","metric","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","AUDIO","get","streaming","abr","useDeadTimeLatency","BUFFER_LEVEL","updateIsUsingBufferOccupancyABR","level","getTopQualityIndexFor","id","idx","checkMaxBitrate","checkMaxRepresentationRatio","checkPortalSize","getTopBitrateInfoFor","streamInfo","getStreamInfo","bitrates","getBitrateList","getMediaInfo","getInitialBitrateFor","TEXT","FRAGMENTED_TEXT","NaN","savedBitrate","getSavedBitrateSettings","configBitrate","initialBitrate","configRatio","initialRepresentationRatio","representation","getAdaptationForType","Representation","Array","isArray","repIdx","Math","max","round","length","bandwidth","isNaN","getMaxAllowedBitrateFor","maxBitrate","getMinAllowedBitrateFor","minBitrate","getMaxAllowedIndexFor","getQualityForBitrate","getMinAllowedIndexFor","mediaInfo","bitrateList","minIdx","bitrate","checkPlaybackQuality","streamId","getQualityFor","rulesContext","abrController","currentValue","switchHistory","useBufferOccupancyABR","playbackQuality","autoSwitchBitrate","topQualityIdx","switchRequest","getMaxQuality","newQuality","quality","SwitchRequest","NO_CHANGE","oldValue","newValue","changeQuality","reason","logLevel","Debug","LOG_LEVEL_DEBUG","bufferLevel","getCurrentBufferLevel","setPlaybackQuality","info","JSON","stringify","setQualityFor","trigger","QUALITY_CHANGE_REQUESTED","getAverageThroughput","setSavedBitrateSettings","setAbandonmentStateFor","getAbandonmentStateFor","latency","voRepresentation","getRepresentationInfo","fragmentDuration","deadTimeRatio","i","bitrateInfo","infoList","ln","BitrateInfo","qualityIndex","width","height","scanType","strategy","ABRStrategy","ABR_STRATEGY_BOLA","ABR_STRATEGY_THROUGHPUT","stableBufferTime","getStableBufferTime","switchOnThreshold","switchOffThreshold","useBufferABR","newUseBufferABR","toFixed","getThroughputHistory","updateTopQualityIndex","representationCount","setTopQualityIndex","isPlayingAtTopQuality","audioQuality","videoQuality","isAtTop","newIdx","maxIdx","min","maxRepresentationRatio","setWindowResizeEventCalled","hasPixelRatio","usePixelRatioInLimitBitrateByPortal","window","pixelRatio","devicePixelRatio","getClientWidth","getClientHeight","limitBitrateByPortal","request","currentRequest","shouldAbandonFragment","fragmentModel","getFragmentModel","getRequests","FragmentModel","FRAGMENT_MODEL_LOADING","index","abortRequests","ABANDON_LOAD","confidence","getActiveStreamInfo","setTimeout","abandonLoadTimeout","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"AbrController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport ABRRulesCollection from '../rules/abr/ABRRulesCollection';\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport BitrateInfo from '../vo/BitrateInfo';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport RulesContext from '../rules/RulesContext';\nimport SwitchRequest from '../rules/SwitchRequest';\nimport SwitchRequestHistory from '../rules/SwitchRequestHistory';\nimport DroppedFramesHistory from '../rules/DroppedFramesHistory';\nimport ThroughputHistory from '../rules/ThroughputHistory';\nimport Debug from '../../core/Debug';\nimport { HTTPRequest } from '../vo/metrics/HTTPRequest';\nimport { checkInteger } from '../utils/SupervisorTools';\n\nconst DEFAULT_VIDEO_BITRATE = 1000;\nconst DEFAULT_AUDIO_BITRATE = 100;\nconst QUALITY_DEFAULT = 0;\n\nfunction AbrController() {\n\n    const context = this.context;\n    const debug = Debug(context).getInstance();\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        abrRulesCollection,\n        streamController,\n        topQualities,\n        qualityDict,\n        streamProcessorDict,\n        abandonmentStateDict,\n        abandonmentTimeout,\n        windowResizeEventCalled,\n        elementWidth,\n        elementHeight,\n        adapter,\n        videoModel,\n        mediaPlayerModel,\n        domStorage,\n        playbackIndex,\n        switchHistoryDict,\n        droppedFramesHistory,\n        throughputHistory,\n        isUsingBufferOccupancyABRDict,\n        dashMetrics,\n        settings;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function registerStreamType(type, streamProcessor) {\n        switchHistoryDict[type] = switchHistoryDict[type] || SwitchRequestHistory(context).create();\n        streamProcessorDict[type] = streamProcessor;\n        abandonmentStateDict[type] = abandonmentStateDict[type] || {};\n        abandonmentStateDict[type].state = MetricsConstants.ALLOW_LOAD;\n        isUsingBufferOccupancyABRDict[type] = false;\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        if (type == Constants.VIDEO) {\n            eventBus.on(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, this);\n            droppedFramesHistory = droppedFramesHistory || DroppedFramesHistory(context).create();\n            setElementSize();\n        }\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, this);\n        eventBus.on(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, this);\n\n        throughputHistory = throughputHistory || ThroughputHistory(context).create({\n            settings: settings\n        });\n    }\n\n    function unRegisterStreamType(type) {\n        delete streamProcessorDict[type];\n    }\n\n    function createAbrRulesCollection() {\n        abrRulesCollection = ABRRulesCollection(context).create({\n            dashMetrics: dashMetrics,\n            mediaPlayerModel: mediaPlayerModel,\n            settings: settings\n        });\n\n        abrRulesCollection.initialize();\n    }\n\n    function resetInitialSettings() {\n        topQualities = {};\n        qualityDict = {};\n        abandonmentStateDict = {};\n        streamProcessorDict = {};\n        switchHistoryDict = {};\n        isUsingBufferOccupancyABRDict = {};\n        if (windowResizeEventCalled === undefined) {\n            windowResizeEventCalled = false;\n        }\n        playbackIndex = undefined;\n        droppedFramesHistory = undefined;\n        throughputHistory = undefined;\n        clearTimeout(abandonmentTimeout);\n        abandonmentTimeout = null;\n    }\n\n    function reset() {\n\n        resetInitialSettings();\n\n        eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        eventBus.off(Events.QUALITY_CHANGE_RENDERED, onQualityChangeRendered, this);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, this);\n        eventBus.off(Events.PERIOD_SWITCH_COMPLETED, createAbrRulesCollection, this);\n\n        if (abrRulesCollection) {\n            abrRulesCollection.reset();\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.domStorage) {\n            domStorage = config.domStorage;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function checkConfig() {\n        if (!domStorage || !domStorage.hasOwnProperty('getSavedBitrateSettings')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function onQualityChangeRendered(e) {\n        if (e.mediaType === Constants.VIDEO) {\n            playbackIndex = e.oldQuality;\n            droppedFramesHistory.push(playbackIndex, videoModel.getPlaybackQuality());\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            throughputHistory.push(e.mediaType, e.value, settings.get().streaming.abr.useDeadTimeLatency);\n        }\n\n        if (e.metric === MetricsConstants.BUFFER_LEVEL && (e.mediaType === Constants.AUDIO || e.mediaType === Constants.VIDEO)) {\n            updateIsUsingBufferOccupancyABR(e.mediaType, 0.001 * e.value.level);\n        }\n    }\n\n    function getTopQualityIndexFor(type, id) {\n        let idx;\n        topQualities[id] = topQualities[id] || {};\n\n        if (!topQualities[id].hasOwnProperty(type)) {\n            topQualities[id][type] = 0;\n        }\n\n        idx = checkMaxBitrate(topQualities[id][type], type);\n        idx = checkMaxRepresentationRatio(idx, type, topQualities[id][type]);\n        idx = checkPortalSize(idx, type);\n        return idx;\n    }\n\n    /**\n     * Gets top BitrateInfo for the player\n     * @param {string} type - 'video' or 'audio' are the type options.\n     * @returns {BitrateInfo | null}\n     */\n    function getTopBitrateInfoFor(type) {\n        if (type  && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            if (streamInfo && streamInfo.id) {\n                const idx = getTopQualityIndexFor(type, streamInfo.id);\n                const bitrates = getBitrateList(streamProcessorDict[type].getMediaInfo());\n                return bitrates[idx] ? bitrates[idx] : null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @param {string} type\n     * @returns {number} A value of the initial bitrate, kbps\n     * @memberof AbrController#\n     */\n    function getInitialBitrateFor(type) {\n        checkConfig();\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT) {\n            return NaN;\n        }\n        const savedBitrate = domStorage.getSavedBitrateSettings(type);\n        let configBitrate = settings.get().streaming.abr.initialBitrate[type];\n        let configRatio = settings.get().streaming.abr.initialRepresentationRatio[type];\n\n        if (configBitrate === -1) {\n            if (configRatio > -1) {\n                const representation = adapter.getAdaptationForType(0, type).Representation;\n                if (Array.isArray(representation)) {\n                    const repIdx = Math.max(Math.round(representation.length * configRatio) - 1, 0);\n                    configBitrate = representation[repIdx].bandwidth;\n                } else {\n                    configBitrate = 0;\n                }\n            } else if (!isNaN(savedBitrate)) {\n                configBitrate = savedBitrate;\n            } else {\n                configBitrate = (type === Constants.VIDEO) ? DEFAULT_VIDEO_BITRATE : DEFAULT_AUDIO_BITRATE;\n            }\n        }\n\n        return configBitrate;\n    }\n\n    function getMaxAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.maxBitrate[type];\n    }\n\n    function getMinAllowedBitrateFor(type) {\n        return settings.get().streaming.abr.minBitrate[type];\n    }\n\n    function getMaxAllowedIndexFor(type) {\n        const maxBitrate = getMaxAllowedBitrateFor(type);\n        if (maxBitrate > -1) {\n            return getQualityForBitrate(streamProcessorDict[type].getMediaInfo(), maxBitrate);\n        } else {\n            return undefined;\n        }\n    }\n\n    function getMinAllowedIndexFor(type) {\n        const minBitrate = getMinAllowedBitrateFor(type);\n\n        if (minBitrate > -1) {\n            const mediaInfo = streamProcessorDict[type].getMediaInfo();\n            const bitrateList = getBitrateList(mediaInfo);\n            // This returns the quality index <= for the given bitrate\n            let minIdx = getQualityForBitrate(mediaInfo, minBitrate);\n            if (bitrateList[minIdx] && minIdx < bitrateList.length - 1 && bitrateList[minIdx].bitrate < minBitrate * 1000) {\n                minIdx++; // Go to the next bitrate\n            }\n            return minIdx;\n        } else {\n            return undefined;\n        }\n    }\n\n    function checkPlaybackQuality(type) {\n        if (type  && streamProcessorDict && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const streamId = streamInfo ? streamInfo.id : null;\n            const oldQuality = getQualityFor(type);\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessorDict[type],\n                currentValue: oldQuality,\n                switchHistory: switchHistoryDict[type],\n                droppedFramesHistory: droppedFramesHistory,\n                useBufferOccupancyABR: useBufferOccupancyABR(type)\n            });\n\n            if (droppedFramesHistory) {\n                const playbackQuality = videoModel.getPlaybackQuality();\n                if (playbackQuality) {\n                    droppedFramesHistory.push(playbackIndex, playbackQuality);\n                }\n            }\n            if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n                const minIdx = getMinAllowedIndexFor(type);\n                const topQualityIdx = getTopQualityIndexFor(type, streamId);\n                const switchRequest = abrRulesCollection.getMaxQuality(rulesContext);\n                let newQuality = switchRequest.quality;\n                if (minIdx !== undefined && ((newQuality > SwitchRequest.NO_CHANGE) ? newQuality : oldQuality) < minIdx) {\n                    newQuality = minIdx;\n                }\n                if (newQuality > topQualityIdx) {\n                    newQuality = topQualityIdx;\n                }\n\n                switchHistoryDict[type].push({oldValue: oldQuality, newValue: newQuality});\n\n                if (newQuality > SwitchRequest.NO_CHANGE && newQuality != oldQuality) {\n                    if (abandonmentStateDict[type].state === MetricsConstants.ALLOW_LOAD || newQuality > oldQuality) {\n                        changeQuality(type, oldQuality, newQuality, topQualityIdx, switchRequest.reason);\n                    }\n                } else if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                    const bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n                    logger.debug('[' + type + '] stay on ' + oldQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ')');\n                }\n            }\n        }\n    }\n\n    function setPlaybackQuality(type, streamInfo, newQuality, reason) {\n        const id = streamInfo.id;\n        const oldQuality = getQualityFor(type);\n\n        checkInteger(newQuality);\n\n        const topQualityIdx = getTopQualityIndexFor(type, id);\n        if (newQuality !== oldQuality && newQuality >= 0 && newQuality <= topQualityIdx) {\n            changeQuality(type, oldQuality, newQuality, topQualityIdx, reason);\n        }\n    }\n\n    function changeQuality(type, oldQuality, newQuality, topQualityIdx, reason) {\n        if (type  && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            if (settings.get().debug.logLevel === Debug.LOG_LEVEL_DEBUG) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(type, true);\n                logger.info('[' + type + '] switch from ' + oldQuality + ' to ' + newQuality + '/' + topQualityIdx + ' (buffer: ' + bufferLevel + ') ' + (reason ? JSON.stringify(reason) : '.'));\n            }\n            setQualityFor(type, id, newQuality);\n            eventBus.trigger(Events.QUALITY_CHANGE_REQUESTED, {mediaType: type, streamInfo: streamInfo, oldQuality: oldQuality, newQuality: newQuality, reason: reason});\n            const bitrate = throughputHistory.getAverageThroughput(type);\n            if (!isNaN(bitrate)) {\n                domStorage.setSavedBitrateSettings(type, bitrate);\n            }\n        }\n    }\n\n    function setAbandonmentStateFor(type, state) {\n        abandonmentStateDict[type].state = state;\n    }\n\n    function getAbandonmentStateFor(type) {\n        return abandonmentStateDict[type] ? abandonmentStateDict[type].state : null;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @param {number} bitrate A bitrate value, kbps\n     * @param {number} latency Expected latency of connection, ms\n     * @returns {number} A quality index <= for the given bitrate\n     * @memberof AbrController#\n     */\n    function getQualityForBitrate(mediaInfo, bitrate, latency) {\n        const voRepresentation = mediaInfo && mediaInfo.type ? streamProcessorDict[mediaInfo.type].getRepresentationInfo() : null;\n\n        if (settings.get().streaming.abr.useDeadTimeLatency && latency && voRepresentation && voRepresentation.fragmentDuration) {\n            latency = latency / 1000;\n            const fragmentDuration = voRepresentation.fragmentDuration;\n            if (latency > fragmentDuration) {\n                return 0;\n            } else {\n                const deadTimeRatio = latency / fragmentDuration;\n                bitrate = bitrate * (1 - deadTimeRatio);\n            }\n        }\n\n        const bitrateList = getBitrateList(mediaInfo);\n\n        for (let i = bitrateList.length - 1; i >= 0; i--) {\n            const bitrateInfo = bitrateList[i];\n            if (bitrate * 1000 >= bitrateInfo.bitrate) {\n                return i;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    /**\n     * @param {MediaInfo} mediaInfo\n     * @returns {Array|null} A list of {@link BitrateInfo} objects\n     * @memberof AbrController#\n     */\n    function getBitrateList(mediaInfo) {\n        const infoList = [];\n        if (!mediaInfo || !mediaInfo.bitrateList) return infoList;\n\n        const bitrateList = mediaInfo.bitrateList;\n        const type = mediaInfo.type;\n\n        let bitrateInfo;\n\n        for (let i = 0, ln = bitrateList.length; i < ln; i++) {\n            bitrateInfo = new BitrateInfo();\n            bitrateInfo.mediaType = type;\n            bitrateInfo.qualityIndex = i;\n            bitrateInfo.bitrate = bitrateList[i].bandwidth;\n            bitrateInfo.width = bitrateList[i].width;\n            bitrateInfo.height = bitrateList[i].height;\n            bitrateInfo.scanType = bitrateList[i].scanType;\n            infoList.push(bitrateInfo);\n        }\n\n        return infoList;\n    }\n\n    function updateIsUsingBufferOccupancyABR(mediaType, bufferLevel) {\n        const strategy = settings.get().streaming.abr.ABRStrategy;\n\n        if (strategy === Constants.ABR_STRATEGY_BOLA) {\n            isUsingBufferOccupancyABRDict[mediaType] = true;\n            return;\n        } else if (strategy === Constants.ABR_STRATEGY_THROUGHPUT) {\n            isUsingBufferOccupancyABRDict[mediaType] = false;\n            return;\n        }\n        // else ABR_STRATEGY_DYNAMIC\n\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const switchOnThreshold = stableBufferTime;\n        const switchOffThreshold = 0.5 * stableBufferTime;\n\n        const useBufferABR = isUsingBufferOccupancyABRDict[mediaType];\n        const newUseBufferABR = bufferLevel > (useBufferABR ? switchOffThreshold : switchOnThreshold); // use hysteresis to avoid oscillating rules\n        isUsingBufferOccupancyABRDict[mediaType] = newUseBufferABR;\n\n        if (newUseBufferABR !== useBufferABR) {\n            if (newUseBufferABR) {\n                logger.info('[' + mediaType + '] switching from throughput to buffer occupancy ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            } else {\n                logger.info('[' + mediaType + '] switching from buffer occupancy to throughput ABR rule (buffer: ' + bufferLevel.toFixed(3) + ').');\n            }\n        }\n    }\n\n    function useBufferOccupancyABR(mediaType) {\n        return isUsingBufferOccupancyABRDict[mediaType];\n    }\n\n    function getThroughputHistory() {\n        return throughputHistory;\n    }\n\n    function updateTopQualityIndex(mediaInfo) {\n        const type = mediaInfo.type;\n        const streamId = mediaInfo.streamInfo.id;\n        const max = mediaInfo.representationCount - 1;\n\n        setTopQualityIndex(type, streamId, max);\n\n        return max;\n    }\n\n    function isPlayingAtTopQuality(streamInfo) {\n        const streamId = streamInfo ? streamInfo.id : null;\n        const audioQuality = getQualityFor(Constants.AUDIO);\n        const videoQuality = getQualityFor(Constants.VIDEO);\n\n        const isAtTop = (audioQuality === getTopQualityIndexFor(Constants.AUDIO, streamId)) &&\n            (videoQuality === getTopQualityIndexFor(Constants.VIDEO, streamId));\n\n        return isAtTop;\n    }\n\n    function getQualityFor(type) {\n        if (type && streamProcessorDict[type]) {\n            const streamInfo = streamProcessorDict[type].getStreamInfo();\n            const id = streamInfo ? streamInfo.id : null;\n            let quality;\n\n            if (id) {\n                qualityDict[id] = qualityDict[id] || {};\n\n                if (!qualityDict[id].hasOwnProperty(type)) {\n                    qualityDict[id][type] = QUALITY_DEFAULT;\n                }\n\n                quality = qualityDict[id][type];\n                return quality;\n            }\n        }\n        return QUALITY_DEFAULT;\n    }\n\n    function setQualityFor(type, id, value) {\n        qualityDict[id] = qualityDict[id] || {};\n        qualityDict[id][type] = value;\n    }\n\n    function setTopQualityIndex(type, id, value) {\n        topQualities[id] = topQualities[id] || {};\n        topQualities[id][type] = value;\n    }\n\n    function checkMaxBitrate(idx, type) {\n        let newIdx = idx;\n\n        if (!streamProcessorDict[type]) {\n            return newIdx;\n        }\n\n        const minIdx = getMinAllowedIndexFor(type);\n        if (minIdx !== undefined) {\n            newIdx = Math.max (idx , minIdx);\n        }\n\n        const maxIdx = getMaxAllowedIndexFor(type);\n        if (maxIdx !== undefined) {\n            newIdx = Math.min (newIdx , maxIdx);\n        }\n\n        return newIdx;\n    }\n\n    function checkMaxRepresentationRatio(idx, type, maxIdx) {\n        const maxRepresentationRatio = settings.get().streaming.abr.maxRepresentationRatio[type];\n        if (isNaN(maxRepresentationRatio) || maxRepresentationRatio >= 1 || maxRepresentationRatio < 0) {\n            return idx;\n        }\n        return Math.min(idx , Math.round(maxIdx * maxRepresentationRatio) );\n    }\n\n    function setWindowResizeEventCalled(value) {\n        windowResizeEventCalled = value;\n    }\n\n    function setElementSize() {\n        if (videoModel) {\n            const hasPixelRatio = settings.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty('devicePixelRatio');\n            const pixelRatio = hasPixelRatio ? window.devicePixelRatio : 1;\n            elementWidth = videoModel.getClientWidth() * pixelRatio;\n            elementHeight = videoModel.getClientHeight() * pixelRatio;\n        }\n    }\n\n    function checkPortalSize(idx, type) {\n        if (type !== Constants.VIDEO || !settings.get().streaming.abr.limitBitrateByPortal || !streamProcessorDict[type]) {\n            return idx;\n        }\n\n        if (!windowResizeEventCalled) {\n            setElementSize();\n        }\n\n        const representation = adapter.getAdaptationForType(0, type).Representation;\n        let newIdx = idx;\n\n        if (elementWidth > 0 && elementHeight > 0) {\n            while (\n                newIdx > 0 &&\n                representation[newIdx] &&\n                elementWidth < representation[newIdx].width &&\n                elementWidth - representation[newIdx - 1].width < representation[newIdx].width - elementWidth) {\n                newIdx = newIdx - 1;\n            }\n\n            // Make sure that in case of multiple representation elements have same\n            // resolution, every such element is included\n            while (newIdx < representation.length - 1 && representation[newIdx].width === representation[newIdx + 1].width) {\n                newIdx = newIdx + 1;\n            }\n        }\n\n        return newIdx;\n    }\n\n    function onFragmentLoadProgress(e) {\n        const type = e.request.mediaType;\n        if (!!settings.get().streaming.abr.autoSwitchBitrate[type]) {\n            const streamProcessor = streamProcessorDict[type];\n            if (!streamProcessor) return; // There may be a fragment load in progress when we switch periods and recreated some controllers.\n\n            const rulesContext = RulesContext(context).create({\n                abrController: instance,\n                streamProcessor: streamProcessor,\n                currentRequest: e.request,\n                useBufferOccupancyABR: useBufferOccupancyABR(type)\n            });\n            const switchRequest = abrRulesCollection.shouldAbandonFragment(rulesContext);\n\n            if (switchRequest.quality > SwitchRequest.NO_CHANGE) {\n                const fragmentModel = streamProcessor.getFragmentModel();\n                const request = fragmentModel.getRequests({state: FragmentModel.FRAGMENT_MODEL_LOADING, index: e.request.index})[0];\n                if (request) {\n                    //TODO Check if we should abort or if better to finish download. check bytesLoaded/Total\n                    fragmentModel.abortRequests();\n                    setAbandonmentStateFor(type, MetricsConstants.ABANDON_LOAD);\n                    switchHistoryDict[type].reset();\n                    switchHistoryDict[type].push({oldValue: getQualityFor(type), newValue: switchRequest.quality, confidence: 1, reason: switchRequest.reason});\n                    setPlaybackQuality(type, streamController.getActiveStreamInfo(), switchRequest.quality, switchRequest.reason);\n\n                    clearTimeout(abandonmentTimeout);\n                    abandonmentTimeout = setTimeout(\n                        () => {setAbandonmentStateFor(type, MetricsConstants.ALLOW_LOAD); abandonmentTimeout = null;},\n                        settings.get().streaming.abandonLoadTimeout\n                    );\n                }\n            }\n        }\n    }\n\n    instance = {\n        isPlayingAtTopQuality: isPlayingAtTopQuality,\n        updateTopQualityIndex: updateTopQualityIndex,\n        getThroughputHistory: getThroughputHistory,\n        getBitrateList: getBitrateList,\n        getQualityForBitrate: getQualityForBitrate,\n        getTopBitrateInfoFor: getTopBitrateInfoFor,\n        getMaxAllowedIndexFor: getMaxAllowedIndexFor,\n        getMinAllowedIndexFor: getMinAllowedIndexFor,\n        getInitialBitrateFor: getInitialBitrateFor,\n        getQualityFor: getQualityFor,\n        getAbandonmentStateFor: getAbandonmentStateFor,\n        setPlaybackQuality: setPlaybackQuality,\n        checkPlaybackQuality: checkPlaybackQuality,\n        getTopQualityIndexFor: getTopQualityIndexFor,\n        setElementSize: setElementSize,\n        setWindowResizeEventCalled: setWindowResizeEventCalled,\n        createAbrRulesCollection: createAbrRulesCollection,\n        registerStreamType: registerStreamType,\n        unRegisterStreamType: unRegisterStreamType,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nAbrController.__dashjs_factory_name = 'AbrController';\nconst factory = FactoryMaker.getSingletonFactory(AbrController);\nfactory.QUALITY_DEFAULT = QUALITY_DEFAULT;\nFactoryMaker.updateSingletonFactory(AbrController.__dashjs_factory_name, factory);\nexport default factory;"]}